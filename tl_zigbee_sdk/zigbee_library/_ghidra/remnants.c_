// WARNING! conflicting data type names: /DWARF/bdb.h/bdb_commissioningMode_t - /bdb_commissioningMode_t
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void ll_reset(void)

{
  undefined1 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  u16 *puVar4;

  for (puVar1 = sdk_version; (int)puVar1 < (int)&_stack_end_;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0xffffffff;
  }
  setExecutionMode(0x12);
  setExecutionMode(0x13);
  for (puVar2 = (undefined4 *)&_ictag_start_; (int)puVar2 < (int)&_ictag_end_; puVar2 = puVar2 + 1)
  {
    *puVar2 = 0;
  }
  DAT_0080060c = 0x17;
  DAT_0080060d = 0x18;
  _DAT_00800060 = 0xff000000;
  DAT_00800064 = 0xff;
  DAT_00800065 = 0xff;
  DAT_0080000c = 0xab;
  iVar3 = 0;
  do
  {
    iVar3 = iVar3 + 1;
  } while (iVar3 < 7);
  DAT_0080000d = 1;
  DAT_008000b8 = 0x7e;
  DAT_008000ba = 0x40;
  if (DAT_008000b9 == '\0')
  {
    puVar2 = (undefined4 *)&_code_size_;
    for (puVar4 = &zcl_attr_currZigbeeStackVer; (int)puVar4 < (int)&_end_data_;
         puVar4 = (u16 *)((int)puVar4 + 4))
    {
      *(undefined4 *)puVar4 = *puVar2;
      puVar2 = puVar2 + 1;
    }
    for (puVar1 = irq_stk; (int)puVar1 < (int)&_end_bss_; puVar1 = (undefined1 *)((int)puVar1 + 4))
    {
      *(undefined4 *)puVar1 = 0;
    }
  }
  else
  {
    DAT_0080063e = tl_multi_addr;
  }
  puVar2 = (undefined4 *)&_custom_stored_bin_;
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = *puVar2;
    puVar2 = puVar2 + 1;
  }
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0;
  }
  main();
  do
  {
    // WARNING: Do nothing block with infinite loop
  } while (true);
}
int __LOAD_RAM(int param_1, int param_2)

{
  int unaff_r6;
  byte in_CY;

  param_2 = param_1 + unaff_r6 + (uint)in_CY << param_2;
  getState(param_2);
  irq_handler();
  setState(param_2);
  return param_2;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void a1(void)

{
  undefined1 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  u16 *puVar4;

  for (puVar1 = sdk_version; (int)puVar1 < (int)&_stack_end_;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0xffffffff;
  }
  setExecutionMode(0x12);
  setExecutionMode(0x13);
  for (puVar2 = (undefined4 *)&_ictag_start_; (int)puVar2 < (int)&_ictag_end_; puVar2 = puVar2 + 1)
  {
    *puVar2 = 0;
  }
  DAT_0080060c = 0x17;
  DAT_0080060d = 0x18;
  _DAT_00800060 = 0xff000000;
  DAT_00800064 = 0xff;
  DAT_00800065 = 0xff;
  DAT_0080000c = 0xab;
  iVar3 = 0;
  do
  {
    iVar3 = iVar3 + 1;
  } while (iVar3 < 7);
  DAT_0080000d = 1;
  DAT_008000b8 = 0x7e;
  DAT_008000ba = 0x40;
  if (DAT_008000b9 == '\0')
  {
    puVar2 = (undefined4 *)&_code_size_;
    for (puVar4 = &zcl_attr_currZigbeeStackVer; (int)puVar4 < (int)&_end_data_;
         puVar4 = (u16 *)((int)puVar4 + 4))
    {
      *(undefined4 *)puVar4 = *puVar2;
      puVar2 = puVar2 + 1;
    }
    for (puVar1 = irq_stk; (int)puVar1 < (int)&_end_bss_; puVar1 = (undefined1 *)((int)puVar1 + 4))
    {
      *(undefined4 *)puVar1 = 0;
    }
  }
  else
  {
    DAT_0080063e = tl_multi_addr;
  }
  puVar2 = (undefined4 *)&_custom_stored_bin_;
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = *puVar2;
    puVar2 = puVar2 + 1;
  }
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0;
  }
  main();
  do
  {
    // WARNING: Do nothing block with infinite loop
  } while (true);
}
void _ramcode_size_div_16_align_256_(undefined4 param_1, undefined4 *param_2, undefined4 *param_3, int param_4)

{
  undefined1 *puVar1;

  while (param_3 = param_3 + 1, (int)param_3 < param_4)
  {
    *param_3 = *param_2;
    param_2 = param_2 + 1;
  }
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0;
  }
  main();
  do
  {
    // WARNING: Do nothing block with infinite loop
  } while (true);
}
undefined4 __irq(undefined4 param_1)

{
  getState(param_1);
  irq_handler();
  setState(param_1);
  return param_1;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
u32 mac_currentTickGet(void)

{
  return _DAT_00800740;
}
void rf_setTrxState(u8 state)

{
  RF_StatusTypeDef rf_status;
  int iVar1;

  if ((uint)state * 0x1000000 - 0x1000000 >> 0x18 < 2)
  {
    if ((rfMode == '\x01') && (iVar1 = rf_trx_state_get(), iVar1 == 1))
    {
      return;
    }
    rfMode = '\x01';
    if (fPaEn != '\0')
    {
      drv_gpio_write(rf_pa_txen_pin, '\0');
      drv_gpio_write(rf_pa_rxen_pin, '\x01');
    }
    if (fPtaEn != '\0')
    {
      drv_gpio_write(rf_pta_priority_pin, '\0');
    }
    rf_status = RF_MODE_RX;
  }
  else
  {
    if (state == 0)
    {
      if ((rfMode != '\0') || (iVar1 = rf_trx_state_get(), iVar1 != 0))
      {
        rfMode = '\0';
        if (fPaEn != '\0')
        {
          drv_gpio_write(rf_pa_txen_pin, '\x01');
          drv_gpio_write(rf_pa_rxen_pin, '\0');
        }
        if (fPtaEn != '\0')
        {
          drv_gpio_write(rf_pta_priority_pin, '\x01');
        }
        rf_trx_state_set(RF_MODE_TX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
      }
      sleep_us(0x78);
      return;
    }
    if ((rfMode == '\x03') && (iVar1 = rf_trx_state_get(), iVar1 == 3))
    {
      return;
    }
    rfMode = '\x03';
    if (fPtaEn != '\0')
    {
      drv_gpio_write(rf_pta_priority_pin, '\0');
    }
    rf_status = RF_MODE_OFF;
  }
  rf_trx_state_set(rf_status, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
  return;
}
// WARNING: Removing unreachable block (RAM,0x000003c4)
// WARNING: Removing unreachable block (RAM,0x000003d2)
// WARNING: Removing unreachable block (RAM,0x000003e0)
void rf_performCCA(void)

{
  do
  {
  } while (true);
}
void rf802154_tx(void)

{
  rf_setTrxState('\0');
  DAT_00800f20 = 1;
  rf_tx_pkt(rf_tx_buf);
  return;
}
void rf_paShutDown(void)

{
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void rf_rx_irq_handler(void)

{
  byte len;
  u16 frameCtrl;
  u8 *rxBuf;
  u8 uVar1;
  u8 *addr;
  int iVar2;
  u8 *puVar3;
  int iVar4;
  byte bVar5;
  uint uVar6;
  u8 *macPld;
  u8 local_26;
  u8 local_25;

  rxBuf = rf_rxBuf;
  local_25 = '\0';
  local_26 = '\0';
  if ((int)((uint)DAT_00800448 << 0x1a) < 0)
  {
    return;
  }
  DAT_00800c20 = DAT_00800c20 & 0xfb;
  g_sysDiags.macRxIrqCnt = g_sysDiags.macRxIrqCnt + '\x01';
  if ((((rf_rxBuf[*rf_rxBuf + 3] & 0x51) == 0x10) && (len = rf_rxBuf[4], (uint)*rf_rxBuf == len + 9)) && (bVar5 = rf_busyFlag & 2, (rf_busyFlag & 2) == 0))
  {
    macPld = rf_rxBuf + 5;
    addr = zb_macDataFilter(macPld, len, &local_26, &local_25);
    if (local_26 != '\0')
    {
      *rf_rxBuf = bVar5;
      rf_rxBuf[4] = bVar5;
      DAT_00800c20 = DAT_00800c20 | 4;
      return;
    }
    iVar4 = 0;
    if (((int)((uint)rxBuf[5] << 0x1a) < 0) &&
        ((rfMode != '\0' || (iVar2 = rf_trx_state_get(), iVar4 = _DAT_00800740, iVar2 != 0))))
    {
      rfMode = '\0';
      if (fPaEn != '\0')
      {
        drv_gpio_write(rf_pa_txen_pin, '\x01');
        drv_gpio_write(rf_pa_rxen_pin, '\0');
      }
      if (fPtaEn != '\0')
      {
        drv_gpio_write(rf_pta_priority_pin, '\x01');
      }
      rf_trx_state_set(RF_MODE_TX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
      iVar4 = _DAT_00800740;
    }
    puVar3 = tl_getRxBuf();
    if (puVar3 != (u8 *)0x0)
    {
      rf_rxBuf = puVar3;
      *puVar3 = '\0';
      rf_rxBuf[4] = '\0';
      _DAT_00800c08 = rf_rxBuf._0_2_;
      if ((int)((uint)rxBuf[5] << 0x1a) < 0)
      {
        rf_ack_buf[7] = rxBuf[7];
        rf_ack_buf[5] = '\x02';
        frameCtrl = *(u16 *)(rxBuf + 5);
        bVar5 = tl_zbMacHdrSize(frameCtrl);
        iVar2 = 0;
        if ((frameCtrl & 7) == 3)
        {
          uVar6 = macPld[bVar5] - 4;
          iVar2 = uVar6 + ~uVar6 + (uint)(3 < macPld[bVar5]);
        }
        bVar5 = 2;
        if ((rxBuf[6] & 0xc0) != 0x80)
        {
          bVar5 = ~((0xbf < (rxBuf[6] & 0xc0)) - 1U) & 3;
        }
        if (((bVar5 != 0) && (iVar2 != 0)) &&
            (uVar1 = tl_zbMacPendingDataCheck(bVar5, addr, '\x01'), uVar1 == '\0'))
        {
          rf_ack_buf[5] = rf_ack_buf[5] | 0x10;
        }
        iVar4 = FUN_0000162c(_DAT_00800740 - iVar4, sysTimerPerUs);
        if (iVar4 < 0x78)
        {
          sleep_us(0x78 - iVar4);
        }
        _DAT_00800640 = _DAT_00800640 & 0xffffdfff;
        rf_tx_pkt(rf_ack_buf);
        do
        {
        } while ((DAT_00800f20 & 2) == 0);
        DAT_00800f20 = 2;
        _DAT_00800640 = _DAT_00800640 | 0x2000;
        if ((rfMode != '\x01') || (iVar4 = rf_trx_state_get(), iVar4 != 1))
        {
          rfMode = '\x01';
          if (fPaEn != '\0')
          {
            drv_gpio_write(rf_pa_txen_pin, '\0');
            drv_gpio_write(rf_pa_rxen_pin, '\x01');
          }
          if (fPtaEn != '\0')
          {
            drv_gpio_write(rf_pta_priority_pin, '\0');
          }
          rf_trx_state_set(RF_MODE_RX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
        }
      }
      DAT_00800c20 = DAT_00800c20 | 4;
      bVar5 = *rxBuf;
      zb_macDataRecvHander(rxBuf, macPld, len, local_25,
                           (uint)rxBuf[bVar5 - 2] << 0x10 | (uint)rxBuf[bVar5 - 3] << 8 |
                               (uint)rxBuf[bVar5 - 4] | (uint)rxBuf[bVar5 - 1] << 0x18,
                           rxBuf[bVar5 + 2] + 0x92);
      return;
    }
    if (((int)((uint)rxBuf[5] << 0x1a) < 0) &&
        ((rfMode != '\x01' || (iVar4 = rf_trx_state_get(), iVar4 != 1))))
    {
      rfMode = '\x01';
      if (fPaEn != '\0')
      {
        drv_gpio_write(rf_pa_txen_pin, '\0');
        drv_gpio_write(rf_pa_rxen_pin, '\x01');
      }
      if (fPtaEn != '\0')
      {
        drv_gpio_write(rf_pta_priority_pin, '\0');
      }
      rf_trx_state_set(RF_MODE_RX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
    }
    g_sysDiags.phytoMACqueuelimitreached = g_sysDiags.phytoMACqueuelimitreached + 1;
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  else
  {
    g_sysDiags.macRxCrcFail = g_sysDiags.macRxCrcFail + 1;
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  DAT_00800c20 = DAT_00800c20 | 4;
  return;
}
void rf_tx_irq_handler(void)

{
  int iVar1;

  rf_busyFlag = rf_busyFlag & 0xfd;
  g_sysDiags.macTxIrqCnt = g_sysDiags.macTxIrqCnt + '\x01';
  if ((rfMode != '\x01') || (iVar1 = rf_trx_state_get(), iVar1 != 1))
  {
    rfMode = '\x01';
    if (fPaEn != '\0')
    {
      drv_gpio_write(rf_pa_txen_pin, '\0');
      drv_gpio_write(rf_pa_rxen_pin, '\x01');
    }
    if (fPtaEn != '\0')
    {
      drv_gpio_write(rf_pta_priority_pin, '\0');
    }
    rf_trx_state_set(RF_MODE_RX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
  }
  zb_macDataSendHander();
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void irq_handler(void)

{
  uint uVar1;
  ushort uVar2;

  uVar2 = _DAT_00800f20;
  if ((_DAT_00800f20 & 2) != 0)
  {
    _DAT_00800f20 = 2;
    T_DBG_irqTest[0] = T_DBG_irqTest[0] + '\x01';
    rf_tx_irq_handler();
  }
  if ((uVar2 & 1) != 0)
  {
    _DAT_00800f20 = 1;
    T_DBG_irqTest[1] = T_DBG_irqTest[1] + '\x01';
    rf_rx_irq_handler();
  }
  uVar1 = _DAT_00800648;
  if ((uVar2 & 4) != 0)
  {
    _DAT_00800f20 = 4;
  }
  if ((uVar2 & 0x400) != 0)
  {
    _DAT_00800f20 = 0x400;
  }
  if ((_DAT_00800648 & 1) != 0)
  {
    _DAT_00800648 = 1;
    DAT_00800623 = 1;
    T_DBG_irqTest[2] = T_DBG_irqTest[2] + '\x01';
    drv_timer_irq0_handler();
  }
  if ((uVar1 & 2) != 0)
  {
    _DAT_00800648 = 2;
    DAT_00800623 = 2;
    T_DBG_irqTest[3] = T_DBG_irqTest[3] + '\x01';
    drv_timer_irq1_handler();
  }
  if ((uVar1 & 0x100000) != 0)
  {
    _DAT_00800648 = 0x100000;
    T_DBG_irqTest[4] = T_DBG_irqTest[4] + '\x01';
    drv_timer_irq3_handler();
  }
  if ((uVar1 & 0x40000) != 0)
  {
    _DAT_00800648 = 0x40000;
    T_DBG_irqTest[5] = T_DBG_irqTest[5] + '\x01';
    drv_gpio_irq_handler();
  }
  if ((uVar1 & 0x200000) != 0)
  {
    _DAT_00800648 = 0x200000;
    T_DBG_irqTest[6] = T_DBG_irqTest[6] + '\x01';
    drv_gpio_irq_risc0_handler();
  }
  if ((uVar1 & 0x400000) != 0)
  {
    _DAT_00800648 = 0x400000;
    T_DBG_irqTest[7] = T_DBG_irqTest[7] + '\x01';
    drv_gpio_irq_risc1_handler();
  }
  if ((DAT_00800c26 & 1) == 0)
  {
    if ((DAT_00800c26 & 2) == 0)
    {
      DAT_00800c26 = 0xfc;
    }
    else
    {
      DAT_00800c26 = 2;
      T_DBG_irqTest[9] = T_DBG_irqTest[9] + '\x01';
      drv_uart_tx_irq_handler();
    }
  }
  else
  {
    DAT_00800c26 = 1;
    T_DBG_irqTest[8] = T_DBG_irqTest[8] + '\x01';
    drv_uart_rx_irq_handler();
  }
  return;
}
// WARNING: Removing unreachable block (RAM,0x00000a2c)
// WARNING: Removing unreachable block (RAM,0x00000a50)
// WARNING: Removing unreachable block (RAM,0x00000aa4)
// WARNING: Removing unreachable block (RAM,0x00000a60)
// WARNING: Removing unreachable block (RAM,0x00000a64)
// WARNING: Removing unreachable block (RAM,0x00000a6a)
// WARNING: Removing unreachable block (RAM,0x00000a74)
// WARNING: Removing unreachable block (RAM,0x00000a7c)
// WARNING: Removing unreachable block (RAM,0x00000a82)
// WARNING: Removing unreachable block (RAM,0x00000a8a)
// WARNING: Removing unreachable block (RAM,0x00000a92)
// WARNING: Removing unreachable block (RAM,0x00000ab0)
// WARNING: Removing unreachable block (RAM,0x00000ad8)
// WARNING: Removing unreachable block (RAM,0x00000af8)
// WARNING: Removing unreachable block (RAM,0x00000b08)
// WARNING: Removing unreachable block (RAM,0x00000a98)
// WARNING: Removing unreachable block (RAM,0x00000a48)
uint adc_sample_and_get_result_op(char mode, uint *d)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}
uint adc_get_result_with_fluct(uint *v)

{
  uint uVar1;

  uVar1 = adc_sample_and_get_result_op('\x01', v);
  return uVar1;
}
void flash_send_addr(uint addr)

{
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  DAT_0080000c = (char)addr;
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  return;
}
void flash_send_cmd(uchar cmd)

{
  DAT_0080000d = 1;
  sleep_us(1);
  DAT_0080000d = 0;
  DAT_0080000c = cmd;
  return;
}
// WARNING: Removing unreachable block (RAM,0x00000bd8)
void flash_wait_done(void)

{
  sleep_us(100);
  flash_send_cmd('\x05');
  DAT_0080000c = 0;
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  DAT_0080000d = 1;
  return;
}
void flash_mspi_read_ram(uchar cmd, ulong addr, uchar addr_en, uchar dummy_cnt, uchar *data,
                         ulong data_len)

{
  undefined uVar1;
  int iVar2;
  ulong uVar3;

  uVar1 = DAT_00800643;
  DAT_00800643 = 0;
  flash_send_cmd(cmd);
  if (addr_en != '\0')
  {
    flash_send_addr(addr);
  }
  if (dummy_cnt != 0)
  {
    iVar2 = 0;
    do
    {
      do
      {
      } while ((DAT_0080000d & 0x10) != 0);
      iVar2 = iVar2 + 1;
    } while (iVar2 < (int)(uint)dummy_cnt);
  }
  DAT_0080000c = '\0';
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  DAT_0080000d = 0;
  if (data_len != 0)
  {
    uVar3 = 0;
    do
    {
      data[uVar3] = DAT_0080000c;
      do
      {
      } while ((DAT_0080000d & 0x10) != 0);
      uVar3 = uVar3 + 1;
    } while (uVar3 != data_len);
  }
  DAT_0080000d = 1;
  DAT_00800643 = uVar1;
  return;
}
void flash_mspi_write_ram(uchar cmd, ulong addr, uchar addr_en, uchar *data, ulong data_len)

{
  undefined uVar1;
  uint uVar2;
  ulong uVar3;
  uint local_20;

  uVar1 = DAT_00800643;
  DAT_00800643 = 0;
  flash_send_cmd('\x06');
  flash_send_cmd(cmd);
  if (addr_en != '\0')
  {
    if ((g_flashIsZbit != '\0') &&
        ((uVar2 = adc_get_result_with_fluct(&local_20), uVar2 <= g_flashWorkVol || (499 < local_20))))
      goto LAB_00000cf4;
    flash_send_addr(addr);
  }
  if (data_len != 0)
  {
    uVar3 = 0;
    do
    {
      DAT_0080000c = data[uVar3];
      do
      {
      } while ((DAT_0080000d & 0x10) != 0);
      uVar3 = uVar3 + 1;
    } while (uVar3 != data_len);
  }
LAB_00000cf4:
  DAT_0080000d = 1;
  flash_wait_done();
  DAT_00800643 = uVar1;
  return;
}
void c1(void)

{
  b1();
  return;
}
uchar analog_read(uchar addr)

{
  DAT_008000b8 = addr;
  DAT_008000ba = 0;
  return DAT_008000b9;
}
void analog_write(uchar addr, uchar v)

{
  DAT_008000b8 = addr;
  DAT_008000b9 = v;
  DAT_008000ba = 0;
  return;
}
// WARNING: Removing unreachable block (RAM,0x00001508)
// WARNING: Removing unreachable block (RAM,0x0000150e)
// WARNING: Removing unreachable block (RAM,0x00001514)
// WARNING: Removing unreachable block (RAM,0x00001522)
// WARNING: Removing unreachable block (RAM,0x00001524)
// WARNING: Removing unreachable block (RAM,0x0000151c)
uint cpu_get_32k_tick(void)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}
int rf_trx_state_set(RF_StatusTypeDef rf_status, char rf_channel)

{
  int iVar1;

  DAT_00800f02 = 0x45;
  rf_set_channel();
  if (rf_status == RF_MODE_TX)
  {
    DAT_00800f02 = 0x55;
    DAT_00800428 = DAT_00800428 & 0xfe;
    RF_TRxState = 0;
    iVar1 = 0;
  }
  else if (rf_status == RF_MODE_RX)
  {
    DAT_00800f02 = 0x65;
    DAT_00800428 = DAT_00800428 | 1;
    RF_TRxState = 1;
    iVar1 = 0;
  }
  else if (rf_status == RF_MODE_OFF)
  {
    DAT_00800f16 = 0x29;
    DAT_00800428 = 0xe0;
    DAT_00800f02 = 0x45;
    RF_TRxState = 3;
    iVar1 = 0;
  }
  else if (rf_status == RF_MODE_AUTO)
  {
    DAT_00800f00 = 0x80;
    DAT_00800f16 = 0x29;
    DAT_00800428 = DAT_00800428 & 0xfe;
    DAT_00800f02 = DAT_00800f02 & 0xce;
    RF_TRxState = 2;
    iVar1 = 0;
  }
  else
  {
    iVar1 = -2;
  }
  return iVar1;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void rf_tx_pkt(uchar *rf_txaddr)

{
  DAT_00800c43 = 4;
  _DAT_00800c0c = (short)rf_txaddr;
  DAT_00800c24 = DAT_00800c24 | 8;
  return;
}
// WARNING: Removing unreachable block (RAM,0x00001612)
void sleep_us(ulong us)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAB(void)

{
  div();
  return;
}
void FUN_00001624(void)

{
  div();
  return;
}
void FUN_00001628(void)

{
  div();
  return;
}
void FUN_0000162c(void)

{
  div();
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 div(void)

{
  undefined4 in_r0;
  undefined4 in_r1;
  uint in_r2;
  uint in_r3;

  getExecutionMode(in_r3);
  setExecutionMode(in_r3 | 0x80);
  _DAT_00800664 = in_r0;
  _DAT_00800668 = in_r1;
  DAT_00800660 = (char)in_r2;
  do
  {
  } while ((char)in_r2 != '\0');
  if (1 < in_r2)
  {
    in_r0 = in_r1;
  }
  setExecutionMode(in_r3);
  return in_r0;
}
void zdp_txCnfCb(void *arg)

{
  return;
}
void zdp_serverCmdHandler(void *ind)

{
  undefined uVar1;
  undefined uVar2;
  short sVar3;
  undefined2 *local_18;
  undefined2 uStack_14;
  undefined2 uStack_12;
  undefined2 local_10;
  undefined local_e;

  uVar1 = *(undefined *)(short *)((int)ind + 8);
  uVar2 = *(undefined *)((int)ind + 9);
  sVar3 = *(short *)((int)ind + 8);
  if (sVar3 == -0x7fe1)
  {
    zdo_parentAnnounceNotify(ind);
    zb_buf_free((zb_buf_t *)ind);
  }
  else
  {
    if ((ushort)(sVar3 + 0x8000U) < 2)
    {
      zdo_remoteAddrNotify(ind);
      uVar1 = *(undefined *)((int)ind + 8);
      uVar2 = *(undefined *)((int)ind + 9);
    }
    uStack_14 = *(undefined2 *)((int)ind + 0x14);
    uStack_12 = CONCAT11(uVar2, uVar1);
    local_18 = *(undefined2 **)((int)ind + 0xc);
    local_10 = *local_18;
    local_e = *(undefined *)((int)ind + 10);
    memcpy(ind, &local_18, 0xb);
    zdp_cb_process((ushort) * (byte *)((int)ind + 8), ind);
    zb_buf_free((zb_buf_t *)ind);
  }
  return;
}
void _ramcode_size_align_256_(void)

{
  zb_buf_t *unaff_r4;

  zb_buf_free(unaff_r4);
  return;
}
// WARNING: Could not reconcile some variable overlaps
void zdp_rxDataIndication(void *ind)

{
  int iVar1;
  u8 uVar2;
  undefined local_30[12];
  undefined4 uStack_24;
  uint uStack_20;
  zdo_callback p_Stack_1c;
  u8 local_18;

  if ((int)((uint) * (ushort *)((int)ind + 8) * 0x10000) < 0)
  {
    zdp_serverCmdHandler(ind);
  }
  else
  {
    iVar1 = 0;
    do
    {
      if (((uint)g_zdpClientFunc[iVar1].clusterId == (uint) * (ushort *)((int)ind + 8)) &&
          (g_zdpClientFunc[iVar1].func != ll_reset))
      {
        if (((g_zdpClientFunc[iVar1].restricted != 1) || (-1 < (int)((uint)aps_ib._18_1_ << 0x1c))) || ((uVar2 = 0x8d, *(u16 *)((int)ind + 0x14) == g_zbInfo.nwkNib.managerAddr &&
                                                                                                                           ((*(byte *)((int)ind + 0x1f) & 1) != 0))))
        {
          zz1(ind);
          return;
        }
        goto LAB_0000177c;
      }
      iVar1 = iVar1 + 1;
    } while (iVar1 != 0x12);
    uVar2 = 0x84;
  LAB_0000177c:
    // WARNING: Load size is inaccurate
    if ((*ind != '\x02') || ((*(ushort *)((int)ind + 2) & 0xfff8) != 0xfff8))
    {
      local_30._0_4_ = (u8 *)0x0;
      local_30._4_4_ = (u8 *)0x0;
      local_30._8_4_ = 0;
      uStack_24 = 0;
      uStack_20 = 0;
      p_Stack_1c = ll_reset;
      local_18 = '\0';
      local_30._0_4_ = (u8 *)tl_bufInitalloc((zb_buf_t *)ind, '\x02');
      *local_30._0_4_ = **(u8 **)((int)ind + 0xc);
      local_30._0_4_[1] = uVar2;
      uStack_20 = (uint)(uint3)(CONCAT12(2, *(undefined2 *)((int)ind + 8)) | 0x8000);
      local_30._8_4_ = local_30._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)ind + 0x14);
      p_Stack_1c = ll_reset;
      local_30._4_4_ = (u8 *)ind;
      zdo_send_req((zdo_zdp_req_t *)local_30);
    }
    zb_buf_free((zb_buf_t *)ind);
  }
  return;
}
void zz1(void)

{
  code *in_r3;

  (*in_r3)();
  af_endpointRegister('\0', &zdoSd, zdp_rxDataIndication, zdp_txCnfCb);
  return;
}
void zdp_init(void)

{
  af_endpointRegister('\0', &zdoSd, zdp_rxDataIndication, zdp_txCnfCb);
  return;
}
void zcl_reset(void)

{
  u8 *puVar1;
  int iVar2;

  zcl_vars.hookFn = ll_reset;
  zcl_vars.clusterNum = '\0';
  puVar1 = &zcl_vars.clusterList[0].endpoint;
  iVar2 = 0;
  do
  {
    *puVar1 = 0xfe;
    zcl_vars.clusterList[iVar2].clusterID = 0xfffe;
    puVar1[1] = '\0';
    *(undefined2 *)&zcl_vars.clusterList[iVar2].attrTable = 0;
    *(undefined2 *)((int)&zcl_vars.clusterList[iVar2].attrTable + 2) = 0;
    *(undefined2 *)&zcl_vars.clusterList[iVar2].cmdHandlerFunc = 0;
    *(undefined2 *)((int)&zcl_vars.clusterList[iVar2].cmdHandlerFunc + 2) = 0;
    *(undefined2 *)&zcl_vars.clusterList[iVar2].clusterAppCb = 0;
    *(undefined2 *)((int)&zcl_vars.clusterList[iVar2].clusterAppCb + 2) = 0;
    iVar2 = iVar2 + 1;
    puVar1 = puVar1 + 0x12;
  } while (iVar2 != 0x10);
  return;
}
void zcl_init(zcl_hookFn_t fn)

{
  u32 uVar1;

  zcl_reset();
  uVar1 = drv_u32Rand();
  zcl_seqNum = (u8)uVar1;
  zcl_vars.hookFn = fn;
  return;
}
void zcl_register(u8 endpoint, u8 clusterNum, zcl_specClusterInfo_t *info)

{
  int iVar1;
  uint uVar2;

  if (clusterNum == 0)
  {
    return;
  }
  uVar2 = 0;
  while ((info->clusterRegisterFunc == ll_reset ||
          (iVar1 = FUN_0000192a(endpoint, info->manuCode, *(undefined *)&info->attrNum, info->attrTbl,
                                info->clusterAppCb),
           iVar1 != 0x89)))
  {
    uVar2 = uVar2 + 1;
    if (clusterNum <= uVar2)
    {
      return;
    }
    info = info + 1;
  }
  return;
}
undefined4 FUN_0000192a(void)

{
  u8 uVar1;
  undefined4 uVar2;
  uint extraout_r1;
  uint uVar3;
  u16 extraout_r2;
  u8 *puVar4;
  u8 extraout_r3;
  int iVar5;
  code *unaff_ip;
  undefined4 in_stack_00000000;
  undefined2 uStack00000004;
  undefined2 uStack00000008;

  uVar1 = (*unaff_ip)();
  uVar3 = (uint)zcl_vars.clusterNum;
  uVar2 = 0x89;
  if (uVar3 < 0x10)
  {
    puVar4 = &zcl_vars.clusterList[0].endpoint;
    iVar5 = 0;
    do
    {
      if ((*puVar4 == uVar1) &&
          ((uint)zcl_vars.clusterList[iVar5].clusterID == (extraout_r1 & 0xffff)))
      {
        return 0x8a;
      }
      iVar5 = iVar5 + 1;
      puVar4 = puVar4 + 0x12;
    } while (iVar5 != 0x10);
    zcl_vars.clusterList[uVar3].endpoint = uVar1;
    zcl_vars.clusterList[uVar3].clusterID = (u16)extraout_r1;
    zcl_vars.clusterList[uVar3].manuCode = extraout_r2;
    zcl_vars.clusterList[uVar3].attrNum = extraout_r3;
    *(undefined2 *)&zcl_vars.clusterList[uVar3].cmdHandlerFunc = uStack00000004;
    *(short *)((int)&zcl_vars.clusterList[uVar3].cmdHandlerFunc + 2) =
        (short)((uint)_uStack00000004 >> 0x10);
    *(undefined2 *)&zcl_vars.clusterList[uVar3].clusterAppCb = uStack00000008;
    *(short *)((int)&zcl_vars.clusterList[uVar3].clusterAppCb + 2) =
        (short)((uint)_uStack00000008 >> 0x10);
    *(short *)&zcl_vars.clusterList[uVar3].attrTable = (short)in_stack_00000000;
    *(short *)((int)&zcl_vars.clusterList[uVar3].attrTable + 2) =
        (short)((uint)in_stack_00000000 >> 0x10);
    zcl_vars.clusterNum = zcl_vars.clusterNum + '\x01';
    uVar2 = 0;
  }
  return uVar2;
}
status_t zcl_registerCluster(u8 endpoint, u16 clusterId, u16 manuCode, u8 attrNum,
                             zclAttrInfo_t *pAttrTbl, cluster_cmdHdlr_t cmdHdlrFn,
                             cluster_forAppCb_t cb)

{
  status_t sVar1;
  uint uVar2;
  u8 *puVar3;
  int iVar4;

  uVar2 = (uint)zcl_vars.clusterNum;
  sVar1 = 0x89;
  if (uVar2 < 0x10)
  {
    puVar3 = &zcl_vars.clusterList[0].endpoint;
    iVar4 = 0;
    do
    {
      if ((*puVar3 == endpoint) && (zcl_vars.clusterList[iVar4].clusterID == clusterId))
      {
        return 0x8a;
      }
      iVar4 = iVar4 + 1;
      puVar3 = puVar3 + 0x12;
    } while (iVar4 != 0x10);
    zcl_vars.clusterList[uVar2].endpoint = endpoint;
    zcl_vars.clusterList[uVar2].clusterID = clusterId;
    zcl_vars.clusterList[uVar2].manuCode = manuCode;
    zcl_vars.clusterList[uVar2].attrNum = attrNum;
    zcl_vars.clusterList[uVar2].cmdHandlerFunc = cmdHdlrFn;
    zcl_vars.clusterList[uVar2].clusterAppCb = cb;
    zcl_vars.clusterList[uVar2].attrTable = pAttrTbl;
    zcl_vars.clusterNum = zcl_vars.clusterNum + '\x01';
    sVar1 = '\0';
  }
  return sVar1;
}
u8 zcl_getDataTypeLen(u8 dataType)

{
  u8 uVar1;
  uint uVar2;

  uVar2 = (uint)dataType * 0x1000000 + 0xf8000000 >> 0x18;
  uVar1 = '\0';
  if (uVar2 < 0xea)
  {
    uVar1 = CSWTCH_32[uVar2];
  }
  return uVar1;
}
u8 zcl_analogDataType(u8 dataType)

{
  uint uVar1;

  uVar1 = (uint)dataType;
  if (uVar1 < 0x3b)
  {
    if (uVar1 < 0x38)
    {
      if (0xf < uVar1 - 0x20)
      {
        return '\0';
      }
      return '\x01';
    }
  }
  else if (2 < uVar1 - 0xe0)
  {
    return '\0';
  }
  return '\x01';
}
u16 zcl_getAttrSize(u8 dataType, u8 *pData)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  uint uVar4;

  uVar1 = (uint)dataType;
  if (uVar1 * 0x1000000 + 0xbd000000 >> 0x18 < 2)
  {
    uVar1 = *pData + 2 + (uint)pData[1] * 0x100 & 0xffff;
  }
  else if ((uVar1 - 0x41 & 0xff) < 2)
  {
    uVar1 = *pData + 1;
  }
  else if (uVar1 == 0x4c)
  {
    uVar1 = 2;
    if (*pData != 0)
    {
      bVar3 = 0;
      do
      {
        uVar4 = pData[uVar1] - 8 & 0xff;
        iVar2 = 1;
        if (uVar4 < 0xea)
        {
          iVar2 = (byte)CSWTCH_32[uVar4] + 1;
        }
        uVar1 = iVar2 + uVar1 & 0xffff;
        bVar3 = bVar3 + 1;
      } while (bVar3 < *pData);
    }
  }
  else
  {
    uVar4 = uVar1 - 8 & 0xff;
    uVar1 = 0;
    if (uVar4 < 0xea)
    {
      uVar1 = (uint)(byte)CSWTCH_32[uVar4];
    }
  }
  return (u16)uVar1;
}
// WARNING: Removing unreachable block (RAM,0x00001ace)
void zcl_analogDataBuild(u8 dataType, u8 *pData, u8 *pBuf)

{
  u16 uVar1;
  uint uVar2;

  uVar1 = zcl_getAttrSize(dataType, pData);
  if (uVar1 != 0)
  {
    uVar2 = 0;
    do
    {
      *pData = pBuf[uVar2];
      uVar2 = uVar2 + 1;
      pData = pData + 1;
    } while (uVar2 != uVar1);
  }
  return;
}
status_t zcl_getAttrVal(u8 endpoint, u16 clusterId, u16 attrId, u16 *len, u8 *val)

{
  u8 *pData;
  status_t sVar1;
  u16 uVar2;
  zclAttrInfo_t *pzVar3;

  pzVar3 = zcl_findAttribute(endpoint, clusterId, attrId);
  if (pzVar3 == (zclAttrInfo_t *)0x0)
  {
    *len = 0;
    sVar1 = 0x8b;
  }
  else
  {
    pData = pzVar3->data;
    if (pData == (u8 *)0x0)
    {
      *len = 0;
      sVar1 = 0x8b;
    }
    else
    {
      uVar2 = zcl_getAttrSize(pzVar3->type, pData);
      *len = uVar2;
      memcpy(val, pData, (uint)uVar2);
      sVar1 = '\0';
    }
  }
  return sVar1;
}
status_t zcl_setAttrVal(u8 endpoint, u16 clusterId, u16 attrId, u8 *val)

{
  status_t sVar1;
  u16 uVar2;
  zclAttrInfo_t *pzVar3;

  pzVar3 = zcl_findAttribute(endpoint, clusterId, attrId);
  sVar1 = 0x86;
  if (pzVar3 != (zclAttrInfo_t *)0x0)
  {
    uVar2 = zcl_getAttrSize(pzVar3->type, val);
    memcpy(pzVar3->data, val, (uint)uVar2);
    sVar1 = '\0';
  }
  return sVar1;
}
status_t zcl_attrWrite(u8 endpoint, u16 clusterId, zclWriteRec_t *pWriteRec, u8 enable)

{
  u16 attrId;
  status_t sVar1;
  zclAttrInfo_t *pzVar2;

  attrId = pWriteRec->attrID;
  pzVar2 = zcl_findAttribute(endpoint, clusterId, attrId);
  sVar1 = 0x86;
  if ((((pzVar2 != (zclAttrInfo_t *)0x0) && (sVar1 = 0x8d, pzVar2->type == pWriteRec->dataType)) &&
       (sVar1 = 0x88, (int)((uint)pzVar2->access << 0x1e) < 0)) &&
      ((sVar1 = 0x86, pzVar2->data != (u8 *)0x0 && (sVar1 = '\0', enable != '\0'))))
  {
    sVar1 = zcl_setAttrVal(endpoint, clusterId, attrId, pWriteRec->attrData);
  }
  return sVar1;
}
status_t zcl_sendCmd(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u8 cmd, u8 specific, u8 direction,
                     u8 disableDefaultRsp, u16 manuCode, u8 seqNo, u16 cmdPldLen, u8 *cmdPld)

{
  u8 uVar1;
  byte *cmdPld_00;
  byte *pbVar2;
  byte bVar3;
  u8 local_25;

  _cmdPldLen = (uint)cmdPldLen;
  cmdPld_00 = ev_buf_allocate((u16)(_cmdPldLen * 0x10000 + 0x50000 >> 0x10));
  bVar3 = 0x89;
  if (cmdPld_00 != (byte *)0x0)
  {
    *cmdPld_00 = 1U - (specific == '\0') | *cmdPld_00 & 0xfc;
    *cmdPld_00 = *cmdPld_00 & 0xfb | (manuCode != 0) * '\x04';
    *cmdPld_00 = *cmdPld_00 & 0xf7 | (byte)((direction & 1) << 3);
    *cmdPld_00 = *cmdPld_00 & 0xef | (byte)((disableDefaultRsp & 1) << 4);
    *cmdPld_00 = *cmdPld_00 & 0x1f;
    pbVar2 = cmdPld_00 + 1;
    if (manuCode != 0)
    {
      *(u16 *)(cmdPld_00 + 1) = manuCode;
      pbVar2 = cmdPld_00 + 3;
    }
    *pbVar2 = seqNo;
    pbVar2[1] = cmd;
    memcpy(cmdPld_00 + ((uint)(pbVar2 + (2 - (int)cmdPld_00)) & 0xff), cmdPld, (uint)cmdPldLen);
    local_25 = '\0';
    uVar1 = af_dataSend(srcEp, pDstEpInfo, clusterId,
                        (cmdPldLen - (short)cmdPld_00) +
                            (short)(cmdPld_00 + ((uint)(pbVar2 + (2 - (int)cmdPld_00)) & 0xff)),
                        cmdPld_00, &local_25);
    ev_buf_free(cmdPld_00);
    bVar3 = ~(1U - (uVar1 == '\0')) & 0x89;
  }
  return bVar3;
}
void zcl_rx_handler(void *pData)

{
  tl_zbTaskPost(zcl_cmdHandler, pData);
  return;
}
status_t zcl_readRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                     u8 direction, u8 seqNo, zclReadRspCmd_t *readRspCmd)

{
  byte bVar1;
  status_t sVar2;
  u16 uVar3;
  u16 uVar4;
  u8 *cmdPld;
  zclReadRspCmd_t *pzVar5;
  u8 *puVar6;
  u8 *out;
  uint uVar7;

  bVar1 = readRspCmd->numAttr;
  if (bVar1 == 0)
  {
    uVar3 = 0;
  }
  else
  {
    uVar7 = 0;
    pzVar5 = readRspCmd;
    uVar4 = 0;
    do
    {
      uVar3 = uVar4 + 3;
      if (pzVar5[3].numAttr == '\0')
      {
        if (*(u8 **)(readRspCmd + uVar7 * 8 + 5) == (u8 *)0x0)
        {
          return 0x85;
        }
        uVar3 = zcl_getAttrSize(pzVar5[4].numAttr, *(u8 **)(readRspCmd + uVar7 * 8 + 5));
        uVar3 = uVar4 + 4 + uVar3;
      }
      uVar7 = uVar7 + 1;
      pzVar5 = pzVar5 + 8;
      uVar4 = uVar3;
    } while ((uVar7 & 0xff) < (uint)bVar1);
  }
  cmdPld = ev_buf_allocate(uVar3);
  sVar2 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (readRspCmd->numAttr != '\0')
    {
      uVar7 = 0;
      puVar6 = cmdPld;
      do
      {
        *puVar6 = readRspCmd[uVar7 * 8 + 1].numAttr;
        puVar6[1] = readRspCmd[uVar7 * 8 + 2].numAttr;
        puVar6[2] = readRspCmd[uVar7 * 8 + 3].numAttr;
        out = puVar6 + 3;
        if (readRspCmd[uVar7 * 8 + 3].numAttr == '\0')
        {
          puVar6[3] = readRspCmd[uVar7 * 8 + 4].numAttr;
          out = puVar6 + 4;
          puVar6 = *(u8 **)(readRspCmd + uVar7 * 8 + 5);
          if (puVar6 != (u8 *)0x0)
          {
            uVar4 = zcl_getAttrSize(readRspCmd[uVar7 * 8 + 4].numAttr, puVar6);
            memcpy(out, puVar6, (uint)uVar4);
            out = out + uVar4;
          }
        }
        uVar7 = uVar7 + 1 & 0xff;
        puVar6 = out;
      } while (uVar7 < readRspCmd->numAttr);
    }
    sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\x01', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, uVar3, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar2;
}
status_t zcl_readRspHandler(zclIncoming_t *pCmd)

{
  zclReadRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInReadRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclReadRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}
status_t zcl_readHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  apsdeDataInd_t *paVar1;
  u16 clusterId;
  u8 *puVar2;
  undefined2 uVar3;
  zclReadRspCmd_t zVar4;
  zclReadCmd_t *pzVar5;
  zclReadRspCmd_t *readRspCmd;
  zclAttrInfo_t *pzVar6;
  int iVar7;
  byte bVar8;
  uint uVar9;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;
  zclReadRspCmd_t local_25;

  local_25.numAttr = '\0';
  paVar1 = pCmd->msg;
  clusterId = (paVar1->indInfo).cluster_id;
  endpoint = (paVar1->indInfo).dst_ep;
  g_sysDiags.lastMessageLQI = (paVar1->indInfo).lqi;
  g_sysDiags.lastMessageRSSI = (pCmd->msg->indInfo).rssi;
  pzVar5 = zcl_parseInReadCmd(pCmd);
  zVar4.numAttr = 0x89;
  if (pzVar5 != (zclReadCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    zVar4.numAttr = '\x01';
    if ((pCmd->msg->indInfo).security_status != 0)
    {
      readRspCmd = (zclReadRspCmd_t *)
          ev_buf_allocate((u16)((uint)pzVar5->numAttr * 0x80000 + 0x10000 >> 0x10));
      zVar4.numAttr = 0x89;
      if (readRspCmd != (zclReadRspCmd_t *)0x0)
      {
        readRspCmd->numAttr = pzVar5->numAttr;
        uVar9 = 0;
        if (pzVar5->numAttr != '\0')
        {
          do
          {
            pzVar6 = zcl_attrRead(endpoint, clusterId, *(u16 *)(pzVar5 + uVar9 * 2 + 1),
                                  &local_25.numAttr);
            iVar7 = uVar9 * 8;
            if (pzVar6 != (zclAttrInfo_t *)0x0)
            {
              readRspCmd[iVar7 + 4].numAttr = pzVar6->type;
              puVar2 = pzVar6->data;
              readRspCmd[iVar7 + 5].numAttr = (u8)puVar2;
              readRspCmd[iVar7 + 6].numAttr = (u8)((uint)puVar2 >> 8);
              readRspCmd[iVar7 + 7].numAttr = (u8)((uint)puVar2 >> 0x10);
              readRspCmd[iVar7 + 8].numAttr = (u8)((uint)puVar2 >> 0x18);
            }
            uVar3 = *(undefined2 *)(pzVar5 + uVar9 * 2 + 1);
            readRspCmd[iVar7 + 1].numAttr = (u8)uVar3;
            readRspCmd[iVar7 + 2].numAttr = (u8)((ushort)uVar3 >> 8);
            readRspCmd[iVar7 + 3].numAttr = local_25.numAttr;
            uVar9 = uVar9 + 1 & 0xff;
          } while (uVar9 < pzVar5->numAttr);
        }
        uStack_34 = 0;
        paVar1 = pCmd->msg;
        uStack_30 = (uint)(paVar1->indInfo).profile_id;
        uStack_2c = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
        local_38 = (uint)(paVar1->indInfo).field_10.src_short_addr;
        local_28 = 4;
        if ((int)((uint)(paVar1->indInfo).security_status << 0x1f) < 0)
        {
          local_28 = 5;
        }
        bVar8 = (pCmd->hdr).frmCtrl.byte & 8;
        local_25.numAttr =
            zcl_readRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                        bVar8 + ~bVar8, (pCmd->hdr).seqNum, readRspCmd);
        ev_buf_free((u8 *)readRspCmd);
        zVar4.numAttr = local_25.numAttr;
        if (local_25.numAttr == '\0')
        {
          zVar4.numAttr = 0xff;
        }
      }
    }
  }
  return zVar4.numAttr;
}
status_t zcl_writeRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                      u8 direction, u8 seqNo, zclWriteRspCmd_t *writeRspCmd)

{
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  uint uVar3;
  u16 size;

  size = (ushort)writeRspCmd->numAttr * 3;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (writeRspCmd->numAttr != '\0')
    {
      uVar3 = 0;
      puVar2 = cmdPld;
      do
      {
        *puVar2 = writeRspCmd[uVar3 * 3 + 1].numAttr;
        puVar2[1] = writeRspCmd[uVar3 * 3 + 2].numAttr;
        puVar2[2] = writeRspCmd[uVar3 * 3 + 3].numAttr;
        puVar2 = puVar2 + 3;
        uVar3 = uVar3 + 1 & 0xff;
      } while (uVar3 < writeRspCmd->numAttr);
      if ((writeRspCmd->numAttr == 1) && (writeRspCmd[1].numAttr == '\0'))
      {
        size = 1;
      }
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\x04', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}
status_t zcl_writeRspHandler(zclIncoming_t *pCmd)

{
  zclWriteRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInWriteRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclWriteRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}
status_t zcl_writeHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  u16 clusterId;
  undefined2 uVar1;
  bool bVar2;
  apsdeDataInd_t *paVar3;
  status_t sVar4;
  zclWriteCmd_t *pzVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uStack_44;
  zclWriteRspCmd_t *pzStack_40;
  u8 uStack_3c;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  endpoint = (pCmd->msg->indInfo).dst_ep;
  pzVar5 = zcl_parseInWriteCmd(pCmd);
  sVar4 = 0x89;
  if (pzVar5 != (zclWriteCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    if ((pCmd->hdr).cmd == '\x02')
    {
      pzStack_40 = (zclWriteRspCmd_t *)ev_buf_allocate((ushort)pzVar5->numAttr * 3 + 1);
      if (pzStack_40 == (zclWriteRspCmd_t *)0x0)
      {
        return 0x89;
      }
      bVar2 = true;
    }
    else
    {
      bVar2 = false;
      pzStack_40 = (zclWriteRspCmd_t *)0x0;
    }
    uVar7 = (uint)pzVar5->numAttr;
    if (uVar7 == 0)
    {
      uStack_3c = '\0';
      uStack_44 = 0;
      sVar4 = '\0';
    }
    else
    {
      uVar8 = 0;
      uStack_44 = 0;
      uVar9 = 0;
      do
      {
        while (sVar4 = zcl_attrWrite(endpoint, clusterId, (zclWriteRec_t *)(pzVar5 + uVar8 * 7 + 1),
                                     '\x01'),
               !bVar2)
        {
        LAB_000025ec:
          uVar8 = uVar8 + 1 & 0xff;
          uVar7 = (uint)pzVar5->numAttr;
          if (uVar7 <= uVar8)
            goto LAB_0000264a;
        }
        if (sVar4 == '\0')
        {
          uStack_44 = uStack_44 + 1 & 0xff;
          goto LAB_000025ec;
        }
        pzStack_40[uVar9 * 3 + 1].numAttr = sVar4;
        uVar1 = *(undefined2 *)(pzVar5 + uVar8 * 7 + 1);
        pzStack_40[uVar9 * 3 + 2].numAttr = (u8)uVar1;
        pzStack_40[uVar9 * 3 + 3].numAttr = (u8)((ushort)uVar1 >> 8);
        uVar9 = uVar9 + 1 & 0xff;
        uVar8 = uVar8 + 1 & 0xff;
        uVar7 = (uint)pzVar5->numAttr;
      } while (uVar8 < uVar7);
    LAB_0000264a:
      uStack_3c = (u8)uVar9;
    }
    if (bVar2)
    {
      if (uVar7 == uStack_44)
      {
        pzStack_40->numAttr = '\x01';
        pzStack_40[1].numAttr = '\0';
      }
      else
      {
        pzStack_40->numAttr = uStack_3c;
      }
      uStack_34 = 0;
      paVar3 = pCmd->msg;
      uStack_30 = (uint)(paVar3->indInfo).profile_id;
      uStack_2c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
      local_38 = (uint)(paVar3->indInfo).field_10.src_short_addr;
      local_28 = 4;
      if ((int)((uint)(paVar3->indInfo).security_status << 0x1f) < 0)
      {
        local_28 = 5;
      }
      bVar6 = (pCmd->hdr).frmCtrl.byte & 8;
      sVar4 = zcl_writeRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                           bVar6 + ~bVar6, (pCmd->hdr).seqNum, pzStack_40);
      if (sVar4 == '\0')
      {
        sVar4 = 0xff;
      }
      ev_buf_free(&pzStack_40->numAttr);
    }
  }
  return sVar4;
}
status_t zcl_writeUndividedHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  u16 clusterId;
  ushort uVar1;
  apsdeDataInd_t *paVar2;
  byte bVar3;
  status_t sVar4;
  zclWriteCmd_t *pzVar5;
  zclWriteRspCmd_t *writeRspCmd;
  uint uVar6;
  byte bVar7;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  endpoint = (pCmd->msg->indInfo).dst_ep;
  pzVar5 = zcl_parseInWriteCmd(pCmd);
  if (pzVar5 == (zclWriteCmd_t *)0x0)
  {
    return 0x89;
  }
  *(char *)&pCmd->attrCmd = (char)pzVar5;
  *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
  *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
  *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
  writeRspCmd = (zclWriteRspCmd_t *)ev_buf_allocate((ushort)pzVar5->numAttr * 3 + 1);
  if (writeRspCmd == (zclWriteRspCmd_t *)0x0)
  {
    return 0x89;
  }
  if (pzVar5->numAttr == '\0')
  {
    writeRspCmd->numAttr = '\0';
  }
  else
  {
    uVar6 = 0;
    bVar7 = 1;
    do
    {
      bVar3 = zcl_attrWrite(endpoint, clusterId, (zclWriteRec_t *)(pzVar5 + uVar6 * 7 + 1), '\0');
      writeRspCmd[uVar6 * 3 + 1].numAttr = bVar3;
      uVar1 = *(ushort *)(pzVar5 + uVar6 * 7 + 1);
      writeRspCmd[uVar6 * 3 + 2].numAttr = (u8)uVar1;
      writeRspCmd[uVar6 * 3 + 3].numAttr = (u8)(uVar1 >> 8);
      bVar7 = bVar7 & ~(bVar3 + ~bVar3 + ((uVar1 >> 7 & 1) != 0));
      uVar6 = uVar6 + 1 & 0xff;
    } while (uVar6 < pzVar5->numAttr);
    writeRspCmd->numAttr = pzVar5->numAttr;
    if (bVar7 == 0)
      goto LAB_000027ea;
  }
  if (pzVar5->numAttr != '\0')
  {
    uVar6 = 0;
    do
    {
      zcl_attrWrite(endpoint, clusterId, (zclWriteRec_t *)(pzVar5 + uVar6 * 7 + 1), '\x01');
      uVar6 = uVar6 + 1 & 0xff;
    } while (uVar6 < pzVar5->numAttr);
  }
  writeRspCmd->numAttr = '\x01';
  writeRspCmd[1].numAttr = '\0';
LAB_000027ea:
  uStack_34 = 0;
  paVar2 = pCmd->msg;
  uStack_30 = (uint)(paVar2->indInfo).profile_id;
  uStack_2c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
  local_38 = (uint)(paVar2->indInfo).field_10.src_short_addr;
  local_28 = (ushort)(((paVar2->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
  bVar7 = (pCmd->hdr).frmCtrl.byte & 8;
  sVar4 = zcl_writeRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                       bVar7 + ~bVar7, (pCmd->hdr).seqNum, writeRspCmd);
  if (sVar4 == '\0')
  {
    sVar4 = 0xff;
  }
  ev_buf_free((u8 *)writeRspCmd);
  return sVar4;
}
status_t zcl_configReportRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode,
                             u8 disableDefaultRsp, u8 direction, u8 seqNo,
                             zclCfgReportRspCmd_t *cfgReportRspCmd)

{
  u16 size;
  status_t sVar1;
  u8 *cmdPld;
  uint uVar2;
  u8 *puVar3;

  size = (ushort)cfgReportRspCmd->numAttr * 4;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (cfgReportRspCmd->numAttr != '\0')
    {
      uVar2 = 0;
      puVar3 = cmdPld;
      do
      {
        *puVar3 = cfgReportRspCmd[uVar2 * 4 + 1].numAttr;
        puVar3[1] = cfgReportRspCmd[uVar2 * 4 + 2].numAttr;
        puVar3[2] = cfgReportRspCmd[uVar2 * 4 + 3].numAttr;
        puVar3[3] = cfgReportRspCmd[uVar2 * 4 + 4].numAttr;
        puVar3 = puVar3 + 4;
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < cfgReportRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\a', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}
status_t zcl_readReportConfigRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                                 u8 direction, u8 seqNo, zclReadReportCfgRspCmd_t *readReportCfgRspCmd)

{
  status_t sVar1;
  u16 uVar2;
  u16 uVar3;
  u8 *cmdPld;
  uint uVar4;
  u8 *out;
  zclReadReportCfgRspCmd_t *pzVar5;
  u8 *puVar6;
  uint uVar7;
  uint uVar8;

  uVar4 = (uint)readReportCfgRspCmd->numAttr;
  uVar2 = 0;
  if (uVar4 != 0)
  {
    uVar7 = 0;
    uVar2 = 0;
    pzVar5 = readReportCfgRspCmd;
  LAB_000029c2:
    do
    {
      uVar3 = uVar2 + 4;
      if (pzVar5[1].numAttr == '\0')
      {
        if (pzVar5[2].numAttr == '\0')
        {
          uVar3 = uVar2 + 9;
          uVar8 = (uint)pzVar5[5].numAttr;
          if (uVar8 < 0x3b)
          {
            if ((uVar8 < 0x38) && (0xf < uVar8 - 0x20))
              goto joined_r0x00002b58;
          }
          else if (2 < uVar8 - 0xe0)
            goto joined_r0x00002b58;
          uVar2 = zcl_getAttrSize(pzVar5[5].numAttr,
                                  *(u8 **)(readReportCfgRspCmd + uVar7 * 0xf + 0xc));
          uVar2 = uVar2 + uVar3;
          uVar7 = uVar7 + 1;
          pzVar5 = pzVar5 + 0xf;
          if (uVar4 <= (uVar7 & 0xff))
            break;
          goto LAB_000029c2;
        }
        uVar3 = uVar2 + 6;
      }
    joined_r0x00002b58:
      uVar2 = uVar3;
      uVar8 = uVar7 + 1;
      pzVar5 = pzVar5 + 0xf;
      uVar7 = uVar7 + 1;
    } while ((uVar8 & 0xff) < uVar4);
  }
  cmdPld = ev_buf_allocate(uVar2);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (readReportCfgRspCmd->numAttr != '\0')
    {
      uVar4 = 0;
      puVar6 = cmdPld;
    LAB_00002a1a:
      do
      {
        *puVar6 = readReportCfgRspCmd[uVar4 * 0xf + 1].numAttr;
        puVar6[1] = readReportCfgRspCmd[uVar4 * 0xf + 2].numAttr;
        puVar6[2] = readReportCfgRspCmd[uVar4 * 0xf + 3].numAttr;
        puVar6[3] = readReportCfgRspCmd[uVar4 * 0xf + 4].numAttr;
        out = puVar6 + 4;
        if (readReportCfgRspCmd[uVar4 * 0xf + 1].numAttr != '\0')
          goto LAB_00002a76;
        if (readReportCfgRspCmd[uVar4 * 0xf + 2].numAttr == '\0')
        {
          puVar6[4] = readReportCfgRspCmd[uVar4 * 0xf + 5].numAttr;
          puVar6[5] = readReportCfgRspCmd[uVar4 * 0xf + 6].numAttr;
          puVar6[6] = readReportCfgRspCmd[uVar4 * 0xf + 7].numAttr;
          puVar6[7] = readReportCfgRspCmd[uVar4 * 0xf + 8].numAttr;
          puVar6[8] = readReportCfgRspCmd[uVar4 * 0xf + 9].numAttr;
          out = puVar6 + 9;
          uVar7 = (uint)readReportCfgRspCmd[uVar4 * 0xf + 5].numAttr;
          if (uVar7 < 0x3b)
          {
            if ((0x37 < uVar7) || (uVar7 - 0x20 < 0x10))
            {
            LAB_00002b08:
              puVar6 = *(u8 **)(readReportCfgRspCmd + uVar4 * 0xf + 0xc);
              uVar3 = zcl_getAttrSize(readReportCfgRspCmd[uVar4 * 0xf + 5].numAttr, puVar6);
              memcpy(out, puVar6, (uint)uVar3);
              puVar6 = out + uVar3;
              uVar4 = uVar4 + 1 & 0xff;
              if (readReportCfgRspCmd->numAttr <= uVar4)
                break;
              goto LAB_00002a1a;
            }
          }
          else if (uVar7 - 0xe0 < 3)
            goto LAB_00002b08;
        LAB_00002a76:
          puVar6 = out;
          uVar4 = uVar4 + 1 & 0xff;
          if (readReportCfgRspCmd->numAttr <= uVar4)
            break;
          goto LAB_00002a1a;
        }
        puVar6[4] = readReportCfgRspCmd[uVar4 * 0xf + 10].numAttr;
        puVar6[5] = readReportCfgRspCmd[uVar4 * 0xf + 0xb].numAttr;
        puVar6 = puVar6 + 6;
        uVar4 = uVar4 + 1 & 0xff;
      } while (uVar4 < readReportCfgRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\t', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, uVar2, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}
status_t zcl_configureReporting(u8 endpoint, u16 profileId, u16 clusterId, zclCfgReportRec_t *pCfgReportRec)

{
  u16 attrId;
  zclAttrInfo_t *pzVar1;
  reportCfgInfo_t *pEntry;
  status_t sVar2;

  attrId = pCfgReportRec->attrID;
  pzVar1 = zcl_findAttribute(endpoint, clusterId, attrId);
  if (pzVar1 == (zclAttrInfo_t *)0x0)
  {
    return 0x86;
  }
  if (pzVar1->type != pCfgReportRec->dataType)
  {
    return 0x8d;
  }
  if (-1 < (int)((uint)pzVar1->access << 0x1d))
  {
    return 0x86;
  }
  if (pCfgReportRec->direction == '\x01')
  {
    return 0x86;
  }
  pEntry = zcl_reportCfgInfoEntryFind(endpoint, clusterId, attrId);
  if (pCfgReportRec->maxReportInt == 0xffff)
  {
    sVar2 = 0x8b;
  }
  else
  {
    if ((pCfgReportRec->maxReportInt == 0) && (pCfgReportRec->minReportInt == 0xffff))
    {
      if (pEntry == (reportCfgInfo_t *)0x0)
      {
        return 0x8b;
      }
      zcl_reportCfgInfoEntryRst(pEntry);
      return '\0';
    }
    if (pEntry != (reportCfgInfo_t *)0x0)
      goto LAB_00002de2;
    pEntry = zcl_reportCfgInfoEntryFreeGet();
    sVar2 = 0x89;
  }
  if (pEntry == (reportCfgInfo_t *)0x0)
  {
    return sVar2;
  }
LAB_00002de2:
  zcl_reportCfgInfoEntryUpdate(pEntry, endpoint, profileId, clusterId, pCfgReportRec);
  return '\0';
}
status_t zcl_configReportHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  apsdeDataInd_t *paVar1;
  u16 profileId;
  u16 clusterId;
  undefined2 uVar2;
  bool bVar3;
  status_t sVar4;
  zclCfgReportCmd_t *pzVar5;
  zclCfgReportRspCmd_t *cfgReportRspCmd;
  byte bVar6;
  uint uVar7;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  paVar1 = pCmd->msg;
  profileId = (paVar1->indInfo).profile_id;
  clusterId = (paVar1->indInfo).cluster_id;
  endpoint = (paVar1->indInfo).dst_ep;
  pzVar5 = zcl_parseInCfgReportCmd(pCmd);
  sVar4 = 0x89;
  if (pzVar5 != (zclCfgReportCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    sVar4 = 0x85;
    if (pzVar5->numAttr != 0)
    {
      cfgReportRspCmd =
          (zclCfgReportRspCmd_t *)
              ev_buf_allocate((ushort)(byte)((uint)pzVar5->numAttr * 0x4000000 + 0x1000000 >> 0x18));
      sVar4 = 0x89;
      if (cfgReportRspCmd != (zclCfgReportRspCmd_t *)0x0)
      {
        cfgReportRspCmd->numAttr = pzVar5->numAttr;
        if (pzVar5->numAttr != '\0')
        {
          uVar7 = 0;
          bVar3 = false;
          do
          {
            sVar4 = zcl_configureReporting(endpoint, profileId, clusterId,
                                           (zclCfgReportRec_t *)(pzVar5 + uVar7 * 0xe + 1));
            if (sVar4 == '\0')
            {
              bVar3 = true;
            }
            cfgReportRspCmd[uVar7 * 4 + 1].numAttr = sVar4;
            uVar2 = *(undefined2 *)(pzVar5 + uVar7 * 0xe + 2);
            cfgReportRspCmd[uVar7 * 4 + 3].numAttr = (u8)uVar2;
            cfgReportRspCmd[uVar7 * 4 + 4].numAttr = (u8)((ushort)uVar2 >> 8);
            cfgReportRspCmd[uVar7 * 4 + 2].numAttr = pzVar5[uVar7 * 0xe + 1].numAttr;
            uVar7 = uVar7 + 1 & 0xff;
          } while (uVar7 < pzVar5->numAttr);
          if (bVar3)
          {
            zcl_reportingTab_save();
          }
        }
        uStack_34 = 0;
        paVar1 = pCmd->msg;
        uStack_30 = (uint)(paVar1->indInfo).profile_id;
        uStack_2c = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
        local_38 = (uint)(paVar1->indInfo).field_10.src_short_addr;
        local_28 = (ushort)(((paVar1->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
        bVar6 = (pCmd->hdr).frmCtrl.byte & 8;
        sVar4 = zcl_configReportRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode,
                                    '\x01', bVar6 + ~bVar6, (pCmd->hdr).seqNum, cfgReportRspCmd);
        if (sVar4 == '\0')
        {
          sVar4 = 0xff;
        }
        ev_buf_free((u8 *)cfgReportRspCmd);
      }
    }
  }
  return sVar4;
}
u8 zcl_configReportRspHandler(zclIncoming_t *pCmd)

{
  zclCfgReportRspCmd_t *pzVar1;
  u8 uVar2;

  pzVar1 = zcl_parseInCfgReportRspCmd(pCmd);
  uVar2 = 0x89;
  if (pzVar1 != (zclCfgReportRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    uVar2 = '\0';
  }
  return uVar2;
}
status_t zcl_readReportCfgHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  u16 clusterId;
  undefined2 uVar1;
  u16 uVar2;
  apsdeDataInd_t *paVar3;
  status_t sVar4;
  zclReadReportCfgCmd_t *pzVar5;
  zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
  zclAttrInfo_t *pzVar6;
  reportCfgInfo_t *prVar7;
  u8 *puVar8;
  byte bVar9;
  uint uVar10;
  uint uVar11;
  u8 uVar12;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  endpoint = (pCmd->msg->indInfo).dst_ep;
  pzVar5 = zcl_parseInReadReportCfgCmd(pCmd);
  sVar4 = 0x89;
  if (pzVar5 != (zclReadReportCfgCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    readReportCfgRspCmd =
        (zclReadReportCfgRspCmd_t *)ev_buf_allocate((ushort)pzVar5->numAttr * 0xf + 1 & 0xff);
    if (readReportCfgRspCmd != (zclReadReportCfgRspCmd_t *)0x0)
    {
      readReportCfgRspCmd->numAttr = pzVar5->numAttr;
      if (pzVar5->numAttr != '\0')
      {
        uVar11 = 0;
        uVar12 = '\0';
        do
        {
          uVar2 = *(u16 *)(pzVar5 + uVar11 * 3 + 2);
          pzVar6 = zcl_findAttribute(endpoint, clusterId, uVar2);
          if (pzVar6 == (zclAttrInfo_t *)0x0)
          {
            uVar12 = 0x86;
          }
          else if (pzVar5[uVar11 * 3 + 1].numAttr == '\0')
          {
            if ((pzVar6->access & 4) == 0)
            {
              uVar12 = 0x8c;
            }
            else
            {
              prVar7 = zcl_reportCfgInfoEntryFind(endpoint, clusterId, uVar2);
              if (prVar7 == (reportCfgInfo_t *)0x0)
              {
                uVar12 = 0x8b;
              }
              else
              {
                readReportCfgRspCmd[uVar11 * 0xf + 5].numAttr = prVar7->dataType;
                uVar2 = prVar7->minInterval;
                readReportCfgRspCmd[uVar11 * 0xf + 6].numAttr = (u8)uVar2;
                readReportCfgRspCmd[uVar11 * 0xf + 7].numAttr = (u8)(uVar2 >> 8);
                uVar2 = prVar7->maxInterval;
                readReportCfgRspCmd[uVar11 * 0xf + 8].numAttr = (u8)uVar2;
                readReportCfgRspCmd[uVar11 * 0xf + 9].numAttr = (u8)(uVar2 >> 8);
                uVar10 = (uint)prVar7->dataType;
                if (uVar10 < 0x3b)
                {
                  if ((0x37 < uVar10) || (uVar10 - 0x20 < 0x10))
                    goto LAB_00003246;
                }
                else if (uVar10 - 0xe0 < 3)
                {
                LAB_00003246:
                  puVar8 = prVar7->reportableChange;
                  readReportCfgRspCmd[uVar11 * 0xf + 0xc].numAttr = (u8)puVar8;
                  readReportCfgRspCmd[uVar11 * 0xf + 0xd].numAttr = (u8)((uint)puVar8 >> 8);
                  readReportCfgRspCmd[uVar11 * 0xf + 0xe].numAttr = (u8)((uint)puVar8 >> 0x10);
                  readReportCfgRspCmd[uVar11 * 0xf + 0xf].numAttr = (u8)((uint)puVar8 >> 0x18);
                }
              }
            }
          }
          else
          {
            uVar12 = 0x86;
          }
          readReportCfgRspCmd[uVar11 * 0xf + 1].numAttr = uVar12;
          readReportCfgRspCmd[uVar11 * 0xf + 2].numAttr = pzVar5[uVar11 * 3 + 1].numAttr;
          uVar1 = *(undefined2 *)(pzVar5 + uVar11 * 3 + 2);
          readReportCfgRspCmd[uVar11 * 0xf + 3].numAttr = (u8)uVar1;
          readReportCfgRspCmd[uVar11 * 0xf + 4].numAttr = (u8)((ushort)uVar1 >> 8);
          uVar11 = uVar11 + 1 & 0xff;
        } while (uVar11 < pzVar5->numAttr);
      }
      uStack_34 = 0;
      paVar3 = pCmd->msg;
      uStack_30 = (uint)(paVar3->indInfo).profile_id;
      uStack_2c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
      local_38 = (uint)(paVar3->indInfo).field_10.src_short_addr;
      local_28 = (ushort)(((paVar3->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
      bVar9 = (pCmd->hdr).frmCtrl.byte & 8;
      sVar4 = zcl_readReportConfigRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                                      bVar9 + ~bVar9, (pCmd->hdr).seqNum, readReportCfgRspCmd);
      if (sVar4 == '\0')
      {
        sVar4 = 0xff;
      }
      ev_buf_free((u8 *)readReportCfgRspCmd);
    }
  }
  return sVar4;
}
status_t zcl_readReportCfgRspHandler(zclIncoming_t *pCmd)

{
  zclReadReportCfgRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInReadReportCfgRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclReadReportCfgRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}
status_t zcl_reportHandler(zclIncoming_t *pCmd)

{
  zclReportCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInReportCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclReportCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}
status_t zcl_sendDfltRsp(zclIncoming_t *inMsg, u8 cmdId, u8 status)

{
  apsdeDataInd_t *paVar1;
  status_t sVar2;
  byte bVar3;
  uint local_30;
  undefined4 uStack_2c;
  uint uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  u8 local_1c;
  u8 uStack_1b;

  paVar1 = inMsg->msg;
  uStack_2c = 0;
  bVar3 = (inMsg->hdr).frmCtrl.byte & 8;
  local_30 = (uint)(paVar1->indInfo).field_10.src_short_addr;
  uStack_24 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
  uStack_28 = (uint)(paVar1->indInfo).profile_id;
  local_20 = 4;
  if ((int)((uint)(paVar1->indInfo).security_status << 0x1f) < 0)
  {
    local_20 = 5;
  }
  local_1c = cmdId;
  uStack_1b = status;
  sVar2 = zcl_sendCmd((paVar1->indInfo).dst_ep, (epInfo_t *)&local_30, (paVar1->indInfo).cluster_id,
                      '\v', '\0', ~bVar3 + bVar3, '\x01', (inMsg->hdr).manufCode, (inMsg->hdr).seqNum, 2,
                      &local_1c);
  return sVar2;
}
status_t zcl_dfltRspHandler(zclIncoming_t *pCmd)

{
  byte bVar1;
  zclDefaultRspCmd_t *pzVar2;
  status_t sVar3;

  bVar1 = (pCmd->hdr).frmCtrl.byte;
  if (-1 < (int)((uint)bVar1 << 0x1b))
  {
    (pCmd->hdr).frmCtrl.byte = bVar1 | 0x10;
  }
  pzVar2 = zcl_parseInDftRspCmd(pCmd);
  sVar3 = 0x89;
  if (pzVar2 != (zclDefaultRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar2;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar2 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar2 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar2 >> 0x18);
    sVar3 = '\0';
  }
  return sVar3;
}
status_t zcl_discAttrsRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode,
                          u8 disableDefaultRsp, u8 direction, u8 seqNo,
                          zclDiscoverAttrRspCmd_t *discAttrRspCmd)

{
  u16 size;
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  uint uVar3;

  size = (ushort)discAttrRspCmd->numAttr * 3 + 1;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = discAttrRspCmd->discComplete;
    if (discAttrRspCmd->numAttr != '\0')
    {
      puVar2 = cmdPld + 1;
      uVar3 = 0;
      do
      {
        *puVar2 = *(u8 *)((int)discAttrRspCmd + uVar3 * 3 + 2);
        puVar2[1] = *(u8 *)((int)discAttrRspCmd + uVar3 * 3 + 3);
        puVar2[2] = *(u8 *)((int)discAttrRspCmd + uVar3 * 3 + 4);
        puVar2 = puVar2 + 3;
        uVar3 = uVar3 + 1 & 0xff;
      } while (uVar3 < discAttrRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\r', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}
status_t zcl_discAttrsExtendedRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                                  u8 direction, u8 seqNo, zclDiscoverAttrExtRspCmd_t *discAttrExtRspCmd)

{
  u16 size;
  status_t sVar1;
  u8 *cmdPld;
  uint uVar2;
  u8 *puVar3;

  size = (u16)((uint)discAttrExtRspCmd->numAttr * 0x40000 + 0x10000 >> 0x10);
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = discAttrExtRspCmd->discComplete;
    if (discAttrExtRspCmd->numAttr != '\0')
    {
      puVar3 = cmdPld + 1;
      uVar2 = 0;
      do
      {
        *puVar3 = discAttrExtRspCmd[uVar2 * 2 + 1].discComplete;
        puVar3[1] = discAttrExtRspCmd[uVar2 * 2 + 1].numAttr;
        puVar3[2] = discAttrExtRspCmd[uVar2 * 2 + 2].discComplete;
        puVar3[3] = discAttrExtRspCmd[uVar2 * 2 + 2].numAttr;
        puVar3 = puVar3 + 4;
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < discAttrExtRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\x16', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}
status_t zcl_discAttrsHandler(zclIncoming_t *pCmd)

{
  u8 srcEp;
  u16 clusterId;
  ushort uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  u16 size;
  zclDiscoverAttrCmd_t *pzVar4;
  zclDiscoverAttrRspCmd_t *discAttrRspCmd;
  uint uVar5;
  byte bVar6;
  byte bVar7;
  u8 uVar8;
  uint uVar9;
  zclAttrInfo_t *pzVar10;
  uint uVar11;
  u8 *puVar12;
  uint uVar13;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  srcEp = (pCmd->msg->indInfo).dst_ep;
  pzVar4 = zcl_parseInDiscAttrsCmd(pCmd);
  if (pzVar4 == (zclDiscoverAttrCmd_t *)0x0)
  {
    return 0x89;
  }
  *(char *)&pCmd->attrCmd = (char)pzVar4;
  *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar4 >> 8);
  *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar4 >> 0x10);
  *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar4 >> 0x18);
  puVar12 = &zcl_vars.clusterList[0].endpoint;
  uVar9 = 0;
  do
  {
    if ((*puVar12 == srcEp) && (zcl_vars.clusterList[uVar9].clusterID == clusterId))
    {
      bVar7 = zcl_vars.clusterList[uVar9 & 0xff].attrNum;
      if ((bVar7 != 0) && (pzVar4->maxAttrIDs != 0))
      {
        pzVar10 = zcl_vars.clusterList[uVar9 & 0xff].attrTable;
        bVar6 = 0;
        uVar9 = 0;
        goto LAB_00003906;
      }
      break;
    }
    uVar9 = uVar9 + 1;
    puVar12 = puVar12 + 0x12;
  } while (uVar9 != 0x10);
  size = 2;
  uVar9 = 0;
  goto LAB_0000393c;
LAB_0000399a:
  do
  {
    pzVar10 = zcl_vars.clusterList[uVar5].attrTable + uVar11;
    uVar1 = pzVar10->id;
    if ((uint)pzVar4->startAttr <= (uint)uVar1)
    {
      if (uVar9 <= uVar13)
      {
        uVar8 = '\0';
        goto LAB_000039fc;
      }
      *(char *)((int)discAttrRspCmd + uVar13 * 3 + 2) = (char)uVar1;
      *(char *)((int)discAttrRspCmd + uVar13 * 3 + 3) = (char)((uint)uVar1 >> 8);
      *(u8 *)((int)discAttrRspCmd + uVar13 * 3 + 4) = pzVar10->type;
      uVar13 = uVar13 + 1 & 0xff;
    }
    uVar11 = uVar11 + 1 & 0xff;
  } while (uVar11 < zcl_vars.clusterList[uVar5].attrNum);
  goto LAB_000039fa;
  while (pzVar10 = pzVar10 + 1, uVar9 < pzVar4->maxAttrIDs)
  {
  LAB_00003906:
    if (pzVar4->startAttr <= pzVar10->id)
    {
      uVar9 = uVar9 + 1 & 0xff;
    }
    bVar6 = bVar6 + 1;
    if (bVar7 <= bVar6)
    {
      size = (u16)(uVar9 * 0x30000 + 0x20000 >> 0x10);
      goto LAB_0000393c;
    }
  }
  size = (short)uVar9 * 3 + 2;
LAB_0000393c:
  puVar12 = &zcl_vars.clusterList[0].endpoint;
  discAttrRspCmd = (zclDiscoverAttrRspCmd_t *)ev_buf_allocate(size);
  sVar3 = 0x89;
  if (discAttrRspCmd != (zclDiscoverAttrRspCmd_t *)0x0)
  {
    uVar8 = '\x01';
    if (uVar9 != 0)
    {
      uVar11 = 0;
      do
      {
        uVar5 = uVar11 & 0xff;
        if ((*puVar12 == srcEp) && (zcl_vars.clusterList[uVar11].clusterID == clusterId))
        {
          if (zcl_vars.clusterList[uVar5].attrNum != '\0')
          {
            uVar11 = 0;
            uVar13 = 0;
            goto LAB_0000399a;
          }
          break;
        }
        uVar11 = uVar11 + 1;
        puVar12 = puVar12 + 0x12;
      } while (uVar11 != 0x10);
    LAB_000039fa:
      uVar8 = '\x01';
    }
  LAB_000039fc:
    discAttrRspCmd->discComplete = uVar8;
    discAttrRspCmd->numAttr = (u8)uVar9;
    uStack_34 = 0;
    paVar2 = pCmd->msg;
    uStack_30 = (uint)(paVar2->indInfo).profile_id;
    uStack_2c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
    local_38 = (uint)(paVar2->indInfo).field_10.src_short_addr;
    local_28 = (ushort)(((paVar2->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
    bVar7 = (pCmd->hdr).frmCtrl.byte & 8;
    sVar3 = zcl_discAttrsRsp(srcEp, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                             bVar7 + ~bVar7, (pCmd->hdr).seqNum, discAttrRspCmd);
    if (sVar3 == '\0')
    {
      sVar3 = 0xff;
    }
    ev_buf_free((u8 *)discAttrRspCmd);
  }
  return sVar3;
}
status_t zcl_discAttrsExtendedHandler(zclIncoming_t *pCmd)

{
  u8 srcEp;
  u16 clusterId;
  ushort uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  u16 size;
  zclDiscoverAttrCmd_t *pzVar4;
  zclDiscoverAttrExtRspCmd_t *discAttrExtRspCmd;
  uint uVar5;
  byte bVar6;
  byte bVar7;
  uint uVar8;
  u8 uVar9;
  uint uVar10;
  zclAttrInfo_t *pzVar11;
  uint uVar12;
  u8 *puVar13;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  srcEp = (pCmd->msg->indInfo).dst_ep;
  pzVar4 = zcl_parseInDiscAttrsCmd(pCmd);
  if (pzVar4 == (zclDiscoverAttrCmd_t *)0x0)
  {
    return 0x89;
  }
  *(char *)&pCmd->attrCmd = (char)pzVar4;
  *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar4 >> 8);
  *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar4 >> 0x10);
  *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar4 >> 0x18);
  puVar13 = &zcl_vars.clusterList[0].endpoint;
  uVar10 = 0;
LAB_00003b1c:
  if ((*puVar13 != srcEp) || (zcl_vars.clusterList[uVar10].clusterID != clusterId))
    goto LAB_00003b14;
  bVar7 = zcl_vars.clusterList[uVar10 & 0xff].attrNum;
  if ((bVar7 != 0) && (pzVar4->maxAttrIDs != 0))
  {
    pzVar11 = zcl_vars.clusterList[uVar10 & 0xff].attrTable;
    bVar6 = 0;
    uVar10 = 0;
    do
    {
      if (pzVar4->startAttr <= pzVar11->id)
      {
        uVar10 = uVar10 + 1 & 0xff;
      }
      bVar6 = bVar6 + 1;
    } while ((bVar6 < bVar7) && (pzVar11 = pzVar11 + 1, uVar10 < pzVar4->maxAttrIDs));
    size = (u16)(uVar10 * 0x40000 + 0x20000 >> 0x10);
    goto LAB_00003b9e;
  }
  goto LAB_00003b9a;
LAB_00003b14:
  uVar10 = uVar10 + 1;
  puVar13 = puVar13 + 0x12;
  if (uVar10 == 0x10)
    goto LAB_00003b9a;
  goto LAB_00003b1c;
LAB_00003b9a:
  size = 2;
  uVar10 = 0;
LAB_00003b9e:
  puVar13 = &zcl_vars.clusterList[0].endpoint;
  discAttrExtRspCmd = (zclDiscoverAttrExtRspCmd_t *)ev_buf_allocate(size);
  if (discAttrExtRspCmd == (zclDiscoverAttrExtRspCmd_t *)0x0)
  {
    return 0x89;
  }
  uVar9 = '\x01';
  if (uVar10 == 0)
    goto LAB_00003c64;
  uVar12 = 0;
  do
  {
    uVar5 = uVar12 & 0xff;
    if ((*puVar13 == srcEp) && (zcl_vars.clusterList[uVar12].clusterID == clusterId))
    {
      if (zcl_vars.clusterList[uVar5].attrNum != '\0')
      {
        uVar8 = 0;
        uVar12 = 0;
        goto LAB_00003bfa;
      }
      break;
    }
    uVar12 = uVar12 + 1;
    puVar13 = puVar13 + 0x12;
  } while (uVar12 != 0x10);
  goto LAB_00003c62;
LAB_00003bfa:
  do
  {
    pzVar11 = zcl_vars.clusterList[uVar5].attrTable + uVar8;
    uVar1 = pzVar11->id;
    if ((uint)pzVar4->startAttr <= (uint)uVar1)
    {
      if (uVar10 <= uVar12)
      {
        uVar9 = '\0';
        goto LAB_00003c64;
      }
      discAttrExtRspCmd[uVar12 * 2 + 1].discComplete = (u8)uVar1;
      discAttrExtRspCmd[uVar12 * 2 + 1].numAttr = (u8)((uint)uVar1 >> 8);
      discAttrExtRspCmd[uVar12 * 2 + 2].discComplete = pzVar11->type;
      discAttrExtRspCmd[uVar12 * 2 + 2].numAttr = pzVar11->access & 7;
      uVar12 = uVar12 + 1 & 0xff;
    }
    uVar8 = uVar8 + 1 & 0xff;
  } while (uVar8 < zcl_vars.clusterList[uVar5].attrNum);
LAB_00003c62:
  uVar9 = '\x01';
LAB_00003c64:
  discAttrExtRspCmd->discComplete = uVar9;
  discAttrExtRspCmd->numAttr = (u8)uVar10;
  uStack_34 = 0;
  paVar2 = pCmd->msg;
  uStack_30 = (uint)(paVar2->indInfo).profile_id;
  uStack_2c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
  local_38 = (uint)(paVar2->indInfo).field_10.src_short_addr;
  local_28 = (ushort)(((paVar2->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
  bVar7 = (pCmd->hdr).frmCtrl.byte & 8;
  sVar3 = zcl_discAttrsExtendedRsp(srcEp, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                                   bVar7 + ~bVar7, (pCmd->hdr).seqNum, discAttrExtRspCmd);
  if (sVar3 == '\0')
  {
    sVar3 = 0xff;
  }
  ev_buf_free((u8 *)discAttrExtRspCmd);
  return sVar3;
}
status_t zcl_discAttrsRspHandler(zclIncoming_t *pCmd)

{
  zclDiscoverAttrRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInDiscAttrsRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclDiscoverAttrRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}
status_t zcl_discAttrsExtRspHandler(zclIncoming_t *pCmd)

{
  zclDiscoverAttrExtRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInDiscAttrsExtRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclDiscoverAttrExtRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}
status_t zcl_foundationCmdHandler(zclIncoming_t *pCmd)

{
  status_t sVar1;

  switch ((pCmd->hdr).cmd)
  {
  case '\0':
    sVar1 = zcl_readHandler(pCmd);
    break;
  case '\x01':
    sVar1 = zcl_readRspHandler(pCmd);
    break;
  case '\x02':
  case '\x05':
    sVar1 = zcl_writeHandler(pCmd);
    break;
  case '\x03':
    sVar1 = zcl_writeUndividedHandler(pCmd);
    break;
  case '\x04':
    sVar1 = zcl_writeRspHandler(pCmd);
    break;
  case '\x06':
    sVar1 = zcl_configReportHandler(pCmd);
    break;
  case '\a':
    sVar1 = zcl_configReportRspHandler(pCmd);
    break;
  case '\b':
    sVar1 = zcl_readReportCfgHandler(pCmd);
    break;
  case '\t':
    sVar1 = zcl_readReportCfgRspHandler(pCmd);
    break;
  case '\n':
    sVar1 = zcl_reportHandler(pCmd);
    break;
  case '\v':
    sVar1 = zcl_dfltRspHandler(pCmd);
    break;
  case '\f':
    sVar1 = zcl_discAttrsHandler(pCmd);
    break;
  case '\r':
    sVar1 = zcl_discAttrsRspHandler(pCmd);
    break;
  default:
    sVar1 = 0x84;
    if ((pCmd->hdr).manufCode == 0)
    {
      sVar1 = 0x82;
    }
    break;
  case '\x15':
    sVar1 = zcl_discAttrsExtendedHandler(pCmd);
    break;
  case '\x16':
    sVar1 = zcl_discAttrsExtRspHandler(pCmd);
  }
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
void zcl_cmdHandler(void *pCmd)

{
  byte bVar1;
  uint uVar2;
  u8 *puVar3;
  ushort uVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  undefined auStack_4c[28];
  undefined4 uStack_30;
  u8 local_2c;
  u16 uStack_28;
  u8 local_25;
  uint extraout_r0;

  auStack_4c._0_4_ = ll_reset;
  auStack_4c._8_4_ = (u8 *)0x0;
  auStack_4c._12_4_ = (u8 *)0x0;
  auStack_4c._16_4_ = 0;
  auStack_4c._20_4_ = 0;
  auStack_4c._24_4_ = 0;
  uStack_30 = 0;
  local_2c = '\0';
  bVar1 = *(byte *)((int)pCmd + 0x25);
  auStack_4c._4_4_ = (apsdeDataInd_t *)pCmd;
  if ((int)((uint)bVar1 << 0x1d) < 0)
  {
    if (*(ushort *)((int)pCmd + 0x23) < 5)
      goto LAB_00003fb0;
    uStack_30 = (uint)bVar1 |
                ((uint) * (byte *)((int)pCmd + 0x27) * 0x100 + (uint) * (byte *)((int)pCmd + 0x26)) *
                        0x10000 >>
                    8 |
                (uint) * (byte *)((int)pCmd + 0x28) << 0x18;
    local_2c = *(u8 *)((int)pCmd + 0x29);
    auStack_4c._8_4_ = (u8 *)((int)pCmd + 0x2a);
    uVar4 = *(ushort *)((int)pCmd + 0x23) - 5;
  }
  else
  {
    if (*(ushort *)((int)pCmd + 0x23) < 3)
      goto LAB_00003fb0;
    uStack_30 = CONCAT13(*(undefined *)((int)pCmd + 0x26), (uint3)bVar1);
    local_2c = *(u8 *)((int)pCmd + 0x27);
    auStack_4c._8_4_ = (u8 *)((int)pCmd + 0x28);
    uVar4 = *(ushort *)((int)pCmd + 0x23) - 3;
  }
  auStack_4c._16_4_ = (uint)uVar4;
  uStack_28 = 0;
  local_25 = '\x01';
  uVar2 = uStack_30 & 0xff;
  if ((uStack_30 & 3) == 0)
  {
    bVar1 = zcl_foundationCmdHandler((zclIncoming_t *)auStack_4c);
    extraout_r0 = (uint)bVar1;
    uVar5 = extraout_r0;
    if ((((extraout_r0 != 0x84) && (extraout_r0 != 0x82)) && (extraout_r0 != 0xff)) &&
        (extraout_r0 != 0))
    {
      uVar5 = 1;
    }
    if (local_25 != '\0')
    {
      uVar2 = uStack_30 & 0xff;
      bVar7 = uVar5 != 0;
      bVar1 = 1;
      goto LAB_00003f64;
    }
    bVar7 = zcl_vars.hookFn != ll_reset;
  }
  else
  {
    puVar3 = &zcl_vars.clusterList[0].endpoint;
    uVar5 = 0;
    do
    {
      uVar6 = uVar5 & 0xff;
      if ((*puVar3 == *(u8 *)((int)pCmd + 1)) &&
          (zcl_vars.clusterList[uVar5].clusterID == *(u16 *)((int)pCmd + 8)))
      {
        uVar5 = (uStack_30 << 8) >> 0x10;
        if (zcl_vars.clusterList[uVar6].manuCode != uVar5)
          goto LAB_00003f58;
        zcl_getAttrVal(*(u8 *)((int)pCmd + 1), 0, 0x12, &uStack_28, &local_25);
        if ((local_25 == '\0') && (zcl_vars.clusterList[uVar6].clusterID != 3))
          goto LAB_00003fb0;
        auStack_4c._0_4_ = zcl_vars.clusterList[uVar6].clusterAppCb;
        auStack_4c._16_4_ = auStack_4c._16_4_ & 0xffff | (uint) * (ushort *)((int)pCmd + 6) << 0x10;
        auStack_4c._20_4_ =
            CONCAT22(*(undefined2 *)((int)pCmd + 2), *(undefined2 *)((int)pCmd + 0x14));
        auStack_4c._24_4_ =
            CONCAT13(auStack_4c[27] & 0xfe | uStack_30._0_1_ >> 3 & 1,
                     CONCAT12(uStack_30._3_1_,
                              CONCAT11(*(undefined *)((int)pCmd + 1), *(undefined *)((int)pCmd + 5))));
        uVar5 = FUNAAAAA();
        uVar2 = uStack_30 & 0xff;
        bVar7 = uVar5 != 0;
        goto LAB_00003f62;
      }
      uVar5 = uVar5 + 1;
      puVar3 = puVar3 + 0x12;
    } while (uVar5 != 0x10);
    uVar5 = (uStack_30 << 8) >> 0x10;
  LAB_00003f58:
    if (uVar5 == 0)
    {
      bVar7 = true;
      uVar5 = 0x81;
    }
    else
    {
      bVar7 = true;
      uVar5 = 0x83;
    }
  LAB_00003f62:
    local_25 = '\x01';
    bVar1 = 0;
  LAB_00003f64:
    if ((((-1 < (int)(uVar2 << 0x1b)) || (bVar7)) &&
         (((auStack_4c._4_4_)->indInfo).dst_addr < 0xfffc)) &&
        ((((auStack_4c._4_4_)->indInfo).dst_addr_mode != '\x01' && (uVar5 != 0xff))))
    {
      zcl_sendDfltRsp((zclIncoming_t *)auStack_4c, local_2c, (u8)uVar5);
    }
    bVar7 = (bool)(bVar1 & zcl_vars.hookFn != ll_reset);
  }
  if ((bVar7) && (auStack_4c._12_4_ != (u8 *)0x0))
  {
    FUNAAAAA();
    ev_buf_free(auStack_4c._12_4_);
  }
LAB_00003fb0:
  ev_buf_free((u8 *)pCmd);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAA(void)

{
  code *in_r3;

  (*in_r3)();
  nv_flashWriteNew('\x01', 3, ' ', 0x95, &reportingTab.reportNum);
  return;
}
nv_sts_t zcl_reportingTab_save(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashWriteNew('\x01', 3, ' ', 0x95, &reportingTab.reportNum);
  return nVar1;
}
nv_sts_t zcl_sceneTable_save(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashWriteNew('\x01', 3, '$', 0x170, &g_zcl_sceneTab[0].used);
  return nVar1;
}
nv_sts_t zcl_sceneTable_restore(void)

{
  nv_sts_t nVar1;

  nv_itemLengthCheckAdd('$', 0x170);
  nVar1 = nv_flashReadNew('\x01', '\x03', '$', 0x2e, &g_zcl_sceneTab[0].used);
  return nVar1;
}
void zcl_reportCfgInfoEntryRst(reportCfgInfo_t *pEntry)

{
  undefined uVar1;
  undefined uVar2;
  undefined uVar3;
  undefined uVar4;

  if (pEntry->used != '\0')
  {
    uVar1 = (undefined)pEntry->minIntDft;
    *(undefined *)&pEntry->minInterval = uVar1;
    uVar4 = (undefined)(pEntry->minIntDft >> 8);
    *(undefined *)((int)&pEntry->minInterval + 1) = uVar4;
    uVar2 = (undefined)pEntry->maxIntDft;
    *(undefined *)&pEntry->maxInterval = uVar2;
    uVar3 = (undefined)(pEntry->maxIntDft >> 8);
    *(undefined *)((int)&pEntry->maxInterval + 1) = uVar3;
    *(undefined *)&pEntry->minIntCnt = uVar1;
    *(undefined *)((int)&pEntry->minIntCnt + 1) = uVar4;
    *(undefined *)&pEntry->maxIntCnt = uVar2;
    *(undefined *)((int)&pEntry->maxIntCnt + 1) = uVar3;
    pEntry->reportableChange[0] = '\0';
    pEntry->reportableChange[1] = '\0';
    pEntry->reportableChange[2] = '\0';
    pEntry->reportableChange[3] = '\0';
    pEntry->reportableChange[4] = '\0';
    pEntry->reportableChange[5] = '\0';
    pEntry->reportableChange[6] = '\0';
    pEntry->reportableChange[7] = '\0';
  }
  return;
}
void zcl_reportCfgInfoEntryUpdate(reportCfgInfo_t *pEntry, u8 endPoint, u16 profileId, u16 clusterId,
                                  zclCfgReportRec_t *pCfgReportRec)

{
  u16 uVar1;
  undefined uVar2;
  u8 *puVar3;
  undefined uVar4;
  u8 uVar5;
  byte bVar6;
  zclAttrInfo_t *pzVar7;
  undefined uVar8;
  undefined uVar9;

  if (pEntry->used == '\0')
  {
    *(char *)&pEntry->profileID = (char)profileId;
    *(char *)((int)&pEntry->profileID + 1) = (char)((uint)profileId >> 8);
    *(char *)&pEntry->clusterID = (char)clusterId;
    *(char *)((int)&pEntry->clusterID + 1) = (char)((uint)clusterId >> 8);
    pEntry->endPoint = endPoint;
    uVar1 = pCfgReportRec->attrID;
    *(char *)&pEntry->attrID = (char)uVar1;
    *(char *)((int)&pEntry->attrID + 1) = (char)(uVar1 >> 8);
    uVar1 = pCfgReportRec->minReportInt;
    uVar2 = (undefined)uVar1;
    *(undefined *)&pEntry->minIntDft = uVar2;
    uVar8 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->minIntDft + 1) = uVar8;
    uVar1 = pCfgReportRec->maxReportInt;
    uVar4 = (undefined)uVar1;
    *(undefined *)&pEntry->maxIntDft = uVar4;
    uVar9 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->maxIntDft + 1) = uVar9;
    *(undefined *)&pEntry->minInterval = uVar2;
    *(undefined *)((int)&pEntry->minInterval + 1) = uVar8;
    *(undefined *)&pEntry->maxInterval = uVar4;
    *(undefined *)((int)&pEntry->maxInterval + 1) = uVar9;
    uVar5 = pCfgReportRec->dataType;
    pEntry->dataType = uVar5;
    uVar5 = zcl_analogDataType(uVar5);
    if (uVar5 != '\0')
    {
      puVar3 = pCfgReportRec->reportableChange;
      bVar6 = zcl_getDataTypeLen(pEntry->dataType);
      memcpy(pEntry->reportableChange, puVar3, (uint)bVar6);
    }
    pzVar7 = zcl_findAttribute(pEntry->endPoint, pEntry->clusterID, pEntry->attrID);
    if (pzVar7 == (zclAttrInfo_t *)0x0)
    {
      sys_exceptionPost(0xcd, '`');
    }
    uVar1 = pCfgReportRec->minReportInt;
    *(char *)&pEntry->minIntCnt = (char)uVar1;
    *(char *)((int)&pEntry->minIntCnt + 1) = (char)(uVar1 >> 8);
    uVar1 = pCfgReportRec->maxReportInt;
    *(char *)&pEntry->maxIntCnt = (char)uVar1;
    *(char *)((int)&pEntry->maxIntCnt + 1) = (char)(uVar1 >> 8);
    pEntry->used = '\x01';
    reportingTab.reportNum = reportingTab.reportNum + '\x01';
  }
  else
  {
    uVar1 = pCfgReportRec->minReportInt;
    uVar2 = (undefined)uVar1;
    *(undefined *)&pEntry->minInterval = uVar2;
    uVar8 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->minInterval + 1) = uVar8;
    uVar1 = pCfgReportRec->maxReportInt;
    uVar4 = (undefined)uVar1;
    *(undefined *)&pEntry->maxInterval = uVar4;
    uVar9 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->maxInterval + 1) = uVar9;
    *(undefined *)&pEntry->minIntCnt = uVar2;
    *(undefined *)((int)&pEntry->minIntCnt + 1) = uVar8;
    *(undefined *)&pEntry->maxIntCnt = uVar4;
    *(undefined *)((int)&pEntry->maxIntCnt + 1) = uVar9;
    uVar5 = zcl_analogDataType(pEntry->dataType);
    if (uVar5 != '\0')
    {
      puVar3 = pCfgReportRec->reportableChange;
      bVar6 = zcl_getDataTypeLen(pEntry->dataType);
      memcpy(pEntry->reportableChange, puVar3, (uint)bVar6);
    }
  }
  return;
}
void zcl_zoneClearEntry(zcl_zoneTable_t *pZoneTab)

{
  if (pZoneTab != (zcl_zoneTable_t *)0x0)
  {
    pZoneTab->used = '\0';
    pZoneTab->endpoint = 0xfe;
    (pZoneTab->zone).zoneId = '\0';
    *(undefined *)&(pZoneTab->zone).zoneType = 0;
    *(undefined *)((int)&(pZoneTab->zone).zoneType + 1) = 0;
    (pZoneTab->zone).zoneAddr[0] = '\0';
    (pZoneTab->zone).zoneAddr[1] = '\0';
    (pZoneTab->zone).zoneAddr[2] = '\0';
    (pZoneTab->zone).zoneAddr[3] = '\0';
    (pZoneTab->zone).zoneAddr[4] = '\0';
    (pZoneTab->zone).zoneAddr[5] = '\0';
    (pZoneTab->zone).zoneAddr[6] = '\0';
    (pZoneTab->zone).zoneAddr[7] = '\0';
  }
  return;
}
void zcl_zoneTabClear(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    zcl_zoneClearEntry(g_zcl_zoneTab + iVar1);
    iVar1 = iVar1 + 1;
  } while (iVar1 != 5);
  return;
}
status_t zcl_iasZone_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  zcl_zoneTabClear();
  sVar1 = zcl_registerCluster(endpoint, 0x500, manuCode, attrNum, attrTbl, zcl_iasZone_cmdHandler, cb);
  return sVar1;
}
void zcl_getZoneId(void)

{
  u8 uVar1;
  zcl_zoneTable_t *pzVar2;

  uVar1 = '\0';
  pzVar2 = g_zcl_zoneTab;
  do
  {
    while ((pzVar2->used != '\0' && ((pzVar2->zone).zoneId == uVar1)))
    {
      uVar1 = uVar1 + '\x01';
      pzVar2 = g_zcl_zoneTab;
      if (uVar1 == 0xff)
      {
        return;
      }
    }
    pzVar2 = pzVar2 + 1;
  } while (pzVar2 != (zcl_zoneTable_t *)0x84293d);
  return;
}
status_t zcl_iasZone_enrollRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                               zoneEnrollRsp_t *pEnrollRsp)

{
  status_t sVar1;
  u8 local_14;
  u8 uStack_13;

  local_14 = pEnrollRsp->code;
  uStack_13 = pEnrollRsp->zoneId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 0x500, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, 2, &local_14);
  return sVar1;
}
status_t zcl_iasZone_cmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  zcl_zoneTable_t *pzVar4;
  u16 zoneType;
  undefined4 in_stack_ffffffb8;
  undefined2 in_stack_ffffffbc;
  undefined2 in_stack_ffffffbe;
  zoneEnrollRsp_t local_24[2];
  u8 local_20;
  u8 uStack_1f;

  if (-1 < (int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c))
  {
    uVar1 = (pInMsg->hdr).cmd;
    if (uVar1 == '\x01')
    {
      if (pInMsg->clusterAppCb != ll_reset)
      {
        sVar3 = FUNAAAAC();
        return sVar3;
      }
      return '\0';
    }
    if (uVar1 == '\0')
    {
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_24[0] = *(zoneEnrollRsp_t *)pInMsg->pData;
        FUNAAAAC();
        return '\0';
      }
      return '\0';
    }
    if (uVar1 != '\x02')
    {
      return 0x81;
    }
    if (pInMsg->clusterAppCb != ll_reset)
    {
      local_20 = *pInMsg->pData;
      uStack_1f = pInMsg->pData[1];
      sVar3 = FUNAAAAC();
      return sVar3;
    }
    return '\0';
  }
  uVar1 = (pInMsg->hdr).cmd;
  if (uVar1 == '\0')
  {
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAC();
      return '\0';
    }
    return '\0';
  }
  if (uVar1 != '\x01')
  {
    return 0x81;
  }
  paVar2 = pInMsg->msg;
  uVar1 = (paVar2->indInfo).dst_ep;
  zoneType = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
  local_24[0] = (zoneEnrollRsp_t)0xff00;
  if (zoneType < 0x2e)
  {
    if (zoneType < 0x2a)
    {
      if (zoneType < 0x17)
      {
        if (((zoneType < 0x15) && (zoneType != 0)) && (zoneType != 0xd))
          goto LAB_000047a2;
      }
      else if (zoneType != 0x28)
        goto LAB_000047a2;
    }
  }
  else if (zoneType != 0x21d)
  {
    if (zoneType < 0x21e)
    {
      if ((zoneType != 0x10f) && (zoneType != 0x115))
        goto LAB_000047a2;
    }
    else if ((zoneType < 0x225) || ((0x226 < zoneType && (zoneType != 0x229))))
    {
    LAB_000047a2:
      local_24[0] = (zoneEnrollRsp_t)0xff01;
      goto LAB_00004656;
    }
  }
  pzVar4 = zcl_addZoneEntry(uVar1, zoneType, &local_24[0].code);
  if ((pzVar4 != (zcl_zoneTable_t *)0x0) && (local_24[0].code == '\0'))
  {
    zb_address_ieee_by_short((paVar2->indInfo).field_10.src_short_addr,
                             (addrExt_t)CONCAT26(in_stack_ffffffbe, CONCAT24(in_stack_ffffffbc, in_stack_ffffffb8)));
    local_24[0] = (zoneEnrollRsp_t)((ushort)local_24[0] & 0xff | (ushort)(pzVar4->zone).zoneId << 8);
  }
LAB_00004656:
  if (pInMsg->clusterAppCb != ll_reset)
  {
    FUNAAAAC();
  }
  zcl_iasZone_enrollRsp(uVar1, (epInfo_t *)&stack0xffffffbc, '\x01', (pInMsg->hdr).seqNum, local_24);
  return 0xff;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 FUNAAAAC(void)

{
  byte bVar1;
  byte *pbVar2;
  void *in;
  int *piVar3;
  undefined4 uVar4;
  int iVar5;
  byte *in_00;
  code *in_r3;
  uint uVar6;
  uint uVar7;
  uint uStack_d0;
  uint uStack_cc;
  uint uStack_c8;
  undefined uStack_c4;
  byte bStack_c3;
  short sStack_c2;
  short sStack_c0;
  undefined auStack_be[10];
  uint uStack_b4;
  uint uStack_b0;
  uint uStack_ac;
  undefined uStack_a8;
  byte bStack_a7;
  undefined auStack_a6[8];
  short sStack_9e;
  uint uStack_9c;
  uint uStack_98;
  uint uStack_94;
  undefined uStack_90;
  byte bStack_8f;
  byte *pbStack_8e;
  undefined auStack_88[8];
  short sStack_80;
  short sStack_7e;
  int iStack_7c;
  short sStack_78;
  short sStack_74;
  short sStack_72;
  int iStack_70;
  int iStack_6c;
  int iStack_68;
  uint uStack_64;
  uint uStack_60;
  uint uStack_5c;
  undefined uStack_58;
  uint uStack_54;
  uint uStack_50;
  uint uStack_4c;
  undefined uStack_48;
  uint uStack_44;
  uint uStack_40;
  uint uStack_3c;
  byte bStack_38;
  byte bStack_37;
  short sStack_36;
  short sStack_34;
  int iStack_32;
  uint uStack_2c;
  uint uStack_28;
  undefined uStack_24;

  piVar3 = (int *)(*in_r3)();
  uVar6 = uStack_3c;
  if ((int)((uint) * (byte *)(piVar3 + 7) << 0x1c) < 0)
  {
    switch (*(undefined *)(piVar3 + 8))
    {
    case 0:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bStack_38 = *pbVar2;
        bStack_37 = pbVar2[1];
        if (((bStack_38 != 0) &&
             (sStack_36 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2], 1 < bStack_38)) &&
            (sStack_34 = (ushort)pbVar2[5] * 0x100 + (ushort)pbVar2[4], bStack_38 == 3))
        {
          iStack_32 = (uint)pbVar2[9] * 0x1000000 + (uint)pbVar2[8] * 0x10000 + (uint)pbVar2[6] +
                      (uint)pbVar2[7] * 0x100;
        }
        uVar4 = FUNAAAAD();
      }
      break;
    default:
    switchD_00004814_caseD_0:
      uVar4 = 0x81;
      break;
    case 2:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_54 = uStack_54 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          uStack_54 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_50 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_4c = iVar5 * 0x100 | uVar6 >> 0x18;
          uStack_48 = (undefined)((uint)iVar5 >> 0x18);
        }
        uVar4 = FUNAAAAD();
      }
      break;
    case 5:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uVar6 = (uint)bVar1;
        uStack_9c = uStack_9c & 0xffffff00 | uVar6;
        if (bVar1 == 0)
        {
          uStack_9c = uVar6 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_94 = iVar5 * 0x100 | uVar6 >> 0x18;
          uStack_90 = (undefined)((uint)iVar5 >> 0x18);
          bStack_8f = pbVar2[0xd];
          pbStack_8e = pbVar2 + 0xe;
        }
        else if (bVar1 == 0x97)
        {
          uVar7 = (uint)pbVar2[4] * 0x1000000 + (uint)pbVar2[3] * 0x10000 + (uint)pbVar2[1] +
                  (uint)pbVar2[2] * 0x100;
          uStack_9c = uVar7 * 0x100 | uVar6;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar6 * 0x100 | uVar7 >> 0x18;
          uStack_94 = uStack_94 & 0xff000000 | uVar6 >> 0x18 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        uVar4 = FUNAAAAD();
      }
      break;
    case 7:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        sStack_74 = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
        sStack_72 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2];
        iStack_70 = (uint)pbVar2[7] * 0x1000000 + (uint)pbVar2[6] * 0x10000 + (uint)pbVar2[4] +
                    (uint)pbVar2[5] * 0x100;
        iStack_6c = (uint)pbVar2[0xb] * 0x1000000 + (uint)pbVar2[10] * 0x10000 + (uint)pbVar2[8] +
                    (uint)pbVar2[9] * 0x100;
        iStack_68 = (uint)pbVar2[0xf] * 0x1000000 + (uint)pbVar2[0xe] * 0x10000 + (uint)pbVar2[0xc] + (uint)pbVar2[0xd] * 0x100;
        uVar4 = FUNAAAAD();
      }
      break;
    case 9:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_64 = uStack_64 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          uStack_64 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_60 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_5c = iVar5 * 0x100 | uVar6 >> 0x18;
          uStack_58 = (undefined)((uint)iVar5 >> 0x18);
        }
        uVar4 = FUNAAAAD();
      }
    }
  }
  else
  {
    switch (*(undefined *)(piVar3 + 8))
    {
    default:
      goto switchD_00004814_caseD_0;
    case 1:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        uStack_44 = ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 | (uint)*pbVar2 |
                    (uint)pbVar2[3] << 0x18;
        uVar7 = (uint)pbVar2[6] * 0x100 +
                (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000;
        uStack_40 = (uint)pbVar2[3] + (uint)pbVar2[4] * 0x100 >> 8 & 0xff | uVar7 * 0x100;
        uVar7 = uVar7 >> 0x18;
        uStack_3c = uStack_3c & 0xffffff00 | uVar7;
        if ((*pbVar2 & 1) != 0)
        {
          uStack_3c = uVar6 & 0xff000000 | uVar7 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        uVar4 = FUN_00004f2a((int)piVar3 + 0x12, 1);
      }
      break;
    case 3:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_b4 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                    (uint)pbVar2[3] << 0x18;
        uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                (uint)pbVar2[6] * 0x100;
        uStack_b0 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                (uint)pbVar2[10] * 0x100;
        uStack_ac = iVar5 * 0x100 | uVar6 >> 0x18;
        uStack_a8 = (undefined)((uint)iVar5 >> 0x18);
        bStack_a7 = pbVar2[0xd];
        in_00 = pbVar2 + 0xe;
        if ((bVar1 & 1) != 0)
        {
          memcpy(auStack_a6, in_00, 8);
          in_00 = pbVar2 + 0x16;
        }
        if ((int)((uint)bVar1 << 0x1e) < 0)
        {
          sStack_9e = (ushort)in_00[1] * 0x100 + (ushort)*in_00;
        }
        uVar4 = FUN_00004f28((int)piVar3 + 0x12, 3, &uStack_b4);
      }
      break;
    case 4:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        uStack_d0 = (uint)*pbVar2 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                    (uint)pbVar2[3] << 0x18;
        uVar6 = (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 +
                (uint)pbVar2[6] * 0x100;
        uStack_cc = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar5 = (uint)pbVar2[9] + (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 +
                (uint)pbVar2[10] * 0x100;
        uStack_c8 = iVar5 * 0x100 | uVar6 >> 0x18;
        uStack_c4 = (undefined)((uint)iVar5 >> 0x18);
        bStack_c3 = pbVar2[0xd];
        sStack_c2 = (ushort)pbVar2[0xf] * 0x100 + (ushort)pbVar2[0xe];
        sStack_c0 = (ushort)pbVar2[0x11] * 0x100 + (ushort)pbVar2[0x10];
        if ((*pbVar2 & 1) != 0)
        {
          memcpy(auStack_be, pbVar2 + 0x12, 8);
        }
        uVar4 = FUN_00004f2c((int)piVar3 + 0x12, 4, &uStack_d0);
      }
      break;
    case 6:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_2c = uStack_2c & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          uStack_2c = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          iVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_28 = iVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          uStack_24 = (undefined)((uint)iVar5 >> 0x18);
        }
        uVar4 = FUNAAAAD();
      }
      break;
    case 8:
      in = (void *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        memcpy(auStack_88, in, 8);
        sStack_80 = (ushort) * (byte *)((int)in + 9) * 0x100 + (ushort) * (byte *)((int)in + 8);
        sStack_7e = (ushort) * (byte *)((int)in + 0xb) * 0x100 + (ushort) * (byte *)((int)in + 10);
        iStack_7c = (uint) * (byte *)((int)in + 0xf) * 0x1000000 +
                    (uint) * (byte *)((int)in + 0xe) * 0x10000 + (uint) * (byte *)((int)in + 0xc) +
                    (uint) * (byte *)((int)in + 0xd) * 0x100;
        sStack_78 = (ushort) * (byte *)((int)in + 0x11) * 0x100 + (ushort) * (byte *)((int)in + 0x10);
        uVar4 = FUN_00004f26((int)piVar3 + 0x12, 8, auStack_88);
      }
    }
  }
  return uVar4;
}
status_t zcl_ota_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  byte *pbVar2;
  u8 *in;
  status_t sVar3;
  int iVar4;
  byte *in_00;
  uint uVar5;
  uint uVar6;
  uint local_d0;
  uint uStack_cc;
  uint uStack_c8;
  undefined uStack_c4;
  byte bStack_c3;
  short sStack_c2;
  short sStack_c0;
  undefined auStack_be[10];
  uint local_b4;
  uint uStack_b0;
  uint uStack_ac;
  undefined uStack_a8;
  byte bStack_a7;
  undefined auStack_a6[8];
  short sStack_9e;
  uint local_9c;
  uint uStack_98;
  uint uStack_94;
  undefined uStack_90;
  byte bStack_8f;
  byte *pbStack_8e;
  undefined auStack_88[8];
  short sStack_80;
  short sStack_7e;
  int iStack_7c;
  short sStack_78;
  short local_74;
  short sStack_72;
  int iStack_70;
  int iStack_6c;
  int iStack_68;
  uint local_64;
  uint uStack_60;
  uint uStack_5c;
  undefined uStack_58;
  uint local_54;
  uint uStack_50;
  uint uStack_4c;
  undefined uStack_48;
  uint local_44;
  uint uStack_40;
  uint uStack_3c;
  byte local_38;
  byte bStack_37;
  short sStack_36;
  short sStack_34;
  int iStack_32;
  uint local_2c;
  uint uStack_28;
  undefined uStack_24;

  uVar5 = uStack_3c;
  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    switch ((pInMsg->hdr).cmd)
    {
    case '\0':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_38 = *pbVar2;
        bStack_37 = pbVar2[1];
        if (((local_38 != 0) &&
             (sStack_36 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2], 1 < local_38)) &&
            (sStack_34 = (ushort)pbVar2[5] * 0x100 + (ushort)pbVar2[4], local_38 == 3))
        {
          iStack_32 = (uint)pbVar2[9] * 0x1000000 + (uint)pbVar2[8] * 0x10000 + (uint)pbVar2[6] +
                      (uint)pbVar2[7] * 0x100;
        }
        sVar3 = FUNAAAAD();
      }
      break;
    default:
    switchD_00004814_caseD_0:
      sVar3 = 0x81;
      break;
    case '\x02':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_54 = local_54 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          local_54 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_50 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_4c = iVar4 * 0x100 | uVar5 >> 0x18;
          uStack_48 = (undefined)((uint)iVar4 >> 0x18);
        }
        sVar3 = FUNAAAAD();
      }
      break;
    case '\x05':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        uVar5 = (uint)bVar1;
        local_9c = local_9c & 0xffffff00 | uVar5;
        if (bVar1 == 0)
        {
          local_9c = uVar5 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_94 = iVar4 * 0x100 | uVar5 >> 0x18;
          uStack_90 = (undefined)((uint)iVar4 >> 0x18);
          bStack_8f = pbVar2[0xd];
          pbStack_8e = pbVar2 + 0xe;
        }
        else if (bVar1 == 0x97)
        {
          uVar6 = (uint)pbVar2[4] * 0x1000000 + (uint)pbVar2[3] * 0x10000 + (uint)pbVar2[1] +
                  (uint)pbVar2[2] * 0x100;
          local_9c = uVar6 * 0x100 | uVar5;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar5 * 0x100 | uVar6 >> 0x18;
          uStack_94 = uStack_94 & 0xff000000 | uVar5 >> 0x18 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        sVar3 = FUNAAAAD();
      }
      break;
    case '\a':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_74 = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
        sStack_72 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2];
        iStack_70 = (uint)pbVar2[7] * 0x1000000 + (uint)pbVar2[6] * 0x10000 + (uint)pbVar2[4] +
                    (uint)pbVar2[5] * 0x100;
        iStack_6c = (uint)pbVar2[0xb] * 0x1000000 + (uint)pbVar2[10] * 0x10000 + (uint)pbVar2[8] +
                    (uint)pbVar2[9] * 0x100;
        iStack_68 = (uint)pbVar2[0xf] * 0x1000000 + (uint)pbVar2[0xe] * 0x10000 + (uint)pbVar2[0xc] + (uint)pbVar2[0xd] * 0x100;
        sVar3 = FUNAAAAD();
      }
      break;
    case '\t':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_64 = local_64 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          local_64 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_60 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_5c = iVar4 * 0x100 | uVar5 >> 0x18;
          uStack_58 = (undefined)((uint)iVar4 >> 0x18);
        }
        sVar3 = FUNAAAAD();
      }
    }
  }
  else
  {
    switch ((pInMsg->hdr).cmd)
    {
    default:
      goto switchD_00004814_caseD_0;
    case '\x01':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_44 = ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 | (uint)*pbVar2 |
                   (uint)pbVar2[3] << 0x18;
        uVar6 = (uint)pbVar2[6] * 0x100 +
                (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000;
        uStack_40 = (uint)pbVar2[3] + (uint)pbVar2[4] * 0x100 >> 8 & 0xff | uVar6 * 0x100;
        uVar6 = uVar6 >> 0x18;
        uStack_3c = uStack_3c & 0xffffff00 | uVar6;
        if ((*pbVar2 & 1) != 0)
        {
          uStack_3c = uVar5 & 0xff000000 | uVar6 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        sVar3 = FUN_00004f2a(&pInMsg->addrInfo, 1);
      }
      break;
    case '\x03':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_b4 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                   (uint)pbVar2[3] << 0x18;
        uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                (uint)pbVar2[6] * 0x100;
        uStack_b0 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                (uint)pbVar2[10] * 0x100;
        uStack_ac = iVar4 * 0x100 | uVar5 >> 0x18;
        uStack_a8 = (undefined)((uint)iVar4 >> 0x18);
        bStack_a7 = pbVar2[0xd];
        in_00 = pbVar2 + 0xe;
        if ((bVar1 & 1) != 0)
        {
          memcpy(auStack_a6, in_00, 8);
          in_00 = pbVar2 + 0x16;
        }
        if ((int)((uint)bVar1 << 0x1e) < 0)
        {
          sStack_9e = (ushort)in_00[1] * 0x100 + (ushort)*in_00;
        }
        sVar3 = FUN_00004f28(&pInMsg->addrInfo, 3, &local_b4);
      }
      break;
    case '\x04':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_d0 = (uint)*pbVar2 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                   (uint)pbVar2[3] << 0x18;
        uVar5 = (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 +
                (uint)pbVar2[6] * 0x100;
        uStack_cc = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar4 = (uint)pbVar2[9] + (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 +
                (uint)pbVar2[10] * 0x100;
        uStack_c8 = iVar4 * 0x100 | uVar5 >> 0x18;
        uStack_c4 = (undefined)((uint)iVar4 >> 0x18);
        bStack_c3 = pbVar2[0xd];
        sStack_c2 = (ushort)pbVar2[0xf] * 0x100 + (ushort)pbVar2[0xe];
        sStack_c0 = (ushort)pbVar2[0x11] * 0x100 + (ushort)pbVar2[0x10];
        if ((*pbVar2 & 1) != 0)
        {
          memcpy(auStack_be, pbVar2 + 0x12, 8);
        }
        sVar3 = FUN_00004f2c(&pInMsg->addrInfo, 4, &local_d0);
      }
      break;
    case '\x06':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_2c = local_2c & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          local_2c = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          iVar4 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_28 = iVar4 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          uStack_24 = (undefined)((uint)iVar4 >> 0x18);
        }
        sVar3 = FUNAAAAD();
      }
      break;
    case '\b':
      in = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        memcpy(auStack_88, in, 8);
        sStack_80 = (ushort)in[9] * 0x100 + (ushort)in[8];
        sStack_7e = (ushort)in[0xb] * 0x100 + (ushort)in[10];
        iStack_7c = (uint)in[0xf] * 0x1000000 + (uint)in[0xe] * 0x10000 + (uint)in[0xc] +
                    (uint)in[0xd] * 0x100;
        sStack_78 = (ushort)in[0x11] * 0x100 + (ushort)in[0x10];
        sVar3 = FUN_00004f26(&pInMsg->addrInfo, 8, auStack_88);
      }
    }
  }
  return sVar3;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAD(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r7;
  code *unaff_r8;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*in_r3)();
  (*unaff_r7)();
  (*unaff_r8)();
  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}
void FUN_00004f26(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r7;
  code *unaff_r8;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r7)();
  (*unaff_r8)();
  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}
void FUN_00004f28(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r8;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r8)();
  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}
void FUN_00004f2a(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}
void FUN_00004f2c(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}
status_t zcl_ota_register(u8 endpoint, u16 manuCode, u8 arrtNum, zclAttrInfo_t *attrTbl,
                          cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x19, manuCode, arrtNum, attrTbl, zcl_ota_cmdHandler, cb);
  return sVar1;
}
status_t zcl_ota_queryNextImageReqSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                       ota_queryNextImageReq_t *pReq)

{
  u32 uVar1;
  short sVar2;
  status_t sVar3;
  byte local_24;
  undefined uStack_23;
  undefined uStack_22;
  undefined uStack_21;
  undefined uStack_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;

  local_24 = pReq->fc;
  uStack_23 = (undefined)pReq->manuCode;
  uStack_22 = (undefined)(pReq->manuCode >> 8);
  uStack_21 = (undefined)pReq->imageType;
  uStack_20 = (undefined)(pReq->imageType >> 8);
  uVar1 = pReq->curFileVer;
  uStack_1f = (undefined)uVar1;
  uStack_1e = (undefined)(uVar1 >> 8);
  uStack_1d = (undefined)(uVar1 >> 0x10);
  uStack_1c = (undefined)(uVar1 >> 0x18);
  sVar2 = (short)&stack0x0000000d;
  if ((int)((uint)local_24 << 0x1f) < 0)
  {
    uStack_1b = (undefined)pReq->hdrwareVer;
    uStack_1a = (undefined)(pReq->hdrwareVer >> 8);
    sVar2 = (short)&stack0x0000000f;
  }
  sVar3 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      (sVar2 + -0x28) - (short)&local_24 & 0xff, &local_24);
  return sVar3;
}
status_t zcl_ota_queryNextImageRspSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                       ota_queryNextImageRsp_t *pRsp)

{
  u32 uVar1;
  status_t sVar2;
  short sVar3;
  u8 local_24;
  undefined uStack_23;
  undefined uStack_22;
  undefined uStack_21;
  undefined uStack_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;
  undefined uStack_19;
  undefined uStack_18;
  undefined auStack_17[7];

  local_24 = pRsp->st;
  sVar3 = (short)&uStack_23;
  if (local_24 == '\0')
  {
    uStack_23 = (undefined)pRsp->manuCode;
    uStack_22 = (undefined)(pRsp->manuCode >> 8);
    uStack_21 = (undefined)pRsp->imageType;
    uStack_20 = (undefined)(pRsp->imageType >> 8);
    uVar1 = pRsp->fileVer;
    uStack_1f = (undefined)uVar1;
    uStack_1e = (undefined)(uVar1 >> 8);
    uStack_1d = (undefined)(uVar1 >> 0x10);
    uStack_1c = (undefined)(uVar1 >> 0x18);
    uVar1 = pRsp->imageSize;
    uStack_1b = (undefined)uVar1;
    uStack_1a = (undefined)(uVar1 >> 8);
    uStack_19 = (undefined)(uVar1 >> 0x10);
    uStack_18 = (undefined)(uVar1 >> 0x18);
    sVar3 = (short)auStack_17;
  }
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x02', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      sVar3 - (short)&local_24 & 0xff, &local_24);
  return sVar2;
}
status_t zcl_ota_imageBlockReqSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_imageBlockReq_t *pReq)

{
  u32 uVar1;
  u16 uVar2;
  status_t sVar3;
  undefined *out;
  uint uVar4;
  byte local_38;
  undefined uStack_37;
  undefined uStack_36;
  undefined uStack_35;
  undefined uStack_34;
  undefined uStack_33;
  undefined uStack_32;
  undefined uStack_31;
  undefined uStack_30;
  undefined uStack_2f;
  undefined uStack_2e;
  undefined uStack_2d;
  undefined uStack_2c;
  u8 uStack_2b;
  undefined local_2a[8];
  undefined auStack_22[2];

  local_38 = pReq->fc;
  uVar4 = (uint)local_38;
  uStack_37 = (undefined)pReq->manuCode;
  uStack_36 = (undefined)(pReq->manuCode >> 8);
  uStack_35 = (undefined)pReq->imageType;
  uStack_34 = (undefined)(pReq->imageType >> 8);
  uVar1 = pReq->fileVer;
  uStack_33 = (undefined)uVar1;
  uStack_32 = (undefined)(uVar1 >> 8);
  uStack_31 = (undefined)(uVar1 >> 0x10);
  uStack_30 = (undefined)(uVar1 >> 0x18);
  uVar1 = pReq->fileOffset;
  uStack_2f = (undefined)uVar1;
  uStack_2e = (undefined)(uVar1 >> 8);
  uStack_2d = (undefined)(uVar1 >> 0x10);
  uStack_2c = (undefined)(uVar1 >> 0x18);
  uStack_2b = pReq->maxDataSize;
  out = local_2a;
  if ((int)(uVar4 << 0x1f) < 0)
  {
    memcpy(out, pReq->reqNodeAddr, 8);
    out = auStack_22;
  }
  if ((int)(uVar4 << 0x1e) < 0)
  {
    uVar2 = pReq->blockReqDelay;
    *out = (char)uVar2;
    out[1] = (char)(uVar2 >> 8);
    out = out + 2;
  }
  sVar3 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x03', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      (short)out - (short)&local_38 & 0xff, &local_38);
  return sVar3;
}
status_t zcl_ota_imageBlockRspSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_imageBlockRsp_t *pRsp)

{
  status_t sVar1;
  u8 *cmdPld;
  u16 size;

  if (pRsp->st == '\0')
  {
    size = (pRsp->rsp).success.dataSize + 0xe & 0xff;
  }
  else
  {
    size = 1;
    if (pRsp->st == 0x97)
    {
      size = 0xb;
    }
  }
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = pRsp->st;
    if (pRsp->st == '\0')
    {
      cmdPld[1] = *(u8 *)&pRsp->rsp;
      cmdPld[2] = *(u8 *)((int)&pRsp->rsp + 1);
      cmdPld[3] = *(u8 *)((int)&pRsp->rsp + 2);
      cmdPld[4] = *(u8 *)((int)&pRsp->rsp + 3);
      cmdPld[5] = *(u8 *)((int)&pRsp->rsp + 4);
      cmdPld[6] = *(u8 *)((int)&pRsp->rsp + 5);
      cmdPld[7] = *(u8 *)((int)&pRsp->rsp + 6);
      cmdPld[8] = *(u8 *)((int)&pRsp->rsp + 7);
      cmdPld[9] = *(u8 *)((int)&pRsp->rsp + 8);
      cmdPld[10] = *(u8 *)((int)&pRsp->rsp + 9);
      cmdPld[0xb] = *(u8 *)((int)&pRsp->rsp + 10);
      cmdPld[0xc] = *(u8 *)((int)&pRsp->rsp + 0xb);
      cmdPld[0xd] = (pRsp->rsp).success.dataSize;
      memcpy(cmdPld + 0xe, (pRsp->rsp).success.data, (uint)(pRsp->rsp).success.dataSize);
    }
    else if (pRsp->st == 0x97)
    {
      cmdPld[1] = *(u8 *)&pRsp->rsp;
      cmdPld[2] = *(u8 *)((int)&pRsp->rsp + 1);
      cmdPld[3] = *(u8 *)((int)&pRsp->rsp + 2);
      cmdPld[4] = *(u8 *)((int)&pRsp->rsp + 3);
      cmdPld[5] = *(u8 *)((int)&pRsp->rsp + 4);
      cmdPld[6] = *(u8 *)((int)&pRsp->rsp + 5);
      cmdPld[7] = *(u8 *)((int)&pRsp->rsp + 6);
      cmdPld[8] = *(u8 *)((int)&pRsp->rsp + 7);
      cmdPld[9] = *(u8 *)((int)&pRsp->rsp + 8);
      cmdPld[10] = *(u8 *)((int)&pRsp->rsp + 9);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x05', '\x01', '\x01', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}
status_t zcl_ota_upgradeEndReqSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_upgradeEndReq_t *pReq)

{
  u32 uVar1;
  status_t sVar2;
  u8 local_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;
  undefined uStack_19;
  undefined uStack_18;
  undefined auStack_17[7];

  local_20 = pReq->st;
  uStack_1f = (undefined)pReq->manuCode;
  uStack_1e = (undefined)(pReq->manuCode >> 8);
  uStack_1d = (undefined)pReq->imageType;
  uStack_1c = (undefined)(pReq->imageType >> 8);
  uVar1 = pReq->fileVer;
  uStack_1b = (undefined)uVar1;
  uStack_1a = (undefined)(uVar1 >> 8);
  uStack_19 = (undefined)(uVar1 >> 0x10);
  uStack_18 = (undefined)(uVar1 >> 0x18);
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x06', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      (short)auStack_17 - (short)&local_20 & 0xff, &local_20);
  return sVar2;
}
status_t zcl_ota_upgradeEndRspSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_upgradeEndRsp_t *pRsp)

{
  u32 uVar1;
  status_t sVar2;
  u8 local_24;
  undefined uStack_23;
  undefined uStack_22;
  undefined uStack_21;
  undefined uStack_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;
  undefined uStack_19;
  undefined uStack_18;
  undefined uStack_17;
  undefined uStack_16;
  undefined uStack_15;
  undefined auStack_14[4];

  local_24 = (u8)pRsp->manuCode;
  uStack_23 = (undefined)(pRsp->manuCode >> 8);
  uStack_22 = (undefined)pRsp->imageType;
  uStack_21 = (undefined)(pRsp->imageType >> 8);
  uVar1 = pRsp->fileVer;
  uStack_20 = (undefined)uVar1;
  uStack_1f = (undefined)(uVar1 >> 8);
  uStack_1e = (undefined)(uVar1 >> 0x10);
  uStack_1d = (undefined)(uVar1 >> 0x18);
  uVar1 = pRsp->currentTime;
  uStack_1c = (undefined)uVar1;
  uStack_1b = (undefined)(uVar1 >> 8);
  uStack_1a = (undefined)(uVar1 >> 0x10);
  uStack_19 = (undefined)(uVar1 >> 0x18);
  uVar1 = pRsp->upgradeTime;
  uStack_18 = (undefined)uVar1;
  uStack_17 = (undefined)(uVar1 >> 8);
  uStack_16 = (undefined)(uVar1 >> 0x10);
  uStack_15 = (undefined)(uVar1 >> 0x18);
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\a', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      (short)auStack_14 - (short)&local_24 & 0xff, &local_24);
  return sVar2;
}
status_t zcl_occupancySensing_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x406, manuCode, attrNum, attrTbl, ll_reset, cb);
  return sVar1;
}
status_t zcl_temperature_measurement_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x402, manuCode, attrNum, attrTbl, ll_reset, cb);
  return sVar1;
}
status_t zcl_basic_cmdHandler(zclIncoming_t *pInMsg)

{
  status_t sVar1;

  sVar1 = 0x81;
  if ((-1 < (int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c)) && ((pInMsg->hdr).cmd == '\0'))
  {
    sVar1 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      sVar1 = FUN_0000548a(&pInMsg->addrInfo, 0, 0);
    }
  }
  return sVar1;
}
void FUN_0000548a(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*in_r3)();
  zcl_registerCluster(endpoint, 0, manuCode, attrNum, pAttrTbl, zcl_basic_cmdHandler, in_stack_00000000);
  return;
}
status_t zcl_basic_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl,
                            cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0, manuCode, attrNum, attrTbl, zcl_basic_cmdHandler, cb);
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_gp_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  undefined3 *puVar2;
  uint3 *puVar3;
  u8 *puVar4;
  status_t sVar5;
  ushort uVar6;
  uint uVar7;
  uint extraout_r1;
  uint uVar8;
  uint extraout_r2;
  uint extraout_r3;
  uint extraout_r3_00;
  uint uVar9;
  byte *pbVar10;
  uint uVar11;
  uint extraout_r3_01;
  uint extraout_r3_02;
  byte *pbVar12;
  byte *pbVar13;
  int *piVar14;
  undefined auStack_134[4];
  byte *pbStack_130;
  byte *pbStack_12c;
  byte *pbStack_128;
  byte *pbStack_124;
  int iStack_120;
  int iStack_10c;
  undefined2 uStack_104;
  short sStack_102;
  short sStack_100;
  short sStack_fe;
  byte bStack_fc;
  byte bStack_fb;
  byte bStack_f9;
  byte bStack_f8;
  byte bStack_f6;
  byte bStack_f5;
  byte bStack_f2;
  char cStack_f1;
  int iStack_f0;
  undefined4 uStack_ec;
  undefined4 uStack_e8;
  undefined4 uStack_e4;
  uint uStack_e0;
  int iStack_dc;
  undefined4 uStack_d8;
  undefined4 uStack_d4;
  undefined4 uStack_d0;
  undefined4 uStack_cc;
  uint uStack_c8;
  uint uStack_c4;
  byte local_c0;
  int iStack_bc;
  undefined4 uStack_b8;
  byte *pbStack_b4;
  int iStack_b0;
  int iStack_ac;
  undefined4 uStack_a8;
  undefined4 uStack_a4;
  int iStack_a0;
  undefined4 uStack_9c;
  byte *pbStack_98;
  int iStack_94;
  undefined4 uStack_90;
  int iStack_8c;
  int iStack_88;
  undefined4 uStack_84;
  byte *pbStack_80;
  undefined4 uStack_7c;
  short local_78;
  byte local_76;
  int iStack_74;
  undefined4 uStack_70;
  int *piStack_6c;
  uint uStack_68;
  int local_64;
  undefined4 uStack_60;
  ushort local_5c;
  undefined local_5a;
  int local_58;
  undefined4 uStack_54;
  ushort local_50;
  undefined local_4e;
  int iStack_4c;
  undefined4 uStack_48;
  undefined local_44;
  int iStack_40;
  uint uStack_3c;
  undefined local_38;
  undefined4 local_34;
  undefined2 uStack_30;
  uint local_2c;
  u8 local_28;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    switch ((pInMsg->hdr).cmd)
    {
    default:
      goto switchD_000054fc_caseD_1;
    case '\x01':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      piVar14 = &iStack_f0;
      iStack_f0 = 0;
      uStack_ec = 0;
      uStack_e8 = 0;
      uStack_e4 = 0;
      iStack_dc = 0;
      uStack_d8 = 0;
      uStack_d4 = 0;
      uStack_d0 = 0;
      uStack_cc = 0;
      uStack_c8 = 0;
      uStack_c4 = 0;
      local_c0 = 0;
      pbVar12 = pInMsg->pData;
      uStack_e0 = (uint)pbVar12[2] * 0x10000 + (uint)pbVar12[1] * 0x100 + (uint)*pbVar12;
      uVar7 = uStack_e0 & 0xff;
      if ((uStack_e0 & 7) != 0)
      {
        sVar5 = FUN_000057ee();
        return sVar5;
      }
      iStack_f0 = (uint)pbVar12[6] * 0x1000000 + (uint)pbVar12[5] * 0x10000 + (uint)pbVar12[3] +
                  (uint)pbVar12[4] * 0x100;
      pbVar13 = pbVar12 + 7;
      if (-1 < (int)(uVar7 << 0x1b))
      {
        uVar8 = uStack_e0 & 0x60;
        if (uVar8 == 0x60)
        {
          FUN_00005e5c();
          uVar8 = extraout_r3;
        }
        if (uVar8 == 0)
        {
          FUN_00005e5c();
          uVar8 = extraout_r3_00;
        }
        if ((uVar8 == 0x40) || (uVar8 == 0x20))
        {
          uStack_c8 = uStack_c8 & 0xffff |
                      (uint)(ushort)((ushort)pbVar12[8] * 0x100 + (ushort)*pbVar13) << 0x10;
          pbVar13 = pbVar12 + 9;
        }
        if ((int)(uVar7 << 0x1c) < 0)
        {
          uStack_c4 = uStack_c4 & 0xffffff | (uint)*pbVar13 << 0x18;
          pbVar12 = pbVar13 + 1;
          if ((int)((uStack_e0 >> 8) << 0x19) < 0)
          {
            iStack_dc = (uint)pbVar13[4] * 0x1000000 + (uint)pbVar13[3] * 0x10000 + (uint)pbVar13[1] + (uint)pbVar13[2] * 0x100;
            pbVar12 = pbVar13 + 5;
          }
          if ((uStack_e0 & 0x8000) != 0)
          {
            FUN_00005ee4();
          }
          uVar7 = uStack_e0 >> 0x10 & 0xff;
          if ((int)(uVar7 << 0x1f) < 0)
          {
            uStack_c4 = uStack_c4 & 0xffff0000 |
                        (uint)(ushort)((ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12);
            pbVar12 = pbVar12 + 2;
          }
          if ((int)(uVar7 << 0x1e) < 0)
          {
            local_c0 = *pbVar12;
          }
        }
      }
      uVar8 = (uint) * (uint3 *)&pInMsg->clusterAppCb;
      uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
      break;
    case '\x02':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      pbVar12 = pInMsg->pData;
      local_2c = (uint)*pbVar12;
      uVar7 = local_2c;
      if ((*pbVar12 & 1) != 0)
      {
        pbVar13 = pbVar12 + 1;
        if ((int)(local_2c << 0x1e) < 0)
        {
          local_2c = local_2c |
                     (uint)(ushort)((ushort)pbVar12[2] * 0x100 + (ushort)pbVar12[1]) << 0x10;
          pbVar13 = pbVar12 + 3;
        }
        if ((int)(uVar7 << 0x1b) < 0)
        {
          local_2c._0_2_ = CONCAT11(*pbVar13, (undefined)local_2c);
          local_2c = local_2c & 0xffff0000 | (uint)(ushort)local_2c;
        }
      }
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 2);
      return sVar5;
    case '\x06':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      iStack_88 = 0;
      uStack_84 = 0;
      pbStack_80 = (byte *)0x0;
      local_78 = 0;
      local_76 = 0;
      pbVar12 = pInMsg->pData;
      bVar1 = *pbVar12;
      uStack_7c = CONCAT13(pbVar12[3],
                           CONCAT12(bVar1, (ushort)pbVar12[2] * 0x100 + (ushort)pbVar12[1]));
      if ((bVar1 & 7) != 0)
      {
        if ((bVar1 & 7) != 2)
        {
          local_78 = (ushort)pbVar12[4] << 8;
          local_76 = pbVar12[5];
          pbStack_80 = pbVar12 + 6;
          sVar5 = FUN_00005f1e(&pInMsg->addrInfo, 6, &iStack_88);
          return sVar5;
        }
        sVar5 = FUN_00005ebe();
        return sVar5;
      }
      iStack_88 = (uint)pbVar12[7] * 0x1000000 + (uint)pbVar12[6] * 0x10000 + (uint)pbVar12[4] +
                  (uint)pbVar12[5] * 0x100;
      sVar5 = FUN_0000575c(1, pbVar12 + 8);
      return sVar5;
    case '\n':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      puVar2 = (undefined3 *)pInMsg->pData;
      local_44 = *(undefined *)(puVar2 + 1);
      iStack_4c = (int)puVar2 + 4;
      uStack_48 = CONCAT31(*puVar2, *(char *)&pInMsg->dataLen + -4);
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 10);
      return sVar5;
    case '\v':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      piVar14 = &local_64;
      local_64 = 0;
      uStack_60 = 0;
      local_5a = 0;
      pbVar12 = pInMsg->pData;
      bVar1 = *pbVar12;
      local_5c = (ushort)bVar1;
      pbVar13 = pbVar12 + 1;
      if ((bVar1 & 0x18) != 0)
      {
        sVar5 = FUN_000057da();
        return sVar5;
      }
      uVar7 = bVar1 & 7;
      if ((bVar1 & 7) == 0)
      {
        local_64 = (uint)pbVar12[4] * 0x1000000 + (uint)pbVar12[3] * 0x10000 + (uint)pbVar12[1] +
                   (uint)pbVar12[2] * 0x100;
        sVar5 = FUN_000057e0();
        return sVar5;
      }
      goto LAB_00005da6;
    }
    goto LAB_00005612;
  }
  switch ((pInMsg->hdr).cmd)
  {
  case '\0':
    uVar9 = (uint) * (byte *)&pInMsg->clusterAppCb;
    uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
    uVar11 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
    uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\x01';
    }
    piVar14 = &iStack_a0;
    iStack_a0 = 0;
    uStack_9c = 0;
    pbStack_98 = (byte *)0x0;
    iStack_94 = 0;
    iStack_8c = 0;
    pbVar12 = pInMsg->pData;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    uStack_90 = (uint)uVar6;
    if ((uVar6 & 7) != 0)
    {
      sVar5 = FUN_00005e00();
      return sVar5;
    }
    iStack_a0 = (uint)pbVar12[3] * 0x100 +
                (uint)pbVar12[5] * 0x1000000 + (uint)pbVar12[4] * 0x10000 + (uint)pbVar12[2];
    iStack_94 = (uint)pbVar12[9] * 0x1000000 + (uint)pbVar12[8] * 0x10000 + (uint)pbVar12[6] +
                (uint)pbVar12[7] * 0x100;
    iStack_8c = (uint) * (ushort *)(pbVar12 + 10) << 8;
    pbStack_98 = pbVar12 + 0xc;
    uStack_90._1_1_ = (byte)(uVar6 >> 8);
    if ((int)((uint)uStack_90._1_1_ << 0x19) < 0)
    {
      pbVar13 = pbStack_98 + pbVar12[0xb];
      uStack_90 = CONCAT22((ushort)pbVar13[1] * 0x100 + (ushort)*pbVar13, uVar6);
      iStack_8c = (uint)CONCAT12(pbVar13[2], *(ushort *)(pbVar12 + 10)) << 8;
    }
    goto LAB_00005956;
  default:
  switchD_000054fc_caseD_1:
    sVar5 = 0x81;
    break;
  case '\x04':
    uVar9 = (uint) * (byte *)&pInMsg->clusterAppCb;
    uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
    uVar11 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
    uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\x01';
    }
    piVar14 = &iStack_bc;
    iStack_bc = 0;
    uStack_b8 = 0;
    pbStack_b4 = (byte *)0x0;
    iStack_b0 = 0;
    iStack_ac = 0;
    uStack_a4 = 0;
    pbVar12 = pInMsg->pData;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    uStack_a8 = (uint)uVar6;
    if ((uVar6 & 7) != 0)
    {
      sVar5 = FUN_00005dd6();
      return sVar5;
    }
    iStack_bc = (uint)pbVar12[3] * 0x100 +
                (uint)pbVar12[5] * 0x1000000 + (uint)pbVar12[4] * 0x10000 + (uint)pbVar12[2];
    iStack_b0 = (uint)pbVar12[9] * 0x1000000 + (uint)pbVar12[8] * 0x10000 + (uint)pbVar12[6] +
                (uint)pbVar12[7] * 0x100;
    uStack_a4._3_1_ = 0;
    pbStack_b4 = pbVar12 + 0xc;
    pbVar13 = pbStack_b4 + pbVar12[0xb];
    uStack_a8._1_1_ = (byte)(uVar6 >> 8);
    if ((int)((uint)uStack_a8._1_1_ << 0x1c) < 0)
    {
      uStack_a8 = CONCAT22((ushort)*pbVar13 + (ushort)pbVar13[1] * 0x100, uVar6);
      uStack_a4._3_1_ = pbVar13[2];
      pbVar13 = pbVar13 + 3;
    }
    uStack_a4 = (uint)CONCAT12(uStack_a4._3_1_, *(undefined2 *)(pbVar12 + 10)) << 8;
    if ((int)((uint)uStack_a8._1_1_ << 0x1e) < 0)
    {
      iStack_ac = (uint)pbVar13[3] * 0x1000000 + (uint)pbVar13[2] * 0x10000 + (uint)*pbVar13 +
                  (uint)pbVar13[1] * 0x100;
    }
  LAB_00005956:
    uVar8 = uVar9 | uVar8 << 8 | uVar11 << 0x10;
  LAB_00005612:
    sVar5 = FUN_00005f1a(&pInMsg->addrInfo, (pInMsg->hdr).cmd, piVar14, uVar8 | uVar7 << 0x18);
    break;
  case '\x05':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      puVar4 = pInMsg->pData;
      local_34 = CONCAT22((ushort)puVar4[4] * 0x100 + (ushort)puVar4[3],
                          (ushort)puVar4[2] * 0x100 + (ushort)puVar4[1]);
      uStack_30 = CONCAT11(puVar4[5], *puVar4);
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 5);
    }
    break;
  case '\b':
    if (pInMsg->clusterAppCb == ll_reset)
    {
      FUN_000054d8(1);
    }
    local_28 = *pInMsg->pData;
    FUN_00005f1a(&pInMsg->addrInfo, 8);
    FUN_000054d8();
  case '\a':
    uVar11 = (uint) * (byte *)&pInMsg->clusterAppCb;
    pbVar13 = (byte *)(uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
    uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
    uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    if (pInMsg->clusterAppCb == ll_reset)
    {
      FUN_000054d8(1);
      uVar7 = extraout_r1;
      uVar8 = extraout_r2;
      uVar11 = extraout_r3_01;
    }
    iStack_74 = 0;
    uStack_70 = 0;
    piStack_6c = (int *)0x0;
    pbVar12 = pInMsg->pData;
    bVar1 = *(byte *)&pInMsg->dataLen;
    uVar6 = (ushort)*pbVar12 + (ushort)pbVar12[1] * 0x100;
    uStack_68 = (uint)uVar6;
    piVar14 = (int *)(pbVar12 + 2);
    if ((uVar6 & 7) == 0)
    {
      iStack_74 = (uint)pbVar12[3] * 0x100 +
                  (uint)pbVar12[5] * 0x1000000 + (uint)pbVar12[4] * 0x10000 + (uint)pbVar12[2];
      piVar14 = (int *)(pbVar12 + 6);
    }
    else if ((uVar6 & 7) == 2)
    {
      memcpy(&iStack_74, piVar14, 8);
      uStack_68 = (uint)CONCAT12(pbVar12[10], (undefined2)uStack_68);
      piVar14 = (int *)(pbVar12 + 0xb);
      uVar11 = (uint) * (byte *)&pInMsg->clusterAppCb;
      pbVar13 = (byte *)(uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
      uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
      uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    }
    uStack_68 = (int)(pbVar12 + ((uint)bVar1 - (int)piVar14)) * 0x1000000 | uStack_68;
    if (((uint)(pbVar12 + ((uint)bVar1 - (int)piVar14)) & 0xff) != 0)
    {
      piStack_6c = piVar14;
    }
    FUN_00005f1a(&pInMsg->addrInfo, (pInMsg->hdr).cmd, &iStack_74,
                 uVar11 | (int)pbVar13 << 8 | uVar7 << 0x10 | uVar8 << 0x18);
    FUN_000054d8();
    uVar7 = extraout_r3_02;
  LAB_00005da6:
    if (uVar7 == 2)
    {
      memcpy(piVar14, pbVar13, 8);
      *(byte *)((int)piVar14 + 9) = pbVar13[8];
      sVar5 = FUN_000057e0();
      return sVar5;
    }
    sVar5 = FUN_000057e0();
    return sVar5;
  case '\t':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      memset(auStack_134, 0, 0x44);
      pbVar12 = pInMsg->pData;
      bStack_fc = *pbVar12;
      uStack_104 = (ushort)pbVar12[2] * 0x100 + (ushort)pbVar12[1];
      if ((uStack_104 & 7) != 0)
      {
        sVar5 = FUN_00005dbc();
        return sVar5;
      }
      iStack_10c = (uint)pbVar12[6] * 0x1000000 + (uint)pbVar12[5] * 0x10000 + (uint)pbVar12[3] +
                   (uint)pbVar12[4] * 0x100;
      bStack_f9 = pbVar12[7];
      pbVar13 = pbVar12 + 8;
      if (((byte)uStack_104 & 0x18) == 0x10)
      {
        sVar5 = FUN_00005ed0();
        return sVar5;
      }
      uStack_104._1_1_ = (byte)(uStack_104 >> 8);
      if ((int)((uint)uStack_104._1_1_ << 0x1f) < 0)
      {
        sStack_102 = (ushort)pbVar12[9] * 0x100 + (ushort)*pbVar13;
        pbVar13 = pbVar12 + 10;
      }
      bStack_f8 = *pbVar13;
      pbVar10 = pbVar13 + 1;
      if ((int)((uint)uStack_104._1_1_ << 0x1e) < 0)
      {
        sVar5 = FUN_00005e90();
        return sVar5;
      }
      if ((int)((uint)(byte)uStack_104 << 0x1a) < 0)
      {
        iStack_120 = (uint)pbVar13[4] * 0x1000000 + (uint)pbVar13[3] * 0x10000 + (uint)*pbVar10 +
                     (uint)pbVar13[2] * 0x100;
        pbVar10 = pbVar13 + 5;
      }
      bStack_f6 = *pbVar10;
      uVar7 = (uint)bStack_f6;
      pbVar10 = pbVar10 + 1;
      pbStack_124 = pbVar10;
      if ((((uVar7 != 0xfe) && (uVar7 != 0)) && (uVar7 != 0xfd)) && (uVar7 != 0xff))
      {
        pbStack_124 = pbVar10 + uVar7;
        pbStack_130 = pbVar10;
      }
      if ((int)((uint)uStack_104._1_1_ << 0x1d) < 0)
      {
        bStack_fb = *pbStack_124;
        pbVar13 = pbStack_124 + 1;
        uVar7 = (uint)bStack_fb;
        if ((int)(uVar7 << 0x1f) < 0)
        {
          sStack_100 = (ushort)pbStack_124[2] * 0x100 + (ushort)*pbVar13;
          pbVar13 = pbStack_124 + 3;
        }
        if ((int)(uVar7 << 0x1e) < 0)
        {
          sStack_fe = (ushort)pbVar13[1] * 0x100 + (ushort)*pbVar13;
          pbVar13 = pbVar13 + 2;
        }
        if ((int)(uVar7 << 0x1d) < 0)
        {
          bStack_f2 = *pbVar13;
          pbVar10 = pbVar13 + 1;
          pbVar13 = pbVar10;
          if (bStack_f2 != 0)
          {
            pbVar13 = pbVar10 + bStack_f2;
            pbStack_12c = pbVar10;
          }
        }
        pbStack_124 = pbVar13;
        if ((int)(uVar7 << 0x1c) < 0)
        {
          pbStack_124 = pbVar13 + 1;
          pbStack_128 = pbVar13;
          if (*pbVar13 != 0)
          {
            pbStack_124 = pbStack_124 + (((uint)*pbVar13 << 0x19) >> 0x18);
          }
        }
        if ((int)(uVar7 << 0x1b) < 0)
        {
          bStack_f5 = *pbStack_124;
          if (bStack_f5 == 2)
          {
            sVar5 = FUN_00005f0a();
            return sVar5;
          }
          pbStack_124 = pbStack_124 + bStack_f5 + 1;
        }
      }
      if ((bStack_fc & 7) == 5)
      {
        if ((int)pbStack_124 - (int)pbVar12 < (int)(uint)pInMsg->dataLen)
        {
          cStack_f1 = ((char)pbVar12 + (char)pInMsg->dataLen) - (char)pbStack_124;
          sVar5 = FUN_00005c82();
          return sVar5;
        }
        sVar5 = FUN_00005c82();
        return sVar5;
      }
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, (pInMsg->hdr).cmd, auStack_134, pInMsg->clusterAppCb);
    }
    break;
  case '\n':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      local_58 = 0;
      uStack_54 = 0;
      local_4e = 0;
      pbVar12 = pInMsg->pData;
      bVar1 = *pbVar12;
      local_50 = (ushort)bVar1;
      if ((bVar1 & 0x18) != 0)
      {
        sVar5 = FUN_00005e50();
        return sVar5;
      }
      if ((bVar1 & 7) == 0)
      {
        local_58 = (uint)pbVar12[4] * 0x1000000 + (uint)pbVar12[3] * 0x10000 + (uint)pbVar12[1] +
                   (uint)pbVar12[2] * 0x100;
      }
      else if ((bVar1 & 7) == 2)
      {
        memcpy(&local_58, pbVar12 + 1, 8);
        local_50 = local_50 & 0xff | (ushort)pbVar12[9] << 8;
      }
      sVar5 = FUN_00005f1c(&pInMsg->addrInfo, 10, &local_58);
    }
    break;
  case '\v':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      iStack_40 = 0;
      puVar3 = (uint3 *)pInMsg->pData;
      uStack_3c = (uint)*puVar3 << 8;
      local_38 = *(undefined *)(puVar3 + 1);
      uVar7 = (int)puVar3 + ((uint) * (byte *)&pInMsg->dataLen - ((int)puVar3 + 4));
      uStack_3c = uStack_3c | uVar7 & 0xff;
      if ((uVar7 & 0xff) != 0)
      {
        iStack_40 = (int)puVar3 + 4;
      }
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 0xb);
    }
  }
  return sVar5;
}
void FUN_000054d8(void)

{
  return;
}
void FUN_000055b0(void)

{
  undefined4 *unaff_r4;
  int unaff_r5;
  byte *pbVar1;
  undefined *unaff_r7;
  int unaff_r8;

  if (unaff_r8 << 0x1c < 0)
  {
    *(undefined *)(unaff_r5 + 0x2f) = *unaff_r7;
    pbVar1 = unaff_r7 + 1;
    if ((int)((uint) * (byte *)(unaff_r5 + 0x11) << 0x19) < 0)
    {
      *(uint *)(unaff_r5 + 0x14) =
          (uint)(byte)unaff_r7[4] * 0x1000000 + (uint)(byte)unaff_r7[3] * 0x10000 +
          (uint)(byte)unaff_r7[1] + (uint)(byte)unaff_r7[2] * 0x100;
      pbVar1 = unaff_r7 + 5;
    }
    if ((*(byte *)(unaff_r5 + 0x11) & 0x80) != 0)
    {
      FUN_00005ee4();
    }
    if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1f) < 0)
    {
      *(ushort *)(unaff_r5 + 0x2c) = (ushort)pbVar1[1] * 0x100 + (ushort)*pbVar1;
      pbVar1 = pbVar1 + 2;
    }
    if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1e) < 0)
    {
      *(byte *)(unaff_r5 + 0x30) = *pbVar1;
    }
  }
  FUN_00005f1a((int)unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 8), unaff_r5, *unaff_r4);
  return;
}
void FUN_000055e6(void)

{
  undefined4 *unaff_r4;
  int unaff_r5;
  byte *unaff_r6;

  if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1f) < 0)
  {
    *(ushort *)(unaff_r5 + 0x2c) = (ushort)unaff_r6[1] * 0x100 + (ushort)*unaff_r6;
    unaff_r6 = unaff_r6 + 2;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1e) < 0)
  {
    *(byte *)(unaff_r5 + 0x30) = *unaff_r6;
  }
  FUN_00005f1a((int)unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 8), unaff_r5, *unaff_r4);
  return;
}
void FUN_0000575c(undefined4 param_1, undefined *param_2)

{
  int unaff_r4;
  int unaff_r5;

  *(undefined *)(unaff_r5 + 0x11) = *param_2;
  *(undefined *)(unaff_r5 + 0x12) = param_2[1];
  *(undefined **)(unaff_r5 + 8) = param_2 + 2;
  FUN_00005f1e(unaff_r4 + 0x12, 6, unaff_r5);
  return;
}
void FUN_000057da(undefined4 param_1, int param_2)

{
  int unaff_r4;
  undefined4 unaff_r5;

  if (param_2 == 8)
  {
    FUN_00005e8a();
    return;
  }
  FUN_00005f1c(unaff_r4 + 0x12, 0xb, unaff_r5);
  return;
}
void FUN_000057e0(void)

{
  int unaff_r4;
  undefined4 unaff_r5;

  FUN_00005f1c(unaff_r4 + 0x12, 0xb, unaff_r5);
  return;
}
void FUN_000057ee(void)

{
  uint uVar1;
  uint extraout_r3;
  uint extraout_r3_00;
  int in_r3;
  undefined4 *unaff_r4;
  void *unaff_r5;
  byte *pbVar2;
  int unaff_r6;
  byte *unaff_r7;
  uint unaff_r8;

  if (in_r3 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 0x2e) = *(undefined *)(unaff_r6 + 0xb);
    unaff_r7 = (byte *)(unaff_r6 + 0xc);
  }
  if (-1 < (int)(unaff_r8 << 0x1b))
  {
    uVar1 = unaff_r8 & 0x60;
    if (uVar1 == 0x60)
    {
      FUN_00005e5c();
      uVar1 = extraout_r3;
    }
    if (uVar1 == 0)
    {
      FUN_00005e5c();
      uVar1 = extraout_r3_00;
    }
    if ((uVar1 == 0x40) || (uVar1 == 0x20))
    {
      *(ushort *)((int)unaff_r5 + 0x2a) = (ushort)unaff_r7[1] * 0x100 + (ushort)*unaff_r7;
      unaff_r7 = unaff_r7 + 2;
    }
    if ((int)(unaff_r8 << 0x1c) < 0)
    {
      *(byte *)((int)unaff_r5 + 0x2f) = *unaff_r7;
      pbVar2 = unaff_r7 + 1;
      if ((int)((uint) * (byte *)((int)unaff_r5 + 0x11) << 0x19) < 0)
      {
        *(uint *)((int)unaff_r5 + 0x14) =
            (uint)unaff_r7[4] * 0x1000000 + (uint)unaff_r7[3] * 0x10000 + (uint)unaff_r7[1] +
            (uint)unaff_r7[2] * 0x100;
        pbVar2 = unaff_r7 + 5;
      }
      if ((*(byte *)((int)unaff_r5 + 0x11) & 0x80) != 0)
      {
        FUN_00005ee4();
      }
      if ((int)((uint) * (byte *)((int)unaff_r5 + 0x12) << 0x1f) < 0)
      {
        *(ushort *)((int)unaff_r5 + 0x2c) = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
        pbVar2 = pbVar2 + 2;
      }
      if ((int)((uint) * (byte *)((int)unaff_r5 + 0x12) << 0x1e) < 0)
      {
        *(byte *)((int)unaff_r5 + 0x30) = *pbVar2;
      }
    }
  }
  FUN_00005f1a((int)unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 8), unaff_r5, *unaff_r4);
  return;
}
void FUN_00005ba8(void)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  byte *pbVar4;
  int unaff_r4;
  int unaff_r5;
  byte *unaff_r6;
  int unaff_r7;
  int unaff_sl;

  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1f) < 0)
  {
    *(ushort *)(unaff_r5 + 0x32) = (ushort)unaff_r6[1] * 0x100 + (ushort)*unaff_r6;
    unaff_r6 = unaff_r6 + 2;
  }
  *(byte *)(unaff_r5 + 0x3c) = *unaff_r6;
  pbVar4 = unaff_r6 + 1;
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1e) < 0)
  {
    FUN_00005e90();
    return;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x30) << 0x1a) < 0)
  {
    *(uint *)(unaff_r5 + 0x14) =
        (uint)unaff_r6[4] * 0x1000000 + (uint)unaff_r6[3] * 0x10000 + (uint)*pbVar4 +
        (uint)unaff_r6[2] * 0x100;
    pbVar4 = unaff_r6 + 5;
  }
  uVar3 = (uint)*pbVar4;
  *(byte *)(unaff_r5 + 0x3e) = *pbVar4;
  pbVar4 = pbVar4 + 1;
  if ((((uVar3 != 0xfe) && (uVar3 != 0)) && (uVar3 != 0xfd)) && (uVar3 != 0xff))
  {
    *(byte **)(unaff_r5 + 4) = pbVar4;
    pbVar4 = pbVar4 + uVar3;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1d) < 0)
  {
    *(byte *)(unaff_r5 + 0x39) = *pbVar4;
    uVar3 = (uint) * (byte *)(unaff_r5 + 0x39);
    pbVar2 = pbVar4 + 1;
    if ((int)(uVar3 << 0x1f) < 0)
    {
      *(ushort *)(unaff_r5 + 0x34) = (ushort)pbVar4[2] * 0x100 + (ushort)pbVar4[1];
      pbVar2 = pbVar4 + 3;
    }
    pbVar4 = pbVar2;
    if ((int)(uVar3 << 0x1e) < 0)
    {
      *(ushort *)(unaff_r5 + 0x36) = (ushort)pbVar4[1] * 0x100 + (ushort)*pbVar4;
      pbVar4 = pbVar4 + 2;
    }
    if ((int)(uVar3 << 0x1d) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x42) = bVar1;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        *(byte **)(unaff_r5 + 8) = pbVar4;
        pbVar4 = pbVar4 + bVar1;
      }
    }
    if ((int)(uVar3 << 0x1c) < 0)
    {
      *(byte **)(unaff_r5 + 0xc) = pbVar4;
      bVar1 = *pbVar4;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        pbVar4 = pbVar4 + (((uint)bVar1 << 0x19) >> 0x18);
      }
    }
    if ((int)(uVar3 << 0x1b) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x3f) = bVar1;
      if (bVar1 == 2)
      {
        FUN_00005f0a();
        return;
      }
      pbVar4 = pbVar4 + bVar1 + 1;
    }
  }
  if ((*(byte *)(unaff_r5 + 0x38) & 7) == 5)
  {
    if (unaff_sl <= (int)pbVar4 - unaff_r7)
    {
      FUN_00005c82();
      return;
    }
    *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)pbVar4;
    *(byte **)(unaff_r5 + 0x10) = pbVar4;
    FUN_00005c82();
    return;
  }
  FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
  return;
}
void FUN_00005c82(void)

{
  int unaff_r4;

  FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
  return;
}
void FUN_00005dbc(undefined4 param_1, undefined *param_2, undefined4 param_3, int param_4)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  int unaff_r4;
  int unaff_r5;
  byte *pbVar4;
  int unaff_r7;
  uint unaff_r8;
  int unaff_sl;

  if (param_4 == 2)
  {
    memcpy(&stack0x00000028, param_2, 8);
    *(undefined *)(unaff_r5 + 0x3a) = *(undefined *)(unaff_r7 + 0xb);
    param_2 = (undefined *)(unaff_r7 + 0xc);
  }
  *(undefined *)(unaff_r5 + 0x3b) = *param_2;
  pbVar4 = param_2 + 1;
  if ((unaff_r8 & 0x18) == 0x10)
  {
    FUN_00005ed0();
    return;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1f) < 0)
  {
    *(ushort *)(unaff_r5 + 0x32) = (ushort)(byte)param_2[2] * 0x100 + (ushort)*pbVar4;
    pbVar4 = param_2 + 3;
  }
  *(byte *)(unaff_r5 + 0x3c) = *pbVar4;
  pbVar3 = pbVar4 + 1;
  if (-1 < (int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1e))
  {
    if ((int)((uint) * (byte *)(unaff_r5 + 0x30) << 0x1a) < 0)
    {
      *(uint *)(unaff_r5 + 0x14) =
          (uint)pbVar4[4] * 0x1000000 + (uint)pbVar4[3] * 0x10000 + (uint)*pbVar3 +
          (uint)pbVar4[2] * 0x100;
      pbVar3 = pbVar4 + 5;
    }
    uVar2 = (uint)*pbVar3;
    *(byte *)(unaff_r5 + 0x3e) = *pbVar3;
    pbVar3 = pbVar3 + 1;
    if ((((uVar2 != 0xfe) && (uVar2 != 0)) && (uVar2 != 0xfd)) && (uVar2 != 0xff))
    {
      *(byte **)(unaff_r5 + 4) = pbVar3;
      pbVar3 = pbVar3 + uVar2;
    }
    if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1d) < 0)
    {
      *(byte *)(unaff_r5 + 0x39) = *pbVar3;
      uVar2 = (uint) * (byte *)(unaff_r5 + 0x39);
      pbVar4 = pbVar3 + 1;
      if ((int)(uVar2 << 0x1f) < 0)
      {
        *(ushort *)(unaff_r5 + 0x34) = (ushort)pbVar3[2] * 0x100 + (ushort)pbVar3[1];
        pbVar4 = pbVar3 + 3;
      }
      pbVar3 = pbVar4;
      if ((int)(uVar2 << 0x1e) < 0)
      {
        *(ushort *)(unaff_r5 + 0x36) = (ushort)pbVar3[1] * 0x100 + (ushort)*pbVar3;
        pbVar3 = pbVar3 + 2;
      }
      if ((int)(uVar2 << 0x1d) < 0)
      {
        bVar1 = *pbVar3;
        *(byte *)(unaff_r5 + 0x42) = bVar1;
        pbVar3 = pbVar3 + 1;
        if (bVar1 != 0)
        {
          *(byte **)(unaff_r5 + 8) = pbVar3;
          pbVar3 = pbVar3 + bVar1;
        }
      }
      if ((int)(uVar2 << 0x1c) < 0)
      {
        *(byte **)(unaff_r5 + 0xc) = pbVar3;
        bVar1 = *pbVar3;
        pbVar3 = pbVar3 + 1;
        if (bVar1 != 0)
        {
          pbVar3 = pbVar3 + (((uint)bVar1 << 0x19) >> 0x18);
        }
      }
      if ((int)(uVar2 << 0x1b) < 0)
      {
        bVar1 = *pbVar3;
        *(byte *)(unaff_r5 + 0x3f) = bVar1;
        if (bVar1 == 2)
        {
          FUN_00005f0a();
          return;
        }
        pbVar3 = pbVar3 + bVar1 + 1;
      }
    }
    if ((*(byte *)(unaff_r5 + 0x38) & 7) != 5)
    {
      FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
      return;
    }
    if ((int)pbVar3 - unaff_r7 < unaff_sl)
    {
      *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)pbVar3;
      *(byte **)(unaff_r5 + 0x10) = pbVar3;
      FUN_00005c82();
      return;
    }
    FUN_00005c82();
    return;
  }
  FUN_00005e90();
  return;
}
void FUN_00005dd6(undefined4 param_1, uint param_2, uint param_3, uint param_4)

{
  byte bVar1;
  byte *unaff_r4;
  void *unaff_r5;
  byte *pbVar2;
  byte *unaff_r7;
  int unaff_r8;
  int unaff_r9;
  uint unaff_ip;

  if (unaff_r8 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 0x18) = *(undefined *)(unaff_r9 + 10);
    unaff_r7 = (byte *)(unaff_r9 + 0xb);
    param_4 = (uint)*unaff_r4;
    unaff_ip = (uint)unaff_r4[1];
    param_2 = (uint)unaff_r4[2];
    param_3 = (uint)unaff_r4[3];
  }
  *(uint *)((int)unaff_r5 + 0xc) =
      (uint)unaff_r7[3] * 0x1000000 + (uint)unaff_r7[2] * 0x10000 + (uint)*unaff_r7 +
      (uint)unaff_r7[1] * 0x100;
  *(byte *)((int)unaff_r5 + 0x19) = unaff_r7[4];
  bVar1 = unaff_r7[5];
  *(byte *)((int)unaff_r5 + 0x1a) = bVar1;
  *(byte **)((int)unaff_r5 + 8) = unaff_r7 + 6;
  pbVar2 = unaff_r7 + 6 + bVar1;
  if ((int)((uint) * (byte *)((int)unaff_r5 + 0x15) << 0x1c) < 0)
  {
    *(ushort *)((int)unaff_r5 + 0x16) = (ushort)*pbVar2 + (ushort)pbVar2[1] * 0x100;
    *(byte *)((int)unaff_r5 + 0x1b) = pbVar2[2];
    pbVar2 = pbVar2 + 3;
  }
  if ((int)((uint) * (byte *)((int)unaff_r5 + 0x15) << 0x1e) < 0)
  {
    *(uint *)((int)unaff_r5 + 0x10) =
        (uint)pbVar2[3] * 0x1000000 + (uint)pbVar2[2] * 0x10000 + (uint)*pbVar2 +
        (uint)pbVar2[1] * 0x100;
  }
  FUN_00005f1a(unaff_r4 + 0x12, unaff_r4[0x20], unaff_r5,
               param_4 | unaff_ip << 8 | param_2 << 0x10 | param_3 << 0x18);
  return;
}
void FUN_00005e00(undefined4 param_1, uint param_2, uint param_3, uint param_4)

{
  byte bVar1;
  byte *unaff_r4;
  void *unaff_r5;
  byte *pbVar2;
  byte *unaff_r7;
  int unaff_r8;
  int unaff_r9;
  uint unaff_ip;

  if (unaff_r8 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 0x14) = *(undefined *)(unaff_r9 + 10);
    unaff_r7 = (byte *)(unaff_r9 + 0xb);
    param_4 = (uint)*unaff_r4;
    unaff_ip = (uint)unaff_r4[1];
    param_2 = (uint)unaff_r4[2];
    param_3 = (uint)unaff_r4[3];
  }
  *(uint *)((int)unaff_r5 + 0xc) =
      (uint)unaff_r7[3] * 0x1000000 + (uint)unaff_r7[2] * 0x10000 + (uint)*unaff_r7 +
      (uint)unaff_r7[1] * 0x100;
  *(byte *)((int)unaff_r5 + 0x15) = unaff_r7[4];
  bVar1 = unaff_r7[5];
  *(byte *)((int)unaff_r5 + 0x16) = bVar1;
  *(byte **)((int)unaff_r5 + 8) = unaff_r7 + 6;
  if ((int)((uint) * (byte *)((int)unaff_r5 + 0x11) << 0x19) < 0)
  {
    pbVar2 = unaff_r7 + 6 + bVar1;
    *(ushort *)((int)unaff_r5 + 0x12) = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
    *(byte *)((int)unaff_r5 + 0x17) = pbVar2[2];
  }
  FUN_00005f1a(unaff_r4 + 0x12, unaff_r4[0x20], unaff_r5,
               param_4 | unaff_ip << 8 | param_2 << 0x10 | param_3 << 0x18);
  return;
}
void FUN_00005e50(undefined4 param_1, int param_2, int param_3)

{
  int unaff_r4;
  int unaff_r5;

  if (param_2 == 8)
  {
    *(undefined *)(unaff_r5 + 10) = *(undefined *)(param_3 + 1);
  }
  FUN_00005f1c(unaff_r4 + 0x12, 10, unaff_r5);
  return;
}
void FUN_00005e5c(void)

{
  int extraout_r3;
  int unaff_r5;
  void *unaff_r7;
  int unaff_sl;

  memcpy(&stack0x0000004c, unaff_r7, 8);
  *(ushort *)(unaff_r5 + 0x28) =
      (ushort) * (byte *)((int)unaff_r7 + 9) * 0x100 + (ushort) * (byte *)((int)unaff_r7 + 8);
  FUN_000055b0();
  if (unaff_sl <= extraout_r3 - ((int)unaff_r7 + 10))
  {
    FUN_00005c82();
    return;
  }
  *(char *)(unaff_r5 + 0x43) = ((char)((int)unaff_r7 + 10) + (char)unaff_sl) - (char)extraout_r3;
  *(int *)(unaff_r5 + 0x10) = extraout_r3;
  FUN_00005c82();
  return;
}
void FUN_00005e8a(undefined4 param_1, undefined4 param_2, int param_3)

{
  int unaff_r5;

  *(undefined *)(unaff_r5 + 10) = *(undefined *)(param_3 + 1);
  FUN_000057e0();
  return;
}
void FUN_00005e90(void)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  byte *pbVar4;
  int in_r3;
  int unaff_r4;
  int unaff_r5;
  int unaff_r6;
  int unaff_r7;
  int unaff_sl;

  *(undefined *)(unaff_r5 + 0x3d) = *(undefined *)(unaff_r6 + 1);
  *(uint *)(unaff_r5 + 0x14) =
      (uint) * (byte *)(in_r3 + 4) * 0x1000000 + (uint) * (byte *)(in_r3 + 3) * 0x10000 +
      (uint) * (byte *)(in_r3 + 1) + (uint) * (byte *)(in_r3 + 2) * 0x100;
  memcpy(&stack0x00000018, (void *)(unaff_r6 + 6), 0x10);
  uVar3 = (uint) * (byte *)(unaff_r6 + 0x16);
  *(byte *)(unaff_r5 + 0x3e) = *(byte *)(unaff_r6 + 0x16);
  pbVar4 = (byte *)(unaff_r6 + 0x17);
  if ((((uVar3 != 0xfe) && (uVar3 != 0)) && (uVar3 != 0xfd)) && (uVar3 != 0xff))
  {
    *(byte **)(unaff_r5 + 4) = pbVar4;
    pbVar4 = pbVar4 + uVar3;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1d) < 0)
  {
    *(byte *)(unaff_r5 + 0x39) = *pbVar4;
    uVar3 = (uint) * (byte *)(unaff_r5 + 0x39);
    pbVar2 = pbVar4 + 1;
    if ((int)(uVar3 << 0x1f) < 0)
    {
      *(ushort *)(unaff_r5 + 0x34) = (ushort)pbVar4[2] * 0x100 + (ushort)pbVar4[1];
      pbVar2 = pbVar4 + 3;
    }
    pbVar4 = pbVar2;
    if ((int)(uVar3 << 0x1e) < 0)
    {
      *(ushort *)(unaff_r5 + 0x36) = (ushort)pbVar4[1] * 0x100 + (ushort)*pbVar4;
      pbVar4 = pbVar4 + 2;
    }
    if ((int)(uVar3 << 0x1d) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x42) = bVar1;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        *(byte **)(unaff_r5 + 8) = pbVar4;
        pbVar4 = pbVar4 + bVar1;
      }
    }
    if ((int)(uVar3 << 0x1c) < 0)
    {
      *(byte **)(unaff_r5 + 0xc) = pbVar4;
      bVar1 = *pbVar4;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        pbVar4 = pbVar4 + (((uint)bVar1 << 0x19) >> 0x18);
      }
    }
    if ((int)(uVar3 << 0x1b) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x3f) = bVar1;
      if (bVar1 == 2)
      {
        FUN_00005f0a();
        return;
      }
      pbVar4 = pbVar4 + bVar1 + 1;
    }
  }
  if ((*(byte *)(unaff_r5 + 0x38) & 7) == 5)
  {
    if (unaff_sl <= (int)pbVar4 - unaff_r7)
    {
      FUN_00005c82();
      return;
    }
    *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)pbVar4;
    *(byte **)(unaff_r5 + 0x10) = pbVar4;
    FUN_00005c82();
    return;
  }
  FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
  return;
}
void FUN_00005ebe(undefined4 param_1, void *param_2)

{
  void *pvVar1;
  void *unaff_r5;
  int unaff_r6;

  pvVar1 = memcpy(unaff_r5, param_2, 8);
  *(undefined *)((int)unaff_r5 + 0x10) = *(undefined *)(unaff_r6 + 0xc);
  FUN_0000575c(pvVar1, unaff_r6 + 0xd);
  return;
}
void FUN_00005ed0(undefined4 param_1, int param_2)

{
  if (*(char *)(param_2 + 1) == '\0')
  {
    FUN_00005ba8();
    return;
  }
  FUN_00005ba8();
  return;
}
void FUN_00005ee4(void)

{
  int extraout_r3;
  int unaff_r4;
  void *unaff_r5;
  void *unaff_r6;
  void *unaff_r7;

  memcpy(&stack0x0000005c, unaff_r6, 0x10);
  FUN_000055e6();
  if (extraout_r3 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 9) = *(undefined *)((int)unaff_r7 + 8);
  }
  FUN_00005f1c(unaff_r4 + 0x12, 10, unaff_r5);
  return;
}
void FUN_00005f0a(undefined4 param_1, int param_2, undefined4 param_3, int param_4)

{
  int unaff_r4;
  int unaff_r5;
  int unaff_r7;
  int unaff_sl;

  *(undefined *)(unaff_r5 + 0x40) = *(undefined *)(param_4 + 1);
  *(undefined *)(unaff_r5 + 0x41) = *(undefined *)(param_2 + 1);
  param_2 = param_2 + 2;
  if ((*(byte *)(unaff_r5 + 0x38) & 7) != 5)
  {
    FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
    return;
  }
  if (unaff_sl <= param_2 - unaff_r7)
  {
    FUN_00005c82();
    return;
  }
  *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)param_2;
  *(int *)(unaff_r5 + 0x10) = param_2;
  FUN_00005c82();
  return;
}
void FUN_00005f1a(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r6;
  code *unaff_r7;
  cluster_forAppCb_t in_stack_00000000;

  (*in_r3)();
  (*unaff_r6)();
  endpoint = (*unaff_r7)();
  zcl_registerCluster(endpoint, 0x21, manuCode, attrNum, pAttrTbl, zcl_gp_cmdHandler, in_stack_00000000);
  return;
}
void FUN_00005f1c(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r6;
  code *unaff_r7;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r6)();
  endpoint = (*unaff_r7)();
  zcl_registerCluster(endpoint, 0x21, manuCode, attrNum, pAttrTbl, zcl_gp_cmdHandler, in_stack_00000000);
  return;
}
void FUN_00005f1e(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r7;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*unaff_r7)();
  zcl_registerCluster(endpoint, 0x21, manuCode, attrNum, pAttrTbl, zcl_gp_cmdHandler, in_stack_00000000);
  return;
}
status_t zcl_gp_register(u8 endpoint, u16 manuCode, u8 arrtNum, zclAttrInfo_t *attrTbl,
                         cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x21, manuCode, arrtNum, attrTbl, zcl_gp_cmdHandler, cb);
  return sVar1;
}
status_t zcl_gp_notificationCmd(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                zcl_gp_notificationCmd_t *pCmd)

{
  ushort size;
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  short sVar3;

  sVar3 = 0xf;
  if (((*(byte *)&pCmd->options & 7) != 0) && (sVar3 = 0x14, (*(byte *)&pCmd->options & 7) != 2))
  {
    sVar3 = 0xb;
  }
  size = sVar3 + (ushort)pCmd->payloadLen & 0xff;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = *(u8 *)&pCmd->options;
    cmdPld[1] = *(u8 *)((int)&pCmd->options + 1);
    puVar2 = cmdPld + 2;
    if ((*(byte *)&pCmd->options & 7) == 0)
    {
      cmdPld[2] = (pCmd->gpdId).gpdIeeeAddr[0];
      cmdPld[3] = (pCmd->gpdId).gpdIeeeAddr[1];
      cmdPld[4] = (pCmd->gpdId).gpdIeeeAddr[2];
      cmdPld[5] = (pCmd->gpdId).gpdIeeeAddr[3];
      puVar2 = cmdPld + 6;
    }
    else if ((*(byte *)&pCmd->options & 7) == 2)
    {
      memcpy(puVar2, pCmd, 8);
      cmdPld[10] = pCmd->endpoint;
      puVar2 = cmdPld + 0xb;
    }
    *puVar2 = *(u8 *)&pCmd->gpdSecFrameCnt;
    puVar2[1] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 1);
    puVar2[2] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 2);
    puVar2[3] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 3);
    puVar2[4] = pCmd->gpdCmdID;
    puVar2[5] = pCmd->payloadLen;
    puVar2 = puVar2 + 6;
    if (pCmd->payloadLen != 0)
    {
      memcpy(puVar2, pCmd->pGpdCmdPayload, (uint)pCmd->payloadLen);
      puVar2 = puVar2 + pCmd->payloadLen;
    }
    if ((int)((uint) * (byte *)((int)&pCmd->options + 1) << 0x19) < 0)
    {
      *puVar2 = *(u8 *)&pCmd->gppShortAddr;
      puVar2[1] = *(u8 *)((int)&pCmd->gppShortAddr + 1);
      *(gpGppGpdLink_t *)(puVar2 + 2) = pCmd->gppGpdLink;
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x21, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}
status_t zcl_gp_commissioningNotificationCmd(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                             zcl_gp_commissioningNotificationCmd_t *pCmd)

{
  ushort size;
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  short sVar3;

  sVar3 = 0xf;
  if (((*(byte *)&pCmd->options & 7) != 0) && (sVar3 = 0x14, (*(byte *)&pCmd->options & 7) != 2))
  {
    sVar3 = 0xb;
  }
  if ((int)((uint) * (byte *)((int)&pCmd->options + 1) << 0x1e) < 0)
  {
    sVar3 = sVar3 + 4;
  }
  size = sVar3 + (ushort)pCmd->payloadLen & 0xff;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = *(u8 *)&pCmd->options;
    cmdPld[1] = *(u8 *)((int)&pCmd->options + 1);
    puVar2 = cmdPld + 2;
    if ((*(byte *)&pCmd->options & 7) == 0)
    {
      cmdPld[2] = (pCmd->gpdId).gpdIeeeAddr[0];
      cmdPld[3] = (pCmd->gpdId).gpdIeeeAddr[1];
      cmdPld[4] = (pCmd->gpdId).gpdIeeeAddr[2];
      cmdPld[5] = (pCmd->gpdId).gpdIeeeAddr[3];
      puVar2 = cmdPld + 6;
    }
    else if ((*(byte *)&pCmd->options & 7) == 2)
    {
      memcpy(puVar2, pCmd, 8);
      cmdPld[10] = pCmd->endpoint;
      puVar2 = cmdPld + 0xb;
    }
    *puVar2 = *(u8 *)&pCmd->gpdSecFrameCnt;
    puVar2[1] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 1);
    puVar2[2] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 2);
    puVar2[3] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 3);
    puVar2[4] = pCmd->gpdCmdID;
    puVar2[5] = pCmd->payloadLen;
    puVar2 = puVar2 + 6;
    if (pCmd->payloadLen != 0)
    {
      memcpy(puVar2, pCmd->pGpdCmdPayload, (uint)pCmd->payloadLen);
      puVar2 = puVar2 + pCmd->payloadLen;
    }
    *puVar2 = *(u8 *)&pCmd->gppShortAddr;
    puVar2[1] = *(u8 *)((int)&pCmd->gppShortAddr + 1);
    *(gpGppGpdLink_t *)(puVar2 + 2) = pCmd->gppGpdLink;
    if ((int)((uint) * (byte *)((int)&pCmd->options + 1) << 0x1e) < 0)
    {
      puVar2[3] = *(u8 *)&pCmd->mic;
      puVar2[4] = *(u8 *)((int)&pCmd->mic + 1);
      puVar2[5] = *(u8 *)((int)&pCmd->mic + 2);
      puVar2[6] = *(u8 *)((int)&pCmd->mic + 3);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x21, '\x04', '\x01', '\0', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}
status_t zcl_gp_proxyTableRspCmd(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                 zcl_gp_proxyTabRspCmd_t *pCmd)

{
  ushort size;
  status_t sVar1;
  u8 *cmdPld;

  size = pCmd->entriesLen + 4 & 0xff;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = pCmd->status;
    cmdPld[1] = pCmd->totalTabEntries;
    cmdPld[2] = pCmd->startIdx;
    cmdPld[3] = pCmd->entriesCnt;
    if (pCmd->entriesLen != 0)
    {
      memcpy(cmdPld + 4, pCmd->proxyTabEntry, (uint)pCmd->entriesLen);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x21, '\v', '\x01', '\0', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}
status_t zcl_group_register(u8 endpoint, u16 manuCode, u8 arrtNum, zclAttrInfo_t *attrTbl,
                            cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 4, manuCode, arrtNum, attrTbl, zcl_group_cmdHandler, cb);
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_group_add(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 groupId,
                       u8 *groupName)

{
  status_t sVar1;
  byte bVar2;
  short sVar3;
  undefined2 local_34;
  byte bStack_32;
  undefined auStack_31[17];

  local_34 = groupId;
  if (groupName == (u8 *)0x0)
  {
    bStack_32 = 0;
    sVar3 = (short)auStack_31;
  }
  else
  {
    bVar2 = *groupName;
    if (0xf < bVar2)
    {
      bVar2 = 0xf;
    }
    bStack_32 = bVar2;
    memcpy(auStack_31, groupName + 1, (uint)bVar2);
    sVar3 = (short)auStack_31 + (ushort)bVar2;
  }
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      sVar3 - (short)&local_34, (u8 *)&local_34);
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_group_addGroupRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 groupId,
                               u8 stauts)

{
  status_t sVar1;
  u8 local_14;
  undefined2 uStack_13;

  local_14 = stauts;
  uStack_13 = groupId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\0', '\x01', '\x01', disableDefaultRsp, 0, seqNo, 3, &local_14);
  return sVar1;
}
status_t zcl_group_viewGroupRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                zcl_viewGroupRsp_t *pViewGroupRsp)

{
  byte *pbVar1;
  status_t sVar2;
  byte bVar3;
  short sVar4;
  u8 local_34;
  undefined uStack_33;
  undefined uStack_32;
  byte bStack_31;
  undefined auStack_30[16];

  local_34 = pViewGroupRsp->status;
  uStack_33 = (undefined)pViewGroupRsp->groupId;
  uStack_32 = (undefined)(pViewGroupRsp->groupId >> 8);
  pbVar1 = pViewGroupRsp->pGroupName;
  if (pbVar1 == (byte *)0x0)
  {
    bStack_31 = 0;
    sVar4 = (short)auStack_30;
  }
  else
  {
    bVar3 = *pbVar1;
    if (0xf < bVar3)
    {
      bVar3 = 0xf;
    }
    bStack_31 = bVar3;
    memcpy(auStack_30, pbVar1 + 1, (uint)bVar3);
    sVar4 = (short)auStack_30 + (ushort)bVar3;
  }
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\x01', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      sVar4 - (short)&local_34, &local_34);
  return sVar2;
}
status_t zcl_group_getGroupMembershipRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 capacity,
                                         u8 groupCnt, u16 *groupList)

{
  status_t sVar1;

  *(u8 *)groupList = capacity;
  *(u8 *)((int)groupList + 1) = groupCnt;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\x02', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      (groupCnt + 1) * 2, (u8 *)groupList);
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_group_removeGroupRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 groupId,
                                  u8 stauts)

{
  status_t sVar1;
  u8 local_14;
  undefined2 uStack_13;

  local_14 = stauts;
  uStack_13 = groupId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\x03', '\x01', '\x01', disableDefaultRsp, 0, seqNo, 3, &local_14);
  return sVar1;
}
u8 zcl_group_serverCmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  u8 uVar2;

  uVar1 = (pInMsg->hdr).cmd;
  if (uVar1 == '\x01')
  {
    uVar2 = '\0';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAE();
      uVar2 = '\0';
    }
  }
  else if (uVar1 == '\0')
  {
    uVar2 = '\0';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAE();
    }
  }
  else if (uVar1 == '\x02')
  {
    uVar2 = '\0';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAE();
    }
  }
  else
  {
    uVar2 = 0x81;
    if ((uVar1 == '\x03') && (uVar2 = '\0', pInMsg->clusterAppCb != ll_reset))
    {
      FUNAAAAE();
    }
  }
  return uVar2;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked
u8 FUNAAAAE(void)

{
  u8 uVar1;
  apsdeDataInd_t *paVar2;
  u8 uVar3;
  u8 uVar4;
  u8 uVar5;
  status_t sVar6;
  aps_status_t aVar7;
  zclIncoming_t *pInMsg;
  aps_group_tbl_ent_t *paVar8;
  u16 groupAddr;
  code *in_r3;
  uint uVar9;
  uint uVar10;
  byte *pbVar11;
  char cVar12;
  uint uStack_98;
  undefined4 uStack_94;
  uint uStack_90;
  undefined4 uStack_8c;
  undefined2 uStack_88;
  undefined4 uStack_84;
  undefined4 uStack_80;
  undefined4 uStack_7c;
  undefined4 uStack_78;
  uint uStack_70;
  undefined4 uStack_6c;
  uint uStack_68;
  undefined4 uStack_64;
  undefined2 uStack_60;
  uint uStack_5c;
  undefined4 uStack_58;
  uint uStack_54;
  undefined4 uStack_50;
  undefined2 uStack_4c;
  uint uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  undefined4 uStack_3c;
  undefined2 uStack_38;
  undefined8 uStack_34;
  aps_delete_group_req_t aStack_2c;
  u16 uStack_28;
  undefined2 uStack_26;

  pInMsg = (zclIncoming_t *)(*in_r3)();
  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    uVar4 = zcl_group_serverCmdHandler(pInMsg);
  }
  else
  {
    uVar4 = 0x81;
    switch ((pInMsg->hdr).cmd)
    {
    case '\0':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      aStack_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
      aStack_2c.ep = uVar1;
      aVar7 = aps_me_group_add_req(&aStack_2c);
      uVar4 = 0x8a;
      if ((aVar7 != APS_STATUS_DUPLICATE_ENTRY) && (uVar4 = '\0', aVar7 == APS_STATUS_TABLE_FULL))
      {
        uVar4 = 0x89;
      }
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uStack_6c = 0;
        uStack_60 = 0;
        uStack_70 = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_64 = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_68 = (uint)(paVar2->indInfo).profile_id;
        zcl_group_addGroupRsp(uVar1, (epInfo_t *)&uStack_70, '\x01', (pInMsg->hdr).seqNum, aStack_2c.group_addr,
                              uVar4);
        uVar4 = 0xff;
      }
      break;
    case '\x01':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      uVar4 = '\0';
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uVar9 = (uint)pInMsg->pData[1] * 0x100 + (uint)*pInMsg->pData & 0xffff;
        uStack_34._0_4_ = (uint)uStack_34 & 0xff0000ff | uVar9 << 8;
        cVar12 = '\0';
        paVar8 = aps_group_search((u16)uVar9, uVar1);
        uStack_34._4_4_ = (uint)uStack_34._7_1_ << 0x18;
        uStack_34._0_4_ =
            ((uint)uStack_34 & 0xffffff00 | (uint)(byte) ~(~(byte)paVar8 + (byte)paVar8 + cVar12)) &
            0xffff8b;
        uStack_58 = 0;
        uStack_4c = 0;
        uStack_5c = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_50 = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_54 = (uint)(paVar2->indInfo).profile_id;
        zcl_group_viewGroupRsp(uVar1, (epInfo_t *)&uStack_5c, '\x01', (pInMsg->hdr).seqNum,
                               (zcl_viewGroupRsp_t *)&uStack_34);
        uVar4 = 0xff;
      }
      break;
    case '\x02':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      uVar4 = '\0';
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uVar4 = *pInMsg->pData;
        uStack_26 = (ushort)uStack_26._1_1_ << 8;
        if (uVar4 != '\0')
        {
          pbVar11 = pInMsg->pData + 1;
          cVar12 = uVar4 + 0xff;
          do
          {
            groupAddr = (ushort)pbVar11[1] * 0x100 + (ushort)*pbVar11;
            paVar8 = aps_group_search(groupAddr, uVar1);
            if (paVar8 != (aps_group_tbl_ent_t *)0x0)
            {
              *(u16 *)((int)&uStack_84 + (uint)(byte)uStack_26 * 2 + 2) = groupAddr;
              uVar9 = (byte)uStack_26 + 1;
              uStack_26 = uStack_26 & 0xff00 | (ushort)(byte)(uVar9 * 0x1000000 >> 0x18);
              if ((uint)APS_GROUP_TABLE_SIZE <= (uVar9 & 0xff))
                goto LAB_00006810;
            }
            if (cVar12 == '\0')
              goto LAB_00006810;
            pbVar11 = pbVar11 + 2;
            cVar12 = cVar12 + -2;
          } while (true);
        }
        aps_group_list_get((u8 *)&uStack_26, (u16 *)((int)&uStack_84 + 2));
      LAB_00006810:
        uVar3 = APS_GROUP_TABLE_SIZE;
        uStack_94 = 0;
        uStack_88 = 0;
        uStack_98 = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_8c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_90 = (uint)(paVar2->indInfo).profile_id;
        uVar4 = (pInMsg->hdr).seqNum;
        uVar5 = aps_group_entry_num_get();
        zcl_group_getGroupMembershipRsp(uVar1, (epInfo_t *)&uStack_98, '\x01', uVar4, uVar3 - uVar5, (byte)uStack_26,
                                        (u16 *)&uStack_84);
        uVar4 = 0xff;
      }
      break;
    case '\x03':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      aStack_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
      aStack_2c.ep = uVar1;
      zcl_scene_removeAllSceneEntry(uVar1, aStack_2c.group_addr, '\x01');
      aVar7 = aps_me_group_delete_req(&aStack_2c);
      uVar4 = '\0';
      if (aVar7 == APS_STATUS_INVALID_GROUP)
      {
        uVar4 = 0x8b;
      }
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uStack_44 = 0;
        uStack_38 = 0;
        uStack_48 = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_3c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_40 = (uint)(paVar2->indInfo).profile_id;
        zcl_group_removeGroupRsp(uVar1, (epInfo_t *)&uStack_48, '\x01', (pInMsg->hdr).seqNum, aStack_2c.group_addr,
                                 uVar4);
        uVar4 = 0xff;
      }
      break;
    case '\x04':
      uVar4 = (pInMsg->msg->indInfo).dst_ep;
      uStack_26 = (ushort)uStack_26._1_1_ << 8;
      uStack_84 = 0;
      uStack_80 = 0;
      uStack_7c = 0;
      uStack_78 = 0;
      aps_group_list_get((u8 *)&uStack_26, (u16 *)&uStack_84);
      uVar9 = (uint)(byte)uStack_26;
      if (uVar9 != 0)
      {
        uVar10 = 0;
        do
        {
          zcl_scene_removeAllSceneEntry(uVar4, *(u16 *)((int)&uStack_84 + uVar10 * 2), uVar9 <= uVar10);
          uVar10 = uVar10 + 1 & 0xff;
          uVar9 = (uint)(byte)uStack_26;
        } while (uVar10 < uVar9);
      }
      aps_me_group_delete_all_req(uVar4);
      uVar4 = '\0';
      break;
    case '\x05':
      paVar2 = pInMsg->msg;
      uStack_26 = 0;
      uStack_28 = 0;
      sVar6 = zcl_getAttrVal((paVar2->indInfo).dst_ep, 3, 0, &uStack_28, (u8 *)&uStack_26);
      uVar4 = '\0';
      if ((sVar6 == '\0') && (uStack_26 != 0))
      {
        aStack_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
        aStack_2c.ep = (paVar2->indInfo).dst_ep;
        aVar7 = aps_me_group_add_req(&aStack_2c);
        uVar4 = 0x8a;
        if ((aVar7 != APS_STATUS_DUPLICATE_ENTRY) && (uVar4 = '\0', aVar7 == APS_STATUS_TABLE_FULL))
        {
          uVar4 = 0x89;
        }
      }
    }
  }
  return uVar4;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_group_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  u8 uVar2;
  apsdeDataInd_t *paVar3;
  u8 uVar4;
  u8 uVar5;
  u8 uVar6;
  status_t sVar7;
  aps_status_t aVar8;
  aps_group_tbl_ent_t *paVar9;
  u16 groupAddr;
  uint uVar10;
  uint uVar11;
  byte *pbVar12;
  char cVar13;
  uint local_98;
  undefined4 uStack_94;
  uint uStack_90;
  undefined4 uStack_8c;
  undefined2 local_88;
  undefined4 local_84;
  undefined4 uStack_80;
  undefined4 uStack_7c;
  undefined4 uStack_78;
  uint local_70;
  undefined4 uStack_6c;
  uint uStack_68;
  undefined4 uStack_64;
  undefined2 local_60;
  uint local_5c;
  undefined4 uStack_58;
  uint uStack_54;
  undefined4 uStack_50;
  undefined2 local_4c;
  uint local_48;
  undefined4 uStack_44;
  uint uStack_40;
  undefined4 uStack_3c;
  undefined2 local_38;
  undefined8 local_34;
  aps_delete_group_req_t local_2c;
  u16 local_28;
  undefined2 local_26;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    uVar5 = zcl_group_serverCmdHandler(pInMsg);
  }
  else
  {
    bVar1 = (pInMsg->hdr).cmd;
    uVar5 = 0x81;
    if (bVar1 < 6)
    {
      switch (bVar1)
      {
      case 0:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        local_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
        local_2c.ep = uVar2;
        aVar8 = aps_me_group_add_req(&local_2c);
        uVar5 = 0x8a;
        if ((aVar8 != APS_STATUS_DUPLICATE_ENTRY) && (uVar5 = '\0', aVar8 == APS_STATUS_TABLE_FULL))
        {
          uVar5 = 0x89;
        }
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uStack_6c = 0;
          local_60 = 0;
          local_70 = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_64 = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_68 = (uint)(paVar3->indInfo).profile_id;
          zcl_group_addGroupRsp(uVar2, (epInfo_t *)&local_70, '\x01', (pInMsg->hdr).seqNum, local_2c.group_addr,
                                uVar5);
          uVar5 = 0xff;
        }
        break;
      case 1:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        uVar5 = '\0';
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uVar10 = (uint)pInMsg->pData[1] * 0x100 + (uint)*pInMsg->pData & 0xffff;
          local_34._0_4_ = (uint)local_34 & 0xff0000ff | uVar10 << 8;
          cVar13 = '\0';
          paVar9 = aps_group_search((u16)uVar10, uVar2);
          local_34._4_4_ = (uint)local_34._7_1_ << 0x18;
          local_34._0_4_ =
              ((uint)local_34 & 0xffffff00 | (uint)(byte) ~(~(byte)paVar9 + (byte)paVar9 + cVar13)) & 0xffff8b;
          uStack_58 = 0;
          local_4c = 0;
          local_5c = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_50 = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_54 = (uint)(paVar3->indInfo).profile_id;
          zcl_group_viewGroupRsp(uVar2, (epInfo_t *)&local_5c, '\x01', (pInMsg->hdr).seqNum,
                                 (zcl_viewGroupRsp_t *)&local_34);
          uVar5 = 0xff;
        }
        break;
      case 2:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        uVar5 = '\0';
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uVar5 = *pInMsg->pData;
          local_26 = (ushort)local_26._1_1_ << 8;
          if (uVar5 != '\0')
          {
            pbVar12 = pInMsg->pData + 1;
            cVar13 = uVar5 + 0xff;
            do
            {
              groupAddr = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
              paVar9 = aps_group_search(groupAddr, uVar2);
              if (paVar9 != (aps_group_tbl_ent_t *)0x0)
              {
                *(u16 *)((int)&local_84 + (uint)(byte)local_26 * 2 + 2) = groupAddr;
                uVar10 = (byte)local_26 + 1;
                local_26 = local_26 & 0xff00 | (ushort)(byte)(uVar10 * 0x1000000 >> 0x18);
                if ((uint)APS_GROUP_TABLE_SIZE <= (uVar10 & 0xff))
                  goto LAB_00006810;
              }
              if (cVar13 == '\0')
                goto LAB_00006810;
              pbVar12 = pbVar12 + 2;
              cVar13 = cVar13 + -2;
            } while (true);
          }
          aps_group_list_get((u8 *)&local_26, (u16 *)((int)&local_84 + 2));
        LAB_00006810:
          uVar4 = APS_GROUP_TABLE_SIZE;
          uStack_94 = 0;
          local_88 = 0;
          local_98 = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_8c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_90 = (uint)(paVar3->indInfo).profile_id;
          uVar5 = (pInMsg->hdr).seqNum;
          uVar6 = aps_group_entry_num_get();
          zcl_group_getGroupMembershipRsp(uVar2, (epInfo_t *)&local_98, '\x01', uVar5, uVar4 - uVar6, (byte)local_26,
                                          (u16 *)&local_84);
          uVar5 = 0xff;
        }
        break;
      case 3:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        local_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
        local_2c.ep = uVar2;
        zcl_scene_removeAllSceneEntry(uVar2, local_2c.group_addr, '\x01');
        aVar8 = aps_me_group_delete_req(&local_2c);
        uVar5 = '\0';
        if (aVar8 == APS_STATUS_INVALID_GROUP)
        {
          uVar5 = 0x8b;
        }
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uStack_44 = 0;
          local_38 = 0;
          local_48 = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_3c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_40 = (uint)(paVar3->indInfo).profile_id;
          zcl_group_removeGroupRsp(uVar2, (epInfo_t *)&local_48, '\x01', (pInMsg->hdr).seqNum, local_2c.group_addr,
                                   uVar5);
          uVar5 = 0xff;
        }
        break;
      case 4:
        uVar5 = (pInMsg->msg->indInfo).dst_ep;
        local_26 = (ushort)local_26._1_1_ << 8;
        local_84 = 0;
        uStack_80 = 0;
        uStack_7c = 0;
        uStack_78 = 0;
        aps_group_list_get((u8 *)&local_26, (u16 *)&local_84);
        uVar10 = (uint)(byte)local_26;
        if (uVar10 != 0)
        {
          uVar11 = 0;
          do
          {
            zcl_scene_removeAllSceneEntry(uVar5, *(u16 *)((int)&local_84 + uVar11 * 2), uVar10 <= uVar11);
            uVar11 = uVar11 + 1 & 0xff;
            uVar10 = (uint)(byte)local_26;
          } while (uVar11 < uVar10);
        }
        aps_me_group_delete_all_req(uVar5);
        uVar5 = '\0';
        break;
      case 5:
        paVar3 = pInMsg->msg;
        local_26 = 0;
        local_28 = 0;
        sVar7 = zcl_getAttrVal((paVar3->indInfo).dst_ep, 3, 0, &local_28, (u8 *)&local_26);
        uVar5 = '\0';
        if ((sVar7 == '\0') && (local_26 != 0))
        {
          local_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
          local_2c.ep = (paVar3->indInfo).dst_ep;
          aVar8 = aps_me_group_add_req(&local_2c);
          uVar5 = 0x8a;
          if ((aVar8 != APS_STATUS_DUPLICATE_ENTRY) &&
              (uVar5 = '\0', aVar8 == APS_STATUS_TABLE_FULL))
          {
            uVar5 = 0x89;
          }
        }
      }
    }
  }
  return uVar5;
}
status_t zcl_identify_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 3, manuCode, attrNum, attrTbl, zcl_identify_cmdHandler, cb);
  return sVar1;
}
status_t zcl_identify_identifyQuery(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo)

{
  status_t sVar1;

  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 3, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}
status_t zcl_identify_identifyQueryRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 timeout)

{
  status_t sVar1;
  u16 local_10[4];

  local_10[0] = timeout;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 3, '\0', '\x01', '\x01', disableDefaultRsp, 0, seqNo, 2,
                      (u8 *)local_10);
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_identify_cmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  byte bVar4;
  uint local_3c;
  uint uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  undefined2 local_2c;
  ushort local_28;
  ushort local_26;
  ushort local_24[2];
  short local_20;

  bVar4 = (pInMsg->hdr).frmCtrl.byte;
  local_24[0] = bVar4 & 8;
  if ((bVar4 & 8) == 0)
  {
    uVar1 = (pInMsg->hdr).cmd;
    if (uVar1 == '\x01')
    {
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      local_28 = local_24[0];
      local_26 = local_24[0];
      bVar4 = zcl_getAttrVal(uVar1, (paVar2->indInfo).cluster_id, 0, &local_28, (u8 *)&local_26);
      if ((bVar4 == 0) && (local_26 != 0))
      {
        local_3c = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_30 = CONCAT13((paVar2->indInfo).src_ep, CONCAT12(2, (ushort)bVar4));
        uStack_34 = (uint)(paVar2->indInfo).profile_id;
        local_2c = 4;
        if (((pInMsg->msg->indInfo).security_status & SECURITY_IN_APSLAYER) != 0)
        {
          local_2c = 5;
        }
        uStack_38 = (uint)bVar4;
        zcl_identify_identifyQueryRsp(uVar1, (epInfo_t *)&local_3c, '\x01', (pInMsg->hdr).seqNum, local_26);
        return 0xff;
      }
    }
    else if (uVar1 == '\0')
    {
      local_24[0] = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
    }
    else
    {
      if (uVar1 != '@')
        goto LAB_00006b70;
      local_24[0] = *(ushort *)pInMsg->pData;
    }
    sVar3 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      sVar3 = FUN_00006c80(&pInMsg->addrInfo, (pInMsg->hdr).cmd, local_24);
    }
  }
  else
  {
    if ((pInMsg->hdr).cmd == '\0')
    {
      local_20 = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar3 = FUN_00006c80(&pInMsg->addrInfo, 0);
      return sVar3;
    }
  LAB_00006b70:
    sVar3 = 0x81;
  }
  return sVar3;
}
status_t FUN_00006c80(void)

{
  u8 srcEp;
  status_t sVar1;
  epInfo_t *pDstEpInfo;
  u8 disableDefaultRsp;
  u8 seqNo;
  code *in_r3;

  srcEp = (*in_r3)();
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 6, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}
status_t zcl_onOff_on(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo)

{
  status_t sVar1;

  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 6, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}
status_t zcl_onOff_off(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo)

{
  status_t sVar1;

  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 6, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}
status_t zcl_pollCtrl_cmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  status_t sVar2;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    if ((pInMsg->hdr).cmd == '\0')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
  }
  else
  {
    uVar1 = (pInMsg->hdr).cmd;
    if (uVar1 == '\x01')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
    if (uVar1 == '\0')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
    if (uVar1 == '\x02')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
    if (uVar1 == '\x03')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
  }
  return 0x81;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAF(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*in_r3)();
  zcl_registerCluster(endpoint, 0x20, manuCode, attrNum, pAttrTbl, zcl_pollCtrl_cmdHandler,
                      in_stack_00000000);
  return;
}
status_t zcl_pollCtrl_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x20, manuCode, attrNum, attrTbl, zcl_pollCtrl_cmdHandler, cb);
  return sVar1;
}
status_t zcl_pollCtrl_chkInRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                               zcl_chkInRsp_t *pCheckInRsp)

{
  status_t sVar1;
  u8 local_14;
  undefined uStack_13;
  undefined uStack_12;

  local_14 = pCheckInRsp->startFastPolling;
  uStack_13 = (undefined)pCheckInRsp->fastPollTimeout;
  uStack_12 = (undefined)(pCheckInRsp->fastPollTimeout >> 8);
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 0x20, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, 3, &local_14);
  return sVar1;
}
void zcl_scene_clearEntry(zcl_sceneTable_t *pSceneTab)

{
  if (pSceneTab != (zcl_sceneTable_t *)0x0)
  {
    pSceneTab->used = '\0';
    pSceneTab->endpoint = 0xfe;
    memset(&pSceneTab->scene, 0, 0x2c);
  }
  return;
}
void zcl_scene_sceneTabClear(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    zcl_scene_clearEntry(g_zcl_sceneTab + iVar1);
    iVar1 = iVar1 + 1;
  } while (iVar1 != 8);
  return;
}
void zcl_scene_updateSceneCntAttr(u8 endpoint)

{
  status_t sVar1;
  zcl_sceneTable_t *pzVar2;
  u16 local_10;
  u8 local_d[5];

  local_10 = 0;
  local_d[0] = '\0';
  sVar1 = zcl_getAttrVal(endpoint, 5, 0, &local_10, local_d);
  if (sVar1 == '\0')
  {
    pzVar2 = g_zcl_sceneTab;
    local_d[0] = '\0';
    do
    {
      if (pzVar2->used != '\0')
      {
        local_d[0] = local_d[0] + '\x01';
      }
      pzVar2 = pzVar2 + 1;
    } while (pzVar2 != (zcl_sceneTable_t *)&g_otaCtx);
    zcl_setAttrVal(endpoint, 5, 0, local_d);
  }
  return;
}
nv_sts_t zcl_scenesSave(u8 endpoint)

{
  nv_sts_t nVar1;

  zcl_scene_updateSceneCntAttr(endpoint);
  nVar1 = zcl_sceneTable_save();
  return nVar1;
}
status_t zcl_scene_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl,
                            cluster_forAppCb_t cb)

{
  nv_sts_t nVar1;
  status_t sVar2;

  nVar1 = zcl_sceneTable_restore();
  if (nVar1 != NV_SUCC)
  {
    zcl_scene_sceneTabClear();
  }
  sVar2 = zcl_registerCluster(endpoint, 5, manuCode, attrNum, attrTbl, zcl_scene_cmdHandler, cb);
  if (sVar2 == '\0')
  {
    zcl_scene_updateSceneCntAttr(endpoint);
  }
  return sVar2;
}
u8 zcl_scene_findAllSceneByGroup(u8 endpoint, u16 groupId, u8 *sceneList)

{
  uint uVar1;
  int iVar2;
  zcl_sceneTable_t *pzVar3;

  pzVar3 = g_zcl_sceneTab;
  iVar2 = 0;
  uVar1 = 0;
  do
  {
    while (((pzVar3->used != '\0' && (pzVar3->endpoint == endpoint)) &&
            (g_zcl_sceneTab[iVar2].scene.groupId == groupId)))
    {
      sceneList[uVar1] = (pzVar3->scene).sceneId;
      uVar1 = uVar1 + 1 & 0xff;
      iVar2 = iVar2 + 1;
      pzVar3 = pzVar3 + 1;
      if (iVar2 == 8)
        goto LAB_00007046;
    }
    iVar2 = iVar2 + 1;
    pzVar3 = pzVar3 + 1;
  } while (iVar2 != 8);
LAB_00007046:
  return (u8)uVar1;
}
status_t zcl_scene_addSceneEntry(u8 endpoint, zcl_sceneEntry_t *pScene)

{
  status_t sVar1;
  zcl_sceneTable_t *pzVar2;
  int iVar3;
  zcl_sceneTable_t *pzVar4;

  pzVar2 = zcl_scene_findEntry(endpoint, pScene->groupId, pScene->sceneId);
  if (pzVar2 == (zcl_sceneTable_t *)0x0)
  {
    pzVar4 = g_zcl_sceneTab;
    iVar3 = 0;
    do
    {
      pzVar2 = g_zcl_sceneTab + iVar3;
      if (pzVar4->used == '\0')
        goto LAB_00007068;
      iVar3 = iVar3 + 1;
      pzVar4 = pzVar4 + 1;
    } while (iVar3 != 8);
    sVar1 = 0x89;
  }
  else
  {
  LAB_00007068:
    pzVar2->used = '\x01';
    pzVar2->endpoint = endpoint;
    memcpy(&pzVar2->scene, pScene, 0x2c);
    zcl_scenesSave(endpoint);
    sVar1 = '\0';
  }
  return sVar1;
}
status_t zcl_scene_removeSceneEntry(u8 endpoint, u16 groupId, u8 sceneId)

{
  zcl_sceneTable_t *pSceneTab;
  status_t sVar1;

  pSceneTab = zcl_scene_findEntry(endpoint, groupId, sceneId);
  sVar1 = 0x8b;
  if (pSceneTab != (zcl_sceneTable_t *)0x0)
  {
    zcl_scene_clearEntry(pSceneTab);
    zcl_scenesSave(endpoint);
    sVar1 = '\0';
  }
  return sVar1;
}
void zcl_scene_removeAllSceneEntry(u8 endpoint, u16 groupId, u8 updateNV)

{
  bool bVar1;
  int iVar2;
  zcl_sceneTable_t *pzVar3;

  pzVar3 = g_zcl_sceneTab;
  iVar2 = 0;
  bVar1 = false;
  do
  {
    while (((pzVar3->used != '\0' && (pzVar3->endpoint == endpoint)) &&
            (g_zcl_sceneTab[iVar2].scene.groupId == groupId)))
    {
      zcl_scene_clearEntry(g_zcl_sceneTab + iVar2);
      bVar1 = true;
      iVar2 = iVar2 + 1;
      pzVar3 = pzVar3 + 1;
      if (iVar2 == 8)
        goto LAB_0000712a;
    }
    iVar2 = iVar2 + 1;
    pzVar3 = pzVar3 + 1;
  } while (iVar2 != 8);
LAB_0000712a:
  if ((bVar1) && (updateNV != '\0'))
  {
    zcl_scenesSave(endpoint);
  }
  return;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_scene_copySceneEntry(u8 endpoint, copyScene_t *pCopyScene)

{
  byte sceneId;
  u16 uVar1;
  status_t sVar2;
  byte bVar3;
  zcl_sceneTable_t *pzVar4;
  zcl_sceneTable_t *pzVar5;
  uint uVar6;
  zcl_sceneTable_t *pzVar7;
  int iVar8;
  uint uVar9;
  uint local_30;
  undefined4 local_2c;
  undefined4 uStack_28;

  local_2c = 0;
  uStack_28 = 0;
  if ((int)((uint)pCopyScene->mode << 0x1f) < 0)
  {
    bVar3 = zcl_scene_findAllSceneByGroup(endpoint, pCopyScene->groupIdFrom, (u8 *)&local_2c);
    if (bVar3 == 0)
    {
      return 0x85;
    }
    sceneId = (byte)local_2c;
    local_30 = (uint)bVar3;
  }
  else
  {
    sceneId = pCopyScene->sceneIdFrom;
    pzVar4 = zcl_scene_findEntry(endpoint, pCopyScene->groupIdFrom, sceneId);
    if (pzVar4 == (zcl_sceneTable_t *)0x0)
    {
      return 0x85;
    }
    local_2c = local_2c & 0xffffff00 | (uint)sceneId;
    local_30 = 1;
  }
  uVar1 = pCopyScene->groupIdTo;
  uVar9 = 0;
  pzVar4 = zcl_scene_findEntry(endpoint, uVar1, (byte)local_2c);
  iVar8 = 0;
  while (true)
  {
    if (pzVar4 == (zcl_sceneTable_t *)0x0)
    {
      uVar9 = uVar9 + 1 & 0xff;
    }
    if (local_30 <= (iVar8 + 1U & 0xff))
      break;
    pzVar4 = zcl_scene_findEntry(endpoint, uVar1, *(u8 *)((int)&local_2c + iVar8 + 1));
    iVar8 = iVar8 + 1;
  }
  pzVar4 = g_zcl_sceneTab;
  uVar6 = 0;
  do
  {
    if (pzVar4->used != '\0')
    {
      uVar6 = uVar6 + 1 & 0xff;
    }
    pzVar4 = pzVar4 + 1;
  } while (pzVar4 != (zcl_sceneTable_t *)&g_otaCtx);
  sVar2 = 0x89;
  if ((int)uVar9 <= (int)(8 - uVar6))
  {
    uVar9 = 0;
    while (true)
    {
      pzVar4 = zcl_scene_findEntry(endpoint, pCopyScene->groupIdFrom, sceneId);
      if (pzVar4 != (zcl_sceneTable_t *)0x0)
      {
        if ((pCopyScene->mode & 1) == 0)
        {
          sceneId = pCopyScene->sceneIdTo;
        }
        pzVar5 = zcl_scene_findEntry(endpoint, pCopyScene->groupIdTo, sceneId);
        if (pzVar5 == (zcl_sceneTable_t *)0x0)
        {
          pzVar7 = g_zcl_sceneTab;
          iVar8 = 0;
          while (pzVar5 = g_zcl_sceneTab + iVar8, pzVar7->used != '\0')
          {
            iVar8 = iVar8 + 1;
            pzVar7 = pzVar7 + 1;
            if (iVar8 == 8)
            {
              return 0x89;
            }
          }
        }
        pzVar5->used = '\x01';
        pzVar5->endpoint = endpoint;
        memcpy(&pzVar5->scene, &pzVar4->scene, 0x2c);
        (pzVar5->scene).sceneId = sceneId;
        uVar1 = pCopyScene->groupIdTo;
        *(char *)&(pzVar5->scene).groupId = (char)uVar1;
        *(char *)((int)&(pzVar5->scene).groupId + 1) = (char)(uVar1 >> 8);
      }
      if (local_30 <= (uVar9 + 1 & 0xff))
        break;
      sceneId = *(byte *)((int)&local_2c + uVar9 + 1);
      uVar9 = uVar9 + 1;
    }
    zcl_scenesSave(endpoint);
    sVar2 = '\0';
  }
  return sVar2;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_scene_sceneRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 cmdId,
                            u8 status, u16 groupId, u8 sceneId)

{
  status_t sVar1;
  short sVar2;
  u8 local_18;
  undefined2 uStack_17;
  u8 uStack_15;
  undefined auStack_14[4];

  local_18 = status;
  sVar2 = (short)&uStack_15;
  if (cmdId != '\x03')
  {
    uStack_15 = sceneId;
    sVar2 = (short)auStack_14;
  }
  uStack_17 = groupId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 5, cmdId, '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      sVar2 - (short)&local_18, &local_18);
  return sVar1;
}
status_t zcl_scene_viewSceneRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 cmdId, u8 status,
                                u16 groupId, u8 sceneId, zcl_sceneEntry_t *pEntry)

{
  byte bVar1;
  status_t sVar2;
  u16 uVar3;
  u8 *cmdPld;
  short sVar4;
  u8 *out;

  if (status == '\0')
  {
    if (pEntry == (zcl_sceneEntry_t *)0x0)
    {
      return '\x01';
    }
    uVar3 = (u16)(byte)(((uint)pEntry->sceneName[0] + (uint)pEntry->extFieldLen) * 0x1000000 +
                            0x7000000 >>
                        0x18);
  }
  else
  {
    uVar3 = 4;
  }
  cmdPld = ev_buf_allocate(uVar3);
  sVar2 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = status;
    *(u16 *)(cmdPld + 1) = groupId;
    cmdPld[3] = sceneId;
    sVar4 = (short)cmdPld + 4;
    if (status == '\0')
    {
      uVar3 = pEntry->transTime;
      if (cmdId == 'A')
      {
        uVar3 = uVar3 * 10 + pEntry->transTime100ms;
      }
      cmdPld[4] = (u8)uVar3;
      cmdPld[5] = (u8)(uVar3 >> 8);
      cmdPld[6] = pEntry->sceneName[0];
      out = cmdPld + 7;
      memcpy(out, pEntry->sceneName + 1, (uint)pEntry->sceneName[0]);
      bVar1 = pEntry->sceneName[0];
      memcpy(out + bVar1, pEntry->extField, (uint)pEntry->extFieldLen);
      sVar4 = (short)(out + bVar1) + (ushort)pEntry->extFieldLen;
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 5, cmdId, '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                sVar4 - (short)cmdPld, cmdPld);
    ev_buf_free(cmdPld);
    sVar2 = '\0';
  }
  return sVar2;
}
status_t zcl_scene_getSceneMembershipRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                         getSceneMemRsp_t *pGetSceneMembershipRsp)

{
  status_t sVar1;
  u16 size;
  u8 *cmdPld;
  short sVar2;

  size = 4;
  if (pGetSceneMembershipRsp->status == '\0')
  {
    size = pGetSceneMembershipRsp->sceneCnt + 5 & 0xff;
  }
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = pGetSceneMembershipRsp->status;
    cmdPld[1] = pGetSceneMembershipRsp->capacity;
    cmdPld[2] = *(u8 *)&pGetSceneMembershipRsp->groupId;
    cmdPld[3] = *(u8 *)((int)&pGetSceneMembershipRsp->groupId + 1);
    sVar2 = (short)cmdPld + 4;
    if (pGetSceneMembershipRsp->status == '\0')
    {
      cmdPld[4] = pGetSceneMembershipRsp->sceneCnt;
      memcpy(cmdPld + 5, pGetSceneMembershipRsp->sceneList, (uint)pGetSceneMembershipRsp->sceneCnt);
      sVar2 = (ushort)pGetSceneMembershipRsp->sceneCnt + (short)(cmdPld + 5);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 5, '\x06', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                sVar2 - (short)cmdPld, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Restarted to delay deadcode elimination for space: stack
status_t zcl_scene_cmdHandler(zclIncoming_t *pInMsg)

{
  apsdeDataInd_t *paVar1;
  u8 *puVar2;
  ushort uVar3;
  byte bVar4;
  status_t sVar5;
  u16 uVar6;
  undefined2 uVar7;
  aps_group_tbl_ent_t *paVar8;
  zcl_sceneTable_t *pzVar9;
  zcl_sceneTable_t *pzVar10;
  char cVar11;
  u16 groupAddr;
  epInfo_t *pDstEpInfo;
  byte *pbVar12;
  byte *extraout_r1;
  zcl_sceneEntry_t *pEntry;
  int iVar13;
  uint uVar14;
  u8 uVar15;
  byte *pbVar16;
  uint extraout_r3;
  int iVar17;
  ushort *val;
  uint uVar18;
  u8 uVar19;
  ushort unaff_r8;
  u8 cmdId;
  uint local_128;
  undefined4 uStack_124;
  uint uStack_120;
  undefined4 uStack_11c;
  undefined4 uStack_118;
  uint uStack_114;
  undefined4 uStack_110;
  undefined4 uStack_10c;
  undefined4 uStack_108;
  undefined4 uStack_104;
  undefined4 uStack_100;
  undefined local_fc;
  undefined auStack_f8[20];
  undefined uStack_e4;
  u16 uStack_e3;
  u8 uStack_e1;
  undefined4 uStack_e0;
  undefined4 uStack_dc;
  undefined4 uStack_d8;
  undefined4 uStack_d4;
  undefined4 uStack_d0;
  uint local_cc;
  undefined4 uStack_c8;
  uint uStack_c4;
  undefined4 uStack_c0;
  undefined2 local_bc;
  uint local_b8;
  undefined4 uStack_b4;
  uint uStack_b0;
  undefined4 uStack_ac;
  undefined2 local_a8;
  uint local_a4;
  undefined4 uStack_a0;
  uint uStack_9c;
  undefined4 uStack_98;
  undefined2 local_94;
  uint local_90;
  undefined4 uStack_8c;
  uint uStack_88;
  undefined4 uStack_84;
  undefined2 local_80;
  uint local_7c;
  undefined4 uStack_78;
  uint uStack_74;
  undefined4 uStack_70;
  undefined2 local_6c;
  uint local_68;
  undefined4 uStack_64;
  uint uStack_60;
  undefined4 uStack_5c;
  undefined2 local_58;
  uint uStack_54;
  undefined4 uStack_50;
  uint uStack_4c;
  undefined4 uStack_48;
  undefined2 uStack_44;
  undefined local_40[12];
  undefined8 local_34;
  ushort local_2c;
  u16 local_2a;
  undefined2 local_28;
  byte local_25;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    val = (ushort *)pInMsg->pData;
    local_128 = 0;
    uStack_124 = 0;
    uStack_120 = 0;
    uStack_11c = 0;
    uStack_118 = 0;
    uStack_114 = 0;
    uStack_110 = 0;
    uStack_10c = 0;
    uStack_108 = 0;
    uStack_104 = 0;
    uStack_100 = 0;
    local_fc = 0;
    switch ((pInMsg->hdr).cmd)
    {
    case '\0':
    case '\x02':
    case '\x04':
    case '@':
    case 'B':
      local_128 = (uint) * (byte *)val;
      local_128 = local_128 |
                  ((uint) * (byte *)(val + 1) * 0x100 + (uint) * (byte *)((int)val + 1)) * 0x10000 >> 8 | (uint) * (byte *)((int)val + 3) << 0x18;
      break;
    case '\x01':
    case 'A':
      unaff_r8 = pInMsg->dataLen;
      local_128 = (uint) * (byte *)val |
                  ((uint) * (byte *)(val + 1) * 0x100 + (uint) * (byte *)((int)val + 1)) * 0x10000 >> 8 | (uint) * (byte *)((int)val + 3) << 0x18;
      if (*(byte *)val != 0)
      {
        FUN_000075b2();
      }
      uStack_114 = uStack_114 & 0xffff0000 |
                   (uint)(ushort)((ushort) * (byte *)((int)val + 5) * 0x100 +
                                  (ushort) * (byte *)(val + 2));
      uVar18 = (uint) * (byte *)(val + 3);
      uVar14 = uVar18;
      if (0xf < uVar18)
      {
        uVar14 = 0xf;
      }
      uStack_124 = uStack_124 & 0xffffff00 | uVar14;
      memcpy((void *)((int)&uStack_124 + 1), (byte *)((int)val + 7), uVar14);
      pbVar12 = (byte *)((int)val + 7) + uVar18;
      pbVar16 = (byte *)((int)val + ((uint)unaff_r8 - (int)pbVar12));
      uVar14 = (uint)pbVar16 & 0xff;
      uStack_110 = uStack_110 & 0xffffff00 | (uint)pbVar16 & 0xff;
      if (uVar14 == 0)
      {
        FUN_000075b2();
        pbVar12 = extraout_r1;
        uVar14 = extraout_r3;
      }
      if (0x14 < uVar14)
      {
        uVar14 = 0x14;
      }
      uStack_110 = uStack_110 & 0xffffff00 | uVar14 & 0xff;
      memcpy((void *)((int)&uStack_110 + 1), pbVar12, uVar14 & 0xff);
      FUN_000075b2();
    case '\x03':
      uVar19 = (u8)&local_128;
      local_128 = local_128 & 0xff000000 | (uint) * (byte *)val |
                  ((uint) * (byte *)(val + 1) * 0x100 + (uint) * (byte *)((int)val + 1)) * 0x10000 >> 8;
      FUN_000075b2();
    LAB_00007e28:
      *val = unaff_r8;
      zcl_setAttrVal(uVar19, 5, 2, (u8 *)val);
      goto LAB_00007aea;
    default:
      goto switchD_0000758e_caseD_5;
    case '\x06':
      local_128 = CONCAT22((ushort) * (byte *)((int)val + 3) * 0x100 + (ushort) * (byte *)(val + 1), *val);
      if (*(byte *)val == 0)
      {
        uStack_124 = (uint) * (byte *)(val + 2);
        uStack_124 = (int)(byte *)((int)val + 5) * 0x100 | uStack_124;
        uStack_120 = (uint)(byte *)((int)val + 5) >> 0x18;
      }
    }
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\0';
    }
    FUNAAAAG();
    return '\0';
  }
  uVar19 = (pInMsg->hdr).cmd;
  switch (uVar19)
  {
  case '\0':
  case '@':
    paVar1 = pInMsg->msg;
    uVar15 = (paVar1->indInfo).dst_ep;
    auStack_f8._4_4_ = 0;
    auStack_f8._8_4_ = 0;
    auStack_f8._12_4_ = 0;
    uStack_e3 = 0;
    uStack_e1 = '\0';
    uStack_e0 = 0;
    uStack_dc = 0;
    uStack_d8 = 0;
    uStack_d4 = 0;
    uStack_d0 = 0;
    pbVar12 = pInMsg->pData;
    uVar3 = pInMsg->dataLen;
    auStack_f8._0_4_ = (uint)CONCAT12(pbVar12[2], (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12);
    auStack_f8._16_4_ = (uint)pbVar12[3] << 0x18;
    uStack_e4 = (undefined)((uint)pbVar12[4] * 0x100 + (uint)pbVar12[3] >> 8);
    uVar14 = (uint)pbVar12[5];
    pbVar16 = pbVar12 + 6;
    local_25 = 0;
    local_28 = 0;
    zcl_getAttrVal(uVar15, 5, 4, &local_28, &local_25);
    if (local_25 != 0)
    {
      uVar18 = uVar14;
      if (0xf < uVar14)
      {
        uVar18 = 0xf;
      }
      auStack_f8._0_4_ = auStack_f8._0_4_ & 0xffffff | uVar18 << 0x18;
      memcpy(auStack_f8 + 4, pbVar16, uVar18);
    }
    uVar18 = (uint)(pbVar12 + ((uint)uVar3 - (int)(pbVar16 + uVar14))) & 0xff;
    uStack_e1 = (u8)((uint)((int)(pbVar12 + ((uint)uVar3 - (int)(pbVar16 + uVar14))) * 0x1000000) >>
                     0x18);
    if (uVar18 != 0)
    {
      if (0x14 < uVar18)
      {
        uVar18 = 0x14;
      }
      uStack_e1 = (u8)uVar18;
      memcpy(&uStack_e0, pbVar16 + uVar14, uVar18);
    }
    if (uVar19 == '@')
    {
      uVar7 = CONCAT11(uStack_e4, auStack_f8[19]);
      uVar6 = FUN_00001628(uVar7, 10);
      uVar14 = CONCAT13(uStack_e1, CONCAT21(uStack_e3, uStack_e4)) & 0xff0000ff;
      uStack_e4 = (undefined)uVar14;
      uStack_e1 = (u8)(uVar14 >> 0x18);
      uStack_e3 = uVar6;
      uVar7 = FUN_0000162c(uVar7, 10);
      auStack_f8._16_4_ = auStack_f8._16_4_ & 0xffffff | (uint)(byte)uVar7 << 0x18;
      uStack_e4 = (undefined)((ushort)uVar7 >> 8);
    }
    if (auStack_f8._0_2_ == 0)
    {
    LAB_0000777e:
      local_40[0] = zcl_scene_addSceneEntry(uVar15, (zcl_sceneEntry_t *)auStack_f8);
    }
    else
    {
      paVar8 = aps_group_search(auStack_f8._0_2_, uVar15);
      local_40[0] = 0x85;
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
        goto LAB_0000777e;
    }
    if (((paVar1->indInfo).dst_addr < 0xfffc) && ((paVar1->indInfo).dst_addr_mode != '\x01'))
    {
      uStack_50 = 0;
      uStack_44 = 0;
      uStack_54 = (uint)(paVar1->indInfo).field_10.src_short_addr;
      uStack_48 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
      uStack_4c = (uint)(paVar1->indInfo).profile_id;
      zcl_scene_sceneRsp(uVar15, (epInfo_t *)&uStack_54, '\x01', (pInMsg->hdr).seqNum, uVar19,
                         local_40[0], (u16)auStack_f8._0_4_, auStack_f8[2]);
      local_40[0] = 0xff;
    }
    break;
  case '\x01':
  case 'A':
    paVar1 = pInMsg->msg;
    pbVar12 = pInMsg->pData;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    uVar15 = (paVar1->indInfo).dst_ep;
    bVar4 = pbVar12[2];
    pzVar9 = zcl_scene_findEntry(uVar15, uVar6, bVar4);
    local_40[0] = '\0';
    if (((pzVar9 == (zcl_sceneTable_t *)0x0) && (local_40[0] = 0x8b, uVar6 != 0)) &&
        (paVar8 = aps_group_search(uVar6, uVar15), paVar8 == (aps_group_tbl_ent_t *)0x0))
    {
      local_40[0] = 0x85;
    }
    if (((paVar1->indInfo).dst_addr < 0xfffc) && ((paVar1->indInfo).dst_addr_mode != '\x01'))
    {
      uStack_64 = 0;
      local_58 = 0;
      local_68 = (uint)(paVar1->indInfo).field_10.src_short_addr;
      uStack_5c = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
      uStack_60 = (uint)(paVar1->indInfo).profile_id;
      pEntry = (zcl_sceneEntry_t *)0x0;
      if (local_40[0] == '\0')
      {
        pEntry = &pzVar9->scene;
      }
      zcl_scene_viewSceneRsp(uVar15, (epInfo_t *)&local_68, '\x01', (pInMsg->hdr).seqNum, uVar19, local_40[0], uVar6,
                             bVar4, pEntry);
      local_40[0] = 0xff;
    }
    break;
  case '\x02':
    paVar1 = pInMsg->msg;
    pbVar12 = pInMsg->pData;
    uVar19 = (paVar1->indInfo).dst_ep;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    bVar4 = pbVar12[2];
    sVar5 = zcl_scene_removeSceneEntry(uVar19, uVar6, bVar4);
    if ((sVar5 == 0x8b) &&
        (paVar8 = aps_group_search(uVar6, uVar19), paVar8 == (aps_group_tbl_ent_t *)0x0))
    {
      sVar5 = 0x85;
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_7c;
    uStack_78 = 0;
    local_6c = 0;
    local_7c = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_70 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_74 = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = '\x02';
    goto LAB_000076b2;
  case '\x03':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    uVar6 = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
    if (uVar6 == 0)
    {
    LAB_00007ca4:
      zcl_scene_removeAllSceneEntry(uVar19, uVar6, '\x01');
      sVar5 = '\0';
    }
    else
    {
      paVar8 = aps_group_search(uVar6, uVar19);
      sVar5 = 0x85;
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
        goto LAB_00007ca4;
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_90;
    bVar4 = 0;
    uStack_8c = 0;
    local_80 = 0;
    local_90 = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_84 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_88 = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = '\x03';
    goto LAB_000076b2;
  case '\x04':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    pbVar12 = pInMsg->pData;
    uVar14 = (uint)pbVar12[1] * 0x100 + (uint)*pbVar12;
    iVar13 = uVar14 * 0x10000;
    uVar14 = uVar14 & 0xffff;
    uVar6 = (u16)uVar14;
    bVar4 = pbVar12[2];
    groupAddr = (u16)((uint)iVar13 >> 0x10);
    if (uVar14 == 0)
    {
    LAB_00007b62:
      pzVar9 = zcl_scene_findEntry(uVar19, groupAddr, bVar4);
      if (pzVar9 == (zcl_sceneTable_t *)0x0)
      {
        pzVar10 = g_zcl_sceneTab;
        iVar17 = 0;
        do
        {
          pzVar9 = g_zcl_sceneTab + iVar17;
          if (pzVar10->used == '\0')
            goto LAB_00007b72;
          iVar17 = iVar17 + 1;
          pzVar10 = pzVar10 + 1;
        } while (iVar17 != 8);
        sVar5 = 0x89;
      }
      else
      {
      LAB_00007b72:
        sVar5 = '\x01';
        if (pInMsg->clusterAppCb != ll_reset)
        {
          FUNAAAAG();
          pzVar9->used = '\x01';
          pzVar9->endpoint = uVar19;
          *(char *)&(pzVar9->scene).groupId = (char)((uint)iVar13 >> 0x10);
          *(char *)((int)&(pzVar9->scene).groupId + 1) = (char)(uVar14 >> 8);
          (pzVar9->scene).sceneId = bVar4;
          local_2c = 0;
          local_25 = 0;
          sVar5 = zcl_getAttrVal(uVar19, 5, 1, &local_2c, &local_25);
          if (sVar5 == '\0')
          {
            local_25 = bVar4;
            zcl_setAttrVal(uVar19, 5, 1, &local_25);
          }
          local_2a = 0;
          sVar5 = zcl_getAttrVal(uVar19, 5, 2, &local_2c, (u8 *)&local_2a);
          if (sVar5 == '\0')
          {
            local_2a = groupAddr;
            zcl_setAttrVal(uVar19, 5, 2, (u8 *)&local_2a);
          }
          local_28 = local_28 & 0xff00;
          sVar5 = zcl_getAttrVal(uVar19, 5, 3, &local_2c, (u8 *)&local_28);
          if (sVar5 == '\0')
          {
            local_28 = CONCAT11(local_28._1_1_, 1);
            zcl_setAttrVal(uVar19, 5, 3, (u8 *)&local_28);
          }
          zcl_scenesSave(uVar19);
          sVar5 = '\0';
        }
      }
    }
    else
    {
      paVar8 = aps_group_search(groupAddr, uVar19);
      sVar5 = 0x85;
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
        goto LAB_00007b62;
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_a4;
    uStack_a0 = 0;
    local_94 = 0;
    local_a4 = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_98 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_9c = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = '\x04';
    goto LAB_000076b2;
  case '\x05':
    pbVar12 = pInMsg->pData;
    unaff_r8 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    bVar4 = pbVar12[2];
    uVar19 = (pInMsg->msg->indInfo).dst_ep;
    pzVar9 = zcl_scene_findEntry(uVar19, unaff_r8, bVar4);
    if (pzVar9 == (zcl_sceneTable_t *)0x0)
    {
      return '\0';
    }
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\0';
    }
    FUNAAAAG();
    pInMsg = (zclIncoming_t *)&local_2a;
    local_2a = 0;
    local_28 = local_28 & 0xff00;
    sVar5 = zcl_getAttrVal(uVar19, 5, 1, (u16 *)pInMsg, (u8 *)&local_28);
    if (sVar5 == '\0')
    {
      local_28 = local_28 & 0xff00 | (ushort)bVar4;
      zcl_setAttrVal(uVar19, 5, 1, (u8 *)&local_28);
    }
    val = &local_2c;
    local_2c = 0;
    sVar5 = zcl_getAttrVal(uVar19, 5, 2, (u16 *)pInMsg, (u8 *)val);
    if (sVar5 == '\0')
      goto LAB_00007e28;
  LAB_00007aea:
    local_25 = 0;
    sVar5 = zcl_getAttrVal(uVar19, 5, 3, (u16 *)pInMsg, &local_25);
    local_40[0] = '\0';
    if (sVar5 == '\0')
    {
      local_25 = 1;
      zcl_setAttrVal(uVar19, 5, 3, &local_25);
    }
    break;
  case '\x06':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    local_40._2_2_ = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
    local_34._0_4_ = 0;
    local_34._4_4_ = 0;
    if ((local_40._2_2_ == 0) ||
        (paVar8 = aps_group_search(local_40._2_2_, uVar19), paVar8 != (aps_group_tbl_ent_t *)0x0))
    {
      bVar4 = zcl_scene_findAllSceneByGroup(uVar19, local_40._2_2_, (u8 *)&local_34);
      local_40[0] = '\0';
    }
    else
    {
      bVar4 = 0;
      local_40[0] = 0x85;
    }
    if (((paVar1->indInfo).dst_addr < 0xfffc) && ((paVar1->indInfo).dst_addr_mode != '\x01'))
    {
      uStack_b4 = 0;
      local_a8 = 0;
      pzVar9 = g_zcl_sceneTab;
      cVar11 = '\0';
      do
      {
        if (pzVar9->used != '\0')
        {
          cVar11 = cVar11 + '\x01';
        }
        pzVar9 = pzVar9 + 1;
      } while (pzVar9 != (zcl_sceneTable_t *)&g_otaCtx);
      local_40[1] = '\b' - cVar11;
      local_40._4_4_ = (int)&local_34 * 0x100 | (uint)bVar4;
      local_40[8] = (undefined)((uint)&local_34 >> 0x18);
      local_b8 = (uint)(paVar1->indInfo).field_10.src_short_addr;
      uStack_ac = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
      uStack_b0 = (uint)(paVar1->indInfo).profile_id;
      zcl_scene_getSceneMembershipRsp(uVar19, (epInfo_t *)&local_b8, '\x01', (pInMsg->hdr).seqNum,
                                      (getSceneMemRsp_t *)local_40);
      local_40[0] = 0xff;
    }
    break;
  default:
  switchD_0000758e_caseD_5:
    local_40[0] = 0x81;
    break;
  case 'B':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    puVar2 = pInMsg->pData;
    uVar6 = (ushort)puVar2[2] * 0x100 + (ushort)puVar2[1];
    local_34._0_4_ = CONCAT13(puVar2[3], CONCAT21(uVar6, *puVar2));
    local_34._4_3_ = CONCAT12(puVar2[6], (ushort)puVar2[5] * 0x100 + (ushort)puVar2[4]);
    local_34._4_4_ = local_34._4_4_ & 0xff000000 | (uint)local_34._4_3_;
    paVar8 = aps_group_search(uVar6, uVar19);
    sVar5 = 0x85;
    if (paVar8 != (aps_group_tbl_ent_t *)0x0)
    {
      paVar8 = aps_group_search(local_34._4_2_, uVar19);
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
      {
        sVar5 = zcl_scene_copySceneEntry(uVar19, (copyScene_t *)&local_34);
      }
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_cc;
    uStack_c8 = 0;
    local_bc = 0;
    local_cc = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_c0 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_c4 = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = 'B';
    uVar6 = (u16)((uint)(undefined4)local_34 >> 8);
    bVar4 = (byte)((uint)(undefined4)local_34 >> 0x18);
  LAB_000076b2:
    zcl_scene_sceneRsp(uVar19, pDstEpInfo, '\x01', uVar15, cmdId, sVar5, uVar6, bVar4);
    local_40[0] = 0xff;
  }
  return local_40[0];
}
undefined4 FUN_000075b2(void)

{
  int *unaff_r4;

  if (*unaff_r4 != 0)
  {
    FUNAAAAG();
  }
  return 0;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAG(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*in_r3)();
  zcl_registerCluster(endpoint, 0x101, manuCode, attrNum, pAttrTbl, zcl_doorLock_cmdHandler,
                      in_stack_00000000);
  return;
}
status_t zcl_doorLock_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x101, manuCode, attrNum, attrTbl, zcl_doorLock_cmdHandler, cb);
  return sVar1;
}
status_t zcl_doorLock_doorLockRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 cmdId,
                                  status_t rspStatus)

{
  status_t sVar1;
  status_t local_14[8];

  local_14[0] = rspStatus;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 0x101, cmdId, '\x01', '\x01', disableDefaultRsp, 0, seqNo, 1,
                      local_14);
  return sVar1;
}
// WARNING: Could not reconcile some variable overlaps
status_t zcl_doorLock_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  uint local_3c;
  uint uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  undefined2 local_2c;
  u8 *puStack_28;
  undefined uStack_24;
  u8 local_20;

  bVar1 = (pInMsg->hdr).frmCtrl.byte;
  uStack_38 = bVar1 & 8;
  if ((bVar1 & 8) == 0)
  {
    sVar3 = 0x81;
    if ((pInMsg->hdr).cmd < 3)
    {
      paVar2 = pInMsg->msg;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        uStack_24 = *(undefined *)&pInMsg->dataLen;
        puStack_28 = pInMsg->pData;
        sVar3 = FUN_000080ae(&pInMsg->addrInfo);
        local_2c = (undefined2)uStack_38;
        local_3c = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_30 = CONCAT13((paVar2->indInfo).src_ep, CONCAT12(2, local_2c));
        uStack_34 = (uint)(paVar2->indInfo).profile_id;
        zcl_doorLock_doorLockRsp((paVar2->indInfo).dst_ep, (epInfo_t *)&local_3c, '\x01', (pInMsg->hdr).seqNum,
                                 (pInMsg->hdr).cmd, sVar3);
        sVar3 = 0xff;
      }
    }
  }
  else
  {
    sVar3 = 0x81;
    if ((pInMsg->hdr).cmd < 3)
    {
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_20 = *pInMsg->pData;
        FUN_000080ac(&pInMsg->addrInfo);
        sVar3 = '\0';
      }
    }
  }
  return sVar3;
}
void FUN_000080ac(void)

{
  code *in_r3;
  code *unaff_sl;

  (*in_r3)();
  (*unaff_sl)();
  nv_flashWriteNew('\x01', 2, '\x04', 0x55, (u8 *)&ss_ib);
  return;
}
void FUN_000080ae(void)

{
  code *unaff_sl;

  (*unaff_sl)();
  nv_flashWriteNew('\x01', 2, '\x04', 0x55, (u8 *)&ss_ib);
  return;
}
void zdo_ssInfoSaveToFlash(void)

{
  nv_flashWriteNew('\x01', 2, '\x04', 0x55, (u8 *)&ss_ib);
  return;
}
u8 zdo_ssInfoInit(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashReadNew('\x01', '\x02', '\x04', 0x55, (u8 *)&ss_ib);
  ss_ib.keyPairSetNew._0_1_ = 0;
  ss_ib.keyPairSetNew._1_1_ = 0x80;
  ss_ib.keyPairSetNew._2_1_ = 0x84;
  ss_ib.keyPairSetNew._3_1_ = 0;
  return nVar1;
}
u8 zdo_ssInfoKeyGet(void)

{
  nv_sts_t nVar1;
  ss_info_base_t ss;

  nVar1 = nv_flashReadNew('\x01', '\x02', '\x04', 0x55, (u8 *)&ss);
  if (nVar1 == NV_SUCC)
  {
    nVar1 = (nv_sts_t)(((uint)ss._62_1_ << 0x1a) >> 0x1e);
  }
  return nVar1;
}
s32 ota_imageBlockWaitCb(void *arg)

{
  if (zcl_attr_imageUpgradeStatus == '\x01')
  {
    tl_zbTaskPost(sendImageBlockReq, (void *)0x0);
  }
  return -2;
}
s32 ota_sendImageBlockReqDelay(void *arg)

{
  tl_zbTaskPost(sendImageBlockReq, (void *)0x0);
  return -2;
}
void ota_ieeeAddrReq(u16 dstAddr)

{
  zdo_ieee_addr_req_t local_c;
  u8 local_5[5];

  local_5[0] = '\0';
  local_c.req_type = ZDO_ADDR_REQ_SINGLE_REQ;
  local_c.start_index = '\0';
  local_c.nwk_addr_interest = dstAddr;
  zb_zdoIeeeAddrReq(dstAddr, &local_c, local_5, ota_ieeeAddrRspCb);
  return;
}
void ota_ieeeAddrReqSend(void *arg)

{
  ota_ieeeAddrReq(g_otaCtx.otaServerEpInfo.dstAddr.shortAddr);
  otaTimer.cb = ota_ieeeAddrRspWait;
  otaTimer.data = (void *)0x0;
  ev_on_timer(&otaTimer, 2000);
  return;
}
void ota_saveUpdateInfo2NV(void *arg)

{
  int iVar1;
  uint uVar2;

  ota_saveUpdateInfo2NV::cnt = ota_saveUpdateInfo2NV::cnt + 1;
  uVar2 = (uint)ota_saveUpdateInfo2NV::cnt;
  iVar1 = FUN_0000162c(g_otaCtx.downloadImageSize, &DAT_000014a0);
  if ((iVar1 + 1U <= uVar2) || (zcl_attr_imageUpgradeStatus == '\x02'))
  {
    ota_saveUpdateInfo2NV::cnt = '\0';
    nv_flashWriteNew('\x01', 5, '\n', 0x15, (u8 *)&otaClientInfo);
  }
  return;
}
u8 mcuBootAddrGet(void)

{
  u8 local_9[5];

  local_9[0] = '\0';
  flash_read(8, 1, local_9);
  return '\x01' - (local_9[0] == 'K');
}
u8 ota_loadImageInfo(ota_hdrFields_t *oh)

{
  bool bVar1;
  ota_hdrFields_t local_50;

  if (oh == (ota_hdrFields_t *)0x0)
  {
    flash_read(((uint)mcuBootAddr + ~(uint)mcuBootAddr + 1) * 0x40000, 0x45, (u8 *)&local_50);
    oh = &local_50;
  }
  bVar1 = oh->otaUpgradeFileID != 0xbeef11e;
  if (!bVar1)
  {
    otaServerBinInfo.fileVer = oh->fileVer;
    otaServerBinInfo.imageType = oh->imageType;
    otaServerBinInfo.manufacturerCode = oh->manufacturerCode;
    otaServerBinInfo.totalImageSize = oh->totalImageSize;
  }
  return bVar1;
}
void ota_clientInfoRecover(void)

{
  nv_sts_t nVar1;
  int *buf;
  int iVar2;

  buf = (int *)ev_buf_allocate(0x51);
  if (buf == (int *)0x0)
  {
    return;
  }
  nVar1 = nv_flashReadNew('\x01', '\x05', '\t', 0x51, (u8 *)buf);
  if (nVar1 == NV_SUCC)
  {
    if (*buf == 0xbeef11e)
    {
      nVar1 = nv_flashReadNew('\x01', '\x05', '\n', 0x15, (u8 *)&otaClientInfo);
      if (nVar1 != NV_SUCC)
        goto LAB_00008304;
      zcl_attr_fileOffset = otaClientInfo.offset;
      zcl_attr_downloadFileVer = *(u32 *)((int)buf + 0xe);
      zcl_attr_downloadZigbeeStackVer = *(u16 *)((int)buf + 0x12);
      zcl_attr_manufacturerID = *(u16 *)((int)buf + 10);
      zcl_attr_imageTypeID = *(u16 *)(buf + 3);
      g_otaCtx.downloadImageSize = buf[0xd];
    }
    iVar2 = memcmp((void *)((int)buf + 0x45), &g_invalid_addr, 8);
    if (iVar2 != 0)
    {
      memcpy(zcl_attr_upgradeServerID, (void *)((int)buf + 0x45), 8);
      g_otaCtx.otaServerEpInfo.profileId = *(u16 *)((int)buf + 0x4d);
      g_otaCtx.otaServerEpInfo.dstEp = *(u8 *)((int)buf + 0x4f);
      g_otaCtx.otaServerEpInfo.txOptions = *(aps_tx_options *)(buf + 0x14);
    }
  }
LAB_00008304:
  ev_buf_free((u8 *)buf);
  return;
}
void ota_init(ota_type_e type, af_simple_descriptor_t *simpleDesc, ota_preamble_t *otaPreamble,
              ota_callBack_t *cb)

{
  otaCb = cb;
  mcuBootAddr = mcuBootAddrGet();
  g_otaCtx.pOtaPreamble = (ota_preamble_t *)0x0;
  g_otaCtx.downloadImageSize = 0;
  g_otaCtx.otaServerEpInfo.dstAddr._0_4_ = 0;
  g_otaCtx.otaServerEpInfo.dstAddr._4_4_ = 0;
  g_otaCtx.otaServerEpInfo._8_4_ = 0;
  g_otaCtx.otaServerEpInfo._12_4_ = 0;
  g_otaCtx._28_4_ = 0;
  otaClientInfo.offset = 0;
  otaClientInfo.crcValue = 0;
  otaClientInfo.otaElementPos = 0;
  otaClientInfo.otaElementLen = 0;
  otaClientInfo._16_4_ = 0;
  otaClientInfo.clientOtaFlg = '\0';
  otaServerBinInfo.fileVer = 0;
  otaServerBinInfo.totalImageSize = 0;
  otaServerBinInfo._8_4_ = 0;
  g_otaCtx.isOtaServer = type + ~OTA_TYPE_SERVER + ~(type + ~OTA_TYPE_SERVER);
  zcl_attr_currZigbeeStackVer = 2;
  zcl_attr_imageUpgradeStatus = '\0';
  g_otaCtx.simpleDesc = simpleDesc;
  zcl_register(simpleDesc->endpoint, OTA_CB_CLUSTER_NUM, g_otaClusterList);
  if (g_otaCtx.isOtaServer == '\0')
  {
    zcl_attr_currFileVer = otaPreamble->fileVer;
    zcl_attr_manufacturerID = otaPreamble->manufacturerCode;
    otaClientInfo.clientOtaFlg = '\0';
    otaClientInfo.crcValue = 0xfffffffe;
    g_otaCtx.pOtaPreamble = otaPreamble;
    ota_clientInfoRecover();
  }
  else
  {
    ota_loadImageInfo((ota_hdrFields_t *)0x0);
  }
  return;
}
void ota_upgradeComplete(u8 status)

{
  if (pOtaUpdateInfo != (ota_updateInfo_t *)0x0)
  {
    ev_buf_free((u8 *)pOtaUpdateInfo);
    pOtaUpdateInfo = (ota_updateInfo_t *)0x0;
  }
  zcl_attr_imageUpgradeStatus = '\0';
  if (status == '\0')
  {
    nv_resetModule('\x05');
    if (otaCb != (ota_callBack_t *)0x0)
    {
      FUNAAAAH();
    }
  }
  else
  {
    if (status == 0x96)
    {
      nv_resetModule('\x05');
      otaClientInfo.offset = 0;
      otaClientInfo.otaElementPos = 0;
      otaClientInfo.otaElementLen = 0;
      otaClientInfo._16_4_ = 0;
      otaClientInfo.clientOtaFlg = '\0';
      otaClientInfo.crcValue = 0xfffffffe;
      zcl_attr_imageTypeID = 0xfffe;
      zcl_attr_fileOffset = 0xfffffffe;
      zcl_attr_downloadFileVer = 0xfffffffe;
    }
    if (otaCb != (ota_callBack_t *)0x0)
    {
      FUNAAAAH();
    }
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 FUNAAAAH(void)

{
  undefined4 uVar1;
  code *in_r3;

  (*in_r3)();
  ota_ieeeAddrRspWait::cnt = ota_ieeeAddrRspWait::cnt + 1;
  if (ota_ieeeAddrRspWait::cnt < 3)
  {
    ota_ieeeAddrReq(g_otaCtx.otaServerEpInfo.dstAddr.shortAddr);
    uVar1 = 0;
  }
  else
  {
    ota_ieeeAddrRspWait::cnt = '\0';
    ota_upgradeComplete(0x95);
    uVar1 = 0xfffffffe;
  }
  return uVar1;
}
s32 ota_ieeeAddrRspWait(void *arg)

{
  s32 sVar1;

  ota_ieeeAddrRspWait::cnt = ota_ieeeAddrRspWait::cnt + 1;
  if (ota_ieeeAddrRspWait::cnt < 3)
  {
    ota_ieeeAddrReq(g_otaCtx.otaServerEpInfo.dstAddr.shortAddr);
    sVar1 = 0;
  }
  else
  {
    ota_ieeeAddrRspWait::cnt = '\0';
    ota_upgradeComplete(0x95);
    sVar1 = -2;
  }
  return sVar1;
}
void ota_imageBlockRspTimeout(void *arg)

{
  ota_upgradeComplete(0x95);
  return;
}
void ota_upgrade(void)

{
  if (zcl_attr_imageUpgradeStatus == '\x02')
  {
    g_otaCtx.upgradeEndRetry = g_otaCtx.upgradeEndRetry + 1;
    if (g_otaCtx.upgradeEndRetry < 2)
    {
      tl_zbTaskPost(ota_upgradeWithWait, &DAT_00000005);
      return;
    }
  }
  else if (zcl_attr_imageUpgradeStatus != '\x04')
  {
    if (zcl_attr_imageUpgradeStatus != '\x03')
    {
      return;
    }
    g_otaCtx.upgradeEndRetry = g_otaCtx.upgradeEndRetry + 1;
    if (g_otaCtx.upgradeEndRetry < 2)
    {
      tl_zbTaskPost(ota_upgradeWithWait, (void *)0xe10);
      return;
    }
  }
  ota_upgradeComplete('\0');
  return;
}
s32 ota_upgradeWaitCb(void *arg)

{
  ota_upgrade();
  return -2;
}
void ota_upgradeWait(u32 seconds)

{
  if (seconds == 0)
  {
    ota_upgrade();
  }
  else
  {
    otaTimer.cb = ota_upgradeWaitCb;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, seconds * 1000);
  }
  return;
}
u8 ota_fileIdCmp(u16 currManuCode, u16 newManuCode, u16 currImageType, u16 newImageType, u32 currFileVer, u32 newFileVer)

{
  byte bVar1;
  u8 uVar2;

  if ((((newManuCode == 0xffff) || (currManuCode == 0xffff)) ||
       (uVar2 = '\0', currManuCode == newManuCode)) &&
      (((newImageType == 0xffff || (currImageType == 0xffff)) ||
        (uVar2 = '\0', currImageType == newImageType))))
  {
    if ((newFileVer == 0xffffffff) || (currFileVer == 0xffffffff))
    {
      uVar2 = '\x01';
    }
    else
    {
      bVar1 = (char)currFileVer - (char)newFileVer;
      uVar2 = bVar1 + ~bVar1 + (newFileVer <= currFileVer);
    }
  }
  return uVar2;
}
// WARNING: Type propagation algorithm not settling
u8 ota_imageDataProcess(u8 len, u8 *pData)

{
  byte bVar1;
  ushort uVar2;
  u32 uVar3;
  bool bVar4;
  ota_updateInfo_t *poVar5;
  u8 uVar6;
  nv_sts_t nVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  bool bVar15;
  uint uStack_50;
  uchar auStack_3c[16];
  u32 uStack_2c;
  ushort uStack_26;

  uVar8 = (uint)len;
  uVar6 = 0x95;
  if (((zcl_attr_imageUpgradeStatus != '\x01') || (uVar6 = 0x96, pData == (u8 *)0x0)) ||
      (uVar6 = '\0', uVar8 == 0))
  {
    return uVar6;
  }
  bVar4 = false;
  uVar14 = 0;
  do
  {
    poVar5 = pOtaUpdateInfo;
    switch (otaClientInfo.clientOtaFlg + 0xfd)
    {
    case '\0':
      if (otaHdrMagic[uVar14] != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = otaHdrMagic[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = 0;
      otaClientInfo.clientOtaFlg = '\x04';
      break;
    case '\x01':
      bVar1 = otaHdrMagic[uVar14];
      if (bVar1 != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar3 = (pOtaUpdateInfo->hdrInfo).otaUpgradeFileID;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = (char)uVar3;
      *(byte *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = (byte)(uVar3 >> 8) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = (char)(uVar3 >> 0x10);
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x05';
      break;
    case '\x02':
      bVar1 = otaHdrMagic[uVar14];
      if (bVar1 != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar3 = (pOtaUpdateInfo->hdrInfo).otaUpgradeFileID;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = (char)(uVar3 >> 8);
      *(byte *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = (byte)(uVar3 >> 0x10) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x06';
      break;
    case '\x03':
      bVar1 = otaHdrMagic[uVar14];
      if (bVar1 != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar3 = (pOtaUpdateInfo->hdrInfo).otaUpgradeFileID;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = (char)(uVar3 >> 8);
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = (char)(uVar3 >> 0x10);
      *(byte *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = (byte)(uVar3 >> 0x18) | bVar1;
      otaClientInfo.clientOtaFlg = '\a';
      break;
    case '\x04':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaHdrVer = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).otaHdrVer + 1) = 0;
      otaClientInfo.clientOtaFlg = '\b';
      break;
    case '\x05':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).otaHdrVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaHdrVer = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).otaHdrVer + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\t';
      break;
    case '\x06':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      if (zcl_attr_fileOffset == 6)
      {
        *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaHdrLen = pData[uVar14];
        *(undefined *)((int)&(poVar5->hdrInfo).otaHdrLen + 1) = 0;
        otaClientInfo.clientOtaFlg = '\n';
      }
    default:
    switchD_00008744_caseD_1e:
      zcl_attr_fileOffset = zcl_attr_fileOffset + 1;
      if (g_otaCtx.downloadImageSize <= zcl_attr_fileOffset)
        goto LAB_00008760;
      goto LAB_00008726;
    case '\a':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).otaHdrLen;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaHdrLen = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).otaHdrLen + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\v';
      break;
    case '\b':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaHdrFC = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).otaHdrFC + 1) = 0;
      otaClientInfo.clientOtaFlg = '\f';
      break;
    case '\t':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).otaHdrFC;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaHdrFC = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).otaHdrFC + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\r';
      break;
    case '\n':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).manufacturerCode = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).manufacturerCode + 1) = 0;
      otaClientInfo.clientOtaFlg = '\x0e';
      break;
    case '\v':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).manufacturerCode;
      *(char *)&(pOtaUpdateInfo->hdrInfo).manufacturerCode = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).manufacturerCode + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\x0f';
      break;
    case '\f':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).imageType = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).imageType + 1) = 0;
      otaClientInfo.clientOtaFlg = '\x10';
      break;
    case '\r':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).imageType;
      *(char *)&(pOtaUpdateInfo->hdrInfo).imageType = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).imageType + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\x11';
      break;
    case '\x0e':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).fileVer = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).fileVer + 1) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).fileVer + 2) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).fileVer + 3) = 0;
      otaClientInfo.clientOtaFlg = '\x12';
      break;
    case '\x0f':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar3 = (pOtaUpdateInfo->hdrInfo).fileVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).fileVer = (char)uVar3;
      *(byte *)((int)&(poVar5->hdrInfo).fileVer + 1) = (byte)(uVar3 >> 8) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 2) = (char)(uVar3 >> 0x10);
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x13';
      break;
    case '\x10':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar3 = (pOtaUpdateInfo->hdrInfo).fileVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).fileVer = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 1) = (char)(uVar3 >> 8);
      *(byte *)((int)&(poVar5->hdrInfo).fileVer + 2) = (byte)(uVar3 >> 0x10) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x14';
      break;
    case '\x11':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar3 = (pOtaUpdateInfo->hdrInfo).fileVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).fileVer = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 1) = (char)(uVar3 >> 8);
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 2) = (char)(uVar3 >> 0x10);
      *(byte *)((int)&(poVar5->hdrInfo).fileVer + 3) = (byte)(uVar3 >> 0x18) | bVar1;
      otaClientInfo.clientOtaFlg = '\x15';
      break;
    case '\x12':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      if (zcl_attr_fileOffset == 0x12)
      {
        *(u8 *)&(pOtaUpdateInfo->hdrInfo).zbStackVer = pData[uVar14];
        *(undefined *)((int)&(poVar5->hdrInfo).zbStackVer + 1) = 0;
        otaClientInfo.clientOtaFlg = '\x16';
      }
      goto switchD_00008744_caseD_1e;
    case '\x13':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar2 = (pOtaUpdateInfo->hdrInfo).zbStackVer;
      uVar10 = (uint)uVar2 | (uint)pData[uVar14] << 8;
      *(char *)&(pOtaUpdateInfo->hdrInfo).zbStackVer = (char)uVar2;
      *(char *)((int)&(poVar5->hdrInfo).zbStackVer + 1) = (char)(uVar10 >> 8);
      if (uVar10 != 2)
      {
        return 0x96;
      }
      zcl_attr_downloadZigbeeStackVer = 2;
      otaClientInfo.clientOtaFlg = '\x17';
      break;
    case '\x14':
      if (0x44 < zcl_attr_fileOffset)
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      (pOtaUpdateInfo->hdrInfo).otaHdrString[zcl_attr_fileOffset - 0x14] = pData[uVar14];
      poVar5 = pOtaUpdateInfo;
      if ((pOtaUpdateInfo->hdrInfo).otaHdrLen - 1 == zcl_attr_fileOffset)
      {
        memcpy(&pOtaUpdateInfo->otaServerAddrInfo, zcl_attr_upgradeServerID, 8);
        *(undefined *)&(poVar5->otaServerAddrInfo).profileId =
            (undefined)g_otaCtx.otaServerEpInfo.profileId;
        *(undefined *)((int)&(poVar5->otaServerAddrInfo).profileId + 1) =
            g_otaCtx.otaServerEpInfo.profileId._1_1_;
        (poVar5->otaServerAddrInfo).endpoint = g_otaCtx.otaServerEpInfo.dstEp;
        (poVar5->otaServerAddrInfo).txOptions = g_otaCtx.otaServerEpInfo.txOptions;
        nVar7 = nv_flashWriteNew('\x01', 5, '\t', 0x51, (u8 *)poVar5);
        if ((ota_updateInfo_t *)(uint)nVar7 != (ota_updateInfo_t *)0x0)
        {
          return 0x96;
        }
        ev_buf_free((u8 *)pOtaUpdateInfo);
        otaClientInfo.clientOtaFlg = '\x18';
        pOtaUpdateInfo = (ota_updateInfo_t *)(uint)nVar7;
      }
      goto switchD_00008744_caseD_1e;
    case '\x15':
      otaClientInfo.otaElementTag = (u16)pData[uVar14];
      otaClientInfo.clientOtaFlg = '\x19';
      break;
    case '\x16':
      otaClientInfo.otaElementTag = otaClientInfo.otaElementTag | (ushort)pData[uVar14] << 8;
      otaClientInfo.otaElementPos = 0;
      otaClientInfo.clientOtaFlg = '\x1a';
      break;
    case '\x17':
      otaClientInfo.otaElementLen = (u32)pData[uVar14];
      otaClientInfo.clientOtaFlg = '\x1b';
      break;
    case '\x18':
      otaClientInfo.otaElementLen = otaClientInfo.otaElementLen | (uint)pData[uVar14] << 8;
      otaClientInfo.clientOtaFlg = '\x1c';
      break;
    case '\x19':
      otaClientInfo.otaElementLen = otaClientInfo.otaElementLen | (uint)pData[uVar14] << 0x10;
      otaClientInfo.clientOtaFlg = '\x1d';
      break;
    case '\x1a':
      otaClientInfo.otaElementLen = (uint)pData[uVar14] << 0x18 | otaClientInfo.otaElementLen;
      otaClientInfo.clientOtaFlg = ' ';
      if (otaClientInfo.otaElementTag == 0xf000)
      {
        otaClientInfo.clientOtaFlg = '\x1e';
      }
      if (g_otaCtx.downloadImageSize - zcl_attr_fileOffset < otaClientInfo.otaElementLen)
      {
        return 0x96;
      }
      if (otaClientInfo.otaElementLen == 0)
      {
        return 0x96;
      }
      goto switchD_00008744_caseD_1e;
    case '\x1b':
      otaClientInfo.otaElementInfo1 = pData[uVar14];
      otaClientInfo.clientOtaFlg = '\x1f';
      break;
    case '\x1c':
      otaClientInfo.otaElementInfo2 = pData[uVar14];
      otaClientInfo.clientOtaFlg = ' ';
      break;
    case '\x1d':
      if (otaClientInfo.otaElementLen == 0)
      {
        return 0x96;
      }
      if (otaClientInfo.otaElementPos > otaClientInfo.otaElementLen)
      {
        return 0x96;
      }
      uVar10 = (uint)otaClientInfo.otaElementTag;
      iVar9 = ~uVar10 + uVar10 + (uint)(otaClientInfo.otaElementPos <= otaClientInfo.otaElementLen);
      iVar11 = (uVar10 - 0xf000) + ~(uVar10 - 0xf000) + (uint)(0xefff < uVar10);
      if (iVar11 == 0)
      {
        if (iVar9 == 0)
        {
          return 0x96;
        }
      LAB_00008bb2:
        if (g_otaEncryptionNeeded != '\0')
        {
          return 0x96;
        }
      }
      else if (iVar9 != 0)
        goto LAB_00008bb2;
      uVar10 = uVar8 - uVar14 & 0xff;
      uStack_50 = uVar10;
      if (otaClientInfo.otaElementLen - otaClientInfo.otaElementPos < uVar10)
      {
        uStack_50 = otaClientInfo.otaElementLen - otaClientInfo.otaElementPos & 0xff;
      }
      if ((iVar11 != 0) && (uStack_50 != 0))
      {
        uVar12 = 0;
        do
        {
          memset(auStack_3c, 0xff, 0x10);
          memcpy(auStack_3c, pData + uVar12 + uVar14, 0x10);
          aes_decrypt("", auStack_3c, pData + uVar12 + uVar14);
          uVar12 = uVar12 + 0x10 & 0xff;
        } while (uVar12 < uStack_50);
      }
      iVar9 = otaClientInfo.otaElementLen - otaClientInfo.otaElementInfo2;
      uVar13 = iVar9 - otaClientInfo.otaElementPos;
      uVar12 = 0;
      if ((4 < uVar13) && (uVar13 = uVar13 - 4, uVar12 = uVar10, uVar13 < uVar10))
      {
        uVar12 = uVar13 & 0xff;
      }
      otaClientInfo.crcValue = xcrc32(pData + uVar14, uVar12, otaClientInfo.crcValue);
      bVar15 = 7 < otaClientInfo.otaElementPos;
      if ((otaClientInfo.otaElementPos < 9) &&
          (bVar15 = 7 < uVar10 + otaClientInfo.otaElementPos,
           8 < uVar10 + otaClientInfo.otaElementPos))
      {
        bVar1 = pData[(uVar14 - otaClientInfo.otaElementPos) + 8];
        bVar15 = 0x4a < bVar1;
        if (bVar1 != 0x4b)
        {
          return 0x96;
        }
        pData[(uVar14 - otaClientInfo.otaElementPos) + 8] = 0xff;
      }
      iVar11 = ((uint)mcuBootAddr + ~(uint)mcuBootAddr + (uint)bVar15) * 0x40000;
      uVar6 = flash_writeWithCheck(otaClientInfo.otaElementPos + iVar11, uStack_50, pData + uVar14);
      if (uVar6 != '\x01')
      {
        return 0x96;
      }
      otaClientInfo.otaElementPos = otaClientInfo.otaElementPos + uStack_50;
      zcl_attr_fileOffset = zcl_attr_fileOffset + uStack_50;
      otaClientInfo.offset = zcl_attr_fileOffset;
      if (otaClientInfo.otaElementPos == otaClientInfo.otaElementLen)
      {
        uStack_26 = 0;
        flash_read(iVar11 + 6, 2, (u8 *)&uStack_26);
        if ((uStack_26 & 0xff) != 0x5d)
        {
          return 0x96;
        }
        if (uStack_26 >> 8 != 2)
        {
          return 0x96;
        }
        flash_read(iVar9 + -4 + iVar11, 4, (u8 *)&uStack_2c);
        if (otaClientInfo.crcValue != uStack_2c)
        {
          return 0x96;
        }
        otaClientInfo.clientOtaFlg = '\x18';
        bVar4 = true;
      }
      uVar12 = uVar8 - 1;
      if (uStack_50 != uVar10)
      {
        uVar12 = (uVar14 - 1 & 0xff) + uStack_50;
      }
      uVar14 = uVar12 & 0xff;
      zcl_attr_fileOffset = zcl_attr_fileOffset - 1;
      goto switchD_00008744_caseD_1e;
    }
    zcl_attr_fileOffset = zcl_attr_fileOffset + 1;
    if (g_otaCtx.downloadImageSize <= zcl_attr_fileOffset)
    {
    LAB_00008760:
      if (!bVar4)
      {
        return 0x96;
      }
      zcl_attr_imageUpgradeStatus = '\x02';
      return '\0';
    }
  LAB_00008726:
    uVar14 = uVar14 + 1 & 0xff;
    if (uVar8 <= uVar14)
    {
      return '\0';
    }
  } while (true);
}
void ota_queryNextImageReq(u8 dstEp, u16 dstAddr, u16 profileId)

{
  u8 seqNo;
  uint local_3c;
  undefined4 uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  ushort local_2c;
  undefined auStack_28[8];
  ushort local_20;
  undefined local_1e;

  seqNo = zcl_seqNum;
  local_1e = 0;
  auStack_28._0_4_ =
      (uint)(g_otaCtx.pOtaPreamble)->manufacturerCode << 8 |
      (uint)(byte)(g_otaCtx.pOtaPreamble)->imageType << 0x18;
  auStack_28._4_4_ =
      zcl_attr_currFileVer << 8 | (uint)(byte)((g_otaCtx.pOtaPreamble)->imageType >> 8);
  local_20 = (ushort)zcl_attr_currFileVer._3_1_;
  uStack_38 = 0;
  local_3c = (uint)dstAddr;
  uStack_30 = CONCAT13(dstEp, 0x20000);
  uStack_34 = (uint)profileId;
  local_2c = g_otaCtx.otaServerEpInfo.txOptions | 4;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_ota_queryNextImageReqSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_3c, '\0', seqNo,
                                (ota_queryNextImageReq_t *)auStack_28);
  return;
}
// WARNING: Could not reconcile some variable overlaps
void ota_imageBlockReq(u8 dstEp, u16 dstAddr, u16 profileId)

{
  u8 seqNo;
  uint uVar1;
  undefined local_44[8];
  uint uStack_3c;
  uint uStack_38;
  undefined4 uStack_34;
  int iStack_30;
  uint local_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  ushort local_1c;

  seqNo = zcl_seqNum;
  uStack_34 = 0;
  local_44._0_4_ =
      (uint)(g_otaCtx.pOtaPreamble)->manufacturerCode << 8 | 2 |
      (uint)(byte)(g_otaCtx.pOtaPreamble)->imageType << 0x18;
  local_44._4_4_ =
      zcl_attr_downloadFileVer << 8 | (uint)(byte)((g_otaCtx.pOtaPreamble)->imageType >> 8);
  uStack_3c = zcl_attr_fileOffset << 8 | zcl_attr_downloadFileVer >> 0x18;
  uVar1 = g_otaCtx.downloadImageSize - zcl_attr_fileOffset;
  if (0x2f < uVar1)
  {
    uVar1 = 0x30;
  }
  uStack_38 = (uint)CONCAT11((char)uVar1, (char)(zcl_attr_fileOffset >> 0x18));
  iStack_30 = (uint)zcl_attr_minBlockPeriod << 0x10;
  uStack_28 = 0;
  local_2c = (uint)dstAddr;
  uStack_20 = CONCAT13(dstEp, 0x20000);
  uStack_24 = (uint)profileId;
  local_1c = g_otaCtx.otaServerEpInfo.txOptions | 4;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_ota_imageBlockReqSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_2c, '\0', seqNo,
                            (ota_imageBlockReq_t *)local_44);
  return;
}
void sendImageBlockReq(void *arg)

{
  ota_imageBlockReq(g_otaCtx.otaServerEpInfo.dstEp, g_otaCtx.otaServerEpInfo.dstAddr.shortAddr,
                    g_otaCtx.otaServerEpInfo.profileId);
  otaTimer.cb = ota_imageBlockRspWait;
  otaTimer.data = (void *)0x0;
  ev_on_timer(&otaTimer, (u32)&DAT_00001388);
  return;
}
void ota_sendImageBlockReq(void *arg)

{
  if (zcl_attr_minBlockPeriod == 0)
  {
    sendImageBlockReq((void *)0x0);
  }
  else
  {
    otaTimer.cb = ota_sendImageBlockReqDelay;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, (uint)zcl_attr_minBlockPeriod);
  }
  return;
}
void ota_ieeeAddrRspCb(void *arg)

{
  int iVar1;

  // WARNING: Load size is inaccurate
  iVar1 = *arg;
  if (*(char *)(iVar1 + 1) == '\0')
  {
    memcpy(zcl_attr_upgradeServerID, (void *)(iVar1 + 2), 8);
  }
  if ((zcl_attr_imageUpgradeStatus == '\x01') && (otaClientInfo.clientOtaFlg < 3))
  {
    ev_unon_timer(&otaTimer);
    if (*(char *)(iVar1 + 1) == '\0')
    {
      ota_sendImageBlockReq((void *)0x0);
      otaClientInfo.clientOtaFlg = '\x03';
      if (otaCb != (ota_callBack_t *)0x0)
      {
        FUNAAAAJ();
      }
    }
    else
    {
      ota_upgradeComplete(0x95);
    }
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAJ(void)

{
  int iVar1;
  code *in_r3;

  iVar1 = (*in_r3)();
  if (iVar1 == 0)
  {
    ota_sendImageBlockReq((void *)0x0);
  }
  else
  {
    otaTimer.cb = ota_imageBlockWaitCb;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, iVar1 * 1000);
  }
  return;
}
void ota_imageBlockWait(u32 seconds)

{
  if (seconds == 0)
  {
    ota_sendImageBlockReq((void *)0x0);
  }
  else
  {
    otaTimer.cb = ota_imageBlockWaitCb;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, seconds * 1000);
  }
  return;
}
void ota_upgradeEndReqSend(ota_upgradeEndReq_t *req)

{
  u8 seqNo;
  uint local_20;
  undefined4 uStack_1c;
  uint uStack_18;
  undefined4 uStack_14;
  ushort local_10;

  seqNo = zcl_seqNum;
  uStack_1c = 0;
  local_20 = (uint)g_otaCtx.otaServerEpInfo.dstAddr.shortAddr;
  uStack_14 = CONCAT13(g_otaCtx.otaServerEpInfo.dstEp, 0x20000);
  uStack_18 = (uint)g_otaCtx.otaServerEpInfo.profileId;
  local_10 = g_otaCtx.otaServerEpInfo.txOptions | 4;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_ota_upgradeEndReqSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_20, '\0', seqNo, req);
  return;
}
void ota_upgradeWithWait(void *arg)

{
  undefined local_14[5];
  undefined3 uStack_f;
  undefined uStack_c;

  uStack_c = zcl_attr_downloadFileVer._3_1_;
  stack0xfffffff0 = CONCAT31((int3)zcl_attr_downloadFileVer, zcl_attr_imageTypeID._1_1_);
  local_14._0_4_ = (uint)(byte)zcl_attr_imageTypeID << 0x18 | (uint)zcl_attr_manufacturerID << 8;
  ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_14);
  ota_upgradeWait((u32)arg);
  return;
}
s32 ota_imageBlockRspWait(void *arg)

{
  undefined local_10[5];
  undefined3 uStack_b;
  undefined uStack_8;

  g_otaCtx.imageBlockRetry = g_otaCtx.imageBlockRetry + 1;
  if (g_otaCtx.imageBlockRetry < 10)
  {
    tl_zbTaskPost(ota_sendImageBlockReq, (void *)0x0);
  }
  else
  {
    uStack_8 = zcl_attr_downloadFileVer._3_1_;
    local_10._0_4_ = (uint)(byte)zcl_attr_imageTypeID << 0x18 | 0x95;
    stack0xfffffff4 = CONCAT31((int3)zcl_attr_downloadFileVer, zcl_attr_imageTypeID._1_1_);
    local_10._0_4_ = local_10._0_4_ | (uint)zcl_attr_manufacturerID << 8;
    ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_10);
    tl_zbTaskPost(ota_imageBlockRspTimeout, (void *)0x0);
  }
  return -2;
}
// WARNING: Type propagation algorithm not settling
status_t zcl_otaCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  char cVar1;
  uint uVar2;
  u16 uVar3;
  u8 uVar4;
  byte status;
  status_t sVar5;
  ushort uVar6;
  int iVar7;
  addrExt_t *m2;
  u8 *buf;
  undefined2 *puVar8;
  undefined2 *extraout_r2;
  u8 *puVar9;
  u32 *puVar10;
  undefined uVar11;
  u32 uVar12;
  u32 *puVar13;
  ota_ctx_t *poVar14;
  u8 *unaff_sl;
  byte bVar15;
  uint local_a4;
  undefined4 uStack_a0;
  uint uStack_9c;
  undefined4 uStack_98;
  undefined2 local_94;
  undefined local_90[8];
  uint uStack_88;
  undefined uStack_84;
  byte bStack_83;
  undefined2 uStack_82;
  undefined2 uStack_80;
  uint local_7c;
  undefined4 uStack_78;
  uint uStack_74;
  undefined4 uStack_70;
  undefined2 local_6c;
  uint local_68;
  undefined4 uStack_64;
  uint uStack_60;
  undefined4 uStack_5c;
  undefined2 local_58;
  ota_upgradeEndRsp_t local_54;
  undefined local_44[8];
  uint uStack_3c;
  undefined uStack_38;
  undefined local_34[8];
  undefined uStack_2c;
  u32 uStack_28;
  ushort local_22;

  poVar14 = &g_otaCtx;
  if (pAddrInfo->dstEp != (g_otaCtx.simpleDesc)->endpoint)
  {
    return '\0';
  }
  bVar15 = pAddrInfo->field_0x9;
  if ((bVar15 & 1) == 0)
  {
    if (cmdId != '\x03')
    {
      if (cmdId == '\x06')
      {
        // WARNING: Load size is inaccurate
        if (*cmdPayload != '\0')
        {
          return '\0';
        }
        local_54.fileVer = *(u32 *)((int)cmdPayload + 5);
        local_54.imageType = *(u16 *)((int)cmdPayload + 3);
        local_54.manuCode = *(u16 *)((int)cmdPayload + 1);
        local_54.currentTime = 0;
        local_54.upgradeTime = 0x3c;
        uStack_78 = 0;
        local_6c = 0;
        local_7c = (uint)pAddrInfo->srcAddr;
        uStack_70 = CONCAT13(pAddrInfo->srcEp, 0x20000);
        uStack_74 = (uint)pAddrInfo->profileId;
        zcl_ota_upgradeEndRspSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_7c, '\x01', pAddrInfo->seqNum,
                                  &local_54);
        return 0xff;
      }
      if (cmdId != '\x01')
      {
        return 0x81;
      }
      uVar3 = *(u16 *)((int)cmdPayload + 3);
      uVar11 = 0x98;
      if (((otaServerBinInfo.manufacturerCode == *(u16 *)((int)cmdPayload + 1)) &&
           (otaServerBinInfo.imageType == uVar3)) &&
          (uVar11 = 0, otaServerBinInfo.fileVer == *(u32 *)((int)cmdPayload + 5)))
      {
        uVar11 = 0x98;
      }
      local_44._0_4_ = CONCAT13((char)uVar3, CONCAT21(*(u16 *)((int)cmdPayload + 1), uVar11));
      local_44._4_4_ = otaServerBinInfo.fileVer << 8 | (uint)(byte)(uVar3 >> 8);
      uStack_3c = otaServerBinInfo.totalImageSize << 8 | otaServerBinInfo.fileVer >> 0x18;
      uStack_38 = otaServerBinInfo.totalImageSize._3_1_;
      uStack_64 = 0;
      local_68 = (uint)pAddrInfo->srcAddr;
      uStack_5c = CONCAT13(pAddrInfo->srcEp, 0x20000);
      uStack_60 = (uint)pAddrInfo->profileId;
      local_58 = 4;
      zcl_ota_queryNextImageRspSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_68, '\x01', pAddrInfo->seqNum,
                                    (ota_queryNextImageRsp_t *)local_44);
      return 0xff;
    }
    if (otaServerBinInfo.manufacturerCode != *(u16 *)((int)cmdPayload + 1))
    {
      return 0x98;
    }
    if (otaServerBinInfo.fileVer != *(u32 *)((int)cmdPayload + 5))
    {
      return 0x98;
    }
    if (otaServerBinInfo.imageType != *(u16 *)((int)cmdPayload + 3))
    {
      return 0x98;
    }
    // WARNING: Load size is inaccurate
    if (((int)((uint)*cmdPayload << 0x1e) < 0) &&
        ((uint) * (ushort *)((int)cmdPayload + 0x16) != (uint)zcl_attr_minBlockPeriod))
    {
      local_90._0_4_ = 0x97;
      local_90._4_4_ = (uint)(bVar15 & 1);
      uStack_88 = (uint)zcl_attr_minBlockPeriod << 8 |
                  (uStack_88 & 0xffffff00 | (uint)bVar15) & 0xff000001;
      unaff_sl = (u8 *)0x0;
      goto LAB_0000953e;
    }
    bVar15 = *(byte *)((int)cmdPayload + 0xd);
    if (0x30 < bVar15)
    {
      bVar15 = 0x30;
    }
    buf = ev_buf_allocate((ushort)bVar15);
    unaff_sl = buf;
    if (buf != (u8 *)0x0)
    {
      flash_read(((uint)mcuBootAddr + ~(uint)mcuBootAddr + 1) * 0x40000 +
                     *(int *)((int)cmdPayload + 9),
                 (uint)bVar15, buf);
      local_90._0_4_ =
          (uint) * (ushort *)((int)cmdPayload + 1) << 8 |
          (uint)(byte) * (undefined2 *)((int)cmdPayload + 3) << 0x18;
      local_90._4_4_ =
          otaServerBinInfo.fileVer << 8 |
          (uint)(byte)((ushort) * (undefined2 *)((int)cmdPayload + 3) >> 8);
      uStack_84 = *(undefined *)((int)cmdPayload + 0xc);
      uStack_88 = CONCAT31(*(undefined3 *)((int)cmdPayload + 9), otaServerBinInfo.fileVer._3_1_);
      uStack_82 = SUB42(buf, 0);
      uStack_80 = (undefined2)((uint)buf >> 0x10);
      bStack_83 = bVar15;
      goto LAB_0000953e;
    }
  }
  else
  {
    if (cmdId == '\x02')
    {
      if (zcl_attr_imageUpgradeStatus == '\x01')
      {
        return '\0';
      }
      g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
      g_otaCtx.otaServerEpInfo.dstAddr.shortAddr = pAddrInfo->srcAddr;
      g_otaCtx.otaServerEpInfo.dstEp = pAddrInfo->srcEp;
      g_otaCtx.otaServerEpInfo.profileId = pAddrInfo->profileId;
      g_otaCtx.otaServerEpInfo.radius = '\0';
      g_otaCtx.imageBlockRetry = '\0';
      // WARNING: Load size is inaccurate
      if (*cmdPayload != '\0')
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (*(u16 *)((int)cmdPayload + 3) != (g_otaCtx.pOtaPreamble)->imageType)
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (*(u16 *)((int)cmdPayload + 1) != (g_otaCtx.pOtaPreamble)->manufacturerCode)
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (*(u32 *)((int)cmdPayload + 5) == (g_otaCtx.pOtaPreamble)->fileVer)
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (0x34000 < *(uint *)((int)cmdPayload + 9))
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return 0x89;
      }
      zcl_attr_imageUpgradeStatus = '\x01';
      ev_unon_timer(&otaTimer);
      if (g_otaCtx.downloadImageSize == *(u32 *)((int)cmdPayload + 9))
      {
        if (zcl_attr_imageTypeID == *(u16 *)((int)cmdPayload + 3))
        {
          puVar13 = &zcl_attr_downloadFileVer;
          if ((*(u32 *)((int)cmdPayload + 5) == zcl_attr_downloadFileVer) &&
              (0x1000 < zcl_attr_fileOffset))
          {
            if (g_otaCtx.downloadImageSize == otaClientInfo.offset)
            {
              bVar15 = otaClientInfo.otaElementLen <= otaClientInfo.otaElementPos;
              if (otaClientInfo.otaElementPos != otaClientInfo.otaElementLen)
                goto LAB_00009696;
            }
            else
            {
              ota_sendImageBlockReq((void *)0x0);
              puVar13 = (u32 *)0x0;
              bVar15 = 1;
              if (otaCb != (ota_callBack_t *)0x0)
                goto LAB_0000974a;
              FUN_0000918e();
            }
            iVar7 = ((uint)mcuBootAddr + ~(uint)mcuBootAddr + (uint)bVar15) * 0x40000;
            local_22 = 0;
            flash_read(iVar7 + 6, 2, (u8 *)&local_22);
            if ((((local_22 & 0xff) == 0x5d) && (local_22 >> 8 == 2)) &&
                (flash_read(((otaClientInfo.otaElementLen - 4) - (uint)otaClientInfo.otaElementInfo2) + iVar7, 4, (u8 *)&uStack_28), otaClientInfo.crcValue == uStack_28))
            {
              ota_upgradeComplete('\0');
              puVar8 = (undefined2 *)FUN_0000918e();
              *puVar8 = 0x2010;
              *extraout_r2 = (short)puVar8;
              sVar5 = FUN_00009f52();
              return sVar5;
            }
          }
        }
        else
        {
          puVar13 = &zcl_attr_downloadFileVer;
        }
      }
      else
      {
        puVar13 = &zcl_attr_downloadFileVer;
      }
    LAB_00009696:
      unaff_sl = &mcuBootAddr;
      puVar10 = &zcl_attr_fileOffset;
      zcl_attr_fileOffset = 0;
      otaClientInfo.crcValue = 0xfffffffe;
      zcl_attr_imageTypeID = *(u16 *)((int)cmdPayload + 3);
      *puVar13 = *(u32 *)((int)cmdPayload + 5);
      g_otaCtx.downloadImageSize = *(uint *)((int)cmdPayload + 9);
      poVar14 = (ota_ctx_t *)((g_otaCtx.downloadImageSize >> 0xc) + 1 & 0xffff);
      uVar12 = ((uint)mcuBootAddr + ~(uint)mcuBootAddr) * 0x40000;
      if (poVar14 != (ota_ctx_t *)0x0)
      {
        puVar10 = (u32 *)0x0;
        do
        {
          flash_erase(uVar12);
          puVar10 = (u32 *)((uint)((int)(af_simple_descriptor_t **)puVar10 + 1) & 0xffff);
          uVar12 = uVar12 + 0x1000;
        } while (puVar10 < poVar14);
      }
      pOtaUpdateInfo = (ota_updateInfo_t *)ev_buf_allocate(0x51);
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x89;
      }
      memset(pOtaUpdateInfo, 0, 0x51);
      iVar7 = memcmp(zcl_attr_upgradeServerID, &g_invalid_addr, 8);
      puVar9 = (u8 *)puVar10;
      if (iVar7 != 0)
      {
        ota_sendImageBlockReq((void *)0x0);
        otaClientInfo.clientOtaFlg = '\x03';
        if (otaCb == (ota_callBack_t *)0x0)
        {
          otaClientInfo.clientOtaFlg = '\x03';
          return '\0';
        }
      LAB_0000974a:
        FUNAAAAK();
        return '\0';
      }
    }
    else
    {
      if (cmdId < 3)
      {
        if (cmdId != '\0')
        {
          return 0x81;
        }
        iVar7 = memcmp(zcl_attr_upgradeServerID, &g_invalid_addr, 8);
        if (((iVar7 != 0) &&
             (m2 = tl_zbExtAddrPtrByShortAddr(pAddrInfo->srcAddr), m2 != (addrExt_t *)0x0)) &&
            (iVar7 = memcmp(zcl_attr_upgradeServerID, m2, 8), iVar7 != 0))
        {
          return 0xff;
        }
        if (zcl_attr_imageUpgradeStatus != '\0')
        {
          return '\x01';
        }
        if ((pAddrInfo->dstAddr & 0xfff8) == 0xfff8)
        {
          // WARNING: Load size is inaccurate
          bVar15 = *cmdPayload;
          if (bVar15 != 0)
          {
            if (*(u16 *)((int)cmdPayload + 2) != (g_otaCtx.pOtaPreamble)->manufacturerCode)
            {
              return '\0';
            }
            if (1 < bVar15)
            {
              if (*(u16 *)((int)cmdPayload + 4) != (g_otaCtx.pOtaPreamble)->imageType)
              {
                return '\0';
              }
              if ((bVar15 != 2) && (*(u32 *)((int)cmdPayload + 6) == zcl_attr_currFileVer))
              {
                return '\0';
              }
            }
          }
          uVar12 = drv_u32Rand();
          uVar6 = FUN_00001628(uVar12 & 0xffff, 100);
          if (*(byte *)((int)cmdPayload + 1) < uVar6)
          {
            return '\0';
          }
        }
        if ((int)((uint)(byte)pAddrInfo->field_0x9 << 0x1e) < 0)
        {
          g_otaCtx.otaServerEpInfo.txOptions =
              g_otaCtx.otaServerEpInfo.txOptions | APS_TX_OPT_SECURITY_ENABLED;
        }
        else
        {
          g_otaCtx.otaServerEpInfo.txOptions =
              g_otaCtx.otaServerEpInfo.txOptions & ~APS_TX_OPT_SECURITY_ENABLED;
        }
        ota_queryNextImageReq(pAddrInfo->srcEp, pAddrInfo->srcAddr, pAddrInfo->profileId);
        return 0xff;
      }
      if (cmdId != '\x05')
      {
        if (cmdId != '\a')
        {
          return 0x81;
        }
        if (zcl_attr_imageUpgradeStatus != '\x02')
        {
          if (zcl_attr_imageUpgradeStatus != '\x03')
          {
            return '\0';
          }
          if (*(int *)((int)cmdPayload + 0xc) == -1)
          {
            return '\0';
          }
        }
        // WARNING: Load size is inaccurate
        uVar4 = ota_fileIdCmp((g_otaCtx.pOtaPreamble)->manufacturerCode, *cmdPayload,
                              (g_otaCtx.pOtaPreamble)->imageType, *(u16 *)((int)cmdPayload + 2),
                              zcl_attr_downloadFileVer, *(u32 *)((int)cmdPayload + 4));
        if (uVar4 == '\0')
        {
          return '\0';
        }
        uVar2 = *(uint *)((int)cmdPayload + 0xc);
        if (uVar2 == 0xffffffff)
        {
          zcl_attr_imageUpgradeStatus = '\x03';
          ota_upgradeWait(0xe10);
          g_otaCtx.upgradeEndRetry = '\0';
        }
        else
        {
          uVar12 = 0;
          if (*(uint *)((int)cmdPayload + 8) < uVar2)
          {
            uVar12 = uVar2 - *(uint *)((int)cmdPayload + 8);
          }
          zcl_attr_imageUpgradeStatus = '\x04';
          ota_upgradeWait(uVar12);
        }
        if (otaCb == (ota_callBack_t *)0x0)
        {
          return '\0';
        }
        FUNAAAAK();
        return '\0';
      }
      puVar9 = &zcl_attr_imageUpgradeStatus;
      if (zcl_attr_imageUpgradeStatus != '\x01')
      {
        return '\0';
      }
      // WARNING: Load size is inaccurate
      cVar1 = *cmdPayload;
      if (cVar1 == '\0')
      {
        bVar15 = 0x96;
        if (((*(u16 *)((int)cmdPayload + 3) == (g_otaCtx.pOtaPreamble)->imageType) &&
             (*(u16 *)((int)cmdPayload + 1) == (g_otaCtx.pOtaPreamble)->manufacturerCode)) &&
            (*(u32 *)((int)cmdPayload + 5) == zcl_attr_downloadFileVer))
        {
          if (*(u32 *)((int)cmdPayload + 9) != zcl_attr_fileOffset)
          {
            return '\0';
          }
          ev_unon_timer(&otaTimer);
          g_otaCtx.imageBlockRetry = '\0';
          bVar15 = ota_imageDataProcess(*(u8 *)((int)cmdPayload + 0xd), *(u8 **)((int)cmdPayload + 0xe));
          status = bVar15;
          if (bVar15 == 0)
          {
            tl_zbTaskPost(ota_saveUpdateInfo2NV, (void *)0x0);
            if (zcl_attr_imageUpgradeStatus != '\x02')
              goto LAB_000098ce;
            uStack_2c = *(undefined *)((int)cmdPayload + 8);
            local_34._4_4_ =
                CONCAT31(*(undefined3 *)((int)cmdPayload + 5),
                         (char)((ushort) * (undefined2 *)((int)cmdPayload + 3) >> 8));
            local_34._0_4_ =
                (uint)(byte) * (undefined2 *)((int)cmdPayload + 3) << 0x18 |
                (uint) * (ushort *)((int)cmdPayload + 1) << 8;
            ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_34);
            g_otaCtx.upgradeEndRetry = '\0';
            ota_upgradeWait(5);
            status = FUN_0000918e();
          }
          ota_upgradeComplete(status);
        }
        zcl_attr_imageUpgradeStatus = '\0';
        uStack_2c = *(undefined *)((int)cmdPayload + 8);
        local_34._0_4_ = CONCAT13((char)*(undefined2 *)((int)cmdPayload + 3), (uint3)bVar15);
        local_34._4_4_ =
            CONCAT31(*(undefined3 *)((int)cmdPayload + 5),
                     (char)((ushort) * (undefined2 *)((int)cmdPayload + 3) >> 8));
        local_34._0_4_ = local_34._0_4_ | (uint) * (ushort *)((int)cmdPayload + 1) << 8;
        ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_34);
        return '\0';
      }
      if (cVar1 != -0x69)
      {
        if (cVar1 != -0x6b)
        {
          return 0x80;
        }
        zcl_attr_imageUpgradeStatus = '\0';
        ev_unon_timer(&otaTimer);
        g_otaCtx.imageBlockRetry = '\0';
        ota_upgradeComplete(0x95);
        return '\0';
      }
      ev_unon_timer(&otaTimer);
      if (*(int *)((int)cmdPayload + 5) == *(int *)((int)cmdPayload + 1))
      {
        zcl_attr_minBlockPeriod = *(u16 *)((int)cmdPayload + 9);
      LAB_000098ce:
        ota_sendImageBlockReq((void *)0x0);
        return '\0';
      }
      g_otaCtx.imageBlockRetry = '\0';
      ota_imageBlockWait(*(int *)((int)cmdPayload + 5) - *(int *)((int)cmdPayload + 1));
      FUN_0000918e();
    }
    tl_zbTaskPost(ota_ieeeAddrReqSend, (void *)0x0);
    buf = (u8 *)FUN_0000918e();
    pAddrInfo = (zclIncomingAddrInfo_t *)puVar9;
  }
  local_90._0_4_ = 0x97;
  local_90._4_4_ = (uint)buf & 0xff;
  uStack_88 = uStack_88 & 0xff000000 | (uint)buf & 0xff | (uint)zcl_attr_minBlockPeriod << 8;
LAB_0000953e:
  uStack_a0 = 0;
  local_94 = 0;
  local_a4 = (uint) * (ushort *)&((ota_ctx_t *)pAddrInfo)->simpleDesc;
  uStack_98 = CONCAT13(((ota_ctx_t *)pAddrInfo)->pOtaPreamble, 0x20000);
  uStack_9c = (uint) * (ushort *)&((ota_ctx_t *)pAddrInfo)->simpleDesc;
  zcl_ota_imageBlockRspSend(poVar14->simpleDesc->endpoint, (epInfo_t *)&local_a4, '\x01',
                            *(u8 *)&((ota_ctx_t *)pAddrInfo)->downloadImageSize, (ota_imageBlockRsp_t *)local_90);
  if (unaff_sl != (u8 *)0x0)
  {
    ev_buf_free(unaff_sl);
  }
  return 0xff;
}
undefined4 FUN_0000918e(void)

{
  undefined4 unaff_r5;

  return unaff_r5;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAK(void)

{
  code *in_r3;
  undefined4 in_lr;

  (*in_r3)();
  sum_rssi = ((int)((DAT_00800441 - 0x6e) * 0x1000000) >> 0x18) + sum_rssi;
  cnt_rssi = cnt_rssi + 1;
  if (0xfffffd < cnt_rssi)
  {
    sum_rssi = FUN_00001624(sum_rssi, cnt_rssi, cnt_rssi, 0xfffffd, in_lr);
    cnt_rssi = 1;
  }
  return;
}
void rf_edDetect(void)

{
  sum_rssi = ((int)((DAT_00800441 - 0x6e) * 0x1000000) >> 0x18) + sum_rssi;
  cnt_rssi = cnt_rssi + 1;
  if (0xfffffd < cnt_rssi)
  {
    sum_rssi = FUN_00001624(sum_rssi, cnt_rssi);
    cnt_rssi = 1;
  }
  return;
}
u8 rf_TrxStateGet(void)

{
  return rfMode;
}
void rf_setChannel(u8 chn)

{
  int iVar1;
  u32 en;

  iVar1 = (uint)chn * 0x1000000;
  if (iVar1 + 0xf5000000U >> 0x18 < 0x10)
  {
    g_zbInfo.macPib.phyChannelCur = (u8)((uint)iVar1 >> 0x18);
    en = drv_disable_irq();
    iVar1 = rf_trx_state_get();
    rf_trx_state_set((RF_StatusTypeDef)iVar1, (char)(((uint)chn * 5 + -0x32) * 0x1000000 >> 0x18));
    if ((iVar1 - 1U & 0xff) < 2)
    {
      rfMode = '\x01';
    }
    else if ((iVar1 == 0) || (iVar1 == 3))
    {
      rfMode = (RF_StatusTypeDef)iVar1;
    }
    drv_restore_irq(en);
  }
  return;
}
u8 rf_getChannel(void)

{
  return g_zbInfo.macPib.phyChannelCur;
}
void rf_setTxPower(u8 power)

{
  rf_set_power_level_index();
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void rf_reset(void)

{
  rf_setTrxState('\0');
  rf_setTxPower(g_zb_txPowerSet);
  rf_setChannel(g_zbInfo.macPib.phyChannelCur);
  if (rf_rxBuf == (u8 *)0x0)
  {
    rf_rxBuf = tl_getRxBuf();
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  else
  {
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  _DAT_00800c08 = rf_rxBuf._0_2_;
  DAT_00800f03 = DAT_00800f03 & 0xfb;
  rf_rx_cf();
  DAT_00800c21 = DAT_00800c21 & 0xf3;
  _DAT_00800f1c = _DAT_00800f1c & 0xe000 | 3;
  _DAT_00800640 = _DAT_00800640 | 0x2000;
  DAT_00800c20 = DAT_00800c20 | 0xc;
  DAT_00800430 = DAT_00800430 | 2;
  return;
}
void rf_init(void)

{
  rf_reset();
  rf_ack_buf._8_4_ = 0;
  rf_ack_buf._0_4_ = 4;
  rf_ack_buf._4_4_ = 0x205;
  ev_on_poll(EV_POLL_ED_DETECT, rf_edDetect);
  ev_disable_poll(EV_POLL_ED_DETECT);
  return;
}
u8 rf_getLqi(s8 rssi)

{
  u8 uVar1;
  int iVar2;

  iVar2 = (int)rssi;
  if (iVar2 + 0xe < 0 == SCARRY4(iVar2, 0xe))
  {
    iVar2 = -0x10;
  }
  else if (iVar2 + 99 < 0 != SCARRY4(iVar2, 99))
  {
    return '\0';
  }
  uVar1 = FUN_00001624((iVar2 + 99) * 0xff, 0x54);
  return uVar1;
}
u8 rf_lqi2cost(u8 lqi)

{
  u8 uVar1;

  uVar1 = '\x01';
  if ((((lqi < 0x77) && (uVar1 = '\x02', lqi < 0x5f)) && (uVar1 = '\x03', lqi < 0x46)) &&
      (uVar1 = '\a', 0x2d < lqi))
  {
    uVar1 = '\x05';
  }
  return uVar1;
}
void rf_startED(void)

{
  soft_rssi = -0x6e;
  sum_rssi = 0;
  cnt_rssi = 0;
  ev_enable_poll(EV_POLL_ED_DETECT);
  rf_setTrxState('\x02');
  return;
}
u8 rf_stopED(void)

{
  u8 uVar1;
  int iVar2;
  int iVar3;

  if (cnt_rssi == 0)
  {
    cnt_rssi = 1;
  }
  soft_rssi = FUN_00001624(sum_rssi, cnt_rssi);
  ev_disable_poll(EV_POLL_ED_DETECT);
  iVar3 = (uint)(byte)soft_rssi << 0x18;
  iVar2 = iVar3 >> 0x18;
  if (iVar2 + 0xe < 0 == SCARRY4(iVar2, 0xe))
  {
    iVar3 = -0xf000000;
  }
  else if (iVar2 + 99 < 0 != SCARRY4(iVar2, 99))
  {
    return '\0';
  }
  uVar1 = FUN_00001624(((iVar3 >> 0x18) + 99) * 0xff, 0x54);
  return uVar1;
}
void rf802154_tx_ready(u8 *buf, u8 len)

{
  rf_tx_buf[0] = len + '\x01';
  rf_tx_buf[1] = '\0';
  rf_tx_buf[2] = '\0';
  rf_tx_buf[3] = '\0';
  rf_tx_buf[4] = len + '\x02';
  memcpy(rf_tx_buf + 5, buf, (uint)len);
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
u8 tl_zbMacAttrGet(u8 attribute, u8 *value, u8 *len)

{
  byte bVar1;
  uint uVar2;

  if (attribute == 0)
  {
    *value = *(u8 *)(FUN_00009f52 + 0x46);
  }
  else
  {
    uVar2 = attribute - 0x40;
    attribute = 0xe8;
    if ((uVar2 & 0xff) < 0x20)
    {
      bVar1 = g_zbMacPibTbl[uVar2].len;
      *len = bVar1;
      memcpy(value, (void *)((uint)g_zbMacPibTbl[uVar2].offset + FUN_00009f52), (uint)bVar1);
      attribute = '\0';
    }
  }
  return attribute;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void FUN_00009f52(int param_1)

{
  int iVar1;
  u32 uVar2;
  int iVar3;
  int unaff_r4;
  u8 auStack_24[8];
  u8 auStack_1c[2];
  u8 uStack_1a;
  char cStack_19;
  char cStack_18;
  char acStack_17[7];
  int iStack_10;

  iStack_10 = unaff_r4 << param_1;
  flash_read(g_u32MacFlashAddr, 8, auStack_1c);
  iVar1 = memcmp(auStack_1c, &g_invalid_addr, 8);
  iVar3 = _DAT_00800740;
  if (iVar1 == 0)
  {
    do
    {
      uVar2 = drv_u32Rand();
      iVar1 = FUN_00001628(uVar2, 0xfff);
    } while (iVar1 == 0);
    do
    {
    } while ((uint)(_DAT_00800740 - iVar3) <= (uint)(iVar1 << 4));
    drv_generateRandomData(auStack_1c, '\x05');
    memcpy(acStack_17, startIEEEAddr, 3);
    flash_write(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_write(g_u32MacFlashAddr + 6, 2, auStack_1c);
    flash_read(g_u32MacFlashAddr, 8, auStack_24);
    iVar3 = memcmp(auStack_24, &g_invalid_addr, 8);
    if (iVar3 == 0)
    {
      sys_exceptionPost(0xa2, '\x04');
    }
  }
  else
  {
    if (cStack_19 == '8')
    {
      if ((cStack_18 != -0x3f) || (acStack_17[0] != -0x5c))
        goto LAB_00009fdc;
    }
    else if (cStack_19 == -0x2f)
    {
      if ((cStack_18 != '\x19') || (acStack_17[0] != -0x3c))
        goto LAB_00009fdc;
    }
    else
    {
      if (cStack_19 == -0x35)
      {
        if (cStack_18 != '\v')
          goto LAB_00009fdc;
      }
      else if ((cStack_19 != 'w') || (cStack_18 != '_'))
        goto LAB_00009fdc;
      if (acStack_17[0] != -0x28)
        goto LAB_00009fdc;
    }
    flash_read(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_read(g_u32MacFlashAddr + 6, 2, auStack_1c);
  }
LAB_00009fdc:
  memcpy(g_zbInfo.macPib.extAddress, auStack_1c, 8);
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void generateIEEEAddr(void)

{
  int iVar1;
  u32 uVar2;
  int iVar3;
  u8 auStack_24[8];
  u8 auStack_1c[2];
  u8 uStack_1a;
  char cStack_19;
  char cStack_18;
  char acStack_17[7];

  flash_read(g_u32MacFlashAddr, 8, auStack_1c);
  iVar1 = memcmp(auStack_1c, &g_invalid_addr, 8);
  iVar3 = _DAT_00800740;
  if (iVar1 == 0)
  {
    do
    {
      uVar2 = drv_u32Rand();
      iVar1 = FUN_00001628(uVar2, 0xfff);
    } while (iVar1 == 0);
    do
    {
    } while ((uint)(_DAT_00800740 - iVar3) <= (uint)(iVar1 << 4));
    drv_generateRandomData(auStack_1c, '\x05');
    memcpy(acStack_17, startIEEEAddr, 3);
    flash_write(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_write(g_u32MacFlashAddr + 6, 2, auStack_1c);
    flash_read(g_u32MacFlashAddr, 8, auStack_24);
    iVar3 = memcmp(auStack_24, &g_invalid_addr, 8);
    if (iVar3 == 0)
    {
      sys_exceptionPost(0xa2, '\x04');
    }
  }
  else
  {
    if (cStack_19 == '8')
    {
      if ((cStack_18 != -0x3f) || (acStack_17[0] != -0x5c))
        goto LAB_00009fdc;
    }
    else if (cStack_19 == -0x2f)
    {
      if ((cStack_18 != '\x19') || (acStack_17[0] != -0x3c))
        goto LAB_00009fdc;
    }
    else
    {
      if (cStack_19 == -0x35)
      {
        if (cStack_18 != '\v')
          goto LAB_00009fdc;
      }
      else if ((cStack_19 != 'w') || (cStack_18 != '_'))
        goto LAB_00009fdc;
      if (acStack_17[0] != -0x28)
        goto LAB_00009fdc;
    }
    flash_read(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_read(g_u32MacFlashAddr + 6, 2, auStack_1c);
  }
LAB_00009fdc:
  memcpy(g_zbInfo.macPib.extAddress, auStack_1c, 8);
  return;
}
u8 gpChangleChannelReqCb(void)

{
  return '\x01';
}
void gpDataCnfPrc(gp_data_cnf_t *pGpDataCnf)

{
  return;
}
void gpSecReqPrc(void *arg)

{
  u8 appId;
  u8 gpdfSecurityLevel;
  undefined uVar1;
  u8 gpdfKeyType;
  undefined uVar2;
  undefined4 uVar3;
  gpSecRsp_status_t gVar4;
  u8 local_38[4];
  u32 uStack_34;

  memcpy(local_38, arg, 0x11);
  uVar3 = *(undefined4 *)((int)arg + 8);
  appId = *(u8 *)((int)arg + 0xc);
  gpdfSecurityLevel = *(u8 *)((int)arg + 0xd);
  uVar1 = *(undefined *)((int)arg + 0xe);
  gpdfKeyType = *(u8 *)((int)arg + 0xf);
  uVar2 = *(undefined *)((int)arg + 0x10);
  memset(arg, 0, 0x22);
  *(u8 *)((int)arg + 0xe) = appId;
  *(undefined *)((int)arg + 0xd) = uVar2;
  *(u8 *)((int)arg + 0xf) = gpdfSecurityLevel;
  memcpy(arg, local_38, 8);
  *(undefined *)((int)arg + 0x20) = uVar1;
  *(char *)((int)arg + 8) = (char)uVar3;
  *(char *)((int)arg + 9) = (char)((uint)uVar3 >> 8);
  *(char *)((int)arg + 10) = (char)((uint)uVar3 >> 0x10);
  *(char *)((int)arg + 0xb) = (char)((uint)uVar3 >> 0x18);
  gVar4 = gpProxySecOperation(appId, (gpdId_t)(ulonglong)CONCAT14(uVar1, uVar3), local_38[0], uStack_34,
                              gpdfSecurityLevel, gpdfKeyType, (u8 *)((int)arg + 0x21),
                              (u8 *)((int)arg + 0x10));
  *(gpSecRsp_status_t *)((int)arg + 0xc) = gVar4;
  tl_zbTaskPost(gpSecRsp, arg);
  return;
}
void gpDataIndPrc(void *arg)

{
  gppGpDataIndProcess((gp_data_ind_t *)arg);
  return;
}
u8 gpDevAnnceCheckCb(u16 aliasNwkAddr, u8 *aliasIeeeAddr)

{
  ev_timer_event_t *peVar1;
  u8 uVar2;
  uint uVar3;
  int iVar4;
  u32 uVar5;
  byte bVar6;
  uint uVar7;
  ev_timer_event_t *peVar8;
  uint uVar9;

  uVar3 = (uint)aliasNwkAddr;
  iVar4 = memcmp(aliasIeeeAddr, &g_invalid_addr, 8);
  peVar1 = g_gppCtx.aliasConflictTimeoutEvt;
  if (iVar4 == 0)
  {
    peVar8 = (ev_timer_event_t *)(ll_reset + 1);
    if ((g_gppCtx.aliasConflictTimeoutEvt != (ev_timer_event_t *)0x0) &&
        (g_gppCtx.gpAliasConflictAddr == uVar3))
    {
      ev_timer_taskCancel(&g_gppCtx.aliasConflictTimeoutEvt);
    }
  }
  else
  {
    peVar8 = (ev_timer_event_t *)(ll_reset + 1);
    if (g_gppCtx.aliasConflictTimeoutEvt == (ev_timer_event_t *)0x0)
    {
      uVar2 = gp_getProxyTabEntryTotalNum();
      peVar8 = (ev_timer_event_t *)0x0;
      if ((uVar2 != '\0') && (peVar8 = peVar1, zclGpAttr_gppMaxProxyTabEntries != '\0'))
      {
        uVar9 = 0;
        do
        {
          uVar7 = (uint)(byte)g_gpProxyTab.gpProxyTab[uVar9].field_0x40;
          if (((int)(uVar7 << 0x1f) >> 0x1f) * -0x1000000 != 0)
          {
            bVar6 = (byte)(uVar3 >> 8);
            if ((uVar7 << 0x1d) >> 0x1e != 0)
            {
              uVar7 = 0;
              do
              {
                iVar4 = memcmp(g_gpProxyTab.gpProxyTab[uVar9].lightweightSinkAddrList + uVar7,
                               aliasIeeeAddr, 8);
                if (iVar4 == 0)
                {
                  *(char *)&g_gpProxyTab.gpProxyTab[uVar9].lightweightSinkAddrList[uVar7].sinkNwkAddr = (char)aliasNwkAddr;
                  *(byte *)((int)&g_gpProxyTab.gpProxyTab[uVar9].lightweightSinkAddrList[uVar7].sinkNwkAddr + 1) = bVar6;
                }
                uVar7 = uVar7 + 1 & 0xff;
              } while (uVar7 < ((uint)(byte)g_gpProxyTab.gpProxyTab[uVar9].field_0x40 << 0x1d) >>
                       0x1e);
            }
            uVar7 = gpAliasSrcAddrDerived();
            if ((uVar7 == uVar3) || (g_gpProxyTab.gpProxyTab[uVar9].gpdAssignedAlias == uVar3))
            {
              tl_zbNwkAddrConflictStatusSend(0xfffd, aliasNwkAddr, '\x01');
              g_gppCtx.gpAliasConflictAddr = aliasNwkAddr & 0xff | (ushort)bVar6 << 8;
              uVar5 = drv_u32Rand();
              iVar4 = FUN_0000162c(uVar5 & 0xffff, 0x28a);
              g_gppCtx.aliasConflictTimeoutEvt =
                  ev_timer_taskPost(gpAliasConflictTimeoutCb, (void *)0x0, iVar4 + 5U & 0xffff);
              peVar8 = (ev_timer_event_t *)(ll_reset + 1);
              goto LAB_0000a17a;
            }
          }
          uVar9 = uVar9 + 1 & 0xff;
        } while (uVar9 < zclGpAttr_gppMaxProxyTabEntries);
        peVar8 = (ev_timer_event_t *)0x0;
      }
    }
  }
LAB_0000a17a:
  return (u8)peVar8;
}
s32 gpAliasConflictTimeoutCb(void *arg)

{
  gpDevAnnceAliasSend(g_gppCtx.gpAliasConflictAddr);
  g_gppCtx.gpAliasConflictAddr = 0xfefd;
  g_gppCtx.aliasConflictTimeoutEvt._0_1_ = 0;
  g_gppCtx.aliasConflictTimeoutEvt._1_1_ = 0;
  g_gppCtx.aliasConflictTimeoutEvt._2_1_ = 0;
  g_gppCtx.aliasConflictTimeoutEvt._3_1_ = 0;
  return -2;
}
void gpCommissioningModeCb(u8 isInCommMode)

{
  if (isInCommMode == '\0')
  {
    zb_nlmePermitJoiningRequest('\0');
  }
  return;
}
void gp_init(u8 endpoint)

{
  gpStubCbInit();
  af_endpointRegister(0xf2, &gp_simpleDesc, zcl_rx_handler, ll_reset);
  zcl_register(0xf2, GP_CB_CLUSTER_NUM, g_gpClusterList);
  gpAppCb = &gpAppCbList;
  gp_proxyInit();
  return;
}
void gpsCommissionModeInvork(void)

{
  return;
}
void gpCommissioningNotificationCmdFromLocalCb(zcl_gp_commissioningNotificationCmd_t *pCmd)

{
  return;
}
status_t zcl_gpCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  status_t sVar1;

  sVar1 = '\0';
  if ((pAddrInfo->dstEp == 0xf2) &&
      (sVar1 = 0x81, (int)((uint)(byte)pAddrInfo->field_0x9 << 0x1f) < 0))
  {
    sVar1 = zcl_gpServerCmdHandler(pAddrInfo, cmdId, cmdPayload);
  }
  return sVar1;
}
s32 gpCommissioningNotificationCmdSend(void *arg)

{
  u8 seqNo;
  int iVar1;

  seqNo = zcl_seqNum;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_gp_commissioningNotificationCmd(0xf2, (epInfo_t *)arg, '\x01', seqNo,
                                      (zcl_gp_commissioningNotificationCmd_t *)((int)arg + 0x12));
  iVar1 = aps_duplicate_check();
  if (iVar1 == 0)
  {
    gpCommissioningNotificationCmdFromLocalCb((zcl_gp_commissioningNotificationCmd_t *)((int)arg + 0x12));
  }
  ev_buf_free((u8 *)arg);
  return -2;
}
void gpCommissioningWindowTimeoutStop(void)

{
  if (g_gppCtx.commissioningWindowTimeoutEvt != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_gppCtx.commissioningWindowTimeoutEvt);
  }
  return;
}
void gpExitCommissioningMode(void)

{
  g_gppCtx.gpCommissioningModeOpt.opts = '\0';
  g_gppCtx.gppInCommMode = '\0';
  g_gppCtx.gpCommissionerAddr = 0xfffd;
  g_gppCtx.gpCommissioningWindow = 0xb4;
  gpTxQueueFree();
  return;
}
s32 gpCommissioningWindowTimeoutCb(void *arg)

{
  gpExitCommissioningMode();
  if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpCommissioningModeCb != ll_reset))
  {
    FUNAAAAM();
  }
  g_gppCtx.commissioningWindowTimeoutEvt = (ev_timer_event_t *)0x0;
  return -2;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAM(void)

{
  code *in_r3;

  (*in_r3)();
  gpProxyTabInit();
  zclGpAttr_gppFunc[0] = '/';
  zclGpAttr_gppFunc[1] = 0xac;
  zclGpAttr_gppFunc[2] = '\t';
  zclGpAttr_gppActiveFunc[0] = 0xff;
  zclGpAttr_gppActiveFunc[1] = 0xff;
  zclGpAttr_gppActiveFunc[2] = 0xff;
  return;
}
void gp_proxyInit(void)

{
  gpProxyTabInit();
  zclGpAttr_gppFunc[0] = '/';
  zclGpAttr_gppFunc[1] = 0xac;
  zclGpAttr_gppFunc[2] = '\t';
  zclGpAttr_gppActiveFunc[0] = 0xff;
  zclGpAttr_gppActiveFunc[1] = 0xff;
  zclGpAttr_gppActiveFunc[2] = 0xff;
  return;
}
void gpProxyCommissioningModeCmdProcess(u16 srcAddr, zcl_gp_proxyCommissioningModeCmd_t *pCmd)

{
  gpProxyCommModeOpt_t gVar1;

  if ((g_gppCtx.gppInCommMode == '\0') || (g_gppCtx.gpCommissionerAddr == srcAddr))
  {
    gVar1.bits = *(anon_struct_1_6_28c719c2_for_bits *)&pCmd->options;
    if ((gVar1.opts & 1) == 0)
    {
      gpCommissioningWindowTimeoutStop();
      gpExitCommissioningMode();
    }
    else
    {
      g_gppCtx.gppInCommMode = '\x01';
      g_gppCtx.gpCommissionerAddr = srcAddr;
      g_gppCtx.gpCommissioningModeOpt.bits = gVar1.bits;
      if ((int)((uint)(pCmd->options).opts << 0x1e) < 0)
      {
        g_gppCtx.gpCommissioningWindow = pCmd->commissioningWindow;
        gpCommissioningWindowTimeoutStop();
        if (g_gppCtx.gpCommissioningWindow != 0)
        {
          g_gppCtx.commissioningWindowTimeoutEvt =
              ev_timer_taskPost(gpCommissioningWindowTimeoutCb, (void *)0x0,
                                (uint)g_gppCtx.gpCommissioningWindow * 1000);
        }
      }
    }
    if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpCommissioningModeCb != ll_reset))
    {
      FUNAAAAN();
    }
  }
  return;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAN(void)

{
  void *in;
  code *in_r3;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined2 uStack_1c;
  undefined uStack_1a;
  byte bStack_18;

  in = (void *)(*in_r3)();
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20._0_2_ = 0;
  uStack_1c = 0;
  uStack_1a = 0;
  g_gppCtx.firstToForward = *(u16 *)((int)in + 0xc) == g_zbInfo.nwkNib.nwkAddr;
  if ((bool)g_gppCtx.firstToForward)
  {
    uStack_20._0_2_ = 0x100;
  }
  uStack_20._0_2_ =
      (ushort)uStack_20 |
      (byte)((byte)((((uint) * (byte *)((int)in + 0xe) << 0x1c) >> 0x1f) << 5) | 1);
  uStack_20._0_3_ =
      CONCAT12((byte)(((uint) * (byte *)((int)in + 0xe) << 0x1d) >> 0x1d), (ushort)uStack_20);
  uStack_20 = (uint)(uint3)uStack_20;
  memcpy(&uStack_28, in, 8);
  uStack_20 = uStack_20 & 0xffffff | (uint) * (byte *)((int)in + 0x10) << 0x18;
  uStack_1c = *(undefined2 *)((int)in + 0x11);
  gpTranimitGPDF();
  if ((uStack_20._1_1_ != '\0') && (*(char *)((int)in + 0x11) == -0xd))
  {
    bStack_18 = **(byte **)((int)in + 8);
    gpSwitchToTransmitChannel(bStack_18 & 0xf, *(u8 *)((int)in + 0xf));
  }
  return;
}
// WARNING: Could not reconcile some variable overlaps
void gpResponseCmdProcess(zcl_gp_responseCmd_t *pCmd)

{
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined2 local_1c;
  undefined local_1a;
  byte local_18;

  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20._0_2_ = 0;
  local_1c = 0;
  local_1a = 0;
  g_gppCtx.firstToForward = pCmd->tempMasterShortAddr == g_zbInfo.nwkNib.nwkAddr;
  if ((bool)g_gppCtx.firstToForward)
  {
    uStack_20._0_2_ = 0x100;
  }
  uStack_20._0_2_ =
      (ushort)uStack_20 | (byte)((byte)((((uint)(pCmd->options).opts << 0x1c) >> 0x1f) << 5) | 1);
  uStack_20._0_3_ = CONCAT12((byte)(((uint)(pCmd->options).opts << 0x1d) >> 0x1d), (ushort)uStack_20);
  uStack_20 = (uint)(uint3)uStack_20;
  memcpy(&uStack_28, pCmd, 8);
  uStack_20 = uStack_20 & 0xffffff | (uint)pCmd->endpoint << 0x18;
  local_1c = *(undefined2 *)&pCmd->gpdCmdID;
  gpTranimitGPDF();
  if ((uStack_20._1_1_ != '\0') && (pCmd->gpdCmdID == 0xf3))
  {
    local_18 = *pCmd->pGpdCmdPayload;
    gpSwitchToTransmitChannel(local_18 & 0xf, pCmd->tempMasterTxChannel);
  }
  return;
}
status_t zcl_gpServerCmdHandler(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  undefined uVar1;
  undefined4 uVar2;
  u8 uVar3;
  byte bVar4;
  byte bVar5;
  u16 uVar6;
  gpProxyTabEntry_t *pgVar7;
  u8 *puVar8;
  u8 *pBuf;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  undefined4 in_stack_ffffffac;
  undefined4 in_stack_ffffffb0;
  uint local_44;
  undefined4 uStack_40;
  uint uStack_3c;
  undefined4 uStack_38;
  undefined2 local_34;
  zcl_gp_proxyTabRspCmd_t local_30;
  undefined2 local_26;

  if (cmdId == '\x02')
  {
    gpProxyCommissioningModeCmdProcess(pAddrInfo->srcAddr, (zcl_gp_proxyCommissioningModeCmd_t *)cmdPayload);
    uVar11 = 0;
    goto LAB_0000a784;
  }
  if (cmdId < 3)
  {
    if (cmdId == '\x01')
    {
      pgVar7 = gp_getProxyTabByGpdId(*(byte *)((int)cmdPayload + 0x10) & 7,
                                     (gpdId_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac));
      uVar9 = (uint) * (byte *)((int)cmdPayload + 0x10);
      if ((int)(uVar9 << 0x1b) < 0)
      {
        uVar11 = 0x8b;
        if (pgVar7 != (gpProxyTabEntry_t *)0x0)
        {
        LAB_0000a7dc:
          gp_proxyTabEntryClear(pgVar7);
          goto LAB_0000a7e2;
        }
      }
      else
      {
        uVar11 = 0x85;
        if (((*(byte *)((int)cmdPayload + 0x10) & 0x60) == 0) ||
            ((*(byte *)((int)cmdPayload + 0x11) & 6) == 2))
          goto LAB_0000aacc;
        if (pgVar7 == (gpProxyTabEntry_t *)0x0)
        {
          uVar11 = 0x8b;
          if (-1 < (int)(uVar9 << 0x1c))
            goto LAB_0000aacc;
          pgVar7 = gp_proxyTabEntryFreeGet();
          if (pgVar7 != (gpProxyTabEntry_t *)0x0)
          {
            uVar9 = (uint) * (byte *)((int)cmdPayload + 0x10);
            goto LAB_0000a8f8;
          }
        LAB_0000adac:
          uVar11 = 0x89;
          goto LAB_0000aacc;
        }
      LAB_0000a8f8:
        uVar11 = uVar9 & 0x60;
        if ((int)(uVar9 << 0x1c) < 0)
        {
          if (uVar11 == 0x60)
          {
            uVar3 = lwSinkAddrListAdd(pgVar7, (u8 *)((int)cmdPayload + 8),
                                      *(u16 *)((int)cmdPayload + 0x28));
          joined_r0x0000ada8:
            if (uVar3 == '\x01')
              goto LAB_0000adac;
          }
          else
          {
            if (uVar11 == 0x40)
            {
              if ((int)((uint) * (byte *)((int)cmdPayload + 0x12) << 0x1f) < 0)
              {
                uVar6 = *(u16 *)((int)cmdPayload + 0x2c);
              }
              else
              {
                uVar6 = 0xffff;
              }
              uVar3 = sinkGroupListAdd(pgVar7, *(u16 *)((int)cmdPayload + 0x2a), uVar6);
              goto joined_r0x0000ada8;
            }
            if (uVar11 == 0x20)
            {
              *(byte *)((int)&pgVar7->options + 1) =
                  *(byte *)((int)&pgVar7->options + 1) & 0xdf |
                  (byte)((*(byte *)((int)cmdPayload + 0x12) & 1) << 5);
              uVar1 = *(undefined *)((int)cmdPayload + 0x2d);
              *(undefined *)&pgVar7->gpdAssignedAlias = *(undefined *)((int)cmdPayload + 0x2c);
              *(undefined *)((int)&pgVar7->gpdAssignedAlias + 1) = uVar1;
            }
          }
          if (-1 < (int)((uint)(byte)pgVar7->field_0x40 << 0x1f))
          {
            pgVar7->field_0x40 = pgVar7->field_0x40 | 1;
            g_gpProxyTab.gpProxyTabNum = g_gpProxyTab.gpProxyTabNum + '\x01';
          }
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0xf8 | *(byte *)((int)cmdPayload + 0x10) & 7;
          *(byte *)&pgVar7->options = *(byte *)&pgVar7->options | 8;
          *(byte *)&pgVar7->options = *(byte *)&pgVar7->options | 0x10;
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0xdf |
              (byte)((((uint) * (byte *)&pgVar7->options << 0x1a |
                       (uint) * (byte *)((int)cmdPayload + 0x11) << 0x1f) >>
                      0x1f)
                     << 5);
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0xbf |
              (byte)((((uint) * (byte *)&pgVar7->options << 0x19) >> 0x1f |
                      (0x5f < (*(byte *)((int)cmdPayload + 0x10) & 0x60)) - 1 & 1)
                     << 6);
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0x7f |
              (byte)(((uint)(*(byte *)&pgVar7->options >> 7) |
                      (0x1f < (*(byte *)((int)cmdPayload + 0x10) & 0x60)) - 1)
                     << 7);
          bVar4 = *(byte *)((int)&pgVar7->options + 1);
          *(byte *)((int)&pgVar7->options + 1) =
              bVar4 & 0xfe |
              (byte)(((uint)bVar4 << 0x1f) >> 0x1f) |
              (0x3f < (*(byte *)((int)cmdPayload + 0x10) & 0x60)) - 1U & 1;
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0xfd;
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0xfb;
          bVar4 = *(byte *)((int)&pgVar7->options + 1);
          *(byte *)((int)&pgVar7->options + 1) =
              bVar4 & 0xf7 |
              (byte)((((uint)bVar4 << 0x1c) >> 0x1f |
                      (uint)(*(byte *)((int)cmdPayload + 0x10) >> 7))
                     << 3);
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0xef | 0x10;
          *(byte *)((int)&pgVar7->options + 1) =
              *(byte *)((int)&pgVar7->options + 1) & 0xbf |
              (1 < ((uint) * (byte *)((int)cmdPayload + 0x11) << 0x1d) >> 0x1e) << 6;
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0x7f;
          if ((*(byte *)&pgVar7->options & 7) == 0)
          {
            // WARNING: Load size is inaccurate
            uVar2 = *cmdPayload;
            (pgVar7->gpdId).gpdIeeeAddr[0] = (u8)uVar2;
            (pgVar7->gpdId).gpdIeeeAddr[1] = (u8)((uint)uVar2 >> 8);
            (pgVar7->gpdId).gpdIeeeAddr[2] = (u8)((uint)uVar2 >> 0x10);
            (pgVar7->gpdId).gpdIeeeAddr[3] = (u8)((uint)uVar2 >> 0x18);
          }
          else if ((*(byte *)&pgVar7->options & 7) == 2)
          {
            memcpy(pgVar7, cmdPayload, 8);
          }
          pgVar7->endpoint = *(u8 *)((int)cmdPayload + 0x2e);
          (pgVar7->secOptions).opts =
              (pgVar7->secOptions).opts & 0xfc | *(byte *)((int)cmdPayload + 0x11) >> 1 & 3;
          (pgVar7->secOptions).opts =
              (pgVar7->secOptions).opts & 0xe3 |
              (byte)((((uint) * (byte *)((int)cmdPayload + 0x11) << 0x1a) >> 0x1d) << 2);
          uVar2 = *(undefined4 *)((int)cmdPayload + 0x14);
          *(char *)&pgVar7->gpdSecFrameCnt = (char)uVar2;
          *(char *)((int)&pgVar7->gpdSecFrameCnt + 1) = (char)((uint)uVar2 >> 8);
          *(char *)((int)&pgVar7->gpdSecFrameCnt + 2) = (char)((uint)uVar2 >> 0x10);
          *(char *)((int)&pgVar7->gpdSecFrameCnt + 3) = (char)((uint)uVar2 >> 0x18);
          memcpy(pgVar7->gpdKey, (void *)((int)cmdPayload + 0x18), 0x10);
          if ((int)((uint) * (byte *)((int)cmdPayload + 0x12) << 0x1e) < 0)
          {
            uVar3 = *(u8 *)((int)cmdPayload + 0x30);
          }
          else
          {
            uVar3 = pgVar7->groupcastRadius;
          }
          pgVar7->groupcastRadius = uVar3;
          pgVar7->searchCnt = '\0';
        }
        else
        {
          if (uVar11 == 0x60)
          {
            uVar3 = lwSinkAddrListRemove(pgVar7, (u8 *)((int)cmdPayload + 8), *(u16 *)((int)cmdPayload + 0x28));
          joined_r0x0000ade8:
            if (uVar3 == '\x01')
            {
              uVar11 = 0x8b;
              goto LAB_0000aacc;
            }
          }
          else if (uVar11 == 0x40)
          {
            uVar3 = sinkGroupListRemove(pgVar7, *(u16 *)((int)cmdPayload + 0x2a));
            goto joined_r0x0000ade8;
          }
          if (((pgVar7->field_0x40 & 0x1e) == 0) && ((*(byte *)&pgVar7->options & 0x80) == 0))
            goto LAB_0000a7dc;
        }
      LAB_0000a7e2:
        gpProxyTabUpdate();
        if ((g_gppCtx.gppInCommMode != '\0') &&
            ((int)((uint)g_gppCtx.gpCommissioningModeOpt.opts << 0x1d) < 0))
        {
          gpCommissioningWindowTimeoutStop();
          gpExitCommissioningMode();
          if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpCommissioningModeCb != ll_reset))
          {
            FUNAAAAP();
            uVar11 = 0;
            goto LAB_0000aacc;
          }
        }
        uVar11 = 0;
      }
    LAB_0000aacc:
      uVar10 = (uint)g_zbInfo.nwkNib.nwkAddr;
      uVar9 = gpAliasSrcAddrDerived();
      if ((uVar10 == uVar9) || (g_zbInfo.nwkNib.nwkAddr == *(u16 *)((int)cmdPayload + 0x2c)))
      {
        tl_zbNwkAddrConflictStatusSend(0xfffd, g_zbInfo.nwkNib.nwkAddr, '\x01');
        uVar6 = tl_zbNwkStochasticAddrCal();
        g_zbInfo.macPib.shortAddress._0_1_ = (undefined)uVar6;
        g_zbInfo.macPib.shortAddress._1_1_ = (byte)((uint)uVar6 >> 8);
        g_zbInfo.nwkNib.nwkAddr = uVar6 & 0xff | (ushort)g_zbInfo.macPib.shortAddress._1_1_ << 8;
        local_26 = 0;
        tl_zbNwkAddrMapAdd(uVar6, (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac),
                           (u16 *)g_zbInfo.macPib.extAddress);
        zb_info_save((void *)0x0);
        zb_zdoSendDevAnnance();
      }
      goto LAB_0000a784;
    }
  }
  else
  {
    if (cmdId == '\x06')
    {
      gpResponseCmdProcess((zcl_gp_responseCmd_t *)cmdPayload);
      uVar11 = 0;
      goto LAB_0000a784;
    }
    if (cmdId == '\v')
    {
      uStack_40 = 0;
      local_34 = 0;
      local_44 = (uint)pAddrInfo->srcAddr;
      uStack_38 = CONCAT13(pAddrInfo->srcEp, 0x20000);
      uStack_3c = (uint)pAddrInfo->profileId;
      local_30.proxyTabEntry = (u8 *)0x0;
      local_30._4_4_ = 0;
      local_30.entriesCnt = '\0';
      uVar3 = gp_getProxyTabEntryTotalNum();
      uVar11 = local_30._4_4_;
      local_30._4_3_ = CONCAT12(uVar3, local_30._4_2_);
      local_30._4_4_ = local_30._4_4_ & 0xff000000 | (uint)local_30._4_3_;
      if (uVar3 == '\0')
      {
        bVar4 = 0xff;
        if ((*(byte *)((int)cmdPayload + 8) & 0x18) != 0)
        {
          bVar4 = *(byte *)((int)cmdPayload + 10);
        }
        local_30._4_4_ = local_30._4_3_ & 0xffff0000 | (uint)bVar4 << 0x18 | 0x8b00;
        local_30.entriesCnt = '\0';
      }
      else
      {
        bVar4 = *(byte *)((int)cmdPayload + 8);
        if ((bVar4 & 0x18) == 0)
        {
          pgVar7 = gp_getProxyTabByGpdId(bVar4 & 7, (gpdId_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac));
          if (pgVar7 != (gpProxyTabEntry_t *)0x0)
          {
            bVar4 = gp_getProxyTabEntryLen(pgVar7);
            puVar8 = ev_buf_allocate((ushort)bVar4);
            uVar11 = 0;
            if (puVar8 == (u8 *)0x0)
              goto LAB_0000a784;
            memset(puVar8, 0, (uint)bVar4);
            gp_buildProxyTabEntryFormat(pgVar7, puVar8);
            local_30._4_4_ = CONCAT13(0xff, (uint3)local_30._4_4_ & 0xff0000);
            local_30.entriesCnt = '\x01';
            local_30._4_4_ = local_30._4_4_ | bVar4;
          LAB_0000abf0:
            local_30.proxyTabEntry = puVar8;
            puVar8 = local_30.proxyTabEntry;
            zcl_gp_proxyTableRspCmd(0xf2, (epInfo_t *)&local_44, '\x01', pAddrInfo->seqNum, &local_30);
            ev_buf_free(puVar8);
            uVar11 = 0;
            goto LAB_0000a784;
          }
          local_30._4_3_ = (uint3)local_30._4_4_ & 0xff0000 | 0x8b00;
          local_30._4_4_ = CONCAT13(0xff, local_30._4_3_);
          local_30.entriesCnt = '\0';
        }
        else if ((bVar4 & 0x18) == 8)
        {
          local_30._4_2_ = CONCAT11(0x8b, (u8)uVar11);
          local_30._4_3_ = CONCAT12(uVar3, local_30._4_2_);
          local_30._4_4_ = CONCAT13(*(undefined *)((int)cmdPayload + 10), local_30._4_3_);
          if (zclGpAttr_gppMaxProxyTabEntries == '\0')
          {
            local_30._4_4_ = local_30._4_4_ & 0xffffff00;
          }
          else
          {
            bVar4 = 0;
            uVar11 = 0;
            uVar9 = 0;
            do
            {
              uVar10 = uVar9;
              if ((((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar11].field_0x40 << 0x1f) >> 0x1f) *
                       -0x1000000 !=
                   0) &&
                  (bVar4 = bVar4 + 1, *(byte *)((int)cmdPayload + 10) < bVar4))
              {
                bVar5 = gp_getProxyTabEntryLen(g_gpProxyTab.gpProxyTab + uVar11);
                uVar10 = bVar5 + uVar9 & 0xff;
                if (0x4a < uVar10)
                  break;
                local_30.entriesCnt = local_30.entriesCnt + '\x01';
              }
              uVar11 = uVar11 + 1 & 0xff;
              uVar9 = uVar10;
            } while (uVar11 < zclGpAttr_gppMaxProxyTabEntries);
            uVar3 = local_30.entriesCnt;
            uVar11 = local_30._4_4_;
            local_30._4_4_ = local_30._4_4_ & 0xffffff00 | uVar9 & 0xff;
            if (uVar9 != 0)
            {
              local_30._4_4_ = uVar11 & 0xffff0000 | uVar9 & 0xff;
              puVar8 = ev_buf_allocate((u16)uVar9);
              uVar11 = 0;
              if (puVar8 == (u8 *)0x0)
                goto LAB_0000a784;
              memset(puVar8, 0, uVar9);
              if (zclGpAttr_gppMaxProxyTabEntries != '\0')
              {
                bVar4 = 0;
                pBuf = puVar8;
                do
                {
                  if ((((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar11].field_0x40 << 0x1f) >>
                        0x1f) *
                           -0x1000000 !=
                       0) &&
                      (bVar4 = bVar4 + 1, *(byte *)((int)cmdPayload + 10) < bVar4))
                  {
                    if (uVar3 == '\0')
                      break;
                    bVar5 = gp_buildProxyTabEntryFormat(g_gpProxyTab.gpProxyTab + uVar11, pBuf);
                    pBuf = pBuf + bVar5;
                    uVar3 = uVar3 + 0xff;
                  }
                  uVar11 = uVar11 + 1 & 0xff;
                } while (uVar11 < zclGpAttr_gppMaxProxyTabEntries);
              }
              goto LAB_0000abf0;
            }
          }
        }
      }
      zcl_gp_proxyTableRspCmd(0xf2, (epInfo_t *)&local_44, '\x01', pAddrInfo->seqNum, &local_30);
      uVar11 = 0;
      goto LAB_0000a784;
    }
  }
  uVar11 = 0x81;
LAB_0000a784:
  return (status_t)uVar11;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAP(void)

{
  char cVar1;
  u8 appId;
  u16 uVar2;
  undefined4 uVar3;
  byte bVar4;
  undefined2 uVar5;
  ushort uVar6;
  int *piVar7;
  gpProxyTabEntry_t *pgVar8;
  u8 *dest;
  uint uVar9;
  u8 uVar10;
  code *in_r3;
  int iVar11;
  uint uVar12;
  bool bVar13;
  undefined4 in_stack_ffffffa8;
  uint uStack_3c;
  undefined4 uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  ushort uStack_2c;
  int iStack_28;
  undefined4 uStack_24;

  piVar7 = (int *)(*in_r3)();
  if (piVar7 == (int *)0x0)
  {
    return;
  }
  if (g_gppCtx.gppInCommMode == '\0')
  {
    if (*(char *)(piVar7 + 7) == '\x03')
    {
      return;
    }
    uVar10 = *(u8 *)((int)piVar7 + 0x21);
    if (uVar10 == '\0')
    {
      iVar11 = piVar7[1];
    }
    else
    {
      if (uVar10 != '\x02')
        goto LAB_0000ae92;
      iVar11 = memcmp(piVar7 + 4, &g_zero_addr, 8);
    }
    if (iVar11 == 0)
    {
      return;
    }
  LAB_0000ae92:
    if ((byte)(*(char *)((int)piVar7 + 0x25) + 0x1eU) < 2)
    {
      return;
    }
    iVar11 = 0;
    appId = '\0';
    iStack_28 = 0;
    uStack_24 = 0;
    if (uVar10 == '\0')
    {
      iStack_28 = piVar7[1];
    }
    else if (uVar10 == '\x02')
    {
      memcpy(&iStack_28, piVar7 + 4, 8);
    }
    pgVar8 = gp_getProxyTabByGpdId(uVar10, (gpdId_t)CONCAT44(iVar11, in_stack_ffffffa8));
    if (pgVar8 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    bVar4 = *(byte *)((int)&pgVar8->options + 1);
    if (-1 < (int)((uint)bVar4 << 0x1d))
    {
      *(byte *)((int)&pgVar8->options + 1) = bVar4 | 4;
    }
    if ((byte)(*(char *)(piVar7 + 7) - 3U) < 2)
    {
      return;
    }
    if (*(char *)((int)piVar7 + 0x22) == '\0')
    {
      uVar12 = (uint) * (byte *)((int)piVar7 + 0x1f);
    }
    else
    {
      uVar12 = piVar7[2];
    }
    *(char *)&pgVar8->gpdSecFrameCnt = (char)uVar12;
    *(char *)((int)&pgVar8->gpdSecFrameCnt + 1) = (char)(uVar12 >> 8);
    *(char *)((int)&pgVar8->gpdSecFrameCnt + 2) = (char)(uVar12 >> 0x10);
    *(char *)((int)&pgVar8->gpdSecFrameCnt + 3) = (char)(uVar12 >> 0x18);
    if (*(char *)((int)piVar7 + 0x21) == '\0')
    {
      appId = '\0';
      iVar11 = piVar7[1];
    }
    else if (*(char *)((int)piVar7 + 0x21) == '\x02')
    {
      appId = '\x02';
      memcpy(&stack0xffffffac, piVar7 + 4, 8);
    }
    gpProxyTabUpdate();
    uStack_3c = 0;
    uStack_38 = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    uStack_2c = 0;
    pgVar8 = gp_getProxyTabByGpdId(appId, (gpdId_t)CONCAT44(iVar11, in_stack_ffffffa8));
    uVar3 = uStack_30;
    if (pgVar8 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
    uStack_34 = uStack_34 & 0xffff0000 | 0xa1e0;
    uStack_2c = uStack_2c & 0xff |
                (ushort)(pgVar8->groupcastRadius & ~(1U - (pgVar8->groupcastRadius == 0xff))) << 8;
    bVar4 = *(byte *)&pgVar8->options;
    if ((bVar4 & 0x40) != 0)
    {
      uStack_30._0_2_ = (ushort)uVar3;
      uStack_30._0_3_ = CONCAT12(2, (ushort)uStack_30);
      uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
      uStack_30 = uStack_30 & 0xffffff00;
      if (((uint)(byte)pgVar8->field_0x40 << 0x1d) >> 0x1e != 0)
      {
        uVar12 = 0;
        do
        {
          uVar10 = zcl_seqNum;
          uStack_3c = uStack_3c & 0xffff0000 |
                      (uint)pgVar8->lightweightSinkAddrList[uVar12].sinkNwkAddr;
          zcl_seqNum = zcl_seqNum + '\x01';
          zcl_gp_notificationCmd(0xf2, (epInfo_t *)&uStack_3c, '\x01', uVar10,
                                 (zcl_gp_notificationCmd_t *)&stack0xffffffac);
          uVar12 = uVar12 + 1 & 0xff;
        } while (uVar12 < ((uint)(byte)pgVar8->field_0x40 << 0x1d) >> 0x1e);
      }
      bVar4 = *(byte *)&pgVar8->options;
    }
    if ((bVar4 & 0x80) != 0)
    {
      uStack_30._0_3_ = CONCAT12(1, (ushort)uStack_30);
      uStack_30 = uStack_30 & 0xff000000 | (uint)(uint3)uStack_30;
      uVar6 = gpAliasSrcAddrDerived();
      uStack_3c = uStack_3c & 0xffff0000 | (uint)uVar6;
      uStack_30 = CONCAT31(uStack_30._1_3_, 1);
      if ((int)((uint) * (byte *)((int)&pgVar8->options + 1) << 0x1a) < 0)
      {
        uVar6 = pgVar8->gpdAssignedAlias;
      }
      else
      {
        uVar6 = gpAliasSrcAddrDerived();
      }
      uVar10 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar6 << 0x10;
      uStack_30._0_2_ = CONCAT11(*(undefined *)((int)piVar7 + 0x1f), (u8)uStack_30);
      uStack_30 = uStack_30 & 0xffff0000 | (uint)(ushort)uStack_30;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&uStack_3c, '\x01', uVar10,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
    }
    if ((*(byte *)((int)&pgVar8->options + 1) & 1) == 0)
    {
      return;
    }
    uStack_30._0_2_ = CONCAT11(*(char *)((int)piVar7 + 0x1f) + -9, 1);
    uStack_30 = uStack_30 & 0xff000000 | (uint)(ushort)uStack_30 | 0x10000;
    if (((uint)(byte)pgVar8->field_0x40 << 0x1b) >> 0x1e == 0)
    {
      return;
    }
    uVar12 = 0;
    do
    {
      uStack_3c = uStack_3c & 0xffff0000 |
                  (uint)CONCAT11(*(undefined *)((int)&pgVar8->sinkGroupList[uVar12].groupId + 1),
                                 *(undefined *)&pgVar8->sinkGroupList[uVar12].groupId);
      uVar6 = pgVar8->sinkGroupList[uVar12].alias;
      if (uVar6 == 0xffff)
      {
        uVar6 = gpAliasSrcAddrDerived();
      }
      uVar10 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar6 << 0x10;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&uStack_3c, '\x01', uVar10,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
      uVar12 = uVar12 + 1 & 0xff;
    } while (uVar12 < ((uint)(byte)pgVar8->field_0x40 << 0x1b) >> 0x1e);
    return;
  }
  cVar1 = *(char *)((int)piVar7 + 0x25);
  if (cVar1 == -0x1d)
  {
    if (*(char *)((int)piVar7 + 0x27) == '\0')
    {
      return;
    }
    if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpChangleChannelReqCb != ll_reset))
    {
      iVar11 = FUNAAAAR();
      if (iVar11 == 0)
      {
        return;
      }
      goto LAB_0000b240;
    }
  }
  else
  {
    if (cVar1 == -0x10)
    {
      return;
    }
    if (cVar1 == -0xd)
    {
      return;
    }
    if (((cVar1 == -0x1e) || (cVar1 == -0x20)) && (*(char *)((int)piVar7 + 0x1a) != '\0'))
    {
      return;
    }
  LAB_0000b240:
    if (*(char *)((int)piVar7 + 0x27) == '\0')
    {
      if (*(char *)((int)piVar7 + 0x21) == '\0')
      {
        iVar11 = piVar7[1];
      }
      else
      {
        if (*(char *)((int)piVar7 + 0x21) != '\x02')
          goto LAB_0000b268;
        iVar11 = memcmp(piVar7 + 4, &g_zero_addr, 8);
      }
      if (iVar11 == 0)
      {
        return;
      }
    }
  }
LAB_0000b268:
  dest = ev_buf_allocate(0x2e);
  if (dest == (u8 *)0x0)
  {
    return;
  }
  memset(dest, 0, 0x2e);
  if (*(char *)((int)piVar7 + 0x25) == -0x1d)
  {
  LAB_0000b650:
    dest[0x26] = dest[0x26] | 8;
  }
  else
  {
    if (*(char *)((int)piVar7 + 0x21) == '\0')
    {
      dest[0x26] = dest[0x26] & 0xf8;
      iVar11 = piVar7[1];
      dest[0x12] = (u8)iVar11;
      dest[0x13] = (u8)((uint)iVar11 >> 8);
      dest[0x14] = (u8)((uint)iVar11 >> 0x10);
      dest[0x15] = (u8)((uint)iVar11 >> 0x18);
    LAB_0000b2be:
      if (*(char *)((int)piVar7 + 0x25) == -0x1d)
        goto LAB_0000b650;
    }
    else if (*(char *)((int)piVar7 + 0x21) == '\x02')
    {
      dest[0x26] = dest[0x26] & 0xf8 | 2;
      memcpy(dest + 0x12, piVar7 + 4, 8);
      dest[0x2a] = *(u8 *)(piVar7 + 9);
      goto LAB_0000b2be;
    }
    dest[0x26] = dest[0x26] & 0xf7 | (byte)((*(byte *)((int)piVar7 + 0x1b) & 1) << 3);
  }
  dest[0x26] = dest[0x26] & 0xcf | (byte)((*(byte *)((int)piVar7 + 0x22) & 3) << 4);
  dest[0x26] = dest[0x26] & 0x3f | (byte)((*(byte *)((int)piVar7 + 0x23) & 3) << 6);
  dest[0x27] = dest[0x27] & 0xfe | *(byte *)((int)piVar7 + 0x23) >> 2 & 1;
  if ((byte)(*(char *)(piVar7 + 7) - 3U) < 2)
  {
    dest[0x27] = dest[0x27] | 2;
    iVar11 = piVar7[3];
    dest[0x22] = (u8)iVar11;
    dest[0x23] = (u8)((uint)iVar11 >> 8);
    dest[0x24] = (u8)((uint)iVar11 >> 0x10);
    dest[0x25] = (u8)((uint)iVar11 >> 0x18);
  }
  else
  {
    dest[0x27] = dest[0x27] & 0xfd;
    dest[0x22] = 0xfe;
    dest[0x23] = 0xfe;
    dest[0x24] = 0xfe;
    dest[0x25] = 0xfe;
  }
  dest[0x27] = dest[0x27] & 0xfb;
  dest[0x27] = dest[0x27] | 8;
  iVar11 = piVar7[2];
  dest[0x1e] = (u8)iVar11;
  dest[0x1f] = (u8)((uint)iVar11 >> 8);
  dest[0x20] = (u8)((uint)iVar11 >> 0x10);
  dest[0x21] = (u8)((uint)iVar11 >> 0x18);
  dest[0x2b] = *(u8 *)((int)piVar7 + 0x25);
  uVar10 = *(char *)((int)piVar7 + 0x26) + 0xff;
  dest[0x2c] = uVar10;
  if (uVar10 != '\0')
  {
    iVar11 = *piVar7 + 1;
    dest[0x1a] = (u8)iVar11;
    dest[0x1b] = (u8)((uint)iVar11 >> 8);
    dest[0x1c] = (u8)((uint)iVar11 >> 0x10);
    dest[0x1d] = (u8)((uint)iVar11 >> 0x18);
  }
  uVar2 = g_zbInfo.nwkNib.nwkAddr;
  dest[0x28] = (u8)g_zbInfo.nwkNib.nwkAddr;
  dest[0x29] = (u8)(uVar2 >> 8);
  bVar4 = *(byte *)((int)piVar7 + 0x1d);
  uVar12 = (uint)bVar4;
  if ((char)bVar4 + 0x6d < 0 != SCARRY4((int)(char)bVar4, 0x6d))
  {
    uVar12 = 0xffffff92;
  }
  uVar9 = uVar12 & 0xff;
  if ('\b' < (char)uVar12)
  {
    uVar9 = 8;
  }
  iVar11 = (uVar9 + 0x6e) * 0x1000000;
  dest[0x2d] = dest[0x2d] & 0xc0 | (byte)((iVar11 >> 0x18) - (iVar11 >> 0x1f) >> 1) & 0x3f;
  bVar13 = *(char *)((int)piVar7 + 0x1e) != '\0';
  bVar4 = bVar13 * '\x02';
  dest[0x2d] = dest[0x2d] & 0x3f | bVar13 * -0x80;
  dest[0xe] = '\x02';
  uVar2 = g_gppCtx.gpCommissionerAddr;
  if ((int)((uint)g_gppCtx.gpCommissioningModeOpt.opts << 0x1a) < 0)
  {
    *dest = (u8)g_gppCtx.gpCommissionerAddr;
    dest[1] = (u8)(uVar2 >> 8);
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
    if ((uVar2 & 0xfff8) != 0xfff8)
    {
      dest[0xc] = '\0';
      goto LAB_0000b458;
    }
  }
  else
  {
    *dest = 0xfc;
    dest[1] = 0xfe;
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
  }
  dest[0xc] = '\x01';
  uVar5 = gpAliasSrcAddrDerived();
  dest[10] = (u8)uVar5;
  dest[0xb] = (u8)((ushort)uVar5 >> 8);
  dest[0xd] = *(char *)((int)piVar7 + 0x1f) + 0xf4;
  bVar4 = dest[0x2d] >> 6;
LAB_0000b458:
  bVar4 = gppTunnelingDelayGet(SUB41(((uint)dest[0x26] << 0x1c) >> 0x1f, 0), bVar4, (bool)g_gppCtx.firstToForward, false);
  ev_timer_taskPost(gpCommissioningNotificationCmdSend, dest, (uint)bVar4);
  return;
}
// WARNING: Could not reconcile some variable overlaps
void gppGpDataIndProcess(gp_data_ind_t *pGpDataInd)

{
  u8 appId;
  u16 uVar1;
  undefined4 uVar2;
  byte bVar3;
  undefined2 uVar4;
  ushort uVar5;
  gpProxyTabEntry_t *pgVar6;
  u32 uVar7;
  u8 *dest;
  uint uVar8;
  u8 uVar9;
  u8 *puVar10;
  uint uVar11;
  int iVar12;
  u32 uVar13;
  bool bVar14;
  undefined4 in_stack_ffffffa8;
  uint local_3c;
  undefined4 uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  ushort local_2c;
  u32 uStack_28;
  undefined4 uStack_24;

  if (pGpDataInd == (gp_data_ind_t *)0x0)
  {
    return;
  }
  if (g_gppCtx.gppInCommMode == '\0')
  {
    if (pGpDataInd->status == '\x03')
    {
      return;
    }
    uVar9 = pGpDataInd->appId;
    if (uVar9 == '\0')
    {
      uVar7 = pGpDataInd->srcId;
    }
    else
    {
      if (uVar9 != '\x02')
        goto LAB_0000ae92;
      uVar7 = memcmp(&pGpDataInd->srcAddr, &g_zero_addr, 8);
    }
    if (uVar7 == 0)
    {
      return;
    }
  LAB_0000ae92:
    if ((byte)(pGpDataInd->gpdCmdId + 0x1e) < 2)
    {
      return;
    }
    uVar7 = 0;
    appId = '\0';
    uStack_28 = 0;
    uStack_24 = 0;
    if (uVar9 == '\0')
    {
      uStack_28 = pGpDataInd->srcId;
    }
    else if (uVar9 == '\x02')
    {
      memcpy(&uStack_28, &pGpDataInd->srcAddr, 8);
    }
    pgVar6 = gp_getProxyTabByGpdId(uVar9, (gpdId_t)CONCAT44(uVar7, in_stack_ffffffa8));
    if (pgVar6 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    bVar3 = *(byte *)((int)&pgVar6->options + 1);
    if (-1 < (int)((uint)bVar3 << 0x1d))
    {
      *(byte *)((int)&pgVar6->options + 1) = bVar3 | 4;
    }
    if ((byte)(pGpDataInd->status - 3) < 2)
    {
      return;
    }
    if (pGpDataInd->gpdfSecurityLevel == '\0')
    {
      uVar13 = (u32)pGpDataInd->seqNum;
    }
    else
    {
      uVar13 = pGpDataInd->gpdSecFrameCnt;
    }
    *(char *)&pgVar6->gpdSecFrameCnt = (char)uVar13;
    *(char *)((int)&pgVar6->gpdSecFrameCnt + 1) = (char)(uVar13 >> 8);
    *(char *)((int)&pgVar6->gpdSecFrameCnt + 2) = (char)(uVar13 >> 0x10);
    *(char *)((int)&pgVar6->gpdSecFrameCnt + 3) = (char)(uVar13 >> 0x18);
    if (pGpDataInd->appId == '\0')
    {
      appId = '\0';
      uVar7 = pGpDataInd->srcId;
    }
    else if (pGpDataInd->appId == '\x02')
    {
      appId = '\x02';
      memcpy(&stack0xffffffac, &pGpDataInd->srcAddr, 8);
    }
    gpProxyTabUpdate();
    local_3c = 0;
    uStack_38 = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    local_2c = 0;
    pgVar6 = gp_getProxyTabByGpdId(appId, (gpdId_t)CONCAT44(uVar7, in_stack_ffffffa8));
    uVar2 = uStack_30;
    if (pgVar6 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
    uStack_34 = uStack_34 & 0xffff0000 | 0xa1e0;
    local_2c = local_2c & 0xff |
               (ushort)(pgVar6->groupcastRadius & ~(1U - (pgVar6->groupcastRadius == 0xff))) << 8;
    bVar3 = *(byte *)&pgVar6->options;
    if ((bVar3 & 0x40) != 0)
    {
      uStack_30._0_2_ = (ushort)uVar2;
      uStack_30._0_3_ = CONCAT12(2, (ushort)uStack_30);
      uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
      uStack_30 = uStack_30 & 0xffffff00;
      if (((uint)(byte)pgVar6->field_0x40 << 0x1d) >> 0x1e != 0)
      {
        uVar11 = 0;
        do
        {
          uVar9 = zcl_seqNum;
          local_3c = local_3c & 0xffff0000 |
                     (uint)pgVar6->lightweightSinkAddrList[uVar11].sinkNwkAddr;
          zcl_seqNum = zcl_seqNum + '\x01';
          zcl_gp_notificationCmd(0xf2, (epInfo_t *)&local_3c, '\x01', uVar9,
                                 (zcl_gp_notificationCmd_t *)&stack0xffffffac);
          uVar11 = uVar11 + 1 & 0xff;
        } while (uVar11 < ((uint)(byte)pgVar6->field_0x40 << 0x1d) >> 0x1e);
      }
      bVar3 = *(byte *)&pgVar6->options;
    }
    if ((bVar3 & 0x80) != 0)
    {
      uStack_30._0_3_ = CONCAT12(1, (ushort)uStack_30);
      uStack_30 = uStack_30 & 0xff000000 | (uint)(uint3)uStack_30;
      uVar5 = gpAliasSrcAddrDerived();
      local_3c = local_3c & 0xffff0000 | (uint)uVar5;
      uStack_30 = CONCAT31(uStack_30._1_3_, 1);
      if ((int)((uint) * (byte *)((int)&pgVar6->options + 1) << 0x1a) < 0)
      {
        uVar5 = pgVar6->gpdAssignedAlias;
      }
      else
      {
        uVar5 = gpAliasSrcAddrDerived();
      }
      uVar9 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar5 << 0x10;
      uStack_30._0_2_ = CONCAT11(pGpDataInd->seqNum, (u8)uStack_30);
      uStack_30 = uStack_30 & 0xffff0000 | (uint)(ushort)uStack_30;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&local_3c, '\x01', uVar9,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
    }
    if ((*(byte *)((int)&pgVar6->options + 1) & 1) == 0)
    {
      return;
    }
    uStack_30._0_2_ = CONCAT11(pGpDataInd->seqNum + 0xf7, 1);
    uStack_30 = uStack_30 & 0xff000000 | (uint)(ushort)uStack_30 | 0x10000;
    if (((uint)(byte)pgVar6->field_0x40 << 0x1b) >> 0x1e == 0)
    {
      return;
    }
    uVar11 = 0;
    do
    {
      local_3c = local_3c & 0xffff0000 |
                 (uint)CONCAT11(*(undefined *)((int)&pgVar6->sinkGroupList[uVar11].groupId + 1),
                                *(undefined *)&pgVar6->sinkGroupList[uVar11].groupId);
      uVar5 = pgVar6->sinkGroupList[uVar11].alias;
      if (uVar5 == 0xffff)
      {
        uVar5 = gpAliasSrcAddrDerived();
      }
      uVar9 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar5 << 0x10;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&local_3c, '\x01', uVar9,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
      uVar11 = uVar11 + 1 & 0xff;
    } while (uVar11 < ((uint)(byte)pgVar6->field_0x40 << 0x1b) >> 0x1e);
    return;
  }
  uVar9 = pGpDataInd->gpdCmdId;
  if (uVar9 == 0xe3)
  {
    if (pGpDataInd->frameType == '\0')
    {
      return;
    }
    if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpChangleChannelReqCb != ll_reset))
    {
      iVar12 = FUNAAAAR();
      if (iVar12 == 0)
      {
        return;
      }
      goto LAB_0000b240;
    }
  }
  else
  {
    if (uVar9 == 0xf0)
    {
      return;
    }
    if (uVar9 == 0xf3)
    {
      return;
    }
    if (((uVar9 == 0xe2) || (uVar9 == 0xe0)) && (pGpDataInd->autoCommissioning != '\0'))
    {
      return;
    }
  LAB_0000b240:
    if (pGpDataInd->frameType == '\0')
    {
      if (pGpDataInd->appId == '\0')
      {
        uVar7 = pGpDataInd->srcId;
      }
      else
      {
        if (pGpDataInd->appId != '\x02')
          goto LAB_0000b268;
        uVar7 = memcmp(&pGpDataInd->srcAddr, &g_zero_addr, 8);
      }
      if (uVar7 == 0)
      {
        return;
      }
    }
  }
LAB_0000b268:
  dest = ev_buf_allocate(0x2e);
  if (dest == (u8 *)0x0)
  {
    return;
  }
  memset(dest, 0, 0x2e);
  if (pGpDataInd->gpdCmdId == 0xe3)
  {
  LAB_0000b650:
    dest[0x26] = dest[0x26] | 8;
  }
  else
  {
    if (pGpDataInd->appId == '\0')
    {
      dest[0x26] = dest[0x26] & 0xf8;
      uVar7 = pGpDataInd->srcId;
      dest[0x12] = (u8)uVar7;
      dest[0x13] = (u8)(uVar7 >> 8);
      dest[0x14] = (u8)(uVar7 >> 0x10);
      dest[0x15] = (u8)(uVar7 >> 0x18);
    LAB_0000b2be:
      if (pGpDataInd->gpdCmdId == 0xe3)
        goto LAB_0000b650;
    }
    else if (pGpDataInd->appId == '\x02')
    {
      dest[0x26] = dest[0x26] & 0xf8 | 2;
      memcpy(dest + 0x12, &pGpDataInd->srcAddr, 8);
      dest[0x2a] = pGpDataInd->endpoint;
      goto LAB_0000b2be;
    }
    dest[0x26] = dest[0x26] & 0xf7 | (byte)((pGpDataInd->rxAfterTx & 1) << 3);
  }
  dest[0x26] = dest[0x26] & 0xcf | (byte)((pGpDataInd->gpdfSecurityLevel & 3) << 4);
  dest[0x26] = dest[0x26] & 0x3f | (byte)((pGpDataInd->gpdfKeyType & 3) << 6);
  dest[0x27] = dest[0x27] & 0xfe | pGpDataInd->gpdfKeyType >> 2 & 1;
  if ((byte)(pGpDataInd->status - 3) < 2)
  {
    dest[0x27] = dest[0x27] | 2;
    uVar7 = pGpDataInd->mic;
    dest[0x22] = (u8)uVar7;
    dest[0x23] = (u8)(uVar7 >> 8);
    dest[0x24] = (u8)(uVar7 >> 0x10);
    dest[0x25] = (u8)(uVar7 >> 0x18);
  }
  else
  {
    dest[0x27] = dest[0x27] & 0xfd;
    dest[0x22] = 0xfe;
    dest[0x23] = 0xfe;
    dest[0x24] = 0xfe;
    dest[0x25] = 0xfe;
  }
  dest[0x27] = dest[0x27] & 0xfb;
  dest[0x27] = dest[0x27] | 8;
  uVar7 = pGpDataInd->gpdSecFrameCnt;
  dest[0x1e] = (u8)uVar7;
  dest[0x1f] = (u8)(uVar7 >> 8);
  dest[0x20] = (u8)(uVar7 >> 0x10);
  dest[0x21] = (u8)(uVar7 >> 0x18);
  dest[0x2b] = pGpDataInd->gpdCmdId;
  uVar9 = pGpDataInd->gpdAsduLen + 0xff;
  dest[0x2c] = uVar9;
  if (uVar9 != '\0')
  {
    puVar10 = pGpDataInd->gpdAsdu + 1;
    dest[0x1a] = (u8)puVar10;
    dest[0x1b] = (u8)((uint)puVar10 >> 8);
    dest[0x1c] = (u8)((uint)puVar10 >> 0x10);
    dest[0x1d] = (u8)((uint)puVar10 >> 0x18);
  }
  uVar1 = g_zbInfo.nwkNib.nwkAddr;
  dest[0x28] = (u8)g_zbInfo.nwkNib.nwkAddr;
  dest[0x29] = (u8)(uVar1 >> 8);
  bVar3 = pGpDataInd->rssi;
  uVar11 = (uint)bVar3;
  if ((char)bVar3 + 0x6d < 0 != SCARRY4((int)(char)bVar3, 0x6d))
  {
    uVar11 = 0xffffff92;
  }
  uVar8 = uVar11 & 0xff;
  if ('\b' < (char)uVar11)
  {
    uVar8 = 8;
  }
  iVar12 = (uVar8 + 0x6e) * 0x1000000;
  dest[0x2d] = dest[0x2d] & 0xc0 | (byte)((iVar12 >> 0x18) - (iVar12 >> 0x1f) >> 1) & 0x3f;
  bVar14 = pGpDataInd->lqi != '\0';
  bVar3 = bVar14 * '\x02';
  dest[0x2d] = dest[0x2d] & 0x3f | bVar14 * -0x80;
  dest[0xe] = '\x02';
  uVar1 = g_gppCtx.gpCommissionerAddr;
  if ((int)((uint)g_gppCtx.gpCommissioningModeOpt.opts << 0x1a) < 0)
  {
    *dest = (u8)g_gppCtx.gpCommissionerAddr;
    dest[1] = (u8)(uVar1 >> 8);
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
    if ((uVar1 & 0xfff8) != 0xfff8)
    {
      dest[0xc] = '\0';
      goto LAB_0000b458;
    }
  }
  else
  {
    *dest = 0xfc;
    dest[1] = 0xfe;
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
  }
  dest[0xc] = '\x01';
  uVar4 = gpAliasSrcAddrDerived();
  dest[10] = (u8)uVar4;
  dest[0xb] = (u8)((ushort)uVar4 >> 8);
  dest[0xd] = pGpDataInd->seqNum + 0xf4;
  bVar3 = dest[0x2d] >> 6;
LAB_0000b458:
  bVar3 = gppTunnelingDelayGet(SUB41(((uint)dest[0x26] << 0x1c) >> 0x1f, 0), bVar3, (bool)g_gppCtx.firstToForward, false);
  ev_timer_taskPost(gpCommissioningNotificationCmdSend, dest, (uint)bVar3);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAR(void)

{
  code *in_r2;

  (*in_r2)();
  nv_flashWriteNew('\x01', 3, '%', 0x146, (u8 *)&g_gpProxyTab);
  return;
}
void gp_proxyTabSave2Flash(void *arg)

{
  nv_flashWriteNew('\x01', 3, '%', 0x146, (u8 *)&g_gpProxyTab);
  return;
}
nv_sts_t gp_proxyTabRestoreFromFlash(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashReadNew('\x01', '\x03', '%', 0x146, (u8 *)&g_gpProxyTab);
  return nVar1;
}
void gp_proxyTabEntryClear(gpProxyTabEntry_t *pEntry)

{
  if ((int)((uint)(byte)pEntry->field_0x40 << 0x1f) < 0)
  {
    memset(pEntry, 0, 0x41);
    g_gpProxyTab.gpProxyTabNum = g_gpProxyTab.gpProxyTabNum + 0xff;
  }
  return;
}
u8 gp_getProxyTabEntryTotalNum(void)

{
  return g_gpProxyTab.gpProxyTabNum;
}
u8 gp_getProxyTabEntryLen(gpProxyTabEntry_t *pEntry)

{
  byte bVar1;
  u8 uVar2;
  uint uVar3;
  uint uVar4;
  char cVar5;
  uint uVar6;
  uint uVar7;

  bVar1 = *(byte *)&pEntry->options;
  uVar6 = (uint)bVar1;
  cVar5 = '\x06';
  if ((bVar1 & 7) != 0)
  {
    cVar5 = '\v';
    if ((uVar6 & 7) != 2)
    {
      cVar5 = '\x02';
    }
  }
  uVar7 = (uint) * (byte *)((int)&pEntry->options + 1);
  if ((int)(uVar7 << 0x1a) < 0)
  {
    cVar5 = cVar5 + '\x02';
  }
  if ((int)(uVar7 << 0x19) < 0)
  {
    cVar5 = cVar5 + '\x15';
  }
  else if ((int)(uVar6 << 0x1a) < 0)
  {
    cVar5 = cVar5 + '\x04';
  }
  if ((bVar1 & 0x40) != 0)
  {
    cVar5 = cVar5 + ((pEntry->field_0x40 & 6) != 0);
    uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
    if (uVar3 != 0)
    {
      uVar4 = 0;
      do
      {
        cVar5 = cVar5 + '\n';
        uVar4 = uVar4 + 1 & 0xff;
      } while (uVar4 < uVar3);
    }
  }
  if ((int)(uVar7 << 0x1f) < 0)
  {
    cVar5 = cVar5 + ((pEntry->field_0x40 & 0x18) != 0);
    uVar7 = ((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e;
    if (uVar7 != 0)
    {
      uVar3 = 0;
      do
      {
        cVar5 = cVar5 + '\x04';
        uVar3 = uVar3 + 1 & 0xff;
      } while (uVar3 < uVar7);
    }
  }
  uVar2 = cVar5 + '\x01';
  if ((uVar6 & 0x18) != 0x18)
  {
    uVar2 = cVar5 + '\x02';
  }
  return uVar2;
}
u8 gp_buildProxyTabEntryFormat(gpProxyTabEntry_t *pEntry, u8 *pBuf)

{
  uint uVar1;
  gpSecOpt_t *pgVar2;
  gpSecOpt_t *out;

  *pBuf = *(u8 *)&pEntry->options;
  pBuf[1] = *(u8 *)((int)&pEntry->options + 1);
  out = (gpSecOpt_t *)(pBuf + 2);
  if ((*(byte *)&pEntry->options & 7) == 0)
  {
    pBuf[2] = (pEntry->gpdId).gpdIeeeAddr[0];
    pBuf[3] = (pEntry->gpdId).gpdIeeeAddr[1];
    pBuf[4] = (pEntry->gpdId).gpdIeeeAddr[2];
    pBuf[5] = (pEntry->gpdId).gpdIeeeAddr[3];
    out = (gpSecOpt_t *)(pBuf + 6);
  }
  else if ((*(byte *)&pEntry->options & 7) == 2)
  {
    memcpy(out, pEntry, 8);
    pBuf[10] = pEntry->endpoint;
    out = (gpSecOpt_t *)(pBuf + 0xb);
  }
  uVar1 = (uint) * (byte *)((int)&pEntry->options + 1);
  if ((int)(uVar1 << 0x1a) < 0)
  {
    *out = *(gpSecOpt_t *)&pEntry->gpdAssignedAlias;
    out[1] = *(gpSecOpt_t *)((int)&pEntry->gpdAssignedAlias + 1);
    out = out + 2;
    uVar1 = (uint) * (byte *)((int)&pEntry->options + 1);
  }
  if ((uVar1 & 0x40) == 0)
  {
  LAB_0000b944:
    uVar1 = (uint) * (byte *)&pEntry->options;
    pgVar2 = out;
    if (-1 < (int)(uVar1 << 0x1a))
      goto LAB_0000b87a;
  }
  else
  {
    *out = pEntry->secOptions;
    out = out + 1;
    pgVar2 = out;
    if ((*(byte *)((int)&pEntry->options + 1) & 0x40) == 0)
      goto LAB_0000b944;
  }
  *pgVar2 = *(gpSecOpt_t *)&pEntry->gpdSecFrameCnt;
  pgVar2[1] = *(gpSecOpt_t *)((int)&pEntry->gpdSecFrameCnt + 1);
  pgVar2[2] = *(gpSecOpt_t *)((int)&pEntry->gpdSecFrameCnt + 2);
  pgVar2[3] = *(gpSecOpt_t *)((int)&pEntry->gpdSecFrameCnt + 3);
  out = pgVar2 + 4;
  if ((int)((uint) * (byte *)((int)&pEntry->options + 1) << 0x19) < 0)
  {
    memcpy(out, pEntry->gpdKey, 0x10);
    out = pgVar2 + 0x14;
  }
  uVar1 = (uint) * (byte *)&pEntry->options;
LAB_0000b87a:
  if ((uVar1 & 0x40) != 0)
  {
    out->opts = (byte)(((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e);
    out = out + 1;
    if (((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e != 0)
    {
      uVar1 = 0;
      do
      {
        memcpy(out, pEntry->lightweightSinkAddrList + uVar1, 8);
        out[8] = *(gpSecOpt_t *)&pEntry->lightweightSinkAddrList[uVar1].sinkNwkAddr;
        out[9] = *(gpSecOpt_t *)((int)&pEntry->lightweightSinkAddrList[uVar1].sinkNwkAddr + 1);
        out = out + 10;
        uVar1 = uVar1 + 1 & 0xff;
      } while (uVar1 < ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e);
    }
  }
  if ((int)((uint) * (byte *)((int)&pEntry->options + 1) << 0x1f) < 0)
  {
    out->opts = (byte)(((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e);
    out = out + 1;
    if (((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e != 0)
    {
      uVar1 = 0;
      do
      {
        *out = *(gpSecOpt_t *)(pEntry->sinkGroupList + uVar1);
        out[1] = *(gpSecOpt_t *)((int)&pEntry->sinkGroupList[uVar1].groupId + 1);
        out[2] = *(gpSecOpt_t *)&pEntry->sinkGroupList[uVar1].alias;
        out[3] = *(gpSecOpt_t *)((int)&pEntry->sinkGroupList[uVar1].alias + 1);
        out = out + 4;
        uVar1 = uVar1 + 1 & 0xff;
      } while (uVar1 < ((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e);
    }
  }
  *out = (gpSecOpt_t)pEntry->groupcastRadius;
  pgVar2 = out + 1;
  if ((*(byte *)&pEntry->options & 0x18) != 0x18)
  {
    out[1] = (gpSecOpt_t)pEntry->searchCnt;
    pgVar2 = out + 2;
  }
  return (u8)((uint)(((int)pgVar2 - (int)pBuf) * 0x1000000) >> 0x18);
}
void zclGpProxyTabAttrUpdate(void)

{
  u8 uVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  u8 *pBuf;
  uint uVar6;

  if (g_gpProxyTab.gpProxyTabNum == '\0')
  {
    zclGpAttr_proxyTabEntry[0] = '\0';
    zclGpAttr_proxyTabEntry[1] = '\0';
  }
  else
  {
    uVar5 = (uint)zclGpAttr_gppMaxProxyTabEntries;
    if (uVar5 == 0)
    {
      zclGpAttr_proxyTabEntry[0] = zclGpAttr_gppMaxProxyTabEntries;
      zclGpAttr_proxyTabEntry[1] = zclGpAttr_gppMaxProxyTabEntries;
    }
    else
    {
      uVar4 = 0;
      uVar6 = 0;
      bVar3 = 0;
      do
      {
        while (((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar4].field_0x40 << 0x1f) >> 0x1f) *
                   -0x1000000 ==
               0)
        {
          uVar4 = uVar4 + 1;
          if (uVar5 <= (uVar4 & 0xff))
            goto LAB_0000b9dc;
        }
        uVar1 = gp_getProxyTabEntryLen(g_gpProxyTab.gpProxyTab + uVar4);
        bVar2 = uVar1 + bVar3;
        if (0x4a < bVar2)
          break;
        uVar6 = uVar6 + 1 & 0xff;
        uVar4 = uVar4 + 1;
        bVar3 = bVar2;
      } while ((uVar4 & 0xff) < uVar5);
    LAB_0000b9dc:
      zclGpAttr_proxyTabEntry[0] = bVar3;
      zclGpAttr_proxyTabEntry[1] = '\0';
      if (uVar6 != 0)
      {
        uVar5 = 0;
        pBuf = zclGpAttr_proxyTabEntry + 2;
        do
        {
          while (((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar5].field_0x40 << 0x1f) >> 0x1f) *
                     -0x1000000 !=
                 0)
          {
            bVar3 = gp_buildProxyTabEntryFormat(g_gpProxyTab.gpProxyTab + uVar5, pBuf);
            pBuf = pBuf + bVar3;
            uVar5 = uVar5 + 1;
            if (uVar6 <= (uVar5 & 0xff))
            {
              return;
            }
          }
          uVar5 = uVar5 + 1;
        } while ((uVar5 & 0xff) < uVar6);
      }
    }
  }
  return;
}
u8 lwSinkAddrListAdd(gpProxyTabEntry_t *pEntry, u8 *sinkIeeeAddr, u16 sinkNwkAddr)

{
  int iVar1;
  uint uVar2;
  uint uVar3;

  if ((pEntry->field_0x40 & 6) == 0)
  {
    memcpy(pEntry->lightweightSinkAddrList, sinkIeeeAddr, 8);
    *(char *)&pEntry->lightweightSinkAddrList[0].sinkNwkAddr = (char)sinkNwkAddr;
    *(char *)((int)&pEntry->lightweightSinkAddrList[0].sinkNwkAddr + 1) =
        (char)((uint)sinkNwkAddr >> 8);
    pEntry->field_0x40 =
        pEntry->field_0x40 & 0xf9 |
        (byte)(((((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e) + 1 & 3) << 1);
  }
  else
  {
    uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
    if (uVar3 != 0)
    {
      uVar2 = 0;
      do
      {
        iVar1 = memcmp(pEntry->lightweightSinkAddrList + uVar2, sinkIeeeAddr, 8);
        if ((iVar1 == 0) &&
            ((uint)pEntry->lightweightSinkAddrList[uVar2].sinkNwkAddr == (uint)sinkNwkAddr))
        {
          return '\0';
        }
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < uVar3);
      if (1 < uVar3)
      {
        return '\x01';
      }
    }
    memcpy(pEntry->lightweightSinkAddrList + uVar3, sinkIeeeAddr, 8);
    uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
    pEntry->lightweightSinkAddrList[uVar3].sinkNwkAddr = sinkNwkAddr;
    pEntry->field_0x40 = pEntry->field_0x40 & 0xf9 | (byte)((uVar3 + 1 & 3) << 1);
  }
  return '\0';
}
u8 lwSinkAddrListRemove(gpProxyTabEntry_t *pEntry, u8 *sinkIeeeAddr, u16 sinkNwkAddr)

{
  u16 uVar1;
  int iVar2;
  uint uVar3;
  u8 *puVar4;
  uint uVar5;
  u16 *puVar6;
  gpLwSinkAddrListItem_t *m1;

  if (((pEntry->field_0x40 & 6) != 0) &&
      (uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e, uVar3 != 0))
  {
    uVar5 = 0;
    do
    {
      m1 = pEntry->lightweightSinkAddrList + uVar5;
      iVar2 = memcmp(m1, sinkIeeeAddr, 8);
      if ((iVar2 == 0) &&
          (puVar6 = &pEntry->lightweightSinkAddrList[uVar5].sinkNwkAddr, *puVar6 == sinkNwkAddr))
      {
        if (uVar5 == uVar3 - 2)
        {
          m1->sinkIeeeAddr[0] = '\0';
          m1->sinkIeeeAddr[1] = '\0';
          m1->sinkIeeeAddr[2] = '\0';
          m1->sinkIeeeAddr[3] = '\0';
          m1->sinkIeeeAddr[4] = '\0';
          m1->sinkIeeeAddr[5] = '\0';
          m1->sinkIeeeAddr[6] = '\0';
          m1->sinkIeeeAddr[7] = '\0';
          *(undefined *)puVar6 = 0;
          *(undefined *)((int)&pEntry->lightweightSinkAddrList[uVar5].sinkNwkAddr + 1) = 0;
          uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
        }
        else
        {
          memcpy(m1, pEntry->gpdKey + uVar3 * 10, 8);
          uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
          uVar1 = pEntry->lightweightSinkAddrList[uVar3 - 1].sinkNwkAddr;
          *(char *)puVar6 = (char)uVar1;
          *(char *)((int)&pEntry->lightweightSinkAddrList[uVar5].sinkNwkAddr + 1) =
              (char)(uVar1 >> 8);
          puVar4 = pEntry->gpdKey + uVar3 * 10 + 10;
          *puVar4 = '\0';
          puVar4[1] = '\0';
          puVar4[2] = '\0';
          puVar4[3] = '\0';
          puVar4[4] = '\0';
          puVar4[5] = '\0';
          puVar4[6] = '\0';
          puVar4[7] = '\0';
          uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
          *(undefined *)&pEntry->lightweightSinkAddrList[uVar3 - 1].sinkNwkAddr = 0;
          *(undefined *)((int)&pEntry->lightweightSinkAddrList[uVar3 - 1].sinkNwkAddr + 1) = 0;
        }
        pEntry->field_0x40 = pEntry->field_0x40 & 0xf9 | (byte)((uVar3 + 3 & 3) << 1);
        return '\0';
      }
      uVar5 = uVar5 + 1 & 0xff;
    } while (uVar5 < uVar3);
  }
  return '\x01';
}
u8 sinkGroupListAdd(gpProxyTabEntry_t *pEntry, u16 sinkGroupID, u16 alias)

{
  byte bVar1;
  undefined uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;

  uVar3 = (uint)sinkGroupID;
  bVar1 = pEntry->field_0x40;
  uVar2 = (undefined)(uVar3 >> 8);
  if ((bVar1 & 0x18) == 0)
  {
    *(char *)&pEntry->sinkGroupList[0].groupId = (char)sinkGroupID;
    *(undefined *)((int)&pEntry->sinkGroupList[0].groupId + 1) = uVar2;
    *(char *)&pEntry->sinkGroupList[0].alias = (char)alias;
    *(char *)((int)&pEntry->sinkGroupList[0].alias + 1) = (char)((uint)alias >> 8);
    pEntry->field_0x40 = bVar1 & 0xe7 | (byte)(((((uint)bVar1 << 0x1b) >> 0x1e) + 1 & 3) << 3);
  }
  else
  {
    uVar5 = ((uint)bVar1 << 0x1b) >> 0x1e;
    if (uVar5 == 0)
    {
    LAB_0000be26:
      *(char *)&pEntry->sinkGroupList[uVar5].groupId = (char)sinkGroupID;
      *(undefined *)((int)&pEntry->sinkGroupList[uVar5].groupId + 1) = uVar2;
      pEntry->sinkGroupList[uVar5].alias = alias;
      pEntry->field_0x40 = pEntry->field_0x40 & 0xe7 | (byte)((uVar5 + 1 & 3) << 3);
    }
    else
    {
      if (pEntry->sinkGroupList[0].groupId == uVar3)
      {
        uVar4 = 0;
      }
      else
      {
        uVar4 = 0;
        do
        {
          uVar4 = uVar4 + 1 & 0xff;
          if (uVar5 <= uVar4)
          {
            if (1 < uVar5)
            {
              return '\x01';
            }
            goto LAB_0000be26;
          }
        } while (CONCAT11(*(undefined *)((int)&pEntry->sinkGroupList[uVar4].groupId + 1),
                          *(undefined *)&pEntry->sinkGroupList[uVar4].groupId) != uVar3);
      }
      pEntry->sinkGroupList[uVar4].alias = alias;
    }
  }
  return '\0';
}
u8 sinkGroupListRemove(gpProxyTabEntry_t *pEntry, u16 sinkGroupID)

{
  undefined2 uVar1;
  int iVar2;
  u8 uVar3;
  uint uVar4;
  uint uVar5;

  uVar3 = '\x01';
  if (((pEntry->field_0x40 & 0x18) != 0) &&
      (uVar5 = ((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e, uVar5 != 0))
  {
    if (pEntry->sinkGroupList[0].groupId == sinkGroupID)
    {
      uVar4 = 0;
    }
    else
    {
      uVar4 = 0;
      do
      {
        uVar4 = uVar4 + 1 & 0xff;
        if (uVar5 <= uVar4)
        {
          return '\x01';
        }
      } while (CONCAT11(*(undefined *)((int)&pEntry->sinkGroupList[uVar4].groupId + 1),
                        *(undefined *)&pEntry->sinkGroupList[uVar4].groupId) != sinkGroupID);
    }
    if (uVar5 - 1 == uVar4)
    {
      iVar2 = uVar5 * 4;
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 6] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 7] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 8] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 9] = '\0';
    }
    else
    {
      iVar2 = uVar5 * 4;
      uVar3 = pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 7];
      *(u8 *)&pEntry->sinkGroupList[uVar4].groupId =
          pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 6];
      *(u8 *)((int)&pEntry->sinkGroupList[uVar4].groupId + 1) = uVar3;
      uVar1 = *(undefined2 *)(pEntry->lightweightSinkAddrList[1].sinkIeeeAddr + iVar2 + 8);
      *(char *)&pEntry->sinkGroupList[uVar4].alias = (char)uVar1;
      *(char *)((int)&pEntry->sinkGroupList[uVar4].alias + 1) = (char)((ushort)uVar1 >> 8);
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 6] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 7] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 8] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 9] = '\0';
    }
    pEntry->field_0x40 = pEntry->field_0x40 & 0xe7 | (byte)((uVar5 + 3 & 3) << 3);
    uVar3 = '\0';
  }
  return uVar3;
}
void gpProxyTabUpdate(void)

{
  zclGpProxyTabAttrUpdate();
  tl_zbTaskPost(gp_proxyTabSave2Flash, (void *)0x0);
  return;
}
void gpProxyTabInit(void)

{
  nv_sts_t nVar1;

  nVar1 = gp_proxyTabRestoreFromFlash();
  if (nVar1 == NV_SUCC)
  {
    zclGpProxyTabAttrUpdate();
  }
  else
  {
    memset(&g_gpProxyTab, 0, 0x146);
  }
  return;
}
u32 zbBufferSizeGet(void)

{
  return 0x1d48;
}
u32 neighborTblSizeGet(void)

{
  return 0x45c;
}
u32 addrMapTblSizeGet(void)

{
  return 0xa0c;
}
u8 bdb_topLevelCommissioning(u8 target)

{
  u8 uVar1;

  uVar1 = '\x06';
  if ((g_bdbCtx.state == '\0') && (g_zbInfo.bdbAttr.commissioningStatus != '\x01'))
  {
    g_zbInfo.bdbAttr.commissioningStatus = '\x01';
    g_bdbCtx.role = target;
    tl_zbTaskPost(bdb_task, &_d);
    uVar1 = '\0';
  }
  return uVar1;
}
s32 bdb_findBindIdentifyQueryTimeout(void *arg)

{
  if ((g_bdbCtx.pFindBindQ == (findBindQ_t *)0x0) ||
      ((g_bdbCtx.pFindBindQ)->front == (g_bdbCtx.pFindBindQ)->rear))
  {
    g_bdbCtx.status = '\x06';
    tl_zbTaskPost(bdb_task, &DAT_0000000a);
  }
  else
  {
    tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  }
  g_bdbCtx.field_2.identifyTimer = (ev_timer_event_t *)0x0;
  return -2;
}
s32 bdb_simpleDescReqTimeoutCb(void *arg)

{
  tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  g_bdbCtx.field_2.identifyTimer = (ev_timer_event_t *)0x0;
  return -2;
}
s32 bdb_task_delay(void *arg)

{
  tl_zbTaskPost(bdb_task, arg);
  return -2;
}
// WARNING: Could not reconcile some variable overlaps
u8 bdb_commissioningFindBind(void)

{
  u8 seqNo;
  u8 uVar1;
  epInfo_t dstEpInfo;

  seqNo = zcl_seqNum;
  uVar1 = '\0';
  if (((int)((uint)(byte)g_zbInfo.bdbAttr.commissioningMode << 0x1c) < 0) &&
      (g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0'))
  {
    if (g_bdbCtx.role == '\x02')
    {
      if (g_bdbCtx.field_2.identifyTimer == (ev_timer_event_t *)0x0)
      {
        g_bdbCtx.field_2.identifyTimer =
            ev_timer_taskPost(bdb_findBindIdentifyTimeout, (void *)0x0, (u32)&DAT_00001388);
      }
      uVar1 = '\x05';
      if ((g_bdbCtx.bdbAppCb)->bdbIdentifyCb != ll_reset)
      {
        FUNAAAAS();
      }
    }
    else
    {
      dstEpInfo.dstAddr._4_4_ = 0;
      dstEpInfo._16_2_ = 0;
      dstEpInfo.dstAddr._0_4_ = 0xfffe;
      dstEpInfo._12_4_ = 0xfe020000;
      dstEpInfo._8_4_ = 0x104;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_identify_identifyQuery((g_bdbCtx.simpleDesc)->endpoint, &dstEpInfo, '\x01', seqNo);
      uVar1 = '\x05';
      if (g_bdbCtx.field_2.identifyTimer == (ev_timer_event_t *)0x0)
      {
        g_bdbCtx.field_2.identifyTimer =
            ev_timer_taskPost(bdb_findBindIdentifyQueryTimeout, (void *)0x0, (u32)&DAT_00001388);
      }
    }
  }
  return uVar1;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
u8 FUNAAAAS(void)

{
  u8 uVar1;
  code *in_r3;

  (*in_r3)();
  if (((int)((uint)(byte)g_zbInfo.bdbAttr.commissioningMode << 0x1d) < 0) &&
      (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0'))
  {
    zb_nwkFormation(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration);
    uVar1 = '\x04';
  }
  else
  {
    uVar1 = bdb_commissioningFindBind();
  }
  return uVar1;
}
u8 bdb_commissioningNetworkFormation(void)

{
  u8 uVar1;

  if (((int)((uint)(byte)g_zbInfo.bdbAttr.commissioningMode << 0x1d) < 0) &&
      (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0'))
  {
    zb_nwkFormation(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration);
    uVar1 = '\x04';
  }
  else
  {
    uVar1 = bdb_commissioningFindBind();
  }
  return uVar1;
}
void bdb_simpleDescReqSend(void *arg)

{
  findBindQ_t *pfVar1;
  byte bVar2;

  pfVar1 = g_bdbCtx.pFindBindQ;
  if ((g_bdbCtx.pFindBindQ == (findBindQ_t *)0x0) ||
      ((g_bdbCtx.pFindBindQ)->rear == (g_bdbCtx.pFindBindQ)->front))
  {
    g_bdbCtx.status = '\0';
    tl_zbTaskPost(bdb_task, &DAT_0000000a);
  }
  else
  {
    bVar2 = FUNAAAAB();
    pfVar1->front = bVar2;
    g_bdbCtx.findDstInfo.addr =
        CONCAT11(*(undefined *)((int)&pfVar1->findBindDstInfo[bVar2].addr + 1),
                 *(undefined *)&pfVar1->findBindDstInfo[bVar2].addr);
    g_bdbCtx.findDstInfo.endpoint = pfVar1->findBindDstInfo[bVar2].endpoint;
    if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
    {
      ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
    }
    tl_zbTaskPost(bdb_task, &DAT_0000000b);
    g_bdbCtx.field_2.identifyTimer =
        ev_timer_taskPost(bdb_simpleDescReqTimeoutCb, (void *)0x0, (u32)&DAT_00001388);
  }
  return;
}
s32 bdb_findBindIdentifyTimeout(void *arg)

{
  status_t sVar1;
  u16 local_14;
  short local_12[3];

  local_12[0] = 0;
  local_14 = 0;
  sVar1 = zcl_getAttrVal((g_bdbCtx.simpleDesc)->endpoint, 3, 0, &local_14, (u8 *)local_12);
  if (sVar1 == '\0')
  {
    if ((local_12[0] != 0) && (bdb_findBindIdentifyTimeout::timerIdentifyCnt < 0x24))
    {
      bdb_findBindIdentifyTimeout::timerIdentifyCnt =
          bdb_findBindIdentifyTimeout::timerIdentifyCnt + 1;
      return 0;
    }
    bdb_findBindIdentifyTimeout::timerIdentifyCnt = 0;
    g_bdbCtx.status = '\0';
    tl_zbTaskPost(bdb_task, &DAT_0000000a);
  }
  g_bdbCtx.field_2 = (anon_union_4_2_85b55d36_for_bdb_ctx_t_2)0x0;
  return -2;
}
void bdb_binding(zdo_bind_dstAddr_t *pDstAddr, u8 clusterNum, u16 *clusterList)

{
  u8 uVar1;
  zdo_status_t zVar2;
  byte bVar3;
  undefined local_3c[12];
  uint uStack_30;
  undefined4 uStack_2c;
  u8 local_28;
  u8 local_25;

  local_3c._0_4_ = 0;
  local_3c._4_4_ = 0;
  local_3c._8_4_ = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  local_28 = '\0';
  memcpy(local_3c, g_zbInfo.macPib.extAddress, 8);
  local_3c._8_3_ = (uint3)local_3c._8_4_ & 0xffff00 | (uint3)(g_bdbCtx.simpleDesc)->endpoint;
  uVar1 = pDstAddr->dstAddrMode;
  local_3c._8_4_ = CONCAT13(uVar1, local_3c._8_3_);
  if (uVar1 == '\x03')
  {
    memcpy(&uStack_30, &pDstAddr->dstAddr, 8);
    local_28 = (pDstAddr->dstAddr).field_0.dstEp;
  }
  else if (uVar1 == '\x01')
  {
    uStack_30 = uStack_30 & 0xffff0000 | (uint)(pDstAddr->dstAddr).dstGroupId;
  }
  if (clusterNum == '\0')
  {
    ev_buf_free((u8 *)g_bdbCtx.matchClusterList);
    g_bdbCtx.matchClusterNum = clusterNum;
  }
  else
  {
    bVar3 = 0;
    do
    {
      local_3c._8_3_ = CONCAT12((char)(*clusterList >> 8), CONCAT11((char)*clusterList, local_3c[8]));
      local_3c._8_4_ = local_3c._8_4_ & 0xff000000 | (uint)local_3c._8_3_;
      local_25 = '\0';
      zVar2 = zb_zdoBindUnbindReq(true, (zdo_bind_req_t *)local_3c, &local_25, ll_reset);
      if (zVar2 == ZDO_TABLE_FULL)
      {
        g_bdbCtx.status = '\a';
        tl_zbTaskPost(bdb_task, &DAT_0000000a);
        ev_buf_free((u8 *)g_bdbCtx.matchClusterList);
        g_bdbCtx.matchClusterList = (u16 *)0x0;
        g_bdbCtx.matchClusterNum = '\0';
        return;
      }
      bVar3 = bVar3 + 1;
      clusterList = clusterList + 1;
    } while (bVar3 < clusterNum);
    ev_buf_free((u8 *)g_bdbCtx.matchClusterList);
    g_bdbCtx.matchClusterNum = '\0';
    g_bdbCtx.matchClusterList = (u16 *)0x0;
    if (zVar2 != ZDO_SUCCESS)
      goto LAB_0000c32a;
  }
  g_bdbCtx.matchClusterList = (u16 *)0x0;
  if ((g_bdbCtx.bdbAppCb != (bdb_appCb_t *)0x0) &&
      ((g_bdbCtx.bdbAppCb)->bdbFindBindSuccessCb != ll_reset))
  {
    FUNAAAAT();
  }
LAB_0000c32a:
  tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAT(void)

{
  byte bVar1;
  int *piVar2;
  code *in_r3;
  undefined auStack_18[4];
  uint uStack_14;
  undefined2 uStack_10;

  piVar2 = (int *)(*in_r3)();
  bVar1 = *(byte *)(*piVar2 + 1);
  uStack_14 = (uint)bVar1;
  if (uStack_14 == 0)
  {
    auStack_18 = (undefined[4])0x3;
    uStack_10 = CONCAT11(g_bdbCtx.bindDstInfo.endpoint, bVar1);
    memcpy(auStack_18 + 1, (void *)(*piVar2 + 2), 8);
    bdb_binding((zdo_bind_dstAddr_t *)auStack_18, g_bdbCtx.matchClusterNum, g_bdbCtx.matchClusterList);
  }
  return;
}
void bdb_ieeeAddrResp(void *arg)

{
  byte bVar1;
  undefined local_18[4];
  uint uStack_14;
  undefined2 local_10;

  // WARNING: Load size is inaccurate
  bVar1 = *(byte *)(*arg + 1);
  uStack_14 = (uint)bVar1;
  if (uStack_14 == 0)
  {
    local_18 = (undefined[4])0x3;
    local_10 = CONCAT11(g_bdbCtx.bindDstInfo.endpoint, bVar1);
    memcpy(local_18 + 1, (void *)(*arg + 2), 8);
    bdb_binding((zdo_bind_dstAddr_t *)local_18, g_bdbCtx.matchClusterNum, g_bdbCtx.matchClusterList);
  }
  return;
}
void bdb_commissioningInfoSave(void *arg)

{
  nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter);
  zdo_ssInfoSaveToFlash();
  zb_info_save((void *)0x0);
  nwk_parentNodeInfoStore();
  g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfd;
  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
  return;
}
u8 bdb_topLevelCommissiongConfirm(void)

{
  u8 uVar1;
  u8 local_11[5];

  g_zbInfo.bdbAttr.commissioningStatus = g_bdbCtx.status;
  if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
  }
  if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
  {
    FUNAAAAU();
  }
  if (g_zbInfo.bdbAttr.commissioningStatus == '\0')
  {
    local_11[0] = g_zbInfo.bdbAttr.commissioningStatus;
    tl_zbMacAttrGet('\0', &g_bdbCtx.channel, local_11);
    if ((g_bdbCtx._43_1_ & 2) != 0)
    {
      bdb_commissioningInfoSave((void *)0x0);
      g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfd;
    }
  }
  else if (((int)((uint)g_zbInfo.bdbAttr.nodeCommissioningCapability << 0x1c) < 0) &&
           (uVar1 = is_device_factory_new(), uVar1 != '\0'))
  {
    tl_zbMacChannelSet(g_bdbCtx.channel);
    rf_setTrxState('\x01');
  }
  return '\0';
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAU(void)

{
  u8 uVar1;
  bool bVar2;
  byte bVar3;
  int iVar4;
  code *in_r3;
  zdo_simple_descriptor_req_t azStack_18[2];
  u8 uStack_12;
  u8 auStack_11[5];

  iVar4 = (*in_r3)();
  auStack_11[0] = '\0';
  uVar1 = g_bdbCtx.state;
  switch (g_bdbCtx.state)
  {
  case '\0':
    if (iVar4 == 2)
    {
      if (((byte)g_zbInfo.bdbAttr.commissioningMode & 1) == 0)
      {
        if (((byte)g_zbInfo.bdbAttr.commissioningMode & 2) != 0)
        {
          if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
          {
            zb_nwkDiscovery(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration, bdb_nwkDiscCnfCb);
          }
          else
          {
            uStack_12 = (u8)(zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1);
            zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', &uStack_12,
                                 (zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1));
            tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
          }
          g_bdbCtx.state = '\x03';
          return;
        }
        uVar1 = bdb_commissioningNetworkFormation();
        if (uVar1 != '\0')
        {
          g_bdbCtx.state = uVar1;
          return;
        }
      }
      else if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
      {
        ss_securityModeSet(1);
      }
      g_zbInfo.bdbAttr.commissioningStatus = '\x03';
      uVar1 = '\0';
      if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
      {
        FUNAAAAV();
      }
    }
    else if (iVar4 == 7)
    {
      bdb_topLevelCommissiongConfirm();
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x01':
    g_bdbCtx.state = '\0';
    uVar1 = g_bdbCtx.state;
    if (iVar4 == 1)
    {
      if ((g_bdbCtx.bdbAppCb)->bdbInitCb != ll_reset)
      {
        FUNAAAAV();
      }
      if ((g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0') &&
          (nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter), g_bdbCtx.initResult == '\0'))
      {
        bVar3 = zdo_ssInfoKeyGet();
        if ((((uint)ss_ib._62_1_ << 0x1a) >> 0x1e != (uint)bVar3) ||
            (((g_zbInfo.macPib.phyChannelCur != g_bdbCtx.channel || ((g_zbNwkCtx._46_1_ & 0x80) != 0)) || ((int)((uint)g_bdbCtx._43_1_ << 0x1c) < 0))))
        {
          g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0x7f;
          tl_zbTaskPost(bdb_commissioningInfoSave, (void *)0x0);
        }
        g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
        zb_zdoSendParentAnnce();
      }
      g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xf6;
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x02':
    if (iVar4 == 3)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xfe);
      g_bdbCtx.state = '\0';
      g_zbInfo.bdbAttr.commissioningStatus = g_bdbCtx.status;
      bdb_topLevelCommissioning('\x02');
      uVar1 = g_bdbCtx.state;
    }
    else if (iVar4 == 4)
    {
      bVar2 = zb_isDeviceFactoryNew();
      if (bVar2 == false)
      {
        bdb_commissioningInfoSave((void *)0x0);
      }
      bdb_topLevelCommissiongConfirm();
      g_bdbCtx.state = '\0';
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x03':
    if (iVar4 == 6)
    {
      ev_timer_taskPost(bdb_retrieveTcLinkKeyStart, (void *)0x0, 1000);
      return;
    }
    if (iVar4 == 5)
    {
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
    LAB_0000c6d6:
      zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', auStack_11, ll_reset);
      tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
      return;
    }
    if (iVar4 != 7)
    {
      return;
    }
    ss_securityModeSet(SS_SEMODE_CENTRALIZED);
    uVar1 = bdb_commissioningNetworkFormation();
    goto joined_r0x0000c518;
  case '\x04':
    if (iVar4 == 8)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
      goto LAB_0000c6d6;
    }
    if (iVar4 != 9)
    {
      return;
    }
    uVar1 = bdb_commissioningFindBind();
  joined_r0x0000c518:
    if (uVar1 == '\0')
    {
    LAB_0000c4fc:
      bdb_topLevelCommissiongConfirm();
    }
    break;
  case '\x05':
    if (iVar4 == 0xb)
    {
      if (g_bdbCtx.role != '\x01')
      {
        return;
      }
      uStack_12 = '\0';
      azStack_18[0].endpoint = g_bdbCtx.findDstInfo.endpoint;
      azStack_18[0].nwk_addr_interest = g_bdbCtx.findDstInfo.addr;
      zb_zdoSimpleDescReq(g_bdbCtx.findDstInfo.addr, azStack_18, &uStack_12, bdb_SimpleDescResp);
      return;
    }
    if (iVar4 != 10)
    {
      return;
    }
    if (g_bdbCtx.pFindBindQ != (findBindQ_t *)0x0)
    {
      ev_buf_free((u8 *)g_bdbCtx.pFindBindQ);
      g_bdbCtx.pFindBindQ = (findBindQ_t *)0x0;
    }
    uVar1 = '\0';
    g_bdbCtx.findDstInfo = (findBindDst_t)0x0;
    g_bdbCtx.bindDstInfo = (findBindDst_t)0x0;
    goto LAB_0000c4fc;
  }
  g_bdbCtx.state = uVar1;
  return;
}
void bdb_task(void *arg)

{
  u8 uVar1;
  bool bVar2;
  byte bVar3;
  zdo_simple_descriptor_req_t local_18[2];
  u8 local_12;
  u8 local_11[5];

  local_11[0] = '\0';
  uVar1 = g_bdbCtx.state;
  switch (g_bdbCtx.state)
  {
  case '\0':
    if ((undefined *)arg == &_d)
    {
      if (((byte)g_zbInfo.bdbAttr.commissioningMode & 1) == 0)
      {
        if (((byte)g_zbInfo.bdbAttr.commissioningMode & 2) != 0)
        {
          if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
          {
            zb_nwkDiscovery(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration, bdb_nwkDiscCnfCb);
          }
          else
          {
            local_12 = (u8)(zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1);
            zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', &local_12,
                                 (zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1));
            tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
          }
          g_bdbCtx.state = '\x03';
          return;
        }
        uVar1 = bdb_commissioningNetworkFormation();
        if (uVar1 != '\0')
        {
          g_bdbCtx.state = uVar1;
          return;
        }
      }
      else if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
      {
        ss_securityModeSet(1);
      }
      g_zbInfo.bdbAttr.commissioningStatus = '\x03';
      uVar1 = '\0';
      if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
      {
        FUNAAAAV();
      }
    }
    else if ((undefined1 *)arg == &DAT_00000007)
    {
      bdb_topLevelCommissiongConfirm();
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x01':
    g_bdbCtx.state = '\0';
    uVar1 = g_bdbCtx.state;
    if ((code *)arg == ll_reset + 1)
    {
      if ((g_bdbCtx.bdbAppCb)->bdbInitCb != ll_reset)
      {
        FUNAAAAV();
      }
      if ((g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0') &&
          (nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter), g_bdbCtx.initResult == '\0'))
      {
        bVar3 = zdo_ssInfoKeyGet();
        if ((((uint)ss_ib._62_1_ << 0x1a) >> 0x1e != (uint)bVar3) ||
            (((g_zbInfo.macPib.phyChannelCur != g_bdbCtx.channel || ((g_zbNwkCtx._46_1_ & 0x80) != 0)) || ((int)((uint)g_bdbCtx._43_1_ << 0x1c) < 0))))
        {
          g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0x7f;
          tl_zbTaskPost(bdb_commissioningInfoSave, (void *)0x0);
        }
        g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
        zb_zdoSendParentAnnce();
      }
      g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xf6;
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x02':
    if ((undefined *)arg == &UNK_00000003)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xfe);
      g_bdbCtx.state = '\0';
      g_zbInfo.bdbAttr.commissioningStatus = g_bdbCtx.status;
      bdb_topLevelCommissioning('\x02');
      uVar1 = g_bdbCtx.state;
    }
    else if ((undefined1 *)arg == &DAT_00000004)
    {
      bVar2 = zb_isDeviceFactoryNew();
      if (bVar2 == false)
      {
        bdb_commissioningInfoSave((void *)0x0);
      }
      bdb_topLevelCommissiongConfirm();
      g_bdbCtx.state = '\0';
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x03':
    if ((undefined1 *)arg == &DAT_00000006)
    {
      ev_timer_taskPost(bdb_retrieveTcLinkKeyStart, (void *)0x0, 1000);
      return;
    }
    if ((undefined1 *)arg == &DAT_00000005)
    {
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
    LAB_0000c6d6:
      zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', local_11, ll_reset);
      tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
      return;
    }
    if ((undefined1 *)arg != &DAT_00000007)
    {
      return;
    }
    ss_securityModeSet(SS_SEMODE_CENTRALIZED);
    uVar1 = bdb_commissioningNetworkFormation();
    goto joined_r0x0000c518;
  case '\x04':
    if ((undefined1 *)arg == &DAT_00000008)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
      goto LAB_0000c6d6;
    }
    if ((undefined1 *)arg != &DAT_00000009)
    {
      return;
    }
    uVar1 = bdb_commissioningFindBind();
  joined_r0x0000c518:
    if (uVar1 == '\0')
    {
    LAB_0000c4fc:
      bdb_topLevelCommissiongConfirm();
    }
    break;
  case '\x05':
    if ((undefined1 *)arg == &DAT_0000000b)
    {
      if (g_bdbCtx.role != '\x01')
      {
        return;
      }
      local_12 = '\0';
      local_18[0].endpoint = g_bdbCtx.findDstInfo.endpoint;
      local_18[0].nwk_addr_interest = g_bdbCtx.findDstInfo.addr;
      zb_zdoSimpleDescReq(g_bdbCtx.findDstInfo.addr, local_18, &local_12, bdb_SimpleDescResp);
      return;
    }
    if ((undefined1 *)arg != &DAT_0000000a)
    {
      return;
    }
    if (g_bdbCtx.pFindBindQ != (findBindQ_t *)0x0)
    {
      ev_buf_free((u8 *)g_bdbCtx.pFindBindQ);
      g_bdbCtx.pFindBindQ = (findBindQ_t *)0x0;
    }
    uVar1 = '\0';
    g_bdbCtx.findDstInfo = (findBindDst_t)0x0;
    g_bdbCtx.bindDstInfo = (findBindDst_t)0x0;
    goto LAB_0000c4fc;
  }
  g_bdbCtx.state = uVar1;
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAV(void)

{
  code *in_r3;

  (*in_r3)();
  zb_nlmePermitJoiningRequest(0xb4);
  g_bdbCtx.status = '\0';
  if (g_bdbCtx.state == '\x03')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000007);
  }
  else if (g_bdbCtx.state == '\x04')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000009);
  }
  if (g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0')
  {
    bdb_commissioningInfoSave((void *)0x0);
  }
  return;
}
void bdb_mgmtPermitJoiningConfirm(void *arg)

{
  zb_nlmePermitJoiningRequest(0xb4);
  g_bdbCtx.status = '\0';
  if (g_bdbCtx.state == '\x03')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000007);
  }
  else if (g_bdbCtx.state == '\x04')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000009);
  }
  if (g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0')
  {
    bdb_commissioningInfoSave((void *)0x0);
  }
  return;
}
void bdb_nwkDiscCnfCb(void)

{
  zb_assocJoinReq();
  return;
}
void bdb_SimpleDescResp(void *arg)

{
  byte bVar1;
  u16 *puVar2;
  u8 uVar3;
  u16 *puVar4;
  int iVar5;
  byte *pbVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  undefined in_stack_ffffffa4;
  undefined in_stack_ffffffa5;
  undefined2 in_stack_ffffffa6;
  undefined4 in_stack_ffffffa8;
  uint local_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined2 local_40;
  undefined local_3c;
  undefined3 uStack_3b;
  undefined4 uStack_38;
  ushort local_34;
  zdo_ieee_addr_req_t local_30;
  undefined4 uStack_2c;
  u8 local_25;

  // WARNING: Load size is inaccurate
  iVar5 = *arg;
  if (*(char *)(iVar5 + 1) == '\0')
  {
    if (g_bdbCtx.matchClusterList != (u16 *)0x0)
    {
      return;
    }
    if (g_bdbCtx.matchClusterNum != '\0')
    {
      return;
    }
    if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
    {
      ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
    }
    bVar1 = *(byte *)(iVar5 + 0xb);
    if ((bVar1 != 0) &&
        (puVar4 = (u16 *)ev_buf_allocate((ushort)bVar1 << 1), puVar2 = g_bdbCtx.clusterList,
         g_bdbCtx.matchClusterList = puVar4, puVar4 != (u16 *)0x0))
    {
      if (g_bdbCtx.clusterNum == '\0')
      {
        uVar8 = (uint)g_bdbCtx.matchClusterNum;
      }
      else
      {
        uVar8 = (uint)g_bdbCtx.matchClusterNum;
        uVar9 = 0;
        do
        {
          pbVar6 = (byte *)(iVar5 + 0xc);
          while (true)
          {
            if (puVar2[uVar9] == (u16)((ushort)pbVar6[1] * 0x100 + (ushort)*pbVar6))
            {
              puVar4[uVar8] = puVar2[uVar9];
              uVar7 = uVar8 + 1;
              uVar8 = uVar7 & 0xff;
              g_bdbCtx.matchClusterNum = (u8)(uVar7 * 0x1000000 >> 0x18);
            }
            else
            {
              uVar8 = (uint)g_bdbCtx.matchClusterNum;
            }
            if (pbVar6 == (byte *)(iVar5 + 0xc) + ((bVar1 - 1) * 0x1000000 >> 0x17))
              break;
            pbVar6 = pbVar6 + 2;
          }
          uVar9 = uVar9 + 1 & 0xff;
        } while (uVar9 < g_bdbCtx.clusterNum);
      }
      uVar3 = zcl_seqNum;
      if (uVar8 != 0)
      {
        g_bdbCtx.bindDstInfo.addr = *(u16 *)(iVar5 + 2);
        g_bdbCtx.bindDstInfo.endpoint = *(u8 *)(iVar5 + 5);
        _local_3c = 0;
        uStack_38 = 0;
        local_34 = 0;
        if (g_zbInfo.bdbAttr.commissioningGroupId == 0xffff)
        {
          local_50 = 0;
          uStack_4c = 0;
          uVar3 = zb_address_ieee_by_short(g_bdbCtx.bindDstInfo.addr,
                                           (addrExt_t)
                                               CONCAT44(in_stack_ffffffa8,
                                                        CONCAT22(in_stack_ffffffa6,
                                                                 CONCAT11(in_stack_ffffffa5, in_stack_ffffffa4))));
          if ((uVar3 != '\0') || (iVar5 = memcmp(&local_50, &g_zero_addr, 8), iVar5 == 0))
          {
            local_25 = '\0';
            local_30 = (zdo_ieee_addr_req_t)(uint)g_bdbCtx.bindDstInfo.addr;
            zb_zdoIeeeAddrReq(g_bdbCtx.bindDstInfo.addr, &local_30, &local_25, bdb_ieeeAddrResp);
            return;
          }
          _local_3c = CONCAT31(uStack_3b, 3);
          local_34 = local_34 & 0xff | (ushort)g_bdbCtx.bindDstInfo.endpoint << 8;
          memcpy(&local_3c + 1, &local_50, 8);
        }
        else
        {
          uStack_4c = 0;
          local_40 = 0;
          uStack_44 = CONCAT13(g_bdbCtx.bindDstInfo.endpoint, 0x20000);
          local_50 = (uint)g_bdbCtx.bindDstInfo.addr;
          uStack_48 = 0x104;
          local_30 = (zdo_ieee_addr_req_t)0x0;
          uStack_2c = 0;
          zcl_seqNum = zcl_seqNum + '\x01';
          zcl_group_add((g_bdbCtx.simpleDesc)->endpoint, (epInfo_t *)&local_50, '\0', uVar3,
                        g_zbInfo.bdbAttr.commissioningGroupId & 0xff |
                            (ushort)(byte)((uint)g_zbInfo.bdbAttr.commissioningGroupId >> 8) << 8,
                        (u8 *)&local_30);
          _local_3c = CONCAT31(uStack_3b, 1);
          _local_3c = _local_3c & 0xff0000ff | (uint)g_zbInfo.bdbAttr.commissioningGroupId << 8;
        }
        bdb_binding((zdo_bind_dstAddr_t *)&local_3c, g_bdbCtx.matchClusterNum,
                    g_bdbCtx.matchClusterList);
        return;
      }
    }
  }
  tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  return;
}
void bdb_retrieveTcLinkKeyDone(u8 status)

{
  undefined1 *arg;

  if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
  }
  g_zbInfo.bdbAttr.nodeIsOnANetwork = status == '\0';
  if ((bool)g_zbInfo.bdbAttr.nodeIsOnANetwork)
  {
    arg = &DAT_00000005;
  }
  else
  {
    arg = &DAT_00000007;
  }
  g_bdbCtx.status = status;
  tl_zbTaskPost(bdb_task, arg);
  return;
}
s32 bdb_retrieveTcLinkKeyStart(void *arg)

{
  zdo_node_descriptor_req_t local_10;
  u8 local_d[5];

  local_d[0] = g_zbInfo.bdbAttr.tcLinkKeyExchangeMethod;
  if (g_zbInfo.bdbAttr.tcLinkKeyExchangeMethod == '\0')
  {
    local_10.nwk_addr_interest = 0;
    zb_zdoNodeDescReq(0, &local_10, local_d, bdb_nodeDescRespHandler);
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfb;
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = '\0';
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttemptsMax = '\x03';
    if (g_bdbCtx.field_2.identifyTimer == (ev_timer_event_t *)0x0)
    {
      g_bdbCtx.field_2.identifyTimer =
          ev_timer_taskPost(bdb_retrieveTcLinkKeyTimeout, (void *)0x0, (u32)&DAT_00001388);
    }
  }
  else
  {
    bdb_retrieveTcLinkKeyDone('\0');
  }
  return -2;
}
s32 bdb_retrieveTcLinkKeyTimeout(void *arg)

{
  bool bVar1;
  u8 uVar2;
  s32 sVar3;
  nlme_leave_req_t nStack_20;
  zdo_node_descriptor_req_t local_14;
  u8 local_11[5];

  if (g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts < g_zbInfo.bdbAttr.tcLinkKeyExchangeAttemptsMax)
  {
    local_11[0] = '\0';
    local_14.nwk_addr_interest = 0;
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts + '\x01';
    zb_zdoNodeDescReq(0, &local_14, local_11, bdb_nodeDescRespHandler);
    sVar3 = 0;
  }
  else
  {
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts + '\x01';
    bVar1 = zb_isDeviceJoinedNwk();
    if (bVar1 == false)
    {
      g_bdbCtx.field_2.identifyTimer = (ev_timer_event_t *)0x0;
      g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = bVar1;
      bdb_retrieveTcLinkKeyDone('\n');
      sVar3 = -2;
    }
    else
    {
      memcpy(&nStack_20, g_zbInfo.macPib.extAddress, 8);
      nStack_20.rejoin = '\0';
      nStack_20.removeChildren = '\0';
      if (((int)((uint)g_bdbCtx._43_1_ << 0x1d) < 0) ||
          (uVar2 = zb_nlmeLeaveReq(&nStack_20), uVar2 != '\0'))
      {
        sVar3 = 3000;
      }
      else
      {
        g_bdbCtx._43_1_ = g_bdbCtx._43_1_ | 4;
        sVar3 = 3000;
      }
    }
  }
  return sVar3;
}
void bdb_nodeDescRespHandler(void *arg)

{
  u8 uVar1;
  uint uVar2;
  uint local_18;
  uint uStack_14;
  uint uStack_10;
  uint uStack_c;
  u8 uStack_8;
  ss_keyReqType_e sStack_7;

  // WARNING: Load size is inaccurate
  uVar2 = (uint) * (byte *)(*arg + 1);
  if (uVar2 == 0)
  {
    if (0x14 < ((uint) * (byte *)(*arg + 0xd) << 0x19) >> 0x1a)
    {
      sStack_7 = SS_KEYREQ_TYPE_TCLK;
      uStack_8 = '\x02';
      local_18 = uVar2;
      uStack_14 = uVar2;
      uStack_10 = uVar2;
      uStack_c = uVar2;
      uVar1 = zb_apsmeRequestKeyReq((ss_apsmeRequestKeyReq_t *)&local_18);
      if (uVar1 == '\0')
      {
        g_zbInfo.bdbAttr.nodeIsOnANetwork = '\0';
        return;
      }
    }
    bdb_retrieveTcLinkKeyDone('\0');
  }
  return;
}
void bdb_zdoStartDevCnf(zdo_start_device_confirm_t *startDevCnf)

{
  byte bVar1;
  int iVar2;
  undefined1 *puVar3;

  if (g_bdbCtx.state == '\x01')
  {
    g_bdbCtx.initResult = '\0';
    if (startDevCnf->status != '\0')
    {
      g_bdbCtx.initResult = g_bdbCtx.state;
    }
    tl_zbTaskPost(bdb_task, ll_reset + 1);
  }
  else if (g_bdbCtx.state == '\0')
  {
    g_bdbCtx.status = startDevCnf->status;
    if (g_bdbCtx.status == '\0')
    {
      g_zbInfo.bdbAttr.nodeIsOnANetwork = '\x01';
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
      bVar1 = zdo_ssInfoKeyGet();
      if ((((((uint)ss_ib._62_1_ << 0x1a) >> 0x1e != (uint)bVar1) ||
            (g_zbInfo.macPib.phyChannelCur != g_bdbCtx.channel)) ||
           ((g_zbNwkCtx._46_1_ & 0x80) != 0)) ||
          ((int)((uint)g_bdbCtx._43_1_ << 0x1c) < 0))
      {
        g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0x7f;
        tl_zbTaskPost(bdb_commissioningInfoSave, (void *)0x0);
      }
    }
    else if (g_bdbCtx.status == '`')
    {
      g_bdbCtx.status = '\v';
    }
    else
    {
      g_bdbCtx.status = '\f';
    }
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xf7;
    tl_zbTaskPost(bdb_task, &DAT_00000007);
  }
  else if (g_bdbCtx.state == '\x03')
  {
    if (startDevCnf->status == '\0')
    {
      g_zbInfo.bdbAttr.nodeIsOnANetwork = '\x01';
      g_bdbCtx.status = '\0';
      iVar2 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8);
      puVar3 = &DAT_00000005;
      if (iVar2 != 0)
      {
        puVar3 = (undefined1 *)(6 - (uint)((ss_ib._62_1_ & 7) == 0));
      }
      ev_timer_taskPost(bdb_task_delay, puVar3, 200);
    }
    else
    {
      g_bdbCtx.status = g_bdbCtx.state;
      tl_zbTaskPost(bdb_task, &DAT_00000007);
    }
  }
  else if (g_bdbCtx.state == '\x04')
  {
    if (startDevCnf->status == '\0')
    {
      g_zbInfo.bdbAttr.nodeIsOnANetwork = '\x01';
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
      g_bdbCtx.status = '\0';
      puVar3 = &DAT_00000008;
      if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
      {
        FUNAAAAW();
      }
    }
    else
    {
      g_bdbCtx.status = '\x05';
      puVar3 = &DAT_00000009;
    }
    tl_zbTaskPost(bdb_task, puVar3);
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAW(void)

{
  code *in_r3;

  (*in_r3)();
  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xf4 | 4);
  ss_securityModeSet(SS_SEMODE_CENTRALIZED);
  bdb_topLevelCommissioning('\x02');
  return;
}
u8 bdb_networkFormationStart(void)

{
  u8 uVar1;

  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xf4 | 4);
  ss_securityModeSet(SS_SEMODE_CENTRALIZED);
  uVar1 = bdb_topLevelCommissioning('\x02');
  return uVar1;
}
u8 bdb_init(af_simple_descriptor_t *simple_desc, bdb_commissionSetting_t *setting, bdb_appCb_t *cb,
            u8 repower)

{
  bool bVar1;
  u8 uVar2;
  int iVar3;
  byte bVar4;
  u8 local_19;

  uVar2 = '\x01';
  if ((g_bdbCtx._43_1_ & 1) == 0)
  {
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ | 1;
    g_bdbCtx.simpleDesc = simple_desc;
    g_bdbCtx.commissionSettings = setting;
    g_bdbCtx.bdbAppCb = cb;
    bVar1 = zb_isDeviceFactoryNew();
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfd | (byte)((bVar1 & 1) << 1);
    g_bdbCtx.state = '\x01';
    if ((int)((uint)g_bdbCtx._43_1_ << 0x1b) < 0)
    {
      ss_zdoInit(false);
    }
    else
    {
      ss_zdoInit(true);
    }
    bdb_linkKeyCfg(setting, (byte)(((uint)g_bdbCtx._43_1_ << 0x1e) >> 0x1f));
    bVar4 = 0;
    bdb_scanCfg(g_zbInfo.bdbAttr.secondaryChannelSet | g_zbInfo.bdbAttr.primaryChannelSet,
                g_zbInfo.bdbAttr.scanDuration);
    g_zbInfo.bdbAttr.commissioningStatus = '\0';
    iVar3 = (g_bdbCtx._43_1_ & 2) + ~(g_bdbCtx._43_1_ & 2) + (uint)bVar4;
    g_zbInfo.bdbAttr.nodeIsOnANetwork = (u8)iVar3;
    if (iVar3 == 0)
    {
      bdb_factoryNewDevCfg(g_zbInfo.bdbAttr.nodeCommissioningCapability & BDB_NODE_COMMISSION_CAP_TOUCHLINK,
                           setting->touchlinkChannel);
      tl_zbTaskPost(bdb_task, ll_reset + 1);
    }
    else
    {
      bdb_outgoingFrameCountUpdate(repower);
      bdb_coordinatorStart();
    }
    local_19 = '\0';
    tl_zbMacAttrGet('\0', &g_bdbCtx.channel, &local_19);
    uVar2 = '\0';
  }
  return uVar2;
}
void tl_bdbAttrInit(void)

{
  memset(&g_zbInfo.bdbAttr, 0, 0x30);
  g_zbInfo.bdbAttr.primaryChannelSet._1_1_ = 0x87;
  g_zbInfo.bdbAttr.primaryChannelSet._2_1_ = 0x10;
  g_zbInfo.bdbAttr.primaryChannelSet._3_1_ = 2;
  g_zbInfo.bdbAttr.secondaryChannelSet._1_1_ = 0x70;
  g_zbInfo.bdbAttr.secondaryChannelSet._2_1_ = 0xee;
  g_zbInfo.bdbAttr.secondaryChannelSet._3_1_ = 5;
  g_zbInfo.bdbAttr.commissioningGroupId._0_1_ = 0xfe;
  g_zbInfo.bdbAttr.commissioningGroupId._1_1_ = 0xfe;
  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
  g_zbInfo.bdbAttr.tcRequireKeyExchange = '\x01';
  g_zbInfo.bdbAttr.scanDuration = '\x03';
  g_zbInfo.bdbAttr.tcLinkKeyExchangeAttemptsMax = '\x03';
  g_zbInfo.bdbAttr.tcNodeJoinTimeout = '\x0f';
  return;
}
void aps_groupEntryDel(aps_group_tbl_ent_t *p)

{
  uint uVar1;
  int iVar2;

  if (p != (aps_group_tbl_ent_t *)0x0)
  {
    *(undefined *)&p->group_addr = 0xfe;
    *(undefined *)((int)&p->group_addr + 1) = 0xfe;
    iVar2 = aps_group_entry_num - 1;
    aps_group_entry_num = (u8)iVar2;
    uVar1 = ((int)(p[-0x4b877].group_name + 5) >> 2) * -0x49249249 & 0xff;
    if ((int)uVar1 < iVar2)
    {
      memcpy(p, p + 1, (iVar2 - uVar1) * 0x1c);
    }
    *(undefined *)&aps_group_tbl[iVar2].group_addr = 0xfe;
    *(undefined *)((int)&aps_group_tbl[iVar2].group_addr + 1) = 0xfe;
  }
  return;
}
void aps_groupTblSave2Flash(void *arg)

{
  nv_flashWriteNew('\x01', 2, '\x05', (ushort)APS_GROUP_TABLE_SIZE * 0x1c, (u8 *)aps_group_tbl);
  return;
}
u8 aps_groupTblNvInit(void)

{
  nv_sts_t nVar1;

  nv_itemLengthCheckAdd('\x05', (ushort)APS_GROUP_TABLE_SIZE * 0x1c);
  nVar1 = nv_flashReadNew('\x01', '\x02', '\x05', 0x1c, (u8 *)aps_group_tbl);
  return nVar1;
}
aps_status_t aps_me_group_add_req(aps_add_group_req_t *req)

{
  u8 endpoint;
  u16 uVar1;
  aps_group_tbl_ent_t *paVar2;
  u8 *puVar3;

  endpoint = req->ep;
  if (0xfd < (byte)(endpoint - 1))
  {
    return APS_STATUS_INVALID_PARAMETER;
  }
  paVar2 = aps_group_search_by_addr(req->group_addr);
  if (paVar2 == (aps_group_tbl_ent_t *)0x0)
  {
    paVar2 = aps_group_search_by_addr(0xffff);
    if (paVar2 == (aps_group_tbl_ent_t *)0x0)
    {
      return APS_STATUS_TABLE_FULL;
    }
    paVar2->endpoints[0] = 0xff;
    paVar2->endpoints[1] = 0xff;
    paVar2->endpoints[2] = 0xff;
    paVar2->endpoints[3] = 0xff;
    paVar2->endpoints[4] = 0xff;
    paVar2->endpoints[5] = 0xff;
    paVar2->endpoints[6] = 0xff;
    paVar2->endpoints[7] = 0xff;
    memset(paVar2->group_name, 0, 0x10);
    uVar1 = req->group_addr;
    *(char *)&paVar2->group_addr = (char)uVar1;
    *(char *)((int)&paVar2->group_addr + 1) = (char)(uVar1 >> 8);
    paVar2->endpoints[0] = req->ep;
    paVar2->n_endpoints = '\x01';
    aps_group_entry_num = aps_group_entry_num + '\x01';
  }
  else
  {
    puVar3 = aps_group_ep_find(paVar2, endpoint);
    if (puVar3 != (u8 *)0x0)
    {
      return APS_STATUS_DUPLICATE_ENTRY;
    }
    puVar3 = aps_group_ep_find(paVar2, 0xff);
    if (puVar3 == (u8 *)0x0)
    {
      return APS_STATUS_TABLE_FULL;
    }
    *puVar3 = endpoint;
    paVar2->n_endpoints = paVar2->n_endpoints + '\x01';
  }
  tl_zbTaskPost(aps_groupTblSave2Flash, (void *)0x0);
  return APS_STATUS_SUCCESS;
}
aps_status_t aps_me_group_delete_req(aps_delete_group_req_t *req)

{
  aps_group_tbl_ent_t *entry;
  u8 *puVar1;
  uint uVar2;
  u8 uVar3;
  int iVar4;
  aps_status_t aVar5;
  u8 local_18[12];

  uVar3 = req->ep;
  aVar5 = APS_STATUS_INVALID_PARAMETER;
  if ((byte)(uVar3 - 1) < 0xfe)
  {
    entry = aps_group_search_by_addr(req->group_addr);
    aVar5 = APS_STATUS_INVALID_GROUP;
    if ((entry != (aps_group_tbl_ent_t *)0x0) &&
        (puVar1 = aps_group_ep_find(entry, uVar3), puVar1 != (u8 *)0x0))
    {
      *puVar1 = 0xff;
      uVar3 = entry->n_endpoints + 0xff;
      entry->n_endpoints = uVar3;
      if (uVar3 == '\0')
      {
        aps_groupEntryDel(entry);
      }
      else
      {
        memset(local_18, 0xff, 8);
        iVar4 = 0;
        uVar2 = 0;
        do
        {
          if (entry->endpoints[iVar4] != 0xff)
          {
            local_18[uVar2] = entry->endpoints[iVar4];
            uVar2 = uVar2 + 1 & 0xff;
          }
          iVar4 = iVar4 + 1;
        } while (iVar4 != 8);
        memcpy(entry->endpoints, local_18, 8);
      }
      tl_zbTaskPost(aps_groupTblSave2Flash, (void *)0x0);
      aVar5 = APS_STATUS_SUCCESS;
    }
  }
  return aVar5;
}
void aps_groupTblReset(void)

{
  uint uVar1;
  aps_group_tbl_ent_t *paVar2;
  uint uVar3;

  aps_group_entry_num = '\0';
  uVar3 = (uint)APS_GROUP_TABLE_SIZE;
  if (uVar3 != 0)
  {
    paVar2 = aps_group_tbl;
    uVar1 = 0;
    do
    {
      *(undefined *)&aps_group_tbl[uVar1].group_addr = 0xfe;
      *(undefined *)((int)&aps_group_tbl[uVar1].group_addr + 1) = 0xfe;
      paVar2->n_endpoints = '\0';
      paVar2->endpoints[0] = 0xfe;
      paVar2->endpoints[1] = 0xfe;
      paVar2->endpoints[2] = 0xfe;
      paVar2->endpoints[3] = 0xfe;
      paVar2->endpoints[4] = 0xfe;
      paVar2->endpoints[5] = 0xfe;
      paVar2->endpoints[6] = 0xfe;
      paVar2->endpoints[7] = 0xfe;
      uVar1 = uVar1 + 1;
      paVar2 = paVar2 + 1;
    } while ((uVar1 & 0xff) < uVar3);
  }
  return;
}
aps_status_t aps_me_group_delete_all_req(u8 ep)

{
  aps_status_t aVar1;
  u8 *puVar2;
  uint uVar3;
  u8 uVar4;
  char cVar5;
  uint uVar6;
  byte bVar7;
  u8 local_2c[8];

  aVar1 = APS_STATUS_INVALID_PARAMETER;
  if ((uint)ep * 0x1000000 - 0x1000000 >> 0x18 < 0xfe)
  {
    uVar6 = 0;
    bVar7 = 0;
    do
    {
      while (aps_group_tbl[uVar6].group_addr != 0xffff)
      {
        puVar2 = aps_group_ep_find(aps_group_tbl + uVar6, ep);
        if (puVar2 == (u8 *)0x0)
        {
          uVar4 = aps_group_tbl[uVar6].n_endpoints;
        }
        else
        {
          *puVar2 = 0xff;
          uVar4 = aps_group_tbl[uVar6].n_endpoints + 0xff;
          aps_group_tbl[uVar6].n_endpoints = uVar4;
        }
        if (uVar4 == '\0')
        {
          aps_groupEntryDel(aps_group_tbl + uVar6);
        }
        else
        {
          memset(local_2c, 0xff, 8);
          puVar2 = aps_group_tbl[uVar6].endpoints;
          cVar5 = '\b';
          uVar3 = 0;
          do
          {
            if (*puVar2 != 0xff)
            {
              local_2c[uVar3] = *puVar2;
              uVar3 = uVar3 + 1 & 0xff;
            }
            cVar5 = cVar5 + -1;
            puVar2 = puVar2 + 1;
          } while (cVar5 != '\0');
          memcpy(aps_group_tbl[uVar6].endpoints, local_2c, 8);
        }
        uVar6 = uVar6 + 1 & 0xff;
        bVar7 = bVar7 + 1;
        if (aps_group_entry_num < bVar7)
          goto LAB_0000d34e;
      }
      uVar6 = uVar6 + 1 & 0xff;
      if (APS_GROUP_TABLE_SIZE <= uVar6)
      {
        bVar7 = bVar7 + 1;
        uVar6 = 0;
      }
    } while (bVar7 <= aps_group_entry_num);
  LAB_0000d34e:
    aps_groupTblReset();
    tl_zbTaskPost(aps_groupTblSave2Flash, (void *)0x0);
    aVar1 = APS_STATUS_SUCCESS;
  }
  return aVar1;
}
u8 aps_group_entry_num_get(void)

{
  return aps_group_entry_num;
}
void aps_group_list_get(u8 *counter, u16 *group_list)

{
  byte bVar1;
  uint uVar2;

  if ((group_list != (u16 *)0x0) && (counter + ~(uint)counter == (u8 *)0xffffffff))
  {
    *counter = '\0';
    if (APS_GROUP_TABLE_SIZE != '\0')
    {
      uVar2 = 0;
      do
      {
        if (aps_group_tbl[uVar2].group_addr != 0xffff)
        {
          bVar1 = *counter;
          group_list[bVar1] = aps_group_tbl[uVar2].group_addr;
          *counter = bVar1 + 1;
        }
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < APS_GROUP_TABLE_SIZE);
    }
  }
  return;
}
void aps_init_group_num_set(void)

{
  uint uVar1;

  if (APS_GROUP_TABLE_SIZE != 0)
  {
    uVar1 = 0;
    do
    {
      if (aps_group_tbl[uVar1].group_addr != 0xffff)
      {
        aps_group_entry_num = aps_group_entry_num + '\x01';
      }
      uVar1 = uVar1 + 1;
    } while ((uVar1 & 0xff) < (uint)APS_GROUP_TABLE_SIZE);
  }
  return;
}
void af_init(void)

{
  available_active_ep_num = '\0';
  memset(aed, 0, 0x80);
  zdo_epDesc.cb_rx = ll_reset;
  zdo_epDesc.cb_cnf = ll_reset;
  zdo_epDesc.correspond_simple_desc = (af_simple_descriptor_t *)0x0;
  zdo_epDesc._12_4_ = 0;
  return;
}
void af_nodeDescManuCodeUpdate(u16 manuCode)

{
  ndt._3_2_ = manuCode;
  return;
}
u8 af_nodeDescStackRevisionGet(void)

{
  return (u8)(ndt.server_mask >> 9);
}
u8 af_nodeMacCapabilityGet(void)

{
  return ndt.mac_capability_flag;
}
device_type_t af_nodeDevTypeGet(void)

{
  return (device_type_t)(((uint)ndt._0_1_ << 0x1d) >> 0x1d);
}
u8 af_simpleDescriptorCopy(u8 *dst, af_simple_descriptor_t *sd)

{
  u8 *puVar1;
  uint uVar2;

  *dst = sd->endpoint;
  dst[1] = *(u8 *)&sd->app_profile_id;
  dst[2] = *(u8 *)((int)&sd->app_profile_id + 1);
  dst[3] = *(u8 *)&sd->app_dev_id;
  dst[4] = *(u8 *)((int)&sd->app_dev_id + 1);
  dst[5] = '\0';
  dst[5] = (byte)(((uint)(byte)sd->field_0x5 << 0x1c) >> 0x1c);
  dst[6] = sd->app_in_cluster_count;
  puVar1 = dst + 7;
  uVar2 = ((uint)sd->app_in_cluster_count << 0x19) >> 0x18;
  memcpy(puVar1, sd->app_in_cluster_lst, uVar2);
  puVar1 = puVar1 + uVar2;
  *puVar1 = sd->app_out_cluster_count;
  uVar2 = ((uint)sd->app_out_cluster_count << 0x19) >> 0x18;
  memcpy(puVar1 + 1, sd->app_out_cluster_lst, uVar2);
  return (u8)((uint)((int)(puVar1 + 1 + (uVar2 - (int)dst)) * 0x1000000) >> 0x18);
}
void af_nodeDescriptorCopy(node_descriptor_t *dst)

{
  memcpy(dst, &ndt, 0xd);
  return;
}
void af_powerDescriptorCopy(power_descriptor_t *dst)

{
  memcpy(dst, &pdt, 2);
  return;
}
u8 af_availableEpNumGet(void)

{
  return available_active_ep_num;
}
u8 af_profileMatchedLocal(u16 profileID, u8 ep)

{
  u8 uVar1;
  uint uVar2;
  uint uVar3;
  u8 *puVar4;
  uint uVar5;

  uVar3 = (uint)ep;
  uVar2 = (uint)profileID;
  if (((uVar3 != 0) || (uVar1 = '\x01', uVar2 != 0)) &&
      ((uVar3 == 0 || (uVar1 = '\x01', uVar2 != 0xc05e))))
  {
    uVar1 = '\0';
    if (available_active_ep_num != 0)
    {
      puVar4 = &aed[0].ep;
      uVar5 = 0;
      do
      {
        if ((((uVar3 - 0xff) + ~(uVar3 - 0xff) + (uint)(0xfe < uVar3) != 0) || (*puVar4 == uVar3)) && ((~(uVar2 - 0xffff) + (uVar2 - 0xffff) + (uint)(0xfffe < uVar2) != 0 ||
                                                                                                        ((aed[uVar5].correspond_simple_desc)->app_profile_id == uVar2))))
        {
          return '\x01';
        }
        uVar5 = uVar5 + 1;
        puVar4 = puVar4 + 0x10;
      } while ((uVar5 & 0xff) < (uint)available_active_ep_num);
      uVar1 = '\0';
    }
  }
  return uVar1;
}
u8 af_clusterMatchedLocal(u16 clusterID, u8 ep)

{
  uint uVar1;
  u16 *puVar2;
  byte bVar3;
  af_simple_descriptor_t *paVar4;
  u8 *puVar5;

  uVar1 = 0;
  if (available_active_ep_num != 0)
  {
    puVar5 = &aed[0].ep;
    do
    {
      if (*puVar5 == ep)
      {
        paVar4 = aed[uVar1].correspond_simple_desc;
        if (paVar4->app_in_cluster_count != 0)
        {
          puVar2 = paVar4->app_in_cluster_lst;
          if (*puVar2 != clusterID)
          {
            bVar3 = 0;
            while (true)
            {
              puVar2 = puVar2 + 1;
              bVar3 = bVar3 + 1;
              if (paVar4->app_in_cluster_count <= bVar3)
                break;
              if (*puVar2 == clusterID)
                goto LAB_0000d75c;
            }
            goto LAB_0000d71e;
          }
        LAB_0000d75c:
          uVar1 = 1;
          goto LAB_0000d75e;
        }
      LAB_0000d71e:
        if (paVar4->app_out_cluster_count != 0)
        {
          puVar2 = paVar4->app_out_cluster_lst;
          if (*puVar2 == clusterID)
            goto LAB_0000d75c;
          bVar3 = 0;
          while (true)
          {
            puVar2 = puVar2 + 1;
            bVar3 = bVar3 + 1;
            if (paVar4->app_out_cluster_count <= bVar3)
              break;
            if (*puVar2 == clusterID)
              goto LAB_0000d75c;
          }
        }
      }
      uVar1 = uVar1 + 1;
      puVar5 = puVar5 + 0x10;
    } while ((uVar1 & 0xff) < (uint)available_active_ep_num);
    uVar1 = 0;
  }
LAB_0000d75e:
  return (u8)uVar1;
}
u8 af_clsuterIdMatched(u16 clusterID, af_simple_descriptor_t *pSimpleDesc)

{
  u16 *puVar1;
  byte bVar2;

  if (pSimpleDesc == (af_simple_descriptor_t *)0x0)
  {
    return '\0';
  }
  if (pSimpleDesc->app_in_cluster_count == 0)
  {
  LAB_0000d7b6:
    if (pSimpleDesc->app_out_cluster_count == 0)
    {
      return '\0';
    }
    puVar1 = pSimpleDesc->app_out_cluster_lst;
    if (*puVar1 == clusterID)
    {
      return '\x01';
    }
    bVar2 = 0;
    do
    {
      puVar1 = puVar1 + 1;
      bVar2 = bVar2 + 1;
      if (pSimpleDesc->app_out_cluster_count <= bVar2)
      {
        return '\0';
      }
    } while (*puVar1 != clusterID);
  }
  else
  {
    puVar1 = pSimpleDesc->app_in_cluster_lst;
    if (*puVar1 == clusterID)
    {
      return '\x01';
    }
    bVar2 = 0;
    do
    {
      puVar1 = puVar1 + 1;
      bVar2 = bVar2 + 1;
      if (pSimpleDesc->app_in_cluster_count <= bVar2)
        goto LAB_0000d7b6;
    } while (*puVar1 != clusterID);
  }
  return '\x01';
}
u8 af_profileIdMatched(u16 profileID, af_simple_descriptor_t *pSimpleDesc)

{
  byte bVar1;
  u8 uVar2;

  uVar2 = '\0';
  if ((pSimpleDesc != (af_simple_descriptor_t *)0x0) && (uVar2 = '\x01', profileID != 0xffff))
  {
    bVar1 = (char)profileID - (char)pSimpleDesc->app_profile_id;
    uVar2 = bVar1 + ~bVar1 + (pSimpleDesc->app_profile_id <= profileID);
  }
  return uVar2;
}
u8 af_endpointRegister(u8 ep, af_simple_descriptor_t *simple_desc, af_endpoint_cb_t rx_cb,
                       af_dataCnf_cb_t cnfCb)

{
  u8 uVar1;
  u8 *puVar2;
  uint uVar3;

  if (ep == '\0')
  {
    uVar1 = '\x01';
    zdo_epDesc.cb_rx = rx_cb;
    zdo_epDesc.cb_cnf = cnfCb;
    zdo_epDesc.correspond_simple_desc = simple_desc;
    zdo_epDesc.ep = ep;
  }
  else
  {
    puVar2 = &aed[0].ep;
    do
    {
      if (*puVar2 == ep)
      {
        return '\0';
      }
      puVar2 = puVar2 + 0x10;
    } while ((u32 *)puVar2 != &prevSysTick);
    uVar3 = (uint)available_active_ep_num;
    uVar1 = '\0';
    if (uVar3 < 8)
    {
      aed[uVar3].ep = ep;
      aed[uVar3].correspond_simple_desc = simple_desc;
      aed[uVar3].cb_cnf = cnfCb;
      aed[uVar3].cb_rx = rx_cb;
      available_active_ep_num = available_active_ep_num + '\x01';
      uVar1 = '\x01';
    }
  }
  return uVar1;
}
u8 sys_exceptionPost(u16 line, u8 evt)

{
  T_evtExcept[1] = (u16)evt;
  T_evtExcept[0] = line;
  if (g_sysExceptCallbak != ll_reset)
  {
    FUNAAAAX();
  }
  return '\0';
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAX(void)

{
  code *in_r3;

  g_sysExceptCallbak = (sys_exception_cb_t)(*in_r3)();
  return;
}
void sys_exceptHandlerRegister(sys_exception_cb_t cb)

{
  g_sysExceptCallbak = cb;
  return;
}
void ev_main(void)

{
  ev_timer_process();
  ev_poll_process();
  return;
}
void ev_buf_reset(void)

{
  byte bVar1;
  ushort uVar2;
  mem_pool_t *pmVar3;
  int iVar4;
  ev_buf_vars_t *peVar5;
  mem_pool_t **ppmVar6;
  u8 **ppuVar7;
  u8 *local_50[4];
  mem_pool_t *local_40[4];
  undefined4 local_30;
  undefined4 uStack_2c;
  undefined4 local_28;

  uStack_2c = 0x3c0018;
  local_30 = 0x4000096;
  ppmVar6 = local_40;
  local_40[2] = &size_0_pool;
  local_40[1] = &size_1_pool;
  local_40[0] = &size_2_pool;
  local_40[3] = &size_3_pool;
  local_50[2] = size_0_mem;
  local_50[1] = size_1_mem;
  local_50[0] = size_2_mem;
  local_50[3] = size_3_mem;
  local_28 = 0x1080808;
  memset(ev_buf_v, 0, 0x20);
  iVar4 = 0;
  peVar5 = ev_buf_v;
  ppuVar7 = local_50;
  do
  {
    bVar1 = *(byte *)((int)&local_28 + iVar4);
    peVar5->bufGroups[iVar4].availBufNum = bVar1;
    pmVar3 = *ppmVar6;
    ppmVar6 = ppmVar6 + 1;
    uVar2 = *(ushort *)((int)&local_30 + iVar4 * 2);
    pmVar3 = mempool_init(pmVar3, *ppuVar7, (uint)uVar2, (uint)bVar1);
    *(char *)&peVar5->bufGroups[iVar4].qHead = (char)pmVar3;
    *(char *)((int)&peVar5->bufGroups[iVar4].qHead + 1) = (char)((uint)pmVar3 >> 8);
    *(char *)((int)&peVar5->bufGroups[iVar4].qHead + 2) = (char)((uint)pmVar3 >> 0x10);
    *(char *)((int)&peVar5->bufGroups[iVar4].qHead + 3) = (char)((uint)pmVar3 >> 0x18);
    peVar5 = ev_buf_v;
    *(char *)&ev_buf_v->bufGroups[iVar4].size = (char)uVar2;
    *(char *)((int)&peVar5->bufGroups[iVar4].size + 1) = (char)(uVar2 >> 8);
    iVar4 = iVar4 + 1;
    ppuVar7 = ppuVar7 + 1;
  } while (iVar4 != 4);
  return;
}
void ev_buf_init(void)

{
  ev_buf_reset();
  return;
}
u8 is_ev_buf(void *arg)

{
  bool bVar1;

  if ((((arg < size_0_mem) || (bVar1 = true, &size_2_pool < arg)) &&
       ((arg < size_1_mem || (bVar1 = true, &size_0_pool < arg)))) &&
      ((arg < size_2_mem || (bVar1 = true, size_3_mem < arg))))
  {
    bVar1 = false;
    if (size_2_mem + 0x4bf < arg)
    {
      bVar1 = arg < (void *)((int)&size_3_pool.free_list + 1);
    }
  }
  return bVar1;
}
buf_sts_t ev_buf_free(u8 *pBuf)

{
  int iVar1;
  undefined4 *puVar2;
  u8 uVar3;
  u32 en;
  uint uVar4;

  en = drv_disable_irq();
  uVar3 = is_ev_buf(pBuf);
  if (uVar3 == '\0')
  {
    sys_exceptionPost(0xd2, 'q');
  }
  iVar1 = *(int *)(pBuf + -4);
  uVar4 = (uint)(iVar1 << 0x18) >> 0x15;
  puVar2 = *(undefined4 **)
               CONCAT13(*(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4 + 3),
                        CONCAT12(*(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4 + 2),
                                 CONCAT11(*(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4 + 1),
                                          *(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4))));
  while (true)
  {
    if (puVar2 == (undefined4 *)0x0)
    {
      mempool_free((mem_pool_t *)
                       CONCAT13(*(undefined *)((int)&ev_buf_v->bufGroups[iVar1].qHead + 3),
                                CONCAT12(*(undefined *)((int)&ev_buf_v->bufGroups[iVar1].qHead + 2),
                                         CONCAT11(*(undefined *)((int)&ev_buf_v->bufGroups[iVar1].qHead + 1),
                                                  *(undefined *)&ev_buf_v->bufGroups[iVar1].qHead))),
                   pBuf + -4);
      ev_buf_v->bufGroups[*(int *)(pBuf + -4)].availBufNum =
          ev_buf_v->bufGroups[*(int *)(pBuf + -4)].availBufNum + '\x01';
      drv_restore_irq(en);
      return BUFFER_SUCC;
    }
    if ((undefined4 *)(pBuf + -8) == puVar2)
      break;
    puVar2 = (undefined4 *)*puVar2;
  }
  sys_exceptionPost(0xdf, 'r');
  drv_restore_irq(en);
  return BUFFER_DUPLICATE_FREE;
}
void ev_buf_getFreeMaxSize(void)

{
  uint uVar1;
  uint uVar2;
  ev_buf_groups_t *peVar3;
  int iVar4;

  iVar4 = 0;
  uVar1 = 0;
  peVar3 = ev_buf_v->bufGroups;
  do
  {
    if ((peVar3->availBufNum != '\0') &&
        (uVar2 = ev_buf_v->bufGroups[iVar4].size - 8, uVar1 < uVar2))
    {
      uVar1 = uVar2 & 0xffff;
    }
    iVar4 = iVar4 + 1;
    peVar3 = peVar3 + 1;
  } while (iVar4 != 4);
  return;
}
void ev_on_poll(ev_poll_e e, ev_poll_callback_t cb)

{
  uint uVar1;

  uVar1 = ((uint)e << 0x18) >> 0x15;
  *(ev_poll_callback_t *)((int)&ev_poll[0].cb + uVar1) = cb;
  *(undefined4 *)((int)&ev_poll[0].valid + uVar1) = 1;
  return;
}
void ev_enable_poll(ev_poll_e e)

{
  *(undefined4 *)((int)&ev_poll[0].valid + (((uint)e << 0x18) >> 0x15)) = 1;
  return;
}
void ev_disable_poll(ev_poll_e e)

{
  *(undefined4 *)((int)&ev_poll[0].valid + (((uint)e << 0x18) >> 0x15)) = 0;
  return;
}
void ev_poll_process(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    if (ev_poll[iVar1].valid != 0)
    {
      FUNAAAAY();
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 3);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAY(void)

{
  code *in_r3;

  (*in_r3)();
  memset(&ev_timer, 0, 0x2ac);
  return;
}
void ev_timer_init(void)

{
  memset(&ev_timer, 0, 0x2ac);
  return;
}
void ev_timer_poolDelUpdate(ev_timer_event_t *evt)

{
  evt->isRunning = '\0';
  *(undefined *)&evt->curSysTick = 0;
  *(undefined *)((int)&evt->curSysTick + 1) = 0;
  *(undefined *)((int)&evt->curSysTick + 2) = 0;
  *(undefined *)((int)&evt->curSysTick + 3) = 0;
  if ((((ev_timer_event_t *)((int)&ev_timer.timer_nearest + 3) < evt) &&
       (evt <= (ev_timer_event_t *)((int)&ev_timer + (g_ev_timer_maxNum - 1) * 0x1c + 8))) &&
      (evt->used != '\0'))
  {
    evt->used = '\0';
    ev_timer.timerEventPool.used_num = ev_timer.timerEventPool.used_num - 1;
  }
  return;
}
void ev_timer_nearestUpdate(void)

{
  ev_timer_event_t **ppeVar1;
  ev_timer_event_t *peVar2;

  ev_timer.timer_nearest = ev_timer.timer_head;
  peVar2 = ev_timer.timer_head;
  if (ev_timer.timer_head != (ev_timer_event_t *)0x0)
  {
    do
    {
      if (peVar2->timeout < (ev_timer.timer_nearest)->timeout)
      {
        ev_timer.timer_nearest = peVar2;
      }
      ppeVar1 = &peVar2->next;
      peVar2 = *ppeVar1;
    } while (*ppeVar1 != (ev_timer_event_t *)0x0);
  }
  return;
}
u8 ev_timer_enough(void)

{
  return ev_timer.timerEventPool.used_num < 0x14;
}
u8 ev_timer_exist(ev_timer_event_t *evt)

{
  u8 uVar1;
  ev_timer_event_t *peVar2;

  uVar1 = '\0';
  if ((ev_timer.timer_head != (ev_timer_event_t *)0x0) &&
      (uVar1 = '\x01', peVar2 = ev_timer.timer_head, ev_timer.timer_head != evt))
  {
    do
    {
      peVar2 = peVar2->next;
      if (peVar2 == (ev_timer_event_t *)0x0)
      {
        return '\0';
      }
    } while (evt != peVar2);
    uVar1 = '\x01';
  }
  return uVar1;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void ev_on_timer(ev_timer_event_t *evt, u32 timeout)

{
  ev_timer_event_t *peVar1;
  u32 uVar2;
  ev_timer_event_t *peVar3;
  undefined4 uVar4;
  u32 en;

  if (evt == (ev_timer_event_t *)0x0)
  {
    sys_exceptionPost(0x7d, '\x01');
  }
  else
  {
    *(char *)&evt->period = (char)timeout;
    *(char *)((int)&evt->period + 1) = (char)(timeout >> 8);
    *(char *)((int)&evt->period + 2) = (char)(timeout >> 0x10);
    *(char *)((int)&evt->period + 3) = (char)(timeout >> 0x18);
    en = drv_disable_irq();
    uVar4 = _DAT_00800740;
    peVar1 = evt;
    peVar3 = ev_timer.timer_head;
    while (peVar3 != (ev_timer_event_t *)0x0)
    {
      if (evt == peVar3)
      {
        uVar2 = evt->period;
        *(char *)&peVar1->timeout = (char)uVar2;
        *(char *)((int)&peVar1->timeout + 1) = (char)(uVar2 >> 8);
        *(char *)((int)&peVar1->timeout + 2) = (char)(uVar2 >> 0x10);
        *(char *)((int)&peVar1->timeout + 3) = (char)(uVar2 >> 0x18);
        goto LAB_0000de70;
      }
      peVar1 = peVar3->next;
      peVar3 = peVar1;
    }
    if (evt->isRunning == '\0')
    {
      *(char *)&evt->curSysTick = (char)_DAT_00800740;
      *(char *)((int)&evt->curSysTick + 1) = (char)((uint)uVar4 >> 8);
      *(char *)((int)&evt->curSysTick + 2) = (char)((uint)uVar4 >> 0x10);
      *(char *)((int)&evt->curSysTick + 3) = (char)((uint)uVar4 >> 0x18);
    }
    uVar2 = evt->period;
    *(char *)&evt->timeout = (char)uVar2;
    *(char *)((int)&evt->timeout + 1) = (char)(uVar2 >> 8);
    *(char *)((int)&evt->timeout + 2) = (char)(uVar2 >> 0x10);
    *(char *)((int)&evt->timeout + 3) = (char)(uVar2 >> 0x18);
    *(char *)&evt->next = (char)ev_timer.timer_head;
    *(char *)((int)&evt->next + 1) = (char)((uint)ev_timer.timer_head >> 8);
    *(char *)((int)&evt->next + 2) = (char)((uint)ev_timer.timer_head >> 0x10);
    *(char *)((int)&evt->next + 3) = (char)((uint)ev_timer.timer_head >> 0x18);
    ev_timer.timer_head = evt;
  LAB_0000de70:
    ev_timer_nearestUpdate();
    drv_restore_irq(en);
  }
  return;
}
void ev_unon_timer(ev_timer_event_t *evt)

{
  u32 en;
  ev_timer_event_t *peVar1;
  ev_timer_event_t *peVar2;

  if (evt == (ev_timer_event_t *)0x0)
  {
    sys_exceptionPost(0x9a, '\x01');
    return;
  }
  peVar1 = ev_timer.timer_head;
  if (ev_timer.timer_head == (ev_timer_event_t *)0x0)
  {
    return;
  }
  do
  {
    if (evt == peVar1)
    {
      en = drv_disable_irq();
      ev_timer_poolDelUpdate(evt);
      peVar1 = ev_timer.timer_head;
      if (ev_timer.timer_head == evt)
      {
        ev_timer.timer_head = evt->next;
        ev_timer_nearestUpdate();
        drv_restore_irq(en);
        return;
      }
      do
      {
        peVar2 = peVar1;
        peVar1 = peVar2->next;
        if (peVar1 == (ev_timer_event_t *)0x0)
        {
          ev_timer_nearestUpdate();
          drv_restore_irq(en);
          return;
        }
      } while (evt != peVar1);
      peVar1 = evt->next;
      *(char *)&peVar2->next = (char)peVar1;
      *(char *)((int)&peVar2->next + 1) = (char)((uint)peVar1 >> 8);
      *(char *)((int)&peVar2->next + 2) = (char)((uint)peVar1 >> 0x10);
      *(char *)((int)&peVar2->next + 3) = (char)((uint)peVar1 >> 0x18);
      ev_timer_nearestUpdate();
      drv_restore_irq(en);
      return;
    }
    peVar1 = peVar1->next;
  } while (peVar1 != (ev_timer_event_t *)0x0);
  return;
}
u8 ev_timer_taskCancel(ev_timer_event_t **evt)

{
  u8 uVar1;
  ev_timer_event_t *evt_00;

  evt_00 = *evt;
  uVar1 = '\b';
  if ((evt_00 != (ev_timer_event_t *)0x0) && (evt_00->used != '\0'))
  {
    ev_unon_timer(evt_00);
    *evt = (ev_timer_event_t *)0x0;
    uVar1 = '\0';
  }
  return uVar1;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void ev_timer_update(u32 updateTime)

{
  int iVar1;
  u32 en;
  int iVar2;
  u32 uVar3;
  int iVar4;
  ev_timer_event_t *peVar5;

  iVar1 = _DAT_00800740;
  if (updateTime != 0)
  {
    en = drv_disable_irq();
    if (ev_timer.timer_head != (ev_timer_event_t *)0x0)
    {
      iVar4 = sysTimerPerUs * 1000;
      peVar5 = ev_timer.timer_head;
      do
      {
        uVar3 = updateTime;
        if (peVar5->isRunning == '\0')
        {
          uVar3 = FUN_0000162c(iVar1 - peVar5->curSysTick, iVar4);
          peVar5->isRunning = '\x01';
        }
        if (uVar3 < peVar5->timeout)
        {
          iVar2 = peVar5->timeout - uVar3;
          *(char *)&peVar5->timeout = (char)iVar2;
          *(char *)((int)&peVar5->timeout + 1) = (char)((uint)iVar2 >> 8);
          *(char *)((int)&peVar5->timeout + 2) = (char)((uint)iVar2 >> 0x10);
          *(char *)((int)&peVar5->timeout + 3) = (char)((uint)iVar2 >> 0x18);
        }
        else
        {
          *(undefined *)&peVar5->timeout = 0;
          *(undefined *)((int)&peVar5->timeout + 1) = 0;
          *(undefined *)((int)&peVar5->timeout + 2) = 0;
          *(undefined *)((int)&peVar5->timeout + 3) = 0;
        }
        peVar5 = peVar5->next;
      } while (peVar5 != (ev_timer_event_t *)0x0);
    }
    drv_restore_irq(en);
  }
  return;
}
void ev_timer_executeCB(void)

{
  u32 uVar1;
  undefined uVar2;
  undefined uVar3;
  ev_timer_event_t **ppeVar4;
  undefined uVar5;
  int iVar6;
  ev_timer_event_t *evt;
  ev_timer_event_t *peVar7;

  evt = ev_timer.timer_head;
  peVar7 = ev_timer.timer_head;
  if (ev_timer.timer_head != (ev_timer_event_t *)0x0)
  {
    do
    {
      while (evt->timeout != 0)
      {
      LAB_0000e0b4:
        ppeVar4 = &evt->next;
        evt = *ppeVar4;
        if (*ppeVar4 == (ev_timer_event_t *)0x0)
          goto LAB_0000e146;
      }
      iVar6 = FUNAAAAZ();
      if (iVar6 < 0)
      {
        ev_unon_timer(evt);
      }
      else if (iVar6 == 0)
      {
        uVar1 = evt->period;
        *(char *)&evt->timeout = (char)uVar1;
        *(char *)((int)&evt->timeout + 1) = (char)(uVar1 >> 8);
        *(char *)((int)&evt->timeout + 2) = (char)(uVar1 >> 0x10);
        *(char *)((int)&evt->timeout + 3) = (char)(uVar1 >> 0x18);
      }
      else
      {
        *(char *)&evt->period = (char)iVar6;
        uVar2 = (undefined)((uint)iVar6 >> 8);
        *(undefined *)((int)&evt->period + 1) = uVar2;
        uVar3 = (undefined)((uint)iVar6 >> 0x10);
        *(undefined *)((int)&evt->period + 2) = uVar3;
        uVar5 = (undefined)((uint)iVar6 >> 0x18);
        *(undefined *)((int)&evt->period + 3) = uVar5;
        *(char *)&evt->timeout = (char)iVar6;
        *(undefined *)((int)&evt->timeout + 1) = uVar2;
        *(undefined *)((int)&evt->timeout + 2) = uVar3;
        *(undefined *)((int)&evt->timeout + 3) = uVar5;
      }
      if (ev_timer.timer_head == peVar7)
        goto LAB_0000e0b4;
      evt = ev_timer.timer_head;
      peVar7 = ev_timer.timer_head;
    } while (ev_timer.timer_head != (ev_timer_event_t *)0x0);
  }
LAB_0000e146:
  ev_timer_nearestUpdate();
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNAAAAZ(void)

{
  int iVar1;
  int iVar2;
  code *in_r3;
  int iVar3;
  int iVar4;
  undefined4 in_lr;

  (*in_r3)();
  if (prevSysTick != _DAT_00800740)
  {
    iVar4 = _DAT_00800740 - prevSysTick;
    prevSysTick = _DAT_00800740;
    iVar3 = sysTimerPerUs * 1000;
    iVar1 = FUN_0000162c(iVar4, iVar3, &prevSysTick, sysTimerPerUs, in_lr);
    iVar4 = FUN_00001628(iVar4, iVar3);
    iVar4 = iVar4 + remSysTick;
    iVar2 = FUN_0000162c(iVar4, iVar3);
    remSysTick = FUN_00001628(iVar4, iVar3);
    if (iVar2 + iVar1 != 0)
    {
      ev_timer_update(iVar2 + iVar1);
      ev_timer_executeCB();
    }
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void ev_timer_process(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  if (prevSysTick != _DAT_00800740)
  {
    iVar4 = _DAT_00800740 - prevSysTick;
    prevSysTick = _DAT_00800740;
    iVar3 = sysTimerPerUs * 1000;
    iVar1 = FUN_0000162c(iVar4, iVar3);
    iVar4 = FUN_00001628(iVar4, iVar3);
    iVar4 = iVar4 + remSysTick;
    iVar2 = FUN_0000162c(iVar4, iVar3);
    remSysTick = FUN_00001628(iVar4, iVar3);
    if (iVar2 + iVar1 != 0)
    {
      ev_timer_update(iVar2 + iVar1);
      ev_timer_executeCB();
    }
  }
  return;
}
u8 drv_adc_init(void)

{
  adc_init();
  return '\x01';
}
void drv_adc_mode_pin_set(drv_adc_mode_t mode, GPIO_PinTypeDef pin)

{
  if (mode == DRV_ADC_BASE_MODE)
  {
    adc_base_init(pin);
  }
  else if (mode == DRV_ADC_VBAT_MODE)
  {
    adc_vbat_init(pin);
  }
  return;
}
void drv_adc_enable(u8 enable)

{
  byte bVar1;

  bVar1 = analog_read(0xfc);
  analog_write(0xfc, (~enable + enable) * ' ' | bVar1 & 0xdf);
  return;
}
// WARNING: Variable defined which should be unmapped: flash_mid
void drv_calibration(void)

{
  int iVar1;
  u8 flash_uid[16];
  u8 adc_vref_calib_value[7];
  uint auStack_10[2];
  u32 flash_mid;

  auStack_10[0] = 0;
  flash_uid._0_4_ = 0;
  flash_uid._4_4_ = 0;
  flash_uid._8_4_ = 0;
  flash_uid._12_4_ = 0;
  iVar1 = flash_read_mid_uid_with_check(auStack_10, flash_uid);
  if (iVar1 != 0)
  {
    adc_vref_calib_value._0_4_ = 0;
    adc_vref_calib_value._4_2_ = 0;
    adc_vref_calib_value[6] = '\0';
    flash_read(g_u32CfgFlashAddr + 0xc0, 7, adc_vref_calib_value);
    if ((((int)((uint)adc_vref_calib_value[4] * 0x1000000) < 0) || (adc_vref_calib_value[5] == 0xff)) || (adc_vref_calib_value[6] == 0xff))
    {
      iVar1 = (adc_vref_calib_value._0_4_ & 0xff) + (adc_vref_calib_value._0_4_ >> 8 & 0xff);
      if ((iVar1 - 0x7fU & 0xffff) < 0x100)
      {
        adc_set_gpio_calib_vref((short)iVar1 + 0x398);
      }
    }
    else
    {
      adc_set_gpio_calib_vref(adc_vref_calib_value[5] + 1000 + (ushort)adc_vref_calib_value[6] * 0x100);
      adc_set_gpio_two_point_calib_offset((char)((adc_vref_calib_value[4] - 0x14) * 0x1000000 >> 0x18));
    }
  }
  return;
}
void flash_write(u32 addr, u32 len, u8 *buf)

{
  flash_write_page(addr, len, buf);
  return;
}
u8 flash_writeWithCheck(u32 addr, u32 len, u8 *buf)

{
  int iVar1;
  u32 uVar2;
  uint len_00;
  uchar auStack_48[48];

  flash_write_page(addr, len, buf);
  if (0 < (int)len)
  {
    while (true)
    {
      uVar2 = len;
      if (0x30 < (int)len)
      {
        uVar2 = 0x30;
      }
      len_00 = uVar2 & 0xff;
      flash_read_page(addr, len_00, auStack_48);
      iVar1 = memcmp(auStack_48, buf, len_00);
      if (iVar1 != 0)
      {
        return '\0';
      }
      len = len - len_00;
      if ((int)len < 1)
        break;
      addr = addr + len_00;
      buf = buf + len_00;
    }
  }
  return '\x01';
}
void flash_read(u32 addr, u32 len, u8 *buf)

{
  flash_read_page(addr, len, buf);
  return;
}
void flash_erase(u32 addr)

{
  flash_erase_sector(addr);
  return;
}
void drv_gpio_irq_process(drv_gpioIrqMode_t mode)

{
  int iVar1;
  undefined4 *puVar2;

  iVar1 = listLength(&gpioIrqHandlerQ_list);
  if (iVar1 != 0)
  {
    for (puVar2 = (undefined4 *)listHead(&gpioIrqHandlerQ_list); puVar2 != (undefined4 *)0x0;
         puVar2 = (undefined4 *)*puVar2)
    {
      if ((*(drv_gpioIrqMode_t *)(puVar2 + 3) == mode) && (puVar2[1] != 0))
      {
        FUNBBBBA();
        return;
      }
    }
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNBBBBA(void)

{
  code *in_r3;

  (*in_r3)();
  drv_gpio_irq_process(GPIO_IRQ_MODE);
  return;
}
void drv_gpio_irq_handler(void)

{
  drv_gpio_irq_process(GPIO_IRQ_MODE);
  return;
}
void drv_gpio_irq_risc0_handler(void)

{
  drv_gpio_irq_process(GPIO_IRQ_RISC0_MODE);
  return;
}
void drv_gpio_irq_risc1_handler(void)

{
  drv_gpio_irq_process(GPIO_IRQ_RISC1_MODE);
  return;
}
void drv_gpio_write(u32 pin, u8 value)

{
  byte *pbVar1;

  if (value == '\0')
  {
    pbVar1 = (byte *)(((pin << 0x10) >> 0x18) * 8 + 0x800583);
    *pbVar1 = *pbVar1 & ~(byte)pin;
  }
  else
  {
    pbVar1 = (byte *)(((pin << 0x10) >> 0x18) * 8 + 0x800583);
    *pbVar1 = (byte)pin | *pbVar1;
  }
  return;
}
void drv_gpio_read_all(u8 *p)

{
  *p = DAT_00800580;
  p[1] = DAT_00800588;
  p[2] = DAT_00800590;
  p[3] = DAT_00800598;
  return;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
char drv_platform_init(void)

{
  char cVar1;
  byte bVar2;
  uchar uVar3;
  undefined4 local_14;

  cpu_wakeup_init();
  cVar1 = pmParam._2_1_;
  clock_init(0x20);
  sysTimerPerUs = 0x10;
  _DAT_00800580 = 0xf38000;
  _DAT_00800584 = 0x7fff00;
  analog_write(0xbd, '\0');
  DAT_0080058a = 0xff;
  DAT_0080058b = 0;
  analog_write(0xbf, 0xff);
  DAT_0080058e = 0xff;
  analog_write(0xc0, '\0');
  DAT_00800592 = 0xff;
  DAT_00800593 = 0;
  analog_write(0xc2, 0xff);
  DAT_00800596 = 0xff;
  _DAT_00800598 = 0xff6000;
  _DAT_0080059c = 0xffff00;
  DAT_008005a1 = 0xf;
  DAT_008005a2 = 0xf;
  DAT_008005a3 = 0;
  DAT_008005a5 = 0xf;
  DAT_008005a6 = 0;
  analog_write('\x0e', '\0');
  analog_write('\x0f', '@');
  analog_write('\x10', '\0');
  analog_write('\x11', '\0');
  analog_write('\x12', '\0');
  analog_write('\x13', '\0');
  analog_write('\x14', '\0');
  analog_write('\x15', '<');
  if (cVar1 == '\x01')
    goto LAB_0000e52a;
  random_generator_init();
  local_14 = flash_read_mid();
  local_14._2_1_ = (byte)(local_14 >> 0x10);
  if (local_14._2_1_ < 0x13)
  {
  LAB_0000e4fc:
    do
    {
      // WARNING: Do nothing block with infinite loop
    } while (true);
  }
  if (g_u32MacFlashAddr == 0xff000)
  {
    if (local_14._2_1_ == 0x13)
      goto LAB_0000e4fc;
  LAB_0000e516:
    if (local_14._2_1_ == 0x15)
    {
      g_u32MacFlashAddr = 0x1ff000;
      g_u32CfgFlashAddr = 0x1fe000;
      goto LAB_0000e52a;
    }
  }
  else
  {
    if (g_u32MacFlashAddr == 0x1ff000)
    {
      if (local_14._2_1_ < 0x15)
        goto LAB_0000e4fc;
      goto LAB_0000e516;
    }
    if (g_u32MacFlashAddr != 0x3ff000)
      goto LAB_0000e516;
    if (local_14._2_1_ < 0x16)
      goto LAB_0000e4fc;
  }
  if (local_14._2_1_ == 0x16)
  {
    g_u32MacFlashAddr = 0x3ff000;
    g_u32CfgFlashAddr = 0x3fe000;
  }
  else if (local_14._2_1_ == 0x14)
  {
    g_u32MacFlashAddr = 0xff000;
    g_u32CfgFlashAddr = 0xfe000;
  }
LAB_0000e52a:
  rf_drv_init();
  local_14._0_1_ = 0xff;
  flash_read_page(g_u32CfgFlashAddr, 1, (uchar *)&local_14);
  if ((byte)local_14 != 0xff)
  {
    local_14._0_1_ = (byte)local_14 & 0x3f;
    bVar2 = analog_read(0x8a);
    analog_write(0x8a, bVar2 & 0xc0 | (byte)local_14);
  }
  drv_hwTmr_init('\x03', '\0');
  drv_calibration();
  uVar3 = flash_is_zb();
  if (uVar3 != '\0')
  {
    drv_adc_init();
    drv_adc_mode_pin_set(DRV_ADC_VBAT_MODE, GPIO_PC5);
    drv_adc_enable('\x01');
    flash_safe_voltage_set(0x898);
    flash_unlock_mid13325e();
  }
  return cVar1;
}
void drv_enable_irq(void)

{
  DAT_00800643 = 1;
  return;
}
undefined drv_disable_irq(void)

{
  undefined uVar1;

  uVar1 = DAT_00800643;
  DAT_00800643 = 0;
  return uVar1;
}
u32 drv_restore_irq(u32 en)

{
  DAT_00800643 = (char)en;
  return 0;
}
u32 drv_u32Rand(void)

{
  u32 uVar1;

  uVar1 = rand();
  return uVar1;
}
void drv_generateRandomData(u8 *pData, u8 len)

{
  uint uVar1;
  uint uVar2;

  if (len != 0)
  {
    uVar2 = 0;
    uVar1 = 0;
    while (true)
    {
      if ((uVar2 & 3) == 0)
      {
        uVar1 = rand();
        pData[uVar2] = (u8)uVar1;
      }
      else
      {
        pData[uVar2] = (u8)uVar1;
      }
      if ((uint)len <= (uVar2 + 1 & 0xff))
        break;
      uVar2 = uVar2 + 1;
      uVar1 = uVar1 >> 8;
    }
  }
  return;
}
u32 key_debounce_filter(u32 *mtrx_cur, u32 filt_en)

{
  uint uVar1;
  uint uVar2;
  bool bVar3;

  uVar2 = *mtrx_cur;
  uVar1 = uVar2;
  if (filt_en != 0)
  {
    uVar1 = (uVar2 | key_debounce_filter::mtrx_pre[0]) & key_debounce_filter::mtrx_last[0] |
            key_debounce_filter::mtrx_pre[0] & ~key_debounce_filter::mtrx_last[0] & uVar2;
    *mtrx_cur = uVar1;
  }
  bVar3 = uVar1 != key_debounce_filter::mtrx_last[0];
  key_debounce_filter::mtrx_pre[0] = uVar2;
  key_debounce_filter::mtrx_last[0] = uVar1;
  return (uint)bVar3;
}
u32 kb_scan_row(int drv_ind, u8 *gpio)

{
  u32 uVar1;

  uVar1 = 0;
  if ((int)(scan_pin_need << 0x1f) < 0)
  {
    uVar1 = (uint)(gpio[scan_pins[0] >> 8] & (byte)scan_pins[0]) +
            ~(uint)(gpio[scan_pins[0] >> 8] & (byte)scan_pins[0]) +
            (uint)((scan_pins[0] >> 7 & 1) != 0);
  }
  if (((scan_pin_need & 2) != 0) && ((gpio[scan_pins[1] >> 8] & (byte)scan_pins[1]) == 0))
  {
    uVar1 = uVar1 | 2;
  }
  drv_gpio_read_all(gpio);
  return uVar1;
}
nv_sts_t nv_index_read_op(u16 id, u8 itemId, u16 *itemLen, u8 opSect, u32 totalItemNum, u16 *idxNo,
                          u8 lenCheck)

{
  u16 uVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  ushort *puVar5;
  int iVar6;
  u8 uVar7;
  bool bVar8;
  u32 local_5c;
  uint uStack_50;
  nv_sts_t nStack_4c;
  u8 auStack_44[4];
  ushort auStack_40[14];

  uVar4 = (uint)id;
  if (uVar4 < 6)
  {
    iVar6 = (uVar4 + 0x1a) * 0x2000;
  }
  else
  {
    iVar6 = (uVar4 + 0x37) * 0x2000;
    if (uVar4 == 7)
    {
      iVar3 = 0x2000;
      uVar1 = *itemLen;
      goto joined_r0x0000e8e8;
    }
  }
  iVar3 = 0x1000;
  uVar1 = *itemLen;
joined_r0x0000e8e8:
  if (itemId == 0xff)
  {
    uVar2 = 0xffff;
    uVar7 = 0xff;
  }
  else
  {
    uVar2 = uVar1 + 8;
    uVar7 = 'Z';
  }
  nStack_4c = NV_ITEM_NOT_FOUND;
  if (totalItemNum != 0)
  {
    local_5c = iVar6 + totalItemNum * 8 + 4 + iVar3 * (uint)opSect;
    uStack_50 = totalItemNum & 0xffff;
    nStack_4c = NV_ITEM_NOT_FOUND;
    do
    {
      uVar4 = totalItemNum;
      if (4 < totalItemNum)
      {
        uVar4 = 4;
      }
      uVar4 = uVar4 & 0xffff;
      local_5c = local_5c + uVar4 * -8;
      uStack_50 = uStack_50 - uVar4 & 0xffff;
      flash_read(local_5c, uVar4 * 8, auStack_44);
      iVar6 = uVar4 - 1;
      if (uVar4 != 0)
      {
        puVar5 = auStack_40 + iVar6 * 4 + 1;
      LAB_0000e964:
        do
        {
          if (itemId == 0xff)
          {
            if (((*(u8 *)((int)puVar5 + 1) != uVar7) || (auStack_40[iVar6 * 4] != uVar2)) ||
                (*(u8 *)puVar5 != 0xff))
              goto LAB_0000e97e;
          }
          else if (((*(u8 *)((int)puVar5 + 1) == 'z') || (*(u8 *)((int)puVar5 + 1) == 'Z')) &&
                   (*(u8 *)puVar5 == itemId))
          {
            if (lenCheck == '\0')
            {
              *itemLen = auStack_40[iVar6 * 4] - 8;
              nStack_4c = NV_SUCC;
              break;
            }
            iVar3 = FUN_00001628(auStack_40[iVar6 * 4] - 8, uVar1);
            if (iVar3 == 0)
            {
            LAB_0000e97e:
              *idxNo = (short)iVar6 + (short)uStack_50;
              return NV_SUCC;
            }
            puVar5 = puVar5 + -4;
            bVar8 = iVar6 == 0;
            iVar6 = iVar6 + -1;
            if (bVar8)
              break;
            goto LAB_0000e964;
          }
          puVar5 = puVar5 + -4;
          bVar8 = iVar6 != 0;
          iVar6 = iVar6 + -1;
        } while (bVar8);
      }
      totalItemNum = totalItemNum - uVar4;
    } while (totalItemNum != 0);
  }
  return nStack_4c;
}
void nv_itemLengthCheckAdd(u8 itemId, u16 len)

{
  uint uVar1;
  int iVar2;
  nv_itemLenChk_t *pnVar3;
  undefined uVar4;

  uVar1 = (uint)g_nvItemLengthCheckNum;
  uVar4 = (undefined)((uint)len >> 8);
  if (uVar1 == 0)
  {
  LAB_0000ea46:
    if (uVar1 < 0x10)
    {
      g_nvItemLenCheckTbl[uVar1].itemId = itemId;
      *(char *)&g_nvItemLenCheckTbl[uVar1].len = (char)len;
      *(undefined *)((int)&g_nvItemLenCheckTbl[uVar1].len + 1) = uVar4;
      g_nvItemLengthCheckNum = g_nvItemLengthCheckNum + '\x01';
    }
    else
    {
      sys_exceptionPost(0x61, 0x80);
    }
  }
  else
  {
    pnVar3 = g_nvItemLenCheckTbl;
    if (g_nvItemLenCheckTbl[0].itemId == itemId)
    {
      iVar2 = 0;
    }
    else
    {
      iVar2 = 0;
      do
      {
        pnVar3 = pnVar3 + 1;
        iVar2 = iVar2 + 1;
        if ((int)uVar1 <= iVar2)
          goto LAB_0000ea46;
      } while (pnVar3->itemId != itemId);
    }
    *(char *)&g_nvItemLenCheckTbl[iVar2].len = (char)len;
    *(undefined *)((int)&g_nvItemLenCheckTbl[iVar2].len + 1) = uVar4;
  }
  return;
}
nv_sts_t nv_index_read(u16 id, u8 itemId, u16 len, u8 opSect, u32 totalItemNum, u16 *idxNo)

{
  nv_sts_t nVar1;
  u16 local_c[4];

  local_c[0] = len;
  nVar1 = nv_index_read_op(id, itemId, local_c, opSect, totalItemNum, idxNo, '\x01');
  return nVar1;
}
// WARNING: Could not reconcile some variable overlaps
nv_sts_t nv_sector_read(u16 id, u8 sectTotalNum, nv_sect_info_t *sectInfo)

{
  byte bVar1;
  u8 uVar2;
  nv_sts_t nVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  u32 addr;
  undefined4 uStack_2c;
  uint local_28;

  uVar5 = (uint)sectTotalNum;
  uVar4 = (uint)id;
  if (uVar4 < 6)
  {
    iVar10 = uVar4 + 0x1a;
  }
  else
  {
    iVar10 = uVar4 + 0x37;
  }
  addr = iVar10 * 0x2000;
  nVar3 = NV_ITEM_NOT_FOUND;
  if (uVar5 != 0)
  {
    uVar9 = 0;
    while (true)
    {
      flash_read(addr, 4, (u8 *)&local_28);
      uVar6 = local_28 >> 0x18 & 3;
      uVar7 = local_28 & 0xffff;
      uStack_2c._3_1_ = (byte)(local_28 >> 0x18);
      if (uVar7 == 0xfafa)
        break;
      iVar10 = (uVar7 - 0x7a7a) + ~(uVar7 - 0x7a7a) + (uint)(0x7a79 < uVar7);
      if (((iVar10 != 0) || (uVar7 == 0x5a5a)) && ((local_28 >> 0x10 & 0xff) == uVar4))
      {
        if (iVar10 == 0)
          goto LAB_0000eb8c;
        uStack_2c = local_28 & 0x3ffffff;
        uVar7 = xcrc32((uchar *)((int)&uStack_2c + 2), 2, 0xfffffffe);
        if ((uVar7 & 0x3f) == (uint)(uStack_2c._3_1_ >> 2))
        {
          local_28 = local_28 & 0xffffff | uVar6 << 0x18;
          memcpy(sectInfo, &local_28, 4);
          goto LAB_0000ebda;
        }
      }
    LAB_0000eb2c:
      if (uVar4 == 7)
      {
        iVar10 = 0x2000;
      }
      else
      {
        iVar10 = 0x1000;
      }
      uVar9 = uVar9 + 1;
      if ((int)uVar5 <= (int)uVar9)
        goto LAB_0000ebda;
      addr = addr + iVar10;
    }
    uStack_2c = local_28 & 0x3ffffff;
    uVar7 = xcrc32((uchar *)((int)&uStack_2c + 2), 2, 0xfffffffe);
    if ((uVar7 & 0x3f) != (uint)(uStack_2c._3_1_ >> 2))
      goto LAB_0000eb2c;
    local_28 = local_28 & 0xffff0000 | 0x5050;
    if (uVar4 < 6)
    {
      iVar10 = (uVar4 + 0x1a) * 0x2000;
    LAB_0000eb78:
      iVar8 = 0x1000;
    }
    else
    {
      iVar10 = (uVar4 + 0x37) * 0x2000;
      if (uVar4 != 7)
        goto LAB_0000eb78;
      iVar8 = 0x2000;
    }
    uVar2 = flash_writeWithCheck(iVar8 * (uVar6 + 1 & 1) + iVar10, 2, (u8 *)&local_28);
    if (uVar2 == '\x01')
    {
      local_28 = local_28 & 0xffff0000 | 0x7a7a;
      flash_writeWithCheck(addr, 2, (u8 *)&local_28);
    }
  LAB_0000eb8c:
    local_28 = local_28 & 0xffffff | uVar6 << 0x18;
    memcpy(sectInfo, &local_28, 4);
  LAB_0000ebda:
    bVar1 = (char)uVar9 - sectTotalNum;
    nVar3 = ~(bVar1 + ~bVar1 + (uVar5 <= uVar9)) & 3;
  }
  return nVar3;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Restarted to delay deadcode elimination for space: stack
nv_sts_t nv_write_item(u8 single, u16 id, u8 itemId, u8 opSect, u16 opItemIdx, u16 len, u8 *buf,
                       u8 isFlashCopy)

{
  u8 uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  u32 addr;
  int iVar7;
  uint uVar8;
  uint uVar9;
  u32 uVar10;
  uint uVar11;
  uint uVar12;
  nv_sts_t nVar13;
  uint uVar14;
  u8 *addr_00;
  uint *local_74;
  uint uStack_70;
  byte local_64[48];
  uint uStack_34;
  u16 uStack_30;
  u8 uStack_2e;
  char cStack_2d;
  uint local_2c;
  undefined4 uStack_28;

  uVar14 = (uint)opSect;
  uVar11 = (uint)id;
  uVar9 = (uint)len;
  local_2c = 0;
  uStack_28 = 0;
  uVar12 = uVar11;
  if (uVar11 < 6)
  {
    iVar4 = (uVar11 + 0x1a) * 0x2000;
  LAB_0000ec86:
    iVar4 = uVar14 * 0x1000 + iVar4 + 4;
    if (opItemIdx == 0)
      goto LAB_0000ec96;
  LAB_0000ee56:
    flash_read((opItemIdx - 2) * 8 + iVar4, 8, (u8 *)&local_2c);
    flash_read(local_2c, 8, (u8 *)&uStack_34);
    if ((cStack_2d == 'z') &&
        (uVar3 = xcrc32((uchar *)&local_2c, 7, 0xfffffffe), (uVar3 & 0xffff) != uStack_34 >> 0x10))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if ((((uStack_28._3_1_ != 'z') && (uStack_28._3_1_ != 'Z')) && (uStack_28._3_1_ != 'P')) &&
        (uStack_28._3_1_ != -6))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if (uVar11 < 6)
    {
      iVar7 = (uVar11 + 0x1a) * 0x2000;
    LAB_0000ee92:
      iVar7 = iVar7 + uVar14 * 0x1000;
      iVar2 = ~(uVar11 - 7) + (uVar11 - 7) + (uint)(6 < uVar11);
      if (((iVar2 != 0) || (uVar11 == 5)) || (uVar11 == 1))
        goto LAB_0000ef24;
      iVar6 = 0x200;
    }
    else
    {
      iVar7 = (uVar11 + 0x37) * 0x2000;
      if (uVar11 != 7)
        goto LAB_0000ee92;
      iVar7 = uVar14 * 0x2000 + iVar7;
      iVar2 = 1;
    LAB_0000ef24:
      iVar6 = 0x400;
    }
    if (local_2c < (uint)(iVar7 + iVar6))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if (uVar11 < 6)
    {
      iVar6 = (uVar11 + 0x1a) * 0x2000;
      iVar7 = 0x1000;
    }
    else
    {
      iVar6 = (uVar11 + 0x37) * 0x2000;
      if (iVar2 == 0)
      {
        iVar7 = 0x1000;
      }
      else
      {
        iVar7 = 0x2000;
      }
    }
    if (iVar7 * (uVar14 + 1) + iVar6 <= local_2c)
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if (uVar11 < 6)
    {
      uStack_70 = (uVar11 + 0x1a) * 0x2000;
      iVar7 = 0x1000;
    }
    else
    {
      uStack_70 = (uVar11 + 0x37) * 0x2000;
      if (iVar2 == 0)
      {
        iVar7 = 0x1000;
      }
      else
      {
        iVar7 = 0x2000;
      }
    }
    if (((uVar14 + 1) * iVar7 + uStack_70) - local_2c < (uStack_28 & 0xffff))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    local_2c = local_2c + 3 + (uStack_28 & 0xffff) & 0xfffffffc;
  }
  else
  {
    iVar4 = (uVar11 + 0x37) * 0x2000;
    if (uVar11 != 7)
      goto LAB_0000ec86;
    iVar4 = uVar14 * 0x2000 + iVar4 + 4;
    if (opItemIdx != 0)
      goto LAB_0000ee56;
  LAB_0000ec96:
    if (uVar11 < 6)
    {
      iVar7 = (uVar11 + 0x1a) * 0x2000;
    LAB_0000eeb4:
      uVar8 = iVar7 + uVar14 * 0x1000;
      uVar3 = uVar11 - 7;
      if ((uVar3 == 0) || (uVar11 == 5))
      {
        uVar5 = 0x400;
      }
      else if (uVar11 == 1)
      {
        uVar5 = 0x400;
        uVar12 = 1;
      }
      else
      {
        uVar5 = 0x200;
      }
    }
    else
    {
      iVar7 = (uVar11 + 0x37) * 0x2000;
      if (uVar11 != 7)
        goto LAB_0000eeb4;
      uVar8 = uVar14 * 0x2000 + iVar7;
      uVar5 = 0x400;
      uVar3 = 0;
    }
    local_2c = uVar8 + uVar5;
    iVar2 = uVar3 + ~uVar3 + (uint)CARRY4(uVar8, uVar5);
  }
  uStack_28 = CONCAT12(itemId, (short)(uVar9 + 8)) | 0xfa000000;
  if (uVar11 < 6)
  {
    iVar7 = (uVar12 + 0x1a) * 0x2000;
  LAB_0000ecde:
    iVar7 = iVar7 + uVar14 * 0x1000;
    if (((iVar2 != 0) || (uVar11 == 5)) || (uVar11 == 1))
      goto LAB_0000eee4;
    iVar6 = 0x200;
  }
  else
  {
    iVar7 = (uVar12 + 0x37) * 0x2000;
    if (uVar11 != 7)
      goto LAB_0000ecde;
    iVar7 = iVar7 + uVar14 * 0x2000;
  LAB_0000eee4:
    iVar6 = 0x400;
  }
  if (local_2c < (uint)(iVar7 + iVar6))
  {
    return NV_ITEM_CHECK_ERROR;
  }
  if (uVar11 < 6)
  {
    iVar7 = (uVar12 + 0x1a) * 0x2000;
    iVar6 = 0x1000;
  }
  else
  {
    iVar7 = (uVar12 + 0x37) * 0x2000;
    if (iVar2 == 0)
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
  }
  if (iVar6 * (uVar14 + 1) + iVar7 <= local_2c)
  {
    return NV_ITEM_CHECK_ERROR;
  }
  if (uVar11 < 6)
  {
    iVar7 = (uVar12 + 0x1a) * 0x2000;
  LAB_0000ef00:
    iVar2 = 0x1000;
  }
  else
  {
    iVar7 = (uVar12 + 0x37) * 0x2000;
    if (iVar2 == 0)
      goto LAB_0000ef00;
    iVar2 = 0x2000;
  }
  if (((uVar14 + 1) * iVar2 + iVar7) - local_2c < (uVar9 + 8 & 0xffff))
  {
    return NV_ITEM_CHECK_ERROR;
  }
  addr = (uint)opItemIdx * 8 + iVar4;
  uVar1 = flash_writeWithCheck(addr, 8, (u8 *)&local_2c);
  uVar12 = local_2c;
  if (uVar1 != '\x01')
  {
    return NV_ITEM_CHECK_ERROR;
  }
  if (isFlashCopy == '\0')
  {
    uVar10 = local_2c + 8;
    uVar12 = xcrc32(buf, uVar9, 0xfffffffe);
    flash_write(uVar10, uVar9, buf);
    if (len == 0)
    {
      uVar11 = 0xfffffffe;
    }
    else
    {
      uVar11 = 0xfffffffe;
      do
      {
        uVar14 = uVar9;
        if (0x10 < (int)uVar9)
        {
          uVar14 = 0x10;
        }
        uVar14 = uVar14 & 0xffff;
        flash_read(uVar10, uVar14, local_64);
        uVar11 = xcrc32(local_64, uVar14, uVar11);
        uVar9 = uVar9 - uVar14;
        uVar10 = uVar10 + uVar14;
      } while (0 < (int)uVar9);
    }
    if (uVar11 != uVar12)
    {
      return NV_CHECK_SUM_ERROR;
    }
    uStack_30 = len;
    uStack_2e = itemId;
  }
  else
  {
    uVar9 = (uStack_28 & 0xffff) - 8;
    flash_read((u32)buf, 8, (u8 *)&uStack_34);
    if ((int)uVar9 < 1)
    {
      uVar11 = 0xfffffffe;
      uVar12 = 0;
      uStack_70 = 0xfffffffe;
    }
    else
    {
      uVar10 = uVar12 + 8;
      addr_00 = buf + 8;
      uVar11 = 0xfffffffe;
      uVar12 = 0;
      uStack_70 = 0xfffffffe;
      while (true)
      {
        uVar14 = uVar9;
        if (0x30 < (int)uVar9)
        {
          uVar14 = 0x30;
        }
        uVar14 = uVar14 & 0xff;
        flash_read((u32)addr_00, uVar14, local_64);
        if (cStack_2d == 'Z')
        {
          if (uVar14 != 0)
          {
            iVar4 = 0;
            do
            {
              uVar12 = uVar12 + local_64[iVar4];
              iVar4 = iVar4 + 1;
            } while (iVar4 < (int)uVar14);
          }
          uVar11 = xcrc32(local_64, uVar14, uVar11);
        }
        else
        {
          uStack_70 = xcrc32(local_64, uVar14, uStack_70);
        }
        uVar1 = flash_writeWithCheck(uVar10, uVar14, local_64);
        if (uVar1 != '\x01')
        {
          return NV_CHECK_SUM_ERROR;
        }
        uVar9 = uVar9 - uVar14;
        if ((int)uVar9 < 1)
          break;
        addr_00 = addr_00 + uVar14;
        uVar10 = uVar10 + uVar14;
      }
    }
    if (cStack_2d != 'Z')
    {
      uVar9 = xcrc32((uchar *)&uStack_30, 4, uStack_70);
      if (((uStack_34 ^ uVar9) & 0xffff) != 0)
      {
        return NV_DATA_CHECK_ERROR;
      }
      goto LAB_0000ede4;
    }
    if (uStack_34 != uVar12)
    {
      return NV_DATA_CHECK_ERROR;
    }
  }
  uVar9 = xcrc32((uchar *)&uStack_30, 4, uVar11);
LAB_0000ede4:
  local_74 = &uStack_34;
  uStack_28 = CONCAT13(0x5a, (undefined3)uStack_28);
  if (single != '\0')
  {
    uStack_28 = CONCAT13(0x7a, (undefined3)uStack_28);
  }
  uVar12 = xcrc32((uchar *)&local_2c, 7, 0xfffffffe);
  uStack_34 = uVar12 << 0x10 | uVar9 & 0xffff;
  uVar1 = flash_writeWithCheck(local_2c, 8, (u8 *)local_74);
  nVar13 = NV_CHECK_SUM_ERROR;
  if (uVar1 == '\x01')
  {
    flash_writeWithCheck(addr + 7, 1, (u8 *)((int)&uStack_28 + 3));
    nVar13 = NV_SUCC;
  }
  return nVar13;
}
nv_sts_t nv_flashReadByIndex(u8 id, u8 itemId, u8 opSect, u16 opIdx, u16 len, u8 *buf)

{
  nv_sts_t nVar1;
  short sVar2;
  int iVar3;
  uint len_00;
  undefined4 *puVar4;
  int iVar5;
  u32 uVar6;
  nv_itemLenChk_t *pnVar7;
  u32 addr;
  uint uVar8;
  u32 uVar9;
  undefined4 local_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  uint uStack_2c;
  ushort uStack_28;
  u8 uStack_26;
  char cStack_25;
  u32 uStack_24;
  char cStack_1d;

  uVar8 = (uint)id;
  if (uVar8 < 6)
  {
    iVar5 = (uVar8 + 0x1a) * 0x2000;
  }
  else
  {
    iVar5 = (uVar8 + 0x37) * 0x2000;
    if (uVar8 == 7)
    {
      iVar3 = 0x2000;
      goto LAB_0000f100;
    }
  }
  iVar3 = 0x1000;
LAB_0000f100:
  flash_read((uint)opIdx * 8 + 4 + iVar3 * (uint)opSect + iVar5, 8, (u8 *)&uStack_24);
  if ((cStack_1d == 'z') || (nVar1 = NV_ITEM_NOT_FOUND, cStack_1d == 'Z'))
  {
    flash_read(uStack_24, 8, (u8 *)&uStack_2c);
    uVar8 = (uint)uStack_28;
    sVar2 = FUN_00001628(uVar8, len);
    pnVar7 = g_nvItemLenCheckTbl;
    iVar5 = 0;
    do
    {
      if (pnVar7->itemId == itemId)
      {
        len_00 = (uint)g_nvItemLenCheckTbl[iVar5].len;
        if (uVar8 < g_nvItemLenCheckTbl[iVar5].len)
        {
          len_00 = uVar8;
        }
        if (sVar2 != 0)
        {
          return NV_ITEM_NOT_FOUND;
        }
        goto LAB_0000f172;
      }
      iVar5 = iVar5 + 1;
      pnVar7 = pnVar7 + 1;
    } while (iVar5 != 0x10);
    nVar1 = NV_ITEM_NOT_FOUND;
    len_00 = uVar8;
    if (sVar2 == 0)
    {
    LAB_0000f172:
      nVar1 = NV_ITEM_NOT_FOUND;
      if (((cStack_25 == 'z') || (cStack_25 == 'Z')) &&
          (nVar1 = NV_ITEM_NOT_FOUND, uStack_26 == itemId))
      {
        flash_read(uStack_24 + 8, len_00, buf);
        addr = uStack_24 + 8 + len_00;
        local_4c = 0;
        uStack_48 = 0;
        uStack_44 = 0;
        uStack_40 = 0;
        uStack_3c = 0;
        uStack_38 = 0;
        uStack_34 = 0;
        uStack_30 = 0;
        if (cStack_25 == 'Z')
        {
          uVar8 = 0;
          if (len_00 != 0)
          {
            iVar5 = 0;
            do
            {
              uVar8 = uVar8 + buf[iVar5];
              iVar5 = iVar5 + 1;
            } while (iVar5 < (int)len_00);
          }
          if ((len_00 < uStack_28) && (uVar9 = uStack_28 - len_00, 0 < (int)uVar9))
          {
            while (true)
            {
              uVar6 = uVar9;
              if (0x20 < (int)uVar9)
              {
                uVar6 = 0x20;
              }
              flash_read(addr, uVar6, (u8 *)&local_4c);
              if (uVar6 != 0)
              {
                puVar4 = &local_4c;
                do
                {
                  uVar8 = uVar8 + *(byte *)puVar4;
                  puVar4 = (undefined4 *)((int)puVar4 + 1);
                } while (puVar4 != (undefined4 *)((int)&local_4c + uVar6));
              }
              uVar9 = uVar9 - uVar6;
              if ((int)uVar9 < 1)
                break;
              addr = addr + uVar6;
            }
          }
          nVar1 = ~(1U - (uStack_2c == uVar8)) & 6;
        }
        else
        {
          uVar8 = xcrc32(buf, len_00, 0xfffffffe);
          if (len_00 < uStack_28)
          {
            for (uVar9 = uStack_28 - len_00; 0 < (int)uVar9; uVar9 = uVar9 - uVar6)
            {
              uVar6 = uVar9;
              if (0x20 < (int)uVar9)
              {
                uVar6 = 0x20;
              }
              flash_read(addr, uVar6, (u8 *)&local_4c);
              uVar8 = xcrc32((uchar *)&local_4c, uVar6, uVar8);
              addr = addr + uVar6;
            }
          }
          uVar8 = xcrc32((uchar *)&uStack_28, 4, uVar8);
          nVar1 = ~(1U - (((uStack_2c ^ uVar8) & 0xffff) == 0)) & 6;
        }
      }
    }
  }
  return nVar1;
}
nv_sts_t nv_itemDeleteByIndex(u8 id, u8 itemId, u8 opSect, u16 opIdx)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  u8 auStack_d[5];

  uVar1 = (uint)id;
  if (uVar1 < 6)
  {
    iVar3 = (uVar1 + 0x1a) * 0x2000;
  }
  else
  {
    iVar3 = (uVar1 + 0x37) * 0x2000;
    if (uVar1 == 7)
    {
      iVar2 = 0x2000;
      goto LAB_0000f2b4;
    }
  }
  iVar2 = 0x1000;
LAB_0000f2b4:
  auStack_d[0] = 'P';
  flash_write((uint)opIdx * 8 + 0xb + iVar2 * (uint)opSect + iVar3, 1, auStack_d);
  return NV_SUCC;
}
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
nv_sts_t nv_flashWriteNewHandler(u8 forceChgSec, u8 single, u16 id, u8 itemId, u16 len, u8 *buf)

{
  bool bVar1;
  bool bVar2;
  byte bVar3;
  byte bVar4;
  nv_sts_t nVar5;
  u8 *puVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  short sVar13;
  uint uVar14;
  uint uVar15;
  u8 *puVar16;
  int iVar17;
  u8 **ppuVar18;
  int iVar19;
  u32 uVar20;
  int iVar21;
  uint uVar22;
  uint uStack_98;
  int iStack_7c;
  int iStack_6c;
  uint uStack_68;
  u32 uStack_64;
  u8 *puStack_60;
  ushort uStack_5c;
  u8 uStack_5a;
  byte bStack_59;
  u8 auStack_40[6];
  byte bStack_3a;
  char cStack_39;
  u8 auStack_38[7];
  byte bStack_31;
  short asStack_30[2];
  nv_sect_info_t nStack_2c;
  u16 uStack_26;

  uVar10 = (uint)id;
  uVar8 = (uint)single;
  if (uVar10 < 6)
  {
    iVar19 = (uVar10 + 0x1a) * 0x2000;
  }
  else
  {
    iVar19 = (uVar10 + 0x37) * 0x2000;
    if (uVar10 == 7)
    {
      uStack_98 = 1;
      bVar2 = true;
      if (0x2000 < len + 0x408)
      {
        return NV_NOT_ENOUGH_SAPCE;
      }
      goto LAB_0000f378;
    }
  }
  uStack_98 = ~(uVar10 - 7) + (uVar10 - 7) + (uint)(6 < uVar10) |
              (uVar10 - 5) + ~(uVar10 - 5) + (uint)(4 < uVar10);
  if (uStack_98 != 0)
  {
    nVar5 = FUN_0000f718();
    return nVar5;
  }
  if (uVar10 == 1)
  {
    nVar5 = FUN_0000f764();
    return nVar5;
  }
  bVar2 = false;
  if (0x1000 < len + 0x208)
  {
    return NV_NOT_ENOUGH_SAPCE;
  }
LAB_0000f378:
  nVar5 = nv_sector_read(id, '\x02', &nStack_2c);
  if (nVar5 != NV_SUCC)
  {
    nVar5 = FUN_0000f722();
    return nVar5;
  }
  uVar14 = (uint)nStack_2c.opSect;
  if (5 < uVar10)
  {
    nVar5 = FUN_0000f750();
    return nVar5;
  }
  uStack_26 = 0;
  if ((uStack_98 == 0) && (uVar10 == 1))
  {
    nVar5 = FUN_0000fa02();
    return nVar5;
  }
  if (forceChgSec == '\0')
  {
    nVar5 = FUN_0000f7d2();
    return nVar5;
  }
  uStack_26 = 0;
  uVar11 = uVar14 + 1 & 1;
  if (bVar2)
  {
    nVar5 = FUN_0000fa06();
    return nVar5;
  }
  uVar20 = uVar11 * 0x1000 + iVar19;
  iVar19 = 0;
  do
  {
    flash_erase(uVar20);
    uVar20 = uVar20 + 0x1000;
    iVar19 = iVar19 + 1;
  } while (iVar19 < 1);
  if (5 < uVar10)
  {
    nVar5 = FUN_0000f940();
    return nVar5;
  }
  if (uStack_98 != 0)
  {
    nVar5 = FUN_0000f93a();
    return nVar5;
  }
  if (uVar10 == 1)
  {
    nVar5 = FUN_0000f97a();
    return nVar5;
  }
  if (uVar10 < 6)
  {
    iStack_6c = uVar10 + 0x1a;
    iStack_7c = 0x1000;
  }
  else
  {
    iStack_6c = uVar10 + 0x37;
    if (!bVar2)
    {
      nVar5 = FUN_0000fa2a();
      return nVar5;
    }
    iStack_7c = 0x2000;
  }
  iStack_6c = iStack_6c * 0x2000;
  if (uVar10 == 1)
  {
    nVar5 = FUN_0000f952();
    return nVar5;
  }
  uVar22 = 0x3e;
  uStack_68 = 0x3f;
  puVar6 = ev_buf_allocate(0x3f);
  if (uVar10 < 6)
  {
    iVar19 = uVar10 + 0x1a;
    iVar17 = 0x1000;
  }
  else
  {
    iVar19 = uVar10 + 0x37;
    if (!bVar2)
    {
      nVar5 = FUN_0000fa24();
      return nVar5;
    }
    iVar17 = 0x2000;
  }
  if (puVar6 != (u8 *)0x0)
  {
    memset(puVar6, 0, 0x3f);
    iVar9 = 0x3e0000;
    uVar20 = iVar17 * uVar14 + iVar19 * 0x2000 + 500;
    sVar13 = 0;
    do
    {
      flash_read(uVar20, 8, auStack_40);
      if (((cStack_39 == 'z') || (cStack_39 == 'Z')) &&
          ((cStack_39 == 'z' || ((uVar10 == bStack_3a && (uVar8 != 0))))))
      {
        iVar19 = (int)sVar13;
        if (iVar19 != 0)
        {
          bVar1 = true;
          iVar17 = 0;
          while (true)
          {
            if (puVar6[iVar17] == bStack_3a)
            {
              nv_itemDeleteByIndex((u8)id, itemId, nStack_2c.opSect, (u16)((uint)iVar9 >> 0x10));
              bVar1 = false;
            }
            if (iVar19 <= iVar17 + 1)
              break;
            iVar17 = iVar17 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        puVar6[iVar19] = bStack_3a;
        sVar13 = sVar13 + 1;
      }
    LAB_0000f530:
      iVar9 = (uVar22 - 2) * 0x10000;
      uVar22 = uVar22 - 2 & 0xffff;
      uVar20 = uVar20 - 9;
    } while (-1 < iVar9);
    ev_buf_free(puVar6);
  }
  if (5 < uVar10)
  {
    nVar5 = FUN_0000f928();
    return nVar5;
  }
  flash_read(uVar14 * 0x1000 + (uVar10 + 0x1a) * 0x2000, 4, (u8 *)asStack_30);
  if (asStack_30[0] != 0x7a7a)
  {
    nVar5 = FUNBBBBB();
    return nVar5;
  }
  uStack_64 = uVar14 * iStack_7c + iStack_6c + 4;
  iVar19 = (uVar10 + 0x1a) * 0x2000;
  iVar17 = (uVar10 + 0x37) * 0x2000;
  uVar22 = 0;
  puVar6 = (u8 *)0x0;
  bVar1 = true;
  do
  {
    uVar15 = uStack_68;
    if (4 < (int)uStack_68)
    {
      uVar15 = 4;
    }
    uVar15 = uVar15 & 0xff;
    flash_read(uStack_64, uVar15 * 8, (u8 *)&puStack_60);
    if (uVar15 != 0)
    {
      iVar9 = 0;
      ppuVar18 = &puStack_60;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar21 = 0;
      if (uVar10 < 6)
      {
        nVar5 = FUN_0000f778();
        return nVar5;
      }
      if (!bVar2)
      {
        nVar5 = FUN_0000f7c2();
        return nVar5;
      }
      if (uVar10 == 1)
      {
        nVar5 = FUN_0000f772();
        return nVar5;
      }
      if (puStack_60 != (u8 *)(uVar14 * 0x2000 + iVar17 + 0x200))
      {
        nVar5 = FUN_0000fa20();
        return nVar5;
      }
      if (5 < uVar10)
      {
        nVar5 = FUN_0000f780();
        return nVar5;
      }
      uVar22 = (uint)uStack_5c;
      puVar6 = puStack_60;
      bVar4 = bStack_59;
      if (((uVar14 + 1) * 0x1000 + iVar19) - (int)puStack_60 < uVar22)
      {
        nVar5 = FUN_0000fa20();
        return nVar5;
      }
      while (true)
      {
        iVar7 = bVar4 - 0x7b;
        bVar3 = (byte)iVar7;
        if (((iVar7 == 0) || (bVar4 == 0x5a)) &&
            ((*(u8 *)((int)ppuVar18 + 6) != itemId || (~uVar8 + uVar8 != 0))))
        {
          flash_read((u32)puVar6, 8, auStack_38);
          if (bStack_31 == 0x7a)
          {
            nVar5 = FUN_0000f8b0();
            return nVar5;
          }
          nVar5 = nv_write_item(~bVar3 + bVar3 + (0x79 < bStack_31), id, *(u8 *)((int)ppuVar18 + 6),
                                (u8)uVar11, uStack_26, *(short *)(&uStack_5a + iVar21 + -2) - 8,
                                *(u8 **)((int)&puStack_60 + iVar21), '\x01');
          if (nVar5 == NV_SUCC)
          {
            uStack_26 = uStack_26 + 1;
            nVar5 = FUN_0000f6c0();
            return nVar5;
          }
          if (nVar5 == NV_ITEM_CHECK_ERROR)
          {
            nVar5 = FUN_0000fa20();
            return nVar5;
          }
          if (nVar5 == NV_CHECK_SUM_ERROR)
          {
            nVar5 = FUN_0000f992();
            return nVar5;
          }
          if (nVar5 == NV_NOT_ENOUGH_SAPCE)
          {
            nVar5 = FUN_0000f992();
            return nVar5;
          }
        }
        iVar9 = iVar9 + 1;
        ppuVar18 = ppuVar18 + 2;
        if ((int)uVar15 <= iVar9)
          break;
      LAB_0000f6cc:
        iVar21 = iVar9 * 8;
        puVar16 = (&puStack_60)[iVar9 * 2];
        if (puVar16 != (u8 *)((uint)(puVar6 + uVar22 + 3) & 0xfffffffc))
        {
          nVar5 = FUN_0000fa20();
          return nVar5;
        }
        iVar7 = iVar19;
        if ((uVar10 < 6) || (iVar7 = iVar17, !bVar2))
        {
          iVar12 = 0x1000;
        }
        else
        {
          iVar12 = 0x2000;
        }
        uVar22 = (uint) * (ushort *)(&uStack_5a + iVar21 + -2);
        if ((iVar12 * (uVar14 + 1) + iVar7) - (int)puVar16 < uVar22)
        {
          nVar5 = FUN_0000fa20();
          return nVar5;
        }
        puVar6 = puVar16;
        bVar4 = *(byte *)((int)ppuVar18 + 7);
      }
      bVar1 = false;
    }
    uStack_68 = uStack_68 - uVar15;
    if ((int)uStack_68 < 1)
    {
      nVar5 = FUN_0000fa20();
      return nVar5;
    }
    uStack_64 = uStack_64 + uVar15 * 8;
  } while (true);
}
undefined4 FUN_0000f342(void)

{
  undefined4 unaff_r6;

  return unaff_r6;
}
// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000f398(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  uint unaff_r4;
  int iVar8;
  undefined4 *puVar9;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  int unaff_sl;
  uint uVar14;
  int in_stack_00000010;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (in_stack_00000010 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, uStack0000008e,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000f3ba(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  uint unaff_r4;
  int iVar8;
  undefined4 *puVar9;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  int unaff_sl;
  uint uVar14;
  int in_stack_00000010;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (in_stack_00000010 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, uStack0000008e,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000f3c2(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  uint unaff_r4;
  int iVar8;
  undefined4 *puVar9;
  int iVar10;
  u32 uVar11;
  int iVar12;
  u32 uVar13;
  int unaff_sl;
  uint uVar14;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int param_11;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 param_13;

  param_13 = 0;
  uVar4 = param_11 + 1U & 1;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, param_13,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            param_13 = param_13 + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}
void FUN_0000f582(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u32 len;
  int iVar5;
  int iVar6;
  int iVar7;
  u32 uVar8;
  uint unaff_r4;
  undefined4 *puVar9;
  int iVar10;
  int iVar11;
  u32 addr;
  uint uVar12;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint uStack00000028;
  u8 in_stack_0000002c;
  uint param_12;
  int param_13;
  int param_14;
  int param_15;
  int param_16;
  uint in_stack_0000004c;
  u32 param_17;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  param_17 = param_11 * param_14 + param_16 + 4;
  param_13 = (unaff_r4 + 0x1a) * 0x2000;
  iVar7 = (unaff_r4 + 0x37) * 0x2000;
  uVar12 = 0;
  addr = 0;
  param_15 = ~param_12 + param_12 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0);
  bVar1 = true;
  do
  {
    uStack00000028 = in_stack_0000004c;
    if (4 < (int)in_stack_0000004c)
    {
      uStack00000028 = 4;
    }
    uStack00000028 = uStack00000028 & 0xff;
    len = uStack00000028 * 8;
    flash_read(param_17, len, (u8 *)&stack0x00000054);
    if (uStack00000028 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar11 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != param_11 * 0x2000 + iVar7 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar12 = (uint)uStack00000058;
      addr = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((param_11 + 1) * 0x1000 + param_13) - in_stack_00000054 < uVar12)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 || (param_15 != 0))))
        {
          flash_read(addr, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar11) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar11), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        if ((int)uStack00000028 <= iVar10)
          break;
      LAB_0000f6cc:
        iVar11 = iVar10 * 8;
        uVar8 = (&stack0x00000054)[iVar10 * 2];
        if (uVar8 != (uVar12 + addr + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = param_13;
        if ((unaff_r4 < 6) || (iVar5 = iVar7, param_9 == 0))
        {
          iVar6 = 0x1000;
        }
        else
        {
          iVar6 = 0x2000;
        }
        uVar12 = (uint) * (ushort *)((int)&stack0x00000058 + iVar10 * 2 * 4);
        if ((iVar6 * (param_11 + 1) + iVar5) - uVar8 < uVar12)
        {
          FUN_0000fa20();
          return;
        }
        addr = uVar8;
        bVar3 = *(byte *)((int)puVar9 + 7);
      }
      bVar1 = false;
    }
    in_stack_0000004c = in_stack_0000004c - uStack00000028;
    if ((int)in_stack_0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    param_17 = param_17 + len;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
void FUN_0000f67a(void)

{
  nv_sts_t nVar1;
  int iVar2;
  int iVar3;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  u32 uVar4;
  uint unaff_sl;
  uint unaff_fp;
  char in_tmpCY;
  int param_9;
  int param_10;
  int in_stack_00000018;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 param_11;
  int in_stack_00000034;
  int in_stack_00000038;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  while (true)
  {
    nVar1 = nv_write_item(~(byte)param_10 + (byte)param_10 + in_tmpCY, (u16)unaff_sl, unaff_r4[6],
                          param_11, in_stack_0000008c._2_2_, *(short *)(unaff_r7 + unaff_r8 + 4) - 8,
                          *(u8 **)(unaff_r7 + unaff_r8), '\x01');
    if (nVar1 == NV_SUCC)
    {
      in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
      FUN_0000f6c0();
      return;
    }
    if (nVar1 == NV_ITEM_CHECK_ERROR)
    {
      FUN_0000fa20();
      return;
    }
    if (nVar1 == NV_CHECK_SUM_ERROR)
    {
      FUN_0000f992();
      return;
    }
    uVar4 = unaff_r9;
    if (nVar1 == NV_NOT_ENOUGH_SAPCE)
      break;
    do
    {
      unaff_r6 = unaff_r6 + 1;
      unaff_r4 = unaff_r4 + 8;
      if ((int)in_stack_00000028 <= unaff_r6)
      {
        do
        {
          in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
          if ((int)in_stack_0000004c < 1)
          {
            FUN_0000fa20();
            return;
          }
          in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
          in_stack_00000028 = in_stack_0000004c;
          if (4 < (int)in_stack_0000004c)
          {
            in_stack_00000028 = 4;
          }
          in_stack_00000028 = in_stack_00000028 & 0xff;
          in_stack_00000048 = in_stack_00000028 << 3;
          flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
        } while (in_stack_00000028 == 0);
        unaff_r6 = 0;
        unaff_r4 = unaff_r7;
      }
      unaff_r8 = unaff_r6 * 8;
      unaff_r9 = *(u32 *)(unaff_r7 + unaff_r8);
      if (unaff_r9 != (unaff_fp + uVar4 + 3 & 0xfffffffc))
      {
        FUN_0000fa20();
        return;
      }
      iVar2 = in_stack_00000034;
      if ((unaff_sl < 6) || (iVar2 = in_stack_00000038, param_9 == 0))
      {
        iVar3 = 0x1000;
      }
      else
      {
        iVar3 = 0x2000;
      }
      unaff_fp = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
      if ((iVar3 * (in_stack_00000018 + 1) + iVar2) - unaff_r9 < unaff_fp)
      {
        FUN_0000fa20();
        return;
      }
      param_10 = unaff_r4[7] - 0x7b;
      uVar4 = unaff_r9;
    } while (((param_10 != 0) && (unaff_r4[7] != 0x5a)) ||
             ((unaff_r4[6] == in_stack_00000024 && (in_stack_0000003c == 0))));
    flash_read(unaff_r9, 8, &stack0x0000007c);
    in_tmpCY = 0x79 < in_stack_00000080._3_1_;
    if (in_stack_00000080._3_1_ == 0x7a)
    {
      FUN_0000f8b0();
      return;
    }
  }
  FUN_0000f992();
  return;
}
// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
void FUN_0000f6c0(void)

{
  byte bVar1;
  nv_sts_t nVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  u32 addr;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  u32 unaff_r9;
  uint unaff_sl;
  uint unaff_fp;
  int param_9;
  int param_11;
  uint param_13;
  uint param_14;
  u8 in_stack_0000002c;
  int param_15;
  int param_16;
  int param_17;
  u32 param_18;
  uint param_19;
  u32 param_20;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  while (true)
  {
    do
    {
      unaff_r6 = unaff_r6 + 1;
      unaff_r4 = unaff_r4 + 8;
      if ((int)param_14 <= unaff_r6)
      {
        do
        {
          param_19 = param_19 - param_14;
          if ((int)param_19 < 1)
          {
            FUN_0000fa20();
            return;
          }
          param_20 = param_20 + param_18;
          param_14 = param_19;
          if (4 < (int)param_19)
          {
            param_14 = 4;
          }
          param_14 = param_14 & 0xff;
          param_18 = param_14 << 3;
          flash_read(param_20, param_18, unaff_r7);
        } while (param_14 == 0);
        unaff_r6 = 0;
        unaff_r4 = unaff_r7;
      }
      iVar4 = unaff_r6 * 8;
      addr = *(u32 *)(unaff_r7 + iVar4);
      if (addr != (unaff_fp + unaff_r9 + 3 & 0xfffffffc))
      {
        FUN_0000fa20();
        return;
      }
      iVar3 = param_15;
      if ((unaff_sl < 6) || (iVar3 = param_16, param_9 == 0))
      {
        iVar5 = 0x1000;
      }
      else
      {
        iVar5 = 0x2000;
      }
      unaff_fp = (uint) * (ushort *)(unaff_r7 + iVar4 + 4);
      if ((iVar5 * (param_11 + 1) + iVar3) - addr < unaff_fp)
      {
        FUN_0000fa20();
        return;
      }
      iVar3 = unaff_r4[7] - 0x7b;
      unaff_r9 = addr;
    } while (((iVar3 != 0) && (unaff_r4[7] != 0x5a)) ||
             ((unaff_r4[6] == param_13 && (param_17 == 0))));
    flash_read(addr, 8, &stack0x0000007c);
    if (in_stack_00000080._3_1_ == 0x7a)
    {
      FUN_0000f8b0();
      return;
    }
    bVar1 = (byte)iVar3;
    nVar2 = nv_write_item(~bVar1 + bVar1 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                          unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                          *(short *)(unaff_r7 + iVar4 + 4) - 8, *(u8 **)(unaff_r7 + iVar4), '\x01');
    if (nVar2 == NV_SUCC)
      break;
    if (nVar2 == NV_ITEM_CHECK_ERROR)
    {
      FUN_0000fa20();
      return;
    }
    if (nVar2 == NV_CHECK_SUM_ERROR)
    {
      FUN_0000f992();
      return;
    }
    if (nVar2 == NV_NOT_ENOUGH_SAPCE)
    {
      FUN_0000f992();
      return;
    }
  }
  in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
  FUN_0000f6c0();
  return;
}
// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
undefined4 FUN_0000f718(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  undefined4 uVar4;
  u8 *pBuf;
  uint uVar5;
  short sVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  undefined4 *puVar11;
  uint unaff_r4;
  int iVar12;
  u32 uVar13;
  int iVar14;
  int unaff_r8;
  u32 uVar15;
  uint uVar16;
  int unaff_sl;
  int param_9;
  int in_stack_0000001c;
  int param_12;
  uint in_stack_00000024;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  nv_sect_info_t in_stack_00000088;
  u16 uStack0000008e;

  if (0x1000 < param_12 + 0x408U)
  {
    return 4;
  }
  nVar3 = nv_sector_read((u16)unaff_r4, '\x02', &stack0x00000088);
  if (nVar3 != NV_SUCC)
  {
    uVar4 = FUN_0000f722();
    return uVar4;
  }
  uVar7 = (uint)in_stack_00000088.opSect;
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000f750();
    return uVar4;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar4 = FUN_0000fa02();
    return uVar4;
  }
  if (unaff_r8 == 0)
  {
    uVar4 = FUN_0000f7d2();
    return uVar4;
  }
  uStack0000008e = 0;
  uVar5 = uVar7 + 1 & 1;
  if (param_9 != 0)
  {
    uVar4 = FUN_0000fa06();
    return uVar4;
  }
  uVar13 = uVar5 * 0x1000 + unaff_sl;
  iVar12 = 0;
  do
  {
    flash_erase(uVar13);
    uVar13 = uVar13 + 0x1000;
    iVar12 = iVar12 + 1;
  } while (iVar12 < 1);
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000f940();
    return uVar4;
  }
  if (in_stack_0000001c != 0)
  {
    uVar4 = FUN_0000f93a();
    return uVar4;
  }
  if (unaff_r4 == 1)
  {
    uVar4 = FUN_0000f97a();
    return uVar4;
  }
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000fa2a();
    return uVar4;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    uVar4 = FUN_0000f952();
    return uVar4;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000fa24();
    return uVar4;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar12 = 0x3e0000;
    uVar13 = uVar7 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar6 = 0;
    do
    {
      flash_read(uVar13, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar14 = (int)sVar6;
        if (iVar14 != 0)
        {
          bVar1 = true;
          iVar10 = 0;
          while (true)
          {
            if (pBuf[iVar10] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, in_stack_00000088.opSect,
                                   (u16)((uint)iVar12 >> 0x10));
              bVar1 = false;
            }
            if (iVar14 <= iVar10 + 1)
              break;
            iVar10 = iVar10 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar14] = in_stack_00000078._2_1_;
        sVar6 = sVar6 + 1;
      }
    LAB_0000f530:
      iVar12 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar13 = uVar13 - 9;
    } while (-1 < iVar12);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000f928();
    return uVar4;
  }
  flash_read(uVar7 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    uVar4 = FUNBBBBB();
    return uVar4;
  }
  uStack00000050 = uVar7 * 0x1000 + iStack00000048 + 4;
  uVar16 = 0;
  uVar13 = 0;
  bVar1 = true;
  do
  {
    uVar8 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar8 = 4;
    }
    uVar8 = uVar8 & 0xff;
    flash_read(uStack00000050, uVar8 * 8, (u8 *)&stack0x00000054);
    if (uVar8 != 0)
    {
      iVar12 = 0;
      puVar11 = &stack0x00000054;
      uVar15 = uVar13;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          uVar4 = FUN_0000f778();
          return uVar4;
        }
        uVar4 = FUN_0000f7c2();
        return uVar4;
      }
      do
      {
        uVar13 = (&stack0x00000054)[iVar12 * 2];
        if (uVar13 != (uVar16 + uVar15 + 3 & 0xfffffffc))
        {
          uVar4 = FUN_0000fa20();
          return uVar4;
        }
        uVar9 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar9 = unaff_r4 + 0x1a;
        }
        uVar16 = (uint)(ushort)(&stack0x00000058)[iVar12 * 4];
        if (((uVar7 + 1) * 0x1000 + uVar9 * 0x2000) - uVar13 < uVar16)
        {
          uVar4 = FUN_0000fa20();
          return uVar4;
        }
        iVar14 = *(byte *)((int)puVar11 + 7) - 0x7b;
        if (((iVar14 == 0) || (*(byte *)((int)puVar11 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar11 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar13, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            uVar4 = FUN_0000f8b0();
            return uVar4;
          }
          bVar2 = (byte)iVar14;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar11 + 6), (u8)uVar5, uStack0000008e,
                                (&stack0x00000058)[iVar12 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar12 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            uVar4 = FUN_0000f6c0();
            return uVar4;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            uVar4 = FUN_0000fa20();
            return uVar4;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            uVar4 = FUN_0000f992();
            return uVar4;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            uVar4 = FUN_0000f992();
            return uVar4;
          }
        }
        iVar12 = iVar12 + 1;
        puVar11 = puVar11 + 2;
        uVar15 = uVar13;
      } while (iVar12 < (int)uVar8);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar8;
    if ((int)uStack0000004c < 1)
    {
      uVar4 = FUN_0000fa20();
      return uVar4;
    }
    uStack00000050 = uStack00000050 + uVar8 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000f722(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  short sVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  undefined4 *puVar8;
  uint unaff_r4;
  int iVar9;
  u32 uVar10;
  int iVar11;
  int unaff_r8;
  u32 uVar12;
  uint uVar13;
  u32 unaff_sl;
  byte in_tmpCY;
  uint param_9;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  uVar10 = unaff_sl;
  for (iVar9 = 0; iVar9 < (int)(2 - (~param_9 + param_9 + (uint)in_tmpCY)); iVar9 = iVar9 + 1)
  {
    flash_erase(uVar10);
    uVar10 = uVar10 + 0x1000;
  }
  if (unaff_r4 < 6)
  {
    FUN_0000f398();
    return;
  }
  if (param_9 == 0)
  {
    FUN_0000f996();
    return;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar10 = unaff_sl + 0x1000;
  iVar9 = 0;
  do
  {
    flash_erase(uVar10);
    uVar10 = uVar10 + 0x1000;
    iVar9 = iVar9 + 1;
  } while (iVar9 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar13 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar9 = 0x3e0000;
    uVar10 = (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar4 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar11 = (int)sVar4;
        if (iVar11 != 0)
        {
          bVar1 = true;
          iVar7 = 0;
          while (true)
          {
            if (pBuf[iVar7] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, '\0', (u16)((uint)iVar9 >> 0x10));
              bVar1 = false;
            }
            if (iVar11 <= iVar7 + 1)
              break;
            iVar7 = iVar7 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar11] = in_stack_00000078._2_1_;
        sVar4 = sVar4 + 1;
      }
    LAB_0000f530:
      iVar9 = (uVar13 - 2) * 0x10000;
      uVar13 = uVar13 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar9);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read((unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = iStack00000048 + 4;
  uVar13 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar5 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar5 = 4;
    }
    uVar5 = uVar5 & 0xff;
    flash_read(uStack00000050, uVar5 * 8, (u8 *)&stack0x00000054);
    if (uVar5 != 0)
    {
      iVar9 = 0;
      puVar8 = &stack0x00000054;
      uVar12 = uVar10;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar10 = (&stack0x00000054)[iVar9 * 2];
        if (uVar10 != (uVar13 + uVar12 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar6 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar6 = unaff_r4 + 0x1a;
        }
        uVar13 = (uint)(ushort)(&stack0x00000058)[iVar9 * 4];
        if ((uVar6 * 0x2000 + 0x1000) - uVar10 < uVar13)
        {
          FUN_0000fa20();
          return;
        }
        iVar11 = *(byte *)((int)puVar8 + 7) - 0x7b;
        if (((iVar11 == 0) || (*(byte *)((int)puVar8 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar8 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar11;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar8 + 6), '\x01', uStack0000008e,
                                (&stack0x00000058)[iVar9 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar9 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar9 = iVar9 + 1;
        puVar8 = puVar8 + 2;
        uVar12 = uVar10;
      } while (iVar9 < (int)uVar5);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar5;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar5 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000f750(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined4 *puVar9;
  uint unaff_r4;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  uint uVar14;
  int unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  if (param_9 == 0)
  {
    FUN_0000f996();
    return;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, uStack0000008e,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
undefined4 FUN_0000f764(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  undefined4 uVar5;
  u8 *pBuf;
  int iVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  short sVar10;
  uint uVar11;
  uint uVar12;
  u32 uVar13;
  int iVar14;
  undefined4 *puVar15;
  uint unaff_r4;
  int iVar16;
  u32 uVar17;
  int iVar18;
  int unaff_r8;
  uint uVar19;
  int unaff_sl;
  int param_9;
  int in_stack_0000001c;
  int in_stack_00000020;
  uint in_stack_00000024;
  uint in_stack_00000030;
  int iStack00000038;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  nv_sect_info_t in_stack_00000088;
  u16 uStack0000008e;

  param_9 = 0;
  if (0x1000 < in_stack_00000020 + 0x408U)
  {
    return 4;
  }
  nVar4 = nv_sector_read((u16)unaff_r4, '\x02', &stack0x00000088);
  if (nVar4 != NV_SUCC)
  {
    uVar5 = FUN_0000f722();
    return uVar5;
  }
  uVar11 = (uint)in_stack_00000088.opSect;
  if (5 < unaff_r4)
  {
    uVar5 = FUN_0000f750();
    return uVar5;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar5 = FUN_0000fa02();
    return uVar5;
  }
  if (unaff_r8 == 0)
  {
    uVar5 = FUN_0000f7d2();
    return uVar5;
  }
  uStack0000008e = 0;
  uVar8 = uVar11 + 1 & 1;
  if (param_9 != 0)
  {
    uVar5 = FUN_0000fa06();
    return uVar5;
  }
  uVar17 = uVar8 * 0x1000 + unaff_sl;
  iVar16 = 0;
  do
  {
    flash_erase(uVar17);
    uVar17 = uVar17 + 0x1000;
    iVar16 = iVar16 + 1;
  } while (iVar16 < 1);
  if (5 < unaff_r4)
  {
    uVar5 = FUN_0000f940();
    return uVar5;
  }
  if (in_stack_0000001c != 0)
  {
    uVar5 = FUN_0000f93a();
    return uVar5;
  }
  if (unaff_r4 == 1)
  {
    uVar5 = FUN_0000f97a();
    return uVar5;
  }
  if (unaff_r4 < 6)
  {
    iStack00000048 = unaff_r4 + 0x1a;
    iStack00000038 = 0x1000;
  }
  else
  {
    iStack00000048 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      uVar5 = FUN_0000fa2a();
      return uVar5;
    }
    iStack00000038 = 0x2000;
  }
  iStack00000048 = iStack00000048 * 0x2000;
  if (unaff_r4 == 1)
  {
    uVar5 = FUN_0000f952();
    return uVar5;
  }
  uVar19 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar16 = unaff_r4 + 0x1a;
    iVar14 = 0x1000;
  }
  else
  {
    iVar16 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      uVar5 = FUN_0000fa24();
      return uVar5;
    }
    iVar14 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar7 = 0x3e0000;
    uVar17 = iVar14 * uVar11 + iVar16 * 0x2000 + 500;
    sVar10 = 0;
    do
    {
      flash_read(uVar17, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar16 = (int)sVar10;
        if (iVar16 != 0)
        {
          bVar1 = true;
          iVar14 = 0;
          while (true)
          {
            if (pBuf[iVar14] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, in_stack_00000088.opSect,
                                   (u16)((uint)iVar7 >> 0x10));
              bVar1 = false;
            }
            if (iVar16 <= iVar14 + 1)
              break;
            iVar14 = iVar14 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar16] = in_stack_00000078._2_1_;
        sVar10 = sVar10 + 1;
      }
    LAB_0000f530:
      iVar7 = (uVar19 - 2) * 0x10000;
      uVar19 = uVar19 - 2 & 0xffff;
      uVar17 = uVar17 - 9;
    } while (-1 < iVar7);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    uVar5 = FUN_0000f928();
    return uVar5;
  }
  flash_read(uVar11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    uVar5 = FUNBBBBB();
    return uVar5;
  }
  uStack00000050 = uVar11 * iStack00000038 + iStack00000048 + 4;
  iVar16 = (unaff_r4 + 0x1a) * 0x2000;
  iVar14 = (unaff_r4 + 0x37) * 0x2000;
  uVar19 = 0;
  uVar17 = 0;
  bVar1 = true;
  do
  {
    uVar12 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar12 = 4;
    }
    uVar12 = uVar12 & 0xff;
    flash_read(uStack00000050, uVar12 * 8, (u8 *)&stack0x00000054);
    if (uVar12 != 0)
    {
      iVar7 = 0;
      puVar15 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar18 = 0;
      if (unaff_r4 < 6)
      {
        uVar5 = FUN_0000f778();
        return uVar5;
      }
      if (param_9 == 0)
      {
        uVar5 = FUN_0000f7c2();
        return uVar5;
      }
      if (unaff_r4 == 1)
      {
        uVar5 = FUN_0000f772();
        return uVar5;
      }
      if (in_stack_00000054 != uVar11 * 0x2000 + iVar14 + 0x200)
      {
        uVar5 = FUN_0000fa20();
        return uVar5;
      }
      if (5 < unaff_r4)
      {
        uVar5 = FUN_0000f780();
        return uVar5;
      }
      uVar19 = (uint)uStack00000058;
      uVar17 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((uVar11 + 1) * 0x1000 + iVar16) - in_stack_00000054 < uVar19)
      {
        uVar5 = FUN_0000fa20();
        return uVar5;
      }
      while (true)
      {
        iVar6 = bVar3 - 0x7b;
        bVar2 = (byte)iVar6;
        if (((iVar6 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar15 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar17, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            uVar5 = FUN_0000f8b0();
            return uVar5;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar15 + 6), (u8)uVar8, uStack0000008e,
                                *(short *)((int)&stack0x00000058 + iVar18) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar18), '\x01');
          if (nVar4 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            uVar5 = FUN_0000f6c0();
            return uVar5;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            uVar5 = FUN_0000fa20();
            return uVar5;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            uVar5 = FUN_0000f992();
            return uVar5;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            uVar5 = FUN_0000f992();
            return uVar5;
          }
        }
        iVar7 = iVar7 + 1;
        puVar15 = puVar15 + 2;
        if ((int)uVar12 <= iVar7)
          break;
      LAB_0000f6cc:
        iVar18 = iVar7 * 8;
        uVar13 = (&stack0x00000054)[iVar7 * 2];
        if (uVar13 != (uVar19 + uVar17 + 3 & 0xfffffffc))
        {
          uVar5 = FUN_0000fa20();
          return uVar5;
        }
        iVar6 = iVar16;
        if ((unaff_r4 < 6) || (iVar6 = iVar14, param_9 == 0))
        {
          iVar9 = 0x1000;
        }
        else
        {
          iVar9 = 0x2000;
        }
        uVar19 = (uint) * (ushort *)((int)&stack0x00000058 + iVar7 * 2 * 4);
        if ((iVar9 * (uVar11 + 1) + iVar6) - uVar13 < uVar19)
        {
          uVar5 = FUN_0000fa20();
          return uVar5;
        }
        uVar17 = uVar13;
        bVar3 = *(byte *)((int)puVar15 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar12;
    if ((int)uStack0000004c < 1)
    {
      uVar5 = FUN_0000fa20();
      return uVar5;
    }
    uStack00000050 = uStack00000050 + uVar12 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
void FUN_0000f772(undefined4 param_1, undefined4 param_2, int param_3)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  u32 uVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int in_stack_00000010;
  int in_stack_00000018;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int in_stack_00000034;
  int in_stack_00000038;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (unaff_r9 != param_3 + 0x400U)
  {
    FUN_0000fa20();
    return;
  }
  if (5 < unaff_sl)
  {
    FUN_0000f780();
    return;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if (((in_stack_00000018 + 1) * 0x1000 + in_stack_00000034) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar5 = bVar1 - 0x7b;
    bVar2 = (byte)iVar5;
    if (((iVar5 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar7 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar7 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar5 = in_stack_00000034;
    if ((unaff_sl < 6) || (iVar5 = in_stack_00000038, in_stack_00000010 == 0))
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar6 * (in_stack_00000018 + 1) + iVar5) - uVar7 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar7;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
void FUN_0000f778(void)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  u32 uVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int param_11;
  int in_stack_00000038;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (in_stack_0000001c != 0)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_sl == 1)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_r9 != in_stack_00000018 * 0x1000 + param_11 + 0x200U)
  {
    FUN_0000fa20();
    return;
  }
  if (5 < unaff_sl)
  {
    FUN_0000f780();
    return;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if (((in_stack_00000018 + 1) * 0x1000 + param_11) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar5 = bVar1 - 0x7b;
    bVar2 = (byte)iVar5;
    if (((iVar5 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar7 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar7 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar5 = param_11;
    if ((unaff_sl < 6) || (iVar5 = in_stack_00000038, param_9 == 0))
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar6 * (in_stack_00000018 + 1) + iVar5) - uVar7 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar7;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
void FUN_0000f780(void)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  u32 uVar6;
  int iVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int param_9;
  int param_11;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int in_stack_00000034;
  int param_12;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (param_9 == 0)
  {
    iVar7 = 0x1000;
  }
  else
  {
    iVar7 = 0x2000;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if ((iVar7 * (param_11 + 1) + param_12) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar7 = bVar1 - 0x7b;
    bVar2 = (byte)iVar7;
    if (((iVar7 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar6 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar6 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar7 = in_stack_00000034;
    if ((unaff_sl < 6) || (iVar7 = param_12, param_9 == 0))
    {
      iVar5 = 0x1000;
    }
    else
    {
      iVar5 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar5 * (param_11 + 1) + iVar7) - uVar6 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar6;
  } while (true);
}
void FUN_0000f7a4(void)

{
  bool bVar1;
  byte bVar2;
  buf_sts_t bVar3;
  nv_sts_t nVar4;
  int iVar5;
  int iVar6;
  u8 uVar7;
  uint uVar8;
  u32 uVar9;
  uint uVar10;
  int iVar11;
  undefined4 *puVar12;
  u8 *unaff_r5;
  int iVar13;
  u8 *unaff_r6;
  int iVar14;
  int iVar15;
  uint unaff_r8;
  u32 addr;
  u32 unaff_r9;
  uint unaff_sl;
  int unaff_fp;
  int param_9;
  int param_10;
  int param_11;
  int in_stack_0000001c;
  uint param_12;
  uint param_13;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  u8 param_14;
  int in_stack_00000038;
  int param_15;
  int in_stack_00000048;
  uint in_stack_0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

code_r0x0000f7a4:
  uVar10 = (uint)unaff_r6[6];
  do
  {
    uVar7 = (u8)uVar10;
    param_10 = param_13 << 0x10;
    iVar14 = param_10 >> 0x10;
    if (iVar14 == 0)
    {
    LAB_0000f520:
      unaff_r5[param_10 >> 0x10] = uVar7;
      param_13 = param_13 + 1 & 0xffff;
    }
    else
    {
      bVar1 = true;
      iVar11 = 0;
      while (true)
      {
        if (unaff_r5[iVar11] == uVar10)
        {
          nv_itemDeleteByIndex(param_14, (u8)param_12, (u8)param_11, (u16)((uint)unaff_fp >> 0x10));
          bVar1 = false;
        }
        if (iVar14 <= iVar11 + 1)
          break;
        iVar11 = iVar11 + 1;
        uVar10 = (uint)unaff_r6[6];
      }
      if (bVar1)
      {
        uVar7 = unaff_r6[6];
        goto LAB_0000f520;
      }
    }
    do
    {
      do
      {
        unaff_fp = (unaff_sl - 2) * 0x10000;
        unaff_sl = unaff_sl - 2 & 0xffff;
        unaff_r9 = unaff_r9 - 9;
        if (unaff_fp < 0)
        {
          bVar3 = ev_buf_free(unaff_r5);
          if (5 < unaff_r8)
          {
            FUN_0000f928(bVar3);
            return;
          }
          flash_read(param_11 * 0x1000 + (unaff_r8 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
          if (in_stack_00000084 != 0x7a7a)
          {
            FUNBBBBB();
            return;
          }
          uStack00000050 = param_11 * in_stack_00000038 + in_stack_00000048 + 4;
          iVar14 = (unaff_r8 + 0x1a) * 0x2000;
          iVar11 = (unaff_r8 + 0x37) * 0x2000;
          uVar10 = 0;
          addr = 0;
          bVar1 = true;
          do
          {
            uVar8 = in_stack_0000004c;
            if (4 < (int)in_stack_0000004c)
            {
              uVar8 = 4;
            }
            uVar8 = uVar8 & 0xff;
            flash_read(uStack00000050, uVar8 * 8, (u8 *)&stack0x00000054);
            if (uVar8 != 0)
            {
              iVar13 = 0;
              puVar12 = &stack0x00000054;
              if (!bVar1)
                goto LAB_0000f6cc;
              iVar15 = 0;
              if (unaff_r8 < 6)
              {
                FUN_0000f778();
                return;
              }
              if (param_9 == 0)
              {
                FUN_0000f7c2();
                return;
              }
              if (in_stack_0000001c != 0)
              {
                FUN_0000f772();
                return;
              }
              if (unaff_r8 == 1)
              {
                FUN_0000f772();
                return;
              }
              if (in_stack_00000054 != param_11 * 0x2000 + iVar11 + 0x200U)
              {
                FUN_0000fa20();
                return;
              }
              if (5 < unaff_r8)
              {
                FUN_0000f780();
                return;
              }
              uVar10 = (uint)uStack00000058;
              addr = in_stack_00000054;
              bVar2 = bStack0000005b;
              if (((param_11 + 1) * 0x1000 + iVar14) - in_stack_00000054 < uVar10)
              {
                FUN_0000fa20();
                return;
              }
              while (true)
              {
                param_10 = bVar2 - 0x7b;
                if (((param_10 == 0) || (bVar2 == 0x5a)) &&
                    ((*(byte *)((int)puVar12 + 6) != param_12 ||
                      (~in_stack_00000030 + in_stack_00000030 +
                           (uint)((unaff_r8 + 0x37 >> 0x13 & 1) != 0) !=
                       0))))
                {
                  flash_read(addr, 8, &stack0x0000007c);
                  if (in_stack_00000080._3_1_ == 0x7a)
                  {
                    FUN_0000f8b0();
                    return;
                  }
                  nVar4 = nv_write_item(~(byte)param_10 + (byte)param_10 +
                                            (0x79 < in_stack_00000080._3_1_),
                                        (u16)unaff_r8,
                                        *(u8 *)((int)puVar12 + 6), in_stack_0000002c,
                                        in_stack_0000008c._2_2_,
                                        *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                        *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
                  if (nVar4 == NV_SUCC)
                  {
                    in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
                    FUN_0000f6c0();
                    return;
                  }
                  if (nVar4 == NV_ITEM_CHECK_ERROR)
                  {
                    FUN_0000fa20();
                    return;
                  }
                  if (nVar4 == NV_CHECK_SUM_ERROR)
                  {
                    FUN_0000f992();
                    return;
                  }
                  if (nVar4 == NV_NOT_ENOUGH_SAPCE)
                  {
                    FUN_0000f992();
                    return;
                  }
                }
                iVar13 = iVar13 + 1;
                puVar12 = puVar12 + 2;
                if ((int)uVar8 <= iVar13)
                  break;
              LAB_0000f6cc:
                iVar15 = iVar13 * 8;
                uVar9 = (&stack0x00000054)[iVar13 * 2];
                if (uVar9 != (uVar10 + addr + 3 & 0xfffffffc))
                {
                  FUN_0000fa20();
                  return;
                }
                iVar5 = iVar14;
                if ((unaff_r8 < 6) || (iVar5 = iVar11, param_9 == 0))
                {
                  iVar6 = 0x1000;
                }
                else
                {
                  iVar6 = 0x2000;
                }
                uVar10 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
                if ((iVar6 * (param_11 + 1) + iVar5) - uVar9 < uVar10)
                {
                  FUN_0000fa20();
                  return;
                }
                addr = uVar9;
                bVar2 = *(byte *)((int)puVar12 + 7);
              }
              bVar1 = false;
            }
            in_stack_0000004c = in_stack_0000004c - uVar8;
            if ((int)in_stack_0000004c < 1)
            {
              FUN_0000fa20();
              return;
            }
            uStack00000050 = uStack00000050 + uVar8 * 8;
          } while (true);
        }
        flash_read(unaff_r9, 8, unaff_r6);
        uVar7 = unaff_r6[7];
      } while ((uVar7 != 'z') && (uVar7 != 'Z'));
      if (uVar7 == 'z')
        goto code_r0x0000f7a4;
      uVar10 = (uint)unaff_r6[6];
    } while ((unaff_r8 != uVar10) || (param_15 == 0));
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
void FUN_0000f7c2(void)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  u32 uVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int in_stack_00000034;
  int param_11;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (in_stack_0000001c != 0)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_sl == 1)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_r9 != in_stack_00000018 * 0x1000 + param_11 + 0x200U)
  {
    FUN_0000fa20();
    return;
  }
  if (5 < unaff_sl)
  {
    FUN_0000f780();
    return;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if (((in_stack_00000018 + 1) * 0x1000 + in_stack_00000034) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar5 = bVar1 - 0x7b;
    bVar2 = (byte)iVar5;
    if (((iVar5 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar7 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar7 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar5 = in_stack_00000034;
    if ((unaff_sl < 6) || (iVar5 = param_11, param_9 == 0))
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar6 * (in_stack_00000018 + 1) + iVar5) - uVar7 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar7;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f856)
// WARNING: Removing unreachable block (RAM,0x0000f84e)
uint FUN_0000f7d2(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  u32 unaff_r6;
  int param_11;
  int in_stack_0000001c;
  u16 param_12;
  u8 in_stack_00000024;
  byte in_stack_0000002c;
  int in_stack_00000030;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined2 uStack0000008c;
  u16 uStack0000008e;
  u8 *in_stack_000000b8;

  nVar1 = nv_index_read((u16)unaff_r4, 0xff, param_12, (u8)param_11, unaff_r6,
                        (u16 *)((int)&stack0x0000008c + 2));
  if (nVar1 == NV_SUCC)
  {
    uVar2 = FUN_0000fa42();
    return uVar2;
  }
  uStack0000008c = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa3e();
    return uVar2;
  }
  if (in_stack_00000030 != 0)
  {
    uVar2 = FUN_0000f9ae();
    return uVar2;
  }
  nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, (u8)param_11, uStack0000008e, param_12,
                        in_stack_000000b8, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (uStack0000008e == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}
// WARNING: Removing unreachable block (RAM,0x0000f856)
// WARNING: Removing unreachable block (RAM,0x0000f84e)
uint FUN_0000f7ec(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  int param_11;
  int in_stack_0000001c;
  u16 in_stack_00000020;
  u8 in_stack_00000024;
  byte in_stack_0000002c;
  int in_stack_00000030;
  int param_12;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined2 uStack0000008c;
  u16 uStack0000008e;
  u8 *in_stack_000000b8;

  param_12 = param_11;
  uStack0000008c = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa3e();
    return uVar2;
  }
  if (in_stack_00000030 != 0)
  {
    uVar2 = FUN_0000f9ae();
    return uVar2;
  }
  nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, (u8)param_11, uStack0000008e,
                        in_stack_00000020, in_stack_000000b8, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (uStack0000008e == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(param_12 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}
// WARNING: Removing unreachable block (RAM,0x0000f84e)
uint FUN_0000f80a(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  int unaff_r8;
  u16 in_stack_00000020;
  u8 in_stack_00000024;
  byte in_stack_0000002c;
  int param_11;
  int in_stack_00000040;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined4 in_stack_0000008c;
  u8 *in_stack_000000b8;

  if (param_11 != 0)
  {
    uVar2 = FUN_0000f9ae();
    return uVar2;
  }
  nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, (u8)in_stack_00000040,
                        in_stack_0000008c._2_2_, in_stack_00000020, in_stack_000000b8, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (unaff_r8 != 0)
    {
      uVar2 = FUN_0000fb1e();
      return uVar2;
    }
    if (in_stack_0000008c._2_2_ == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(in_stack_00000040 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}
uint FUN_0000f814(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  int unaff_r7;
  int unaff_r8;
  u16 param_11;
  u8 param_12;
  byte in_stack_0000002c;
  u8 param_13;
  int param_14;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined4 in_stack_0000008c;
  u8 *param_16;

  nVar1 = nv_write_item(param_13, (u16)unaff_r4, param_12, (u8)param_14, in_stack_0000008c._2_2_,
                        param_11, param_16, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (unaff_r7 != 0)
    {
      uVar2 = FUN_0000f9c4();
      return uVar2;
    }
    if (unaff_r8 != 0)
    {
      uVar2 = FUN_0000fb1e();
      return uVar2;
    }
    if (in_stack_0000008c._2_2_ == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(param_14 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}
undefined4 FUN_0000f850(void)

{
  undefined4 uVar1;
  uint uVar2;
  uint unaff_r4;
  undefined4 unaff_r6;
  int unaff_r8;
  byte param_11;
  int in_stack_00000040;
  undefined2 param_12;
  uchar param_13;
  byte param_14;
  undefined4 in_stack_0000008c;

  if (unaff_r8 != 0)
  {
    uVar1 = FUN_0000fb1e();
    return uVar1;
  }
  if (in_stack_0000008c._2_2_ == 0)
  {
    param_13 = (uchar)unaff_r4;
    param_12 = 0x7a7a;
    param_14 = param_11;
    uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
    param_14 = param_14 | (byte)(uVar2 << 2);
    if (5 < unaff_r4)
    {
      uVar1 = FUN_0000fc04();
      return uVar1;
    }
    flash_writeWithCheck(in_stack_00000040 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
  }
  return unaff_r6;
}
void FUN_0000f8b0(void)

{
  uint uVar1;
  uchar *unaff_r4;
  uint param_11;

  uVar1 = xcrc32(unaff_r4, 7, 0xfffffffe);
  if ((uVar1 & 0xffff) != param_11 >> 0x10)
  {
    FUN_0000f6c0();
    return;
  }
  FUN_0000f67a();
  return;
}
// WARNING: Removing unreachable block (RAM,0x0000f858)
// WARNING: Removing unreachable block (RAM,0x0000f864)
// WARNING: Removing unreachable block (RAM,0x0000f896)
// WARNING: Removing unreachable block (RAM,0x0000f898)
// WARNING: Removing unreachable block (RAM,0x0000f862)
// WARNING: Removing unreachable block (RAM,0x0000f84e)
// WARNING: Unknown calling convention -- yet parameter storage is locked
uint FUNBBBBB(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  int iVar3;
  u16 uVar4;
  int in_r3;
  int iVar5;
  uint unaff_r4;
  int in_stack_00000010;
  int in_stack_0000001c;
  int in_stack_00000020;
  u8 in_stack_00000024;
  int in_stack_0000002c;
  int in_stack_00000030;
  u8 in_stack_00000040;
  int in_stack_00000044;
  undefined2 uStack0000008c;
  u16 in_stack_0000008e;
  u8 *in_stack_000000b8;

  if (in_r3 == 0x5a5a)
  {
    uVar2 = FUN_0000f582();
    return uVar2;
  }
  uVar4 = 0x7f;
  if ((in_stack_0000001c == 0) && (uVar4 = 0x3f, unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa1c();
    return uVar2;
  }
  uVar2 = 4;
  if (uVar4 != in_stack_0000008e)
  {
    if (unaff_r4 < 6)
    {
      iVar3 = (unaff_r4 + 0x1a) * 0x2000;
      iVar5 = 0x1000;
    }
    else
    {
      iVar3 = (unaff_r4 + 0x37) * 0x2000;
      if (in_stack_00000010 == 0)
      {
        iVar5 = 0x1000;
      }
      else
      {
        iVar5 = 0x2000;
      }
    }
    uVar2 = 4;
    if ((uint)(in_stack_00000020 + 8 + in_stack_00000044) <=
        (uint)(iVar5 * (in_stack_0000002c + 1) + iVar3))
    {
      uStack0000008c = 0;
      if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
      {
        uVar2 = FUN_0000fa3e();
        return uVar2;
      }
      if (in_stack_00000030 != 0)
      {
        uVar2 = FUN_0000f9ae();
        return uVar2;
      }
      nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, in_stack_00000040, in_stack_0000008e, (u16)in_stack_00000020, in_stack_000000b8, '\0');
      uVar2 = (uint)nVar1;
      if (nVar1 == 0)
      {
        if (5 < unaff_r4)
        {
          uVar2 = FUN_0000f99c();
          return uVar2;
        }
        uVar2 = FUN_0000fb1e();
        return uVar2;
      }
    }
  }
  return uVar2;
}
// WARNING: Removing unreachable block (RAM,0x0000f858)
// WARNING: Removing unreachable block (RAM,0x0000f864)
// WARNING: Removing unreachable block (RAM,0x0000f896)
// WARNING: Removing unreachable block (RAM,0x0000f898)
// WARNING: Removing unreachable block (RAM,0x0000f862)
// WARNING: Removing unreachable block (RAM,0x0000f84e)
uint FUN_0000f8de(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  int iVar3;
  u16 uVar4;
  int iVar5;
  uint unaff_r4;
  int param_9;
  int param_11;
  int in_stack_00000020;
  u8 in_stack_00000024;
  int in_stack_0000002c;
  int in_stack_00000030;
  u8 in_stack_00000040;
  int in_stack_00000044;
  undefined4 in_stack_0000008c;
  u8 *in_stack_000000b8;

  uVar4 = 0x7f;
  if ((param_11 == 0) && (uVar4 = 0x3f, unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa1c();
    return uVar2;
  }
  uVar2 = 4;
  if (uVar4 != in_stack_0000008c._2_2_)
  {
    if (unaff_r4 < 6)
    {
      iVar3 = (unaff_r4 + 0x1a) * 0x2000;
      iVar5 = 0x1000;
    }
    else
    {
      iVar3 = (unaff_r4 + 0x37) * 0x2000;
      if (param_9 == 0)
      {
        iVar5 = 0x1000;
      }
      else
      {
        iVar5 = 0x2000;
      }
    }
    uVar2 = 4;
    if ((uint)(in_stack_00000020 + 8 + in_stack_00000044) <=
        (uint)(iVar5 * (in_stack_0000002c + 1) + iVar3))
    {
      if ((param_11 == 0) && (unaff_r4 == 1))
      {
        uVar2 = FUN_0000fa3e();
        return uVar2;
      }
      if (in_stack_00000030 != 0)
      {
        uVar2 = FUN_0000f9ae();
        return uVar2;
      }
      nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, in_stack_00000040,
                            in_stack_0000008c._2_2_, (u16)in_stack_00000020, in_stack_000000b8, '\0');
      uVar2 = (uint)nVar1;
      if (nVar1 == 0)
      {
        if (5 < unaff_r4)
        {
          uVar2 = FUN_0000f99c();
          return uVar2;
        }
        uVar2 = FUN_0000fb1e();
        return uVar2;
      }
    }
  }
  return uVar2;
}
// WARNING: Removing unreachable block (RAM,0x0000f858)
// WARNING: Removing unreachable block (RAM,0x0000f864)
// WARNING: Removing unreachable block (RAM,0x0000f896)
// WARNING: Removing unreachable block (RAM,0x0000f898)
// WARNING: Removing unreachable block (RAM,0x0000f862)
// WARNING: Removing unreachable block (RAM,0x0000f84e)
uint FUN_0000f8ee(void)

{
  nv_sts_t nVar1;
  int iVar2;
  uint in_r3;
  int iVar3;
  uint unaff_r4;
  uint uVar4;
  int param_9;
  int param_11;
  int param_12;
  u8 in_stack_00000024;
  int param_13;
  int in_stack_00000030;
  u8 in_stack_00000040;
  int param_14;
  undefined4 param_15;
  u8 *in_stack_000000b8;

  uVar4 = 4;
  if (in_r3 != param_15._2_2_)
  {
    if (unaff_r4 < 6)
    {
      iVar2 = (unaff_r4 + 0x1a) * 0x2000;
      iVar3 = 0x1000;
    }
    else
    {
      iVar2 = (unaff_r4 + 0x37) * 0x2000;
      if (param_9 == 0)
      {
        iVar3 = 0x1000;
      }
      else
      {
        iVar3 = 0x2000;
      }
    }
    uVar4 = 4;
    if ((uint)(param_12 + 8 + param_14) <= (uint)(iVar3 * (param_13 + 1) + iVar2))
    {
      if ((param_11 == 0) && (unaff_r4 == 1))
      {
        uVar4 = FUN_0000fa3e();
        return uVar4;
      }
      if (in_stack_00000030 != 0)
      {
        uVar4 = FUN_0000f9ae();
        return uVar4;
      }
      nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, in_stack_00000040, param_15._2_2_,
                            (u16)param_12, in_stack_000000b8, '\0');
      uVar4 = (uint)nVar1;
      if (nVar1 == 0)
      {
        if (5 < unaff_r4)
        {
          uVar4 = FUN_0000f99c();
          return uVar4;
        }
        uVar4 = FUN_0000fb1e();
        return uVar4;
      }
    }
  }
  return uVar4;
}
void FUN_0000f928(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  u32 uVar9;
  int iVar10;
  undefined4 *puVar11;
  uint unaff_r4;
  int iVar12;
  int iVar13;
  u32 addr;
  uint uVar14;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int in_stack_00000038;
  int in_stack_00000048;
  uint in_stack_0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000080;
  short param_12;
  undefined4 in_stack_0000008c;

  if (param_9 == 0)
  {
    iVar10 = 0x1000;
  }
  else
  {
    iVar10 = 0x2000;
  }
  flash_read(iVar10 * param_11 + (unaff_r4 + 0x37) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (param_12 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = param_11 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar10 = (unaff_r4 + 0x1a) * 0x2000;
  iVar7 = (unaff_r4 + 0x37) * 0x2000;
  uVar14 = 0;
  addr = 0;
  bVar1 = true;
  do
  {
    uVar8 = in_stack_0000004c;
    if (4 < (int)in_stack_0000004c)
    {
      uVar8 = 4;
    }
    uVar8 = uVar8 & 0xff;
    flash_read(uStack00000050, uVar8 * 8, (u8 *)&stack0x00000054);
    if (uVar8 != 0)
    {
      iVar12 = 0;
      puVar11 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar13 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != param_11 * 0x2000 + iVar7 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar14 = (uint)uStack00000058;
      addr = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((param_11 + 1) * 0x1000 + iVar10) - in_stack_00000054 < uVar14)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar11 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(addr, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar11 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar13) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar13), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar12 = iVar12 + 1;
        puVar11 = puVar11 + 2;
        if ((int)uVar8 <= iVar12)
          break;
      LAB_0000f6cc:
        iVar13 = iVar12 * 8;
        uVar9 = (&stack0x00000054)[iVar12 * 2];
        if (uVar9 != (uVar14 + addr + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar10;
        if ((unaff_r4 < 6) || (iVar5 = iVar7, param_9 == 0))
        {
          iVar6 = 0x1000;
        }
        else
        {
          iVar6 = 0x2000;
        }
        uVar14 = (uint) * (ushort *)((int)&stack0x00000058 + iVar12 * 2 * 4);
        if ((iVar6 * (param_11 + 1) + iVar5) - uVar9 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        addr = uVar9;
        bVar3 = *(byte *)((int)puVar11 + 7);
      }
      bVar1 = false;
    }
    in_stack_0000004c = in_stack_0000004c - uVar8;
    if ((int)in_stack_0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar8 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f60c)
void FUN_0000f93a(undefined4 param_1, undefined4 param_2, int param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  int iVar15;
  uint uVar16;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int param_11;
  uint param_12;
  u32 param_13;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  param_12 = param_3 + 0x400;
  if (unaff_r4 < 6)
  {
    param_13 = (unaff_r4 + 0x1a) * 0x2000;
    param_11 = 0x1000;
  }
  else
  {
    param_13 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 == 0)
    {
      FUN_0000fa2a();
      return;
    }
    param_11 = 0x2000;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f96e();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * param_11 + param_13 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iVar13 = (unaff_r4 + 0x37) * 0x2000;
  uVar16 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    param_13 = uVar11 << 3;
    flash_read(uStack00000050, param_13, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar6 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar15 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar13 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar16 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar16)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
          if (nVar4 == NV_SUCC)
          {
            param_12 = *(ushort *)((int)&stack0x00000058 + iVar15) + 3 + param_12 & 0xfffffffc;
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar15 = iVar6 * 8;
        uVar12 = (&stack0x00000054)[iVar6 * 2];
        if (uVar12 != (uVar16 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iVar13, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar16 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar16)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar11;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + param_13;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000f940(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  int iVar15;
  uint uVar16;
  int param_9;
  int in_stack_00000018;
  int param_11;
  uint in_stack_00000024;
  u8 param_12;
  uint in_stack_00000030;
  int iStack00000038;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  if (param_11 != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (unaff_r4 < 6)
  {
    iStack00000048 = unaff_r4 + 0x1a;
    iStack00000038 = 0x1000;
  }
  else
  {
    iStack00000048 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa2a();
      return;
    }
    iStack00000038 = 0x2000;
  }
  iStack00000048 = iStack00000048 * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * iStack00000038 + iStack00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iVar13 = (unaff_r4 + 0x37) * 0x2000;
  uVar16 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar6 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar15 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar13 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar16 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar16)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), param_12, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar15 = iVar6 * 8;
        uVar12 = (&stack0x00000054)[iVar6 * 2];
        if (uVar12 != (uVar16 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iVar13, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar16 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar16)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar11;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}
void FUN_0000f952(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  int iVar5;
  u8 *pBuf;
  int iVar6;
  int iVar7;
  uint uVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  int iVar15;
  int iVar16;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int in_stack_00000038;
  int in_stack_00000048;
  uint param_11;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  pBuf = ev_buf_allocate(0x7f);
  uVar8 = 0x7e;
  param_11 = 0x7f;
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x7f);
    iVar6 = 0x7e0000;
    uVar10 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 0x3f4;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar15 = (int)sVar9;
        if (iVar15 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar15 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar15] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar8 - 2) * 0x10000;
      uVar8 = uVar8 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar6 = (unaff_r4 + 0x1a) * 0x2000;
  iVar15 = (unaff_r4 + 0x37) * 0x2000;
  uVar8 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = param_11;
    if (4 < (int)param_11)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar16 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar15 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar8 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar6) - in_stack_00000054 < uVar8)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar16) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar16), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar16 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar8 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar6;
        if ((unaff_r4 < 6) || (iVar5 = iVar15, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar8 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar8)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    param_11 = param_11 - uVar11;
    if ((int)param_11 < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}
void FUN_0000f96e(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint uVar15;
  int iVar16;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int in_stack_00000038;
  int in_stack_00000048;
  uint param_11;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  uVar15 = 0x7e;
  param_11 = 0x7f;
  pBuf = ev_buf_allocate(0x7f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x7f);
    iVar6 = 0x7e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 0x3f4;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar15 - 2) * 0x10000;
      uVar15 = uVar15 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iVar13 = (unaff_r4 + 0x37) * 0x2000;
  uVar15 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = param_11;
    if (4 < (int)param_11)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar6 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar16 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar13 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar15 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar15)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar16) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar16), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar16 = iVar6 * 8;
        uVar12 = (&stack0x00000054)[iVar6 * 2];
        if (uVar12 != (uVar15 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iVar13, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar15 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar15)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    param_11 = param_11 - uVar11;
    if ((int)param_11 < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f60c)
void FUN_0000f97a(undefined4 param_1, undefined4 param_2, int param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint uVar15;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000038;
  uint param_11;
  u32 uStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  param_11 = param_3 + 0x400;
  uStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  iStack00000038 = 0x1000;
  if (in_stack_0000001c != 0)
  {
    FUN_0000f96e();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar15 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar15 - 2) * 0x10000;
      uVar15 = uVar15 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * iStack00000038 + uStack00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iStack00000038 = (unaff_r4 + 0x37) * 0x2000;
  uVar15 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    uStack00000048 = uVar11 << 3;
    flash_read(uStack00000050, uStack00000048, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar6 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iStack00000038 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar15 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar15)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar6) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar6), '\x01');
          if (nVar4 == NV_SUCC)
          {
            param_11 = *(ushort *)((int)&stack0x00000058 + iVar6) + 3 + param_11 & 0xfffffffc;
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar6 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar15 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iStack00000038, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar15 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar15)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar11;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uStack00000048;
  } while (true);
}
undefined4 FUN_0000f992(undefined4 param_1)

{
  return param_1;
}
// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000f996(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined4 *puVar9;
  uint unaff_r4;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  uint uVar14;
  int unaff_sl;
  int param_9;
  int in_stack_00000018;
  int param_11;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 param_12;

  param_12 = 0;
  if ((param_11 == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  param_12 = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (param_11 != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, param_12,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            param_12 = param_12 + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}
undefined4 FUN_0000f99c(undefined4 param_1, undefined4 param_2)

{
  undefined4 uVar1;
  uint uVar2;
  uint unaff_r4;
  undefined4 unaff_r6;
  int unaff_r7;
  int unaff_r8;
  undefined4 param_9;
  byte in_stack_0000002c;
  int in_stack_00000040;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined4 in_stack_0000008c;

  if (unaff_r7 != 0)
  {
    uVar1 = FUN_0000f9c4(param_9, param_2, (unaff_r4 + 0x37) * 0x2000);
    return uVar1;
  }
  if (unaff_r8 == 0)
  {
    if (in_stack_0000008c._2_2_ == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar1 = FUN_0000fc04();
        return uVar1;
      }
      flash_writeWithCheck(in_stack_00000040 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
    return unaff_r6;
  }
  uVar1 = FUN_0000fb1e();
  return uVar1;
}
void FUN_0000f9ae(void)

{
  u32 in_r3;
  u16 unaff_r4;
  u16 *unaff_r5;
  u16 param_11;
  u8 param_12;
  u8 param_13;

  nv_index_read(unaff_r4, param_12, param_11, param_13, in_r3, unaff_r5);
  FUN_0000f814();
  return;
}
undefined4 FUN_0000f9c4(undefined4 param_1, undefined4 param_2, int param_3, int param_4)

{
  u8 uVar1;
  undefined4 uVar2;
  ushort *unaff_r5;
  int param_11;
  u8 uStack0000005b;

  uStack0000005b = 'P';
  uVar1 = flash_writeWithCheck((uint)*unaff_r5 * 8 + 0xb + param_4 * param_11 + param_3, 1, &stack0x0000005b);
  if (uVar1 == '\x01')
  {
    uVar2 = FUN_0000f850();
    return uVar2;
  }
  return 6;
}
undefined4 FUN_0000f9e8(void)

{
  return 6;
}
void FUN_0000fa02(void)

{
  FUN_0000f3ba();
  return;
}
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)
void FUN_0000fa06(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  short sVar8;
  uint uVar9;
  u32 uVar10;
  int iVar11;
  undefined4 *puVar12;
  uint unaff_r4;
  int iVar13;
  u32 uVar14;
  int iVar15;
  uint uVar16;
  int unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int param_11;
  uint in_stack_00000030;
  int iStack00000038;
  undefined4 param_12;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  uVar14 = param_11 * 0x2000 + unaff_sl;
  iVar13 = 0;
  param_12 = param_3;
  do
  {
    flash_erase(uVar14);
    uVar14 = uVar14 + 0x1000;
    iVar13 = iVar13 + 1;
  } while (iVar13 < 2);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (unaff_r4 < 6)
  {
    iStack00000048 = unaff_r4 + 0x1a;
    iStack00000038 = 0x1000;
  }
  else
  {
    iStack00000048 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa2a();
      return;
    }
    iStack00000038 = 0x2000;
  }
  iStack00000048 = iStack00000048 * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar13 = unaff_r4 + 0x1a;
    iVar11 = 0x1000;
  }
  else
  {
    iVar13 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar11 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar14 = iVar11 * in_stack_00000018 + iVar13 * 0x2000 + 500;
    sVar8 = 0;
    do
    {
      flash_read(uVar14, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar13 = (int)sVar8;
        if (iVar13 != 0)
        {
          bVar1 = true;
          iVar11 = 0;
          while (true)
          {
            if (pBuf[iVar11] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar13 <= iVar11 + 1)
              break;
            iVar11 = iVar11 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar13] = in_stack_00000078._2_1_;
        sVar8 = sVar8 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar14 = uVar14 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * iStack00000038 + iStack00000048 + 4;
  iVar13 = (unaff_r4 + 0x1a) * 0x2000;
  iVar11 = (unaff_r4 + 0x37) * 0x2000;
  uVar16 = 0;
  uVar14 = 0;
  bVar1 = true;
  do
  {
    uVar9 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar9 = 4;
    }
    uVar9 = uVar9 & 0xff;
    flash_read(uStack00000050, uVar9 * 8, (u8 *)&stack0x00000054);
    if (uVar9 != 0)
    {
      iVar6 = 0;
      puVar12 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar15 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar11 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar16 = (uint)uStack00000058;
      uVar14 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar13) - in_stack_00000054 < uVar16)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar12 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar14, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar12 + 6), (u8)param_11, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar12 = puVar12 + 2;
        if ((int)uVar9 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar15 = iVar6 * 8;
        uVar10 = (&stack0x00000054)[iVar6 * 2];
        if (uVar10 != (uVar16 + uVar14 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar13;
        if ((unaff_r4 < 6) || (iVar5 = iVar11, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar16 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar10 < uVar16)
        {
          FUN_0000fa20();
          return;
        }
        uVar14 = uVar10;
        bVar3 = *(byte *)((int)puVar12 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar9;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar9 * 8;
  } while (true);
}
void FUN_0000fa1c(void)

{
  FUN_0000f8ee();
  return;
}
void FUN_0000fa20(void)

{
  FUN_0000f8de();
  return;
}
void FUN_0000fa24(undefined4 param_1, undefined4 param_2, int param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  buf_sts_t bVar4;
  nv_sts_t nVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint unaff_r5;
  int iVar15;
  int iVar16;
  u8 *unaff_r8;
  uint unaff_sl;
  uint uVar17;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint param_13;
  int in_stack_00000038;
  int in_stack_00000048;
  uint in_stack_0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  bVar4 = BUFFER_SUCC;
  if (unaff_r8 != (u8 *)0x0)
  {
    memset(unaff_r8, 0, unaff_r5);
    iVar7 = unaff_sl << 0x10;
    uVar10 = (iVar7 >> 0xd) + 4 + param_11 * 0x1000 + param_3;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (param_13 != 0))))))
      {
        iVar15 = (int)sVar9;
        if (iVar15 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (unaff_r8[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)param_11, (u16)((uint)iVar7 >> 0x10));
              bVar1 = false;
            }
            if (iVar15 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        unaff_r8[iVar15] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar7 = (unaff_sl - 2) * 0x10000;
      unaff_sl = unaff_sl - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar7);
    bVar4 = ev_buf_free(unaff_r8);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928(bVar4);
    return;
  }
  flash_read(param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = param_11 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar7 = (unaff_r4 + 0x1a) * 0x2000;
  iVar15 = (unaff_r4 + 0x37) * 0x2000;
  uVar17 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = in_stack_0000004c;
    if (4 < (int)in_stack_0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar16 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != param_11 * 0x2000 + iVar15 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar17 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((param_11 + 1) * 0x1000 + iVar7) - in_stack_00000054 < uVar17)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar6 = bVar3 - 0x7b;
        bVar2 = (byte)iVar6;
        if (((iVar6 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~param_13 + param_13 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) != 0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar5 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar16) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar16), '\x01');
          if (nVar5 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar5 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar5 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar5 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar16 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar17 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar6 = iVar7;
        if ((unaff_r4 < 6) || (iVar6 = iVar15, param_9 == 0))
        {
          iVar8 = 0x1000;
        }
        else
        {
          iVar8 = 0x2000;
        }
        uVar17 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar8 * (param_11 + 1) + iVar6) - uVar12 < uVar17)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    in_stack_0000004c = in_stack_0000004c - uVar11;
    if ((int)in_stack_0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0000f60c)
void FUN_0000fa2a(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint uVar15;
  int param_9;
  int in_stack_00000018;
  int param_11;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int param_12;
  int in_stack_00000048;
  uint param_13;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  param_12 = 0x1000;
  if (param_11 != 0)
  {
    FUN_0000f96e();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar15 = 0x3e;
  param_13 = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar15 - 2) * 0x10000;
      uVar15 = uVar15 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * param_12 + in_stack_00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  param_12 = (unaff_r4 + 0x37) * 0x2000;
  uVar15 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = param_13;
    if (4 < (int)param_13)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar6 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + param_12 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar15 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar15)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar6) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar6), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar6 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar15 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = param_12, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar15 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar15)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    param_13 = param_13 - uVar11;
    if ((int)param_13 < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}
void FUN_0000fa3e(void)

{
  FUN_0000f80a();
  return;
}
void FUN_0000fa42(void)

{
  uint unaff_r4;
  int unaff_r5;
  int iVar1;
  int unaff_r6;
  int unaff_r7;
  int param_11;
  int in_stack_0000001c;
  int param_12;
  uint param_13;
  ushort uStack00000058;
  char cStack0000005b;
  undefined4 in_stack_0000008c;

  flash_read((uint)in_stack_0000008c._2_2_ * 8 + 4 + unaff_r5 * param_11 + unaff_r7, 8,
             (u8 *)&stack0x00000054);
  if ((uint)in_stack_0000008c._2_2_ == unaff_r6 - 1U)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fbee();
    return;
  }
  iVar1 = param_11 + 1;
  if (iVar1 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 < param_13 + 8 + (uint)uStack00000058 + param_12)
  {
    FUN_0000f3c2();
    return;
  }
  if ((((cStack0000005b != 'z') && (cStack0000005b != 'Z')) && (cStack0000005b != 'P')) &&
      (cStack0000005b != -6))
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc4a();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000fc44();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000fc44();
    return;
  }
  if (param_13 < param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 0x200)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (iVar1 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_13)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((iVar1 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_13 < (uint)uStack00000058)
  {
    FUN_0000f3c2();
    return;
  }
  in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
  FUN_0000f7ec();
  return;
}
// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
void FUN_0000fb1e(void)

{
  byte bVar1;
  nv_sts_t nVar2;
  u8 uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  u8 *puVar9;
  uint unaff_r4;
  u8 *unaff_r7;
  u32 uVar10;
  u32 unaff_r9;
  uint unaff_sl;
  uint unaff_fp;
  int param_9;
  int param_11;
  uint in_stack_00000024;
  uint in_stack_00000028;
  byte param_12;
  int in_stack_00000034;
  int in_stack_00000038;
  int in_stack_0000003c;
  int param_13;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined2 param_14;
  uchar param_15;
  byte param_16;
  undefined4 in_stack_0000008c;

  param_15 = (uchar)unaff_r4;
  param_14 = 0xfafa;
  param_16 = param_12;
  uVar5 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
  param_16 = param_16 | (byte)((uVar5 & 0x3f) << 2);
  if (unaff_r4 < 6)
  {
    iVar6 = (unaff_r4 + 0x1a) * 0x2000;
    iVar8 = 0x1000;
  }
  else
  {
    iVar6 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 == 0)
    {
      iVar8 = 0x1000;
    }
    else
    {
      iVar8 = 0x2000;
    }
  }
  uVar3 = flash_writeWithCheck(iVar8 * param_13 + iVar6, 4, (u8 *)&stack0x00000088);
  if (uVar3 != '\x01')
  {
    FUN_0000f9e8();
    return;
  }
  param_14 = 0x5050;
  if (unaff_r4 < 6)
  {
    iVar6 = (unaff_r4 + 0x1a) * 0x2000;
    iVar8 = 0x1000;
  }
  else
  {
    iVar6 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 == 0)
    {
      iVar8 = 0x1000;
    }
    else
    {
      iVar8 = 0x2000;
    }
  }
  uVar3 = flash_writeWithCheck(iVar8 * param_11 + iVar6, 2, (u8 *)&stack0x00000088);
  if (uVar3 != '\x01')
  {
    FUN_0000f342();
  }
  param_14 = 0x7a7a;
  if (unaff_r4 < 6)
  {
    iVar6 = (unaff_r4 + 0x1a) * 0x2000;
  }
  else
  {
    iVar6 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 != 0)
    {
      iVar8 = 0x2000;
      goto LAB_0000fbae;
    }
  }
  iVar8 = 0x1000;
LAB_0000fbae:
  uVar3 = flash_writeWithCheck(iVar8 * param_13 + iVar6, 2, (u8 *)&stack0x00000088);
  FUN_0000f342(uVar3);
  do
  {
    do
    {
      in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
      if ((int)in_stack_0000004c < 1)
      {
        FUN_0000fa20();
        return;
      }
      in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
      in_stack_00000028 = in_stack_0000004c;
      if (4 < (int)in_stack_0000004c)
      {
        in_stack_00000028 = 4;
      }
      in_stack_00000028 = in_stack_00000028 & 0xff;
      in_stack_00000048 = in_stack_00000028 << 3;
      flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
    } while (in_stack_00000028 == 0);
    iVar6 = 0;
    puVar9 = unaff_r7;
    uVar10 = unaff_r9;
    do
    {
      iVar8 = iVar6 * 8;
      unaff_r9 = *(u32 *)(unaff_r7 + iVar8);
      if (unaff_r9 != (unaff_fp + uVar10 + 3 & 0xfffffffc))
      {
        FUN_0000fa20();
        return;
      }
      iVar4 = in_stack_00000034;
      if ((unaff_sl < 6) || (iVar4 = in_stack_00000038, param_9 == 0))
      {
        iVar7 = 0x1000;
      }
      else
      {
        iVar7 = 0x2000;
      }
      unaff_fp = (uint) * (ushort *)(unaff_r7 + iVar8 + 4);
      if ((iVar7 * (param_11 + 1) + iVar4) - unaff_r9 < unaff_fp)
      {
        FUN_0000fa20();
        return;
      }
      iVar4 = puVar9[7] - 0x7b;
      if (((iVar4 == 0) || (puVar9[7] == 0x5a)) &&
          ((puVar9[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
      {
        flash_read(unaff_r9, 8, &stack0x0000007c);
        if (in_stack_00000080._3_1_ == 0x7a)
        {
          FUN_0000f8b0();
          return;
        }
        bVar1 = (byte)iVar4;
        nVar2 = nv_write_item(~bVar1 + bVar1 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                              puVar9[6], param_12, in_stack_0000008c._2_2_,
                              *(short *)(unaff_r7 + iVar8 + 4) - 8, *(u8 **)(unaff_r7 + iVar8), '\x01');
        if (nVar2 == NV_SUCC)
        {
          in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
          FUN_0000f6c0();
          return;
        }
        if (nVar2 == NV_ITEM_CHECK_ERROR)
        {
          FUN_0000fa20();
          return;
        }
        if (nVar2 == NV_CHECK_SUM_ERROR)
        {
          FUN_0000f992();
          return;
        }
        if (nVar2 == NV_NOT_ENOUGH_SAPCE)
        {
          FUN_0000f992();
          return;
        }
      }
      iVar6 = iVar6 + 1;
      puVar9 = puVar9 + 8;
      uVar10 = unaff_r9;
    } while (iVar6 < (int)in_stack_00000028);
  } while (true);
}
void FUN_0000fbee(uint param_1, undefined4 param_2, short param_3)

{
  char cVar1;
  int iVar2;
  uint unaff_r4;
  int iVar3;
  uint unaff_r6;
  int unaff_r7;
  uint unaff_ip;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  short sStack0000008e;

  iVar3 = param_11 + 1;
  if (param_9 == 0)
  {
    iVar2 = 0x1000;
  }
  else
  {
    iVar2 = 0x2000;
  }
  if (iVar2 * iVar3 + (unaff_r4 + 0x37) * 0x2000 < unaff_r6)
  {
    FUN_0000f3c2();
    return;
  }
  cVar1 = *(char *)(unaff_r7 + 7);
  if ((((cVar1 != 'z') && (cVar1 != 'Z')) && (cVar1 != 'P')) && (cVar1 != -6))
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc4a();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000fc44();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000fc44();
    return;
  }
  if (param_1 < param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 0x200)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (iVar3 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((iVar3 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}
undefined4 FUN_0000fc04(void)

{
  int iVar1;
  int unaff_r4;
  undefined4 unaff_r6;
  int param_9;
  int param_11;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  flash_writeWithCheck(iVar1 * param_11 + (unaff_r4 + 0x37) * 0x2000, 4, &stack0x00000088);
  return unaff_r6;
}
void FUN_0000fc44(uint param_1, int param_2, short param_3)

{
  uint unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  short sStack0000008e;

  if (param_1 < param_2 + 0x400U)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}
void FUN_0000fc4a(uint param_1, undefined4 param_2, short param_3)

{
  int iVar1;
  uint unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  int param_9;
  int param_11;
  int param_12;
  short sStack0000008e;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  if (param_12 != 0)
  {
    FUN_0000fc44();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000fc44();
    return;
  }
  if (param_1 < iVar1 * param_11 + (unaff_r4 + 0x37) * 0x2000 + 0x200)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}
void FUN_0000fc62(uint param_1, undefined4 param_2, short param_3)

{
  int iVar1;
  uint unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  int param_9;
  short sStack0000008e;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  if (iVar1 * unaff_r5 + (unaff_r4 + 0x37) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}
void FUN_0000fc8a(int param_1, undefined4 param_2, short param_3)

{
  int iVar1;
  int unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  int param_9;
  short param_11;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  if ((uint)((iVar1 * unaff_r5 + (unaff_r4 + 0x37) * 0x2000) - param_1) < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  param_11 = param_3 + 1;
  FUN_0000f7ec();
  return;
}
nv_sts_t nv_flashSingleItemRemove(u8 id, u8 itemId, u16 len)

{
  nv_sts_t nVar1;
  u32 totalItemNum;
  nv_sect_info_t nStack_20;
  u16 local_1a;

  local_1a = 0;
  nVar1 = nv_sector_read((ushort)id, '\x02', &nStack_20);
  if (nVar1 == NV_SUCC)
  {
    if (((id == '\a') || (id == '\x05')) || (totalItemNum = 0x3f, id == '\x01'))
    {
      totalItemNum = 0x7f;
    }
    nVar1 = nv_index_read((ushort)id, itemId, len, nStack_20.opSect, totalItemNum, &local_1a);
    if (nVar1 == NV_SUCC)
    {
      nVar1 = nv_itemDeleteByIndex(id, itemId, nStack_20.opSect, local_1a);
    }
  }
  return nVar1;
}
nv_sts_t nv_flashSingleItemSizeGet(u8 id, u8 itemId, u16 *len)

{
  nv_sts_t nVar1;
  u32 totalItemNum;
  nv_sect_info_t nStack_20;
  u16 local_1a;

  local_1a = 0;
  nVar1 = nv_sector_read((ushort)id, '\x02', &nStack_20);
  if (nVar1 == NV_SUCC)
  {
    if (((id == '\a') || (id == '\x05')) || (totalItemNum = 0x3f, id == '\x01'))
    {
      totalItemNum = 0x7f;
    }
    nVar1 = nv_index_read_op((ushort)id, itemId, len, nStack_20.opSect, totalItemNum, &local_1a, '\0');
  }
  return nVar1;
}
nv_sts_t nv_flashWriteNew(u8 single, u16 id, u8 itemId, u16 len, u8 *buf)

{
  nv_sts_t nVar1;

  nVar1 = NV_INVALID_MODULS;
  if (id != 4)
  {
    nVar1 = nv_flashWriteNewHandler('\0', single, id, itemId, len, buf);
    if (nVar1 == NV_ITEM_CHECK_ERROR)
    {
      nVar1 = nv_flashWriteNewHandler('\x01', single, id, itemId, len, buf);
    }
  }
  return nVar1;
}
// WARNING: Could not reconcile some variable overlaps
nv_sts_t nv_flashReadNew(u8 single, u8 id, u8 itemId, u16 len, u8 *buf)

{
  nv_sts_t nVar1;
  u32 totalItemNum;
  nv_sect_info_t nStack_28;
  undefined2 local_22;

  local_22 = 0;
  nVar1 = NV_INVALID_MODULS;
  if ((id != '\x04') && (nVar1 = nv_sector_read((ushort)id, '\x02', &nStack_28), nVar1 == NV_SUCC))
  {
    if ((id == '\a') || ((id == '\x05' || (totalItemNum = 0x3f, id == '\x01'))))
    {
      totalItemNum = 0x7f;
    }
    nVar1 = nv_index_read((ushort)id, itemId, len, nStack_28.opSect, totalItemNum, &local_22);
    if (single == '\0')
    {
      *buf = (u8)local_22;
      buf[1] = local_22._1_1_;
      buf[2] = nStack_28.opSect;
    }
    else if ((nVar1 == NV_SUCC) &&
             (nVar1 = nv_flashReadByIndex(id, itemId, nStack_28.opSect, local_22, len, buf),
              nVar1 == NV_CHECK_SUM_ERROR))
    {
      nv_itemDeleteByIndex(id, itemId, nStack_28.opSect, local_22);
    }
  }
  return nVar1;
}
nv_sts_t nv_nwkFrameCountSearch(u8 id, u8 opSect, u32 *frameCount, u32 *validAddr)

{
  u32 *puVar1;
  u32 uVar2;
  int iVar3;
  u32 uVar4;
  int iVar5;
  u32 uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  u32 local_34;
  u32 uStack_30;
  u32 local_2c[2];

  uVar9 = (uint)id;
  uVar2 = (uint)opSect * 0x1000 + 0x3c004;
  *validAddr = uVar2;
  if (uVar9 < 6)
  {
    iVar5 = (uVar9 + 0x1a) * 0x2000;
  }
  else
  {
    iVar5 = (uVar9 + 0x37) * 0x2000;
    if (uVar9 == 7)
    {
      iVar3 = 0x2000;
      goto LAB_0000fe9e;
    }
  }
  iVar3 = 0x1000;
LAB_0000fe9e:
  uVar6 = iVar5 + -0x100 + (opSect + 1) * iVar3;
  uVar4 = uVar6 - 0xe00;
  iVar5 = 0;
  do
  {
    flash_read(uVar6, 4, (u8 *)&local_34);
    if (local_34 != 0xffffffff)
    {
      uVar9 = 0x100;
    LAB_0000ff02:
      uVar2 = uVar6 + 0x100 & 0xffffff00;
      do
      {
        uVar7 = uVar9;
        if (0x10 < uVar9)
        {
          uVar7 = 0x10;
        }
        uVar8 = (uVar7 << 0x18) >> 0x1a;
        uVar2 = uVar2 + uVar8 * -4;
        flash_read(uVar2, uVar7 & 0xff, (u8 *)&local_34);
        if (local_34 == 0xffffffff)
        {
          *validAddr = uVar2;
        }
        else
        {
          *frameCount = local_34;
          if (1 < uVar8)
          {
            if (uStack_30 == 0xffffffff)
            {
              iVar5 = 4;
            }
            else
            {
              *frameCount = uStack_30;
              if (uVar8 - 1 != 1)
              {
                puVar1 = local_2c;
                iVar5 = 1;
              LAB_0000ff62:
                iVar3 = iVar5;
                iVar5 = iVar3 + 1;
                if (iVar5 < (int)uVar8)
                {
                  uVar6 = *puVar1;
                  puVar1 = puVar1 + 1;
                  if (uVar6 != 0xffffffff)
                    goto code_r0x0000ff5c;
                  goto LAB_0000ff86;
                }
                goto LAB_0000ff68;
              }
              iVar5 = 8;
            }
          LAB_0000ff88:
            *validAddr = iVar5 + uVar2;
            return NV_SUCC;
          }
        }
      LAB_0000ff68:
        uVar9 = uVar9 - (uVar7 & 0xff) & 0xffff;
        if (uVar9 == 0)
        {
          return NV_ITEM_NOT_FOUND;
        }
      } while (true);
    }
    *validAddr = uVar6;
    iVar5 = iVar5 + 1;
    if (uVar6 == uVar4)
    {
      if (iVar5 != 0xf)
      {
        return NV_ITEM_NOT_FOUND;
      }
      uVar9 = 0xfc;
      uVar6 = uVar2;
      goto LAB_0000ff02;
    }
    uVar6 = uVar6 - 0x100;
  } while (true);
code_r0x0000ff5c:
  *frameCount = uVar6;
  if (iVar5 == uVar8 - 1)
  {
    iVar5 = iVar3 + 2;
  LAB_0000ff86:
    iVar5 = iVar5 << 2;
    goto LAB_0000ff88;
  }
  goto LAB_0000ff62;
}
nv_sts_t nv_nwkFrameCountSaveToFlashHandler(u8 forceChgSec, u8 *errSect, u32 frameCount)

{
  nv_sts_t nVar1;
  nv_sts_t nVar2;
  u8 uVar3;
  uint uVar4;
  byte bVar5;
  int iVar6;
  u32 addr;
  uint uVar7;
  uint uVar8;
  u32 local_30;
  u32 uStack_2c;
  u32 uStack_28;
  nv_sect_info_t local_24;

  local_30 = frameCount;
  if (forceChgSec == '\0')
  {
    nVar2 = nv_sector_read(4, '\x02', &local_24);
    if (nVar2 == NV_SUCC)
    {
      uVar8 = (uint)local_24.opSect;
    }
    else
    {
      flash_erase(0x3c000);
      flash_erase(0x3d000);
      uVar8 = 0;
    }
  }
  else
  {
    uVar8 = *errSect + 1 & 1;
    flash_erase(uVar8 * 0x1000 + 0x3c000);
    nVar2 = NV_SUCC;
  }
  nVar1 = nv_nwkFrameCountSearch('\x04', (u8)uVar8, &uStack_28, &uStack_2c);
  uVar7 = uVar8;
  if (nVar1 == NV_SUCC)
  {
    bVar5 = 0;
    if (uVar8 * 0x1000 + 0x3d000 == uStack_2c)
    {
      uVar7 = uVar8 + 1 & 1;
      flash_erase(uVar7 * 0x1000 + 0x3c000);
      iVar6 = (uVar7 + 0x3c) * 0x1000;
      uVar3 = flash_writeWithCheck(iVar6 + 4, 4, (u8 *)&uStack_28);
      if (uVar3 != '\x01')
      {
        return NV_CHECK_SUM_ERROR;
      }
      uStack_2c = iVar6 + 8;
      bVar5 = 1;
    }
    uVar3 = flash_writeWithCheck(uStack_2c, 4, (u8 *)&local_30);
  }
  else
  {
    bVar5 = 0;
    uVar3 = flash_writeWithCheck(uStack_2c, 4, (u8 *)&local_30);
  }
  if (uVar3 == '\x01')
  {
    if ((bVar5 == 0) && (uVar7 * 0x1000 + 0x3c004 != uStack_2c))
    {
      return nVar2;
    }
    local_24.idName = '\x04';
    local_24.usedFlag = 0xfafa;
    local_24.opSect = (u8)uVar7;
    uVar4 = xcrc32(&local_24.idName, 2, 0xfffffffe);
    local_24.opSect = (byte)((uVar4 & 0x3f) << 2) | local_24.opSect;
    addr = uVar7 * 0x1000 + 0x3c000;
    uVar3 = flash_writeWithCheck(addr, 4, (u8 *)&local_24);
    if (uVar3 == '\x01')
    {
      if ((bVar5 | forceChgSec) == 0)
      {
        return nVar2;
      }
      if (forceChgSec != '\0')
      {
        uVar8 = (uint)*errSect;
      }
      local_24.usedFlag = 0x5050;
      uVar3 = flash_writeWithCheck(uVar8 * 0x1000 + 0x3c000, 2, (u8 *)&local_24);
      if (uVar3 == '\x01')
      {
        local_24.usedFlag = 0x7a7a;
        flash_writeWithCheck(addr, 2, (u8 *)&local_24);
        return nVar2;
      }
    }
  }
  return NV_CHECK_SUM_ERROR;
}
nv_sts_t nv_nwkFrameCountSaveToFlash(u32 frameCount)

{
  nv_sts_t nVar1;
  u8 local_d[5];

  local_d[0] = 0xff;
  nVar1 = nv_nwkFrameCountSaveToFlashHandler('\0', local_d, frameCount);
  if (nVar1 == NV_CHECK_SUM_ERROR)
  {
    nv_nwkFrameCountSaveToFlashHandler('\x01', local_d, frameCount);
  }
  return NV_SUCC;
}
nv_sts_t nv_nwkFrameCountFromFlash(u32 *frameCount)

{
  nv_sts_t nVar1;
  int local_2c;
  int iStack_28;
  uint uStack_24;
  u32 uStack_20;
  nv_sect_info_t nStack_1c;
  byte local_15[5];

  local_15[0] = 0;
  nVar1 = nv_sector_read(4, '\x02', &nStack_1c);
  if (nVar1 == NV_SUCC)
  {
    local_15[0] = nStack_1c.opSect;
    nVar1 = nv_nwkFrameCountSearch('\x04', nStack_1c.opSect, &uStack_20, &uStack_24);
    if (nVar1 == NV_SUCC)
    {
      *frameCount = uStack_20;
      if ((uint)local_15[0] * 0x1000 + 0x3c00c < uStack_24)
      {
        flash_read(uStack_24 - 8, 8, (u8 *)&local_2c);
        if (0x400 < (uint)(iStack_28 - local_2c))
        {
          *frameCount = local_2c + 0x400U;
          nv_nwkFrameCountSaveToFlashHandler('\x01', local_15, local_2c + 0x400U);
        }
      }
    }
  }
  return nVar1;
}
nv_sts_t nv_resetModule(u8 modules)

{
  uint uVar1;
  int iVar2;
  u32 addr;
  int iVar3;
  u32 uVar4;
  int iVar5;

  uVar1 = (uint)modules;
  if (uVar1 < 6)
  {
    uVar4 = (uVar1 + 0x1a) * 0x2000;
  }
  else
  {
    uVar4 = (uVar1 + 0x37) * 0x2000;
    iVar3 = 2;
    if (uVar1 == 7)
      goto LAB_000101f2;
  }
  iVar3 = 1;
LAB_000101f2:
  iVar5 = 2;
  do
  {
    iVar2 = 0;
    addr = uVar4;
    do
    {
      flash_erase(addr);
      addr = addr + 0x1000;
      iVar2 = iVar2 + 1;
    } while (iVar2 < iVar3);
    uVar4 = uVar4 + iVar3 * 0x1000;
    iVar5 = iVar5 + -2;
  } while (iVar5 != 0);
  return NV_SUCC;
}
u8 nv_facrotyNewRstFlagCheck(void)

{
  u8 local_9[5];

  local_9[0] = 0xff;
  flash_read(0x79000, 1, local_9);
  return '\x01' - (local_9[0] == 0xff);
}
void nv_facrotyNewRstFlagSet(void)

{
  u8 local_5[5];

  local_5[0] = 'Z';
  flash_writeWithCheck(0x79000, 1, local_5);
  return;
}
void nv_facrotyNewRstFlagClear(void)

{
  flash_erase(0x79000);
  return;
}
nv_sts_t nv_resetToFactoryNew(void)

{
  u8 uVar1;
  int iVar2;
  int iVar3;

  uVar1 = nv_facrotyNewRstFlagCheck();
  if (uVar1 == '\0')
  {
    nv_facrotyNewRstFlagSet();
  }
  iVar2 = 0;
  for (iVar3 = 1; (iVar2 == 4 || (nv_resetModule((u8)iVar2), iVar3 < 8)); iVar3 = iVar3 + 1)
  {
    iVar2 = iVar2 + 1;
  }
  nv_facrotyNewRstFlagClear();
  return NV_SUCC;
}
u32 drv_pm_deepSleep_frameCnt_get(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;

  analog_write(':', '\0');
  bVar1 = analog_read('8');
  bVar2 = analog_read('7');
  bVar3 = analog_read('6');
  bVar4 = analog_read('5');
  return (uint)bVar4 | (uint)bVar2 << 0x10 | (uint)bVar1 << 0x18 | (uint)bVar3 << 8;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void hwTimerStop(u8 tmrIdx)

{
  if (tmrIdx < 3)
  {
    timer_stop(tmrIdx);
  }
  else
  {
    _DAT_00800640 = _DAT_00800640 & 0xffefffff;
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void drv_hwTmr_irq_process(u8 tmrIdx)

{
  uint uVar1;
  int iVar2;
  u32 uVar3;
  int iVar4;

  uVar1 = (uint)tmrIdx;
  iVar4 = uVar1 * 4;
  if ((*(byte *)&hwTmr_vars.timerInfo[uVar1].flags & 3) == 2)
  {
    if (hwTmr_vars.timerInfo[uVar1].cb != ll_reset)
    {
      iVar2 = FUNBBBBC();
      if (iVar2 < 0)
      {
        hwTimerStop(tmrIdx);
        hwTmr_vars.timerInfo[uVar1].expireInfo.low = 0;
        hwTmr_vars.timerInfo[uVar1].expireInfo.high = 0;
        hwTmr_vars.timerInfo[uVar1].cb = ll_reset;
        hwTmr_vars.timerInfo[uVar1].arg = (void *)0x0;
        hwTmr_vars.timerInfo[uVar1].flags.byteVal = 0;
      }
      else
      {
        if (iVar2 != 0)
        {
          uVar3 = 0x30;
          if (2 < uVar1)
          {
            uVar3 = sysTimerPerUs;
          }
          hwTmr_vars.timerInfo[uVar1].expireInfo.low = iVar2 * uVar3;
        }
        if (hwTmr_vars.timerInfo[uVar1].expireInfo.high == 0)
        {
          uVar3 = hwTmr_vars.timerInfo[uVar1].expireInfo.low;
        }
        else
        {
          uVar3 = 0xfffffffd;
        }
        if (uVar1 < 3)
        {
          *(undefined4 *)(iVar4 + 0x800630) = 0;
          *(u32 *)(iVar4 + 0x800624) = uVar3;
        }
        else
        {
          _DAT_00800744 = uVar3 + _DAT_00800740;
        }
      }
    }
  }
  else
  {
    uVar3 = hwTmr_vars.timerInfo[uVar1].expireInfo.high - 1;
    hwTmr_vars.timerInfo[uVar1].expireInfo.high = uVar3;
    if (uVar3 == 0)
    {
      uVar3 = hwTmr_vars.timerInfo[uVar1].expireInfo.low;
      if (uVar1 < 3)
      {
        *(undefined4 *)(iVar4 + 0x800630) = 0;
        *(u32 *)(iVar4 + 0x800624) = uVar3;
      }
      else
      {
        _DAT_00800744 = _DAT_00800740 + uVar3;
      }
      *(byte *)&hwTmr_vars.timerInfo[uVar1].flags =
          *(byte *)&hwTmr_vars.timerInfo[uVar1].flags & 0xfc | 2;
    }
    else if (uVar1 < 3)
    {
      *(undefined4 *)(iVar4 + 0x800630) = 0;
      *(undefined4 *)(iVar4 + 0x800624) = 0xfffffffd;
    }
    else
    {
      _DAT_00800744 = _DAT_00800740 + -2;
    }
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNBBBBC(void)

{
  uint uVar1;
  TIMER_ModeTypeDef mode;
  code *in_r3;

  uVar1 = (*in_r3)();
  uVar1 = uVar1 & 0xff;
  if (uVar1 < 4)
  {
    memset(hwTmr_vars.timerInfo + uVar1, 0, 0x14);
    if (uVar1 == 3)
    {
      DAT_0080074c = DAT_0080074c | 2;
    }
    else
    {
      timer_set_mode((TIMER_TypeDef)uVar1, mode);
      _DAT_00800640 = 1 << uVar1 | _DAT_00800640;
    }
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void drv_hwTmr_init(u8 tmrIdx, u8 mode)

{
  uint uVar1;

  uVar1 = (uint)tmrIdx;
  if (uVar1 < 4)
  {
    memset(hwTmr_vars.timerInfo + uVar1, 0, 0x14);
    if (uVar1 == 3)
    {
      DAT_0080074c = DAT_0080074c | 2;
    }
    else
    {
      timer_set_mode(tmrIdx, mode);
      _DAT_00800640 = 1 << uVar1 | _DAT_00800640;
    }
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
hw_timer_sts_t drv_hwTmr_set(u8 tmrIdx, u32 t_us, timerCb_t func, void *arg)

{
  byte bVar1;
  uint uVar2;
  u32 en;
  uint uVar3;
  uint uVar4;
  hw_timer_sts_t hVar5;
  u32 uStack_2c;

  uVar2 = (uint)tmrIdx;
  hVar5 = HW_TIMER_INVALID;
  if (uVar2 < 4)
  {
    uStack_2c = 0x30;
    if (uVar2 == 3)
    {
      uStack_2c = sysTimerPerUs;
    }
    bVar1 = *(byte *)&hwTmr_vars.timerInfo[uVar2].flags;
    hVar5 = HW_TIMER_IS_RUNNING;
    if ((bVar1 & 3) == 0)
    {
      en = drv_disable_irq();
      hwTmr_vars.timerInfo[uVar2].expireInfo.high = bVar1 & 3;
      hwTmr_vars.timerInfo[uVar2].expireInfo.low = t_us * uStack_2c;
      hwTmr_vars.timerInfo[uVar2].cb = func;
      hwTmr_vars.timerInfo[uVar2].arg = arg;
      *(byte *)&hwTmr_vars.timerInfo[uVar2].flags =
          *(byte *)&hwTmr_vars.timerInfo[uVar2].flags & 0xfc | 2;
      uVar4 = hwTmr_vars.timerInfo[uVar2].expireInfo.low;
      if (uVar2 == 3)
      {
        uVar3 = sysTimerPerUs * 10;
      }
      else
      {
        uVar3 = 0x1e0;
      }
      if (uVar4 < uVar3)
      {
        drv_restore_irq(en);
        hwTmr_vars.timerInfo[uVar2].expireInfo.low = 0;
        hwTmr_vars.timerInfo[uVar2].expireInfo.high = 0;
        hwTmr_vars.timerInfo[uVar2].cb = ll_reset;
        hwTmr_vars.timerInfo[uVar2].arg = (void *)0x0;
        hwTmr_vars.timerInfo[uVar2].flags.byteVal = 0;
        hVar5 = HW_TIMER_SUCC;
        if (func != ll_reset)
        {
          FUNBBBBD();
        }
      }
      else
      {
        if (uVar2 == 3)
        {
          _DAT_00800744 = uVar4 + _DAT_00800740;
          _DAT_00800640 = _DAT_00800640 | 0x100000;
        }
        else
        {
          *(undefined4 *)(uVar2 * 4 + 0x800630) = 0;
          *(uint *)(uVar2 * 4 + 0x800624) = uVar4;
          timer_start(tmrIdx);
        }
        drv_restore_irq(en);
        hVar5 = HW_TIMER_SUCC;
      }
    }
  }
  return hVar5;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNBBBBD(void)

{
  code *unaff_r8;

  (*unaff_r8)();
  drv_hwTmr_irq_process('\0');
  return;
}
void drv_timer_irq0_handler(void)

{
  drv_hwTmr_irq_process('\0');
  return;
}
void drv_timer_irq1_handler(void)

{
  drv_hwTmr_irq_process('\x01');
  return;
}
void drv_timer_irq3_handler(void)

{
  drv_hwTmr_irq_process('\x03');
  return;
}
void drv_uart_rx_irq_handler(void)

{
  if (myUartDriver.recvCb != ll_reset)
  {
    FUNBBBBE();
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNBBBBE(void)

{
  code *in_r3;

  (*in_r3)();
  if (uartDrvTxBuf != (u8 *)0x0)
  {
    ev_buf_free(uartDrvTxBuf);
    uartDrvTxBuf = (u8 *)0x0;
  }
  myUartDriver.status = '\x02';
  return;
}
void drv_uart_tx_irq_handler(void)

{
  if (uartDrvTxBuf != (u8 *)0x0)
  {
    ev_buf_free(uartDrvTxBuf);
    uartDrvTxBuf = (u8 *)0x0;
  }
  myUartDriver.status = '\x02';
  return;
}
void listAdd(list_t list, void *item)

{
  int *piVar1;
  int *piVar2;

  *(undefined *)item = 0;
  *(undefined *)((int)item + 1) = 0;
  *(undefined *)((int)item + 2) = 0;
  *(undefined *)((int)item + 3) = 0;
  piVar1 = (int *)*list;
  if ((int *)*list == (int *)0x0)
  {
    *list = item;
  }
  else
  {
    do
    {
      piVar2 = piVar1;
      piVar1 = (int *)*piVar2;
    } while ((int *)*piVar2 != (int *)0x0);
    *(char *)piVar2 = (char)item;
    *(char *)((int)piVar2 + 1) = (char)((uint)item >> 8);
    *(char *)((int)piVar2 + 2) = (char)((uint)item >> 0x10);
    *(char *)((int)piVar2 + 3) = (char)((uint)item >> 0x18);
  }
  return;
}
void listRemove(list_t list, void *item)

{
  void *pvVar1;
  void **ppvVar2;
  void **ppvVar3;

  ppvVar2 = (void **)*list;
  if (ppvVar2 != (void **)0x0)
  {
    if (ppvVar2 == (void **)item)
    {
      *list = *ppvVar2;
    }
    else
    {
      do
      {
        ppvVar3 = ppvVar2;
        ppvVar2 = (void **)*ppvVar3;
        if (ppvVar2 == (void **)0x0)
        {
          return;
        }
      } while ((void **)item != ppvVar2);
      pvVar1 = *ppvVar2;
      *(char *)ppvVar3 = (char)pvVar1;
      *(char *)((int)ppvVar3 + 1) = (char)((uint)pvVar1 >> 8);
      *(char *)((int)ppvVar3 + 2) = (char)((uint)pvVar1 >> 0x10);
      *(char *)((int)ppvVar3 + 3) = (char)((uint)pvVar1 >> 0x18);
    }
    *(undefined *)ppvVar2 = 0;
    *(undefined *)((int)ppvVar2 + 1) = 0;
    *(undefined *)((int)ppvVar2 + 2) = 0;
    *(undefined *)((int)ppvVar2 + 3) = 0;
  }
  return;
}
int listLength(list_t list)

{
  int iVar1;
  undefined4 *puVar2;

  iVar1 = 0;
  for (puVar2 = (undefined4 *)*list; puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2)
  {
    iVar1 = iVar1 + 1;
  }
  return iVar1;
}
void mempool_free(mem_pool_t *pool, void *p)

{
  mem_block_t *pmVar1;
  undefined *puVar2;

  puVar2 = (undefined *)((int)p + -4);
  pmVar1 = pool->free_list;
  *puVar2 = (char)pmVar1;
  *(char *)((int)p + -3) = (char)((uint)pmVar1 >> 8);
  *(char *)((int)p + -2) = (char)((uint)pmVar1 >> 0x10);
  *(char *)((int)p + -1) = (char)((uint)pmVar1 >> 0x18);
  *(char *)&pool->free_list = (char)puVar2;
  *(char *)((int)&pool->free_list + 1) = (char)((uint)puVar2 >> 8);
  *(char *)((int)&pool->free_list + 2) = (char)((uint)puVar2 >> 0x10);
  *(char *)((int)&pool->free_list + 3) = (char)((uint)puVar2 >> 0x18);
  return;
}
int memcmp(void *m1, void *m2, uint n)

{
  int iVar1;
  uint uVar2;
  uint uVar3;

  iVar1 = 0;
  if (n != 0)
  {
    // WARNING: Load size is inaccurate
    uVar3 = (uint)*m1;
    // WARNING: Load size is inaccurate
    uVar2 = (uint)*m2;
    if (uVar3 == uVar2)
    {
      iVar1 = 0;
      do
      {
        if (n - 1 == iVar1)
        {
          return 0;
        }
        m1 = (void *)((int)m1 + 1);
        // WARNING: Load size is inaccurate
        uVar3 = (uint)*m1;
        iVar1 = iVar1 + 1;
        uVar2 = (uint) * (byte *)((int)m2 + iVar1);
      } while (uVar3 == uVar2);
    }
    iVar1 = uVar3 - uVar2;
  }
  return iVar1;
}
void bcopy(char *src, char *dest, int len)

{
  int iVar1;
  uint uVar2;

  if (dest < src)
  {
    if (len != 0)
    {
      iVar1 = 0;
      do
      {
        dest[iVar1] = src[iVar1];
        iVar1 = iVar1 + 1;
      } while (iVar1 != len);
    }
  }
  else if (len != 0)
  {
    uVar2 = 0;
    do
    {
      dest[uVar2 + len + -1] = src[uVar2 + len + -1];
      uVar2 = uVar2 - 1;
    } while (uVar2 != ~len);
  }
  return;
}
uint xcrc32(uchar *buf, int len, uint init)

{
  byte *pbVar1;

  if (len != 0)
  {
    pbVar1 = buf + len;
    do
    {
      init = crc32_table[(init ^ *buf) & 0xff] ^ init >> 8;
      buf = buf + 1;
    } while (buf != pbVar1);
  }
  return init;
}
void adc_set_ref_voltage(ADC_ChTypeDef ch_n, ADC_RefVolTypeDef v_ref)

{
  byte bVar1;

  analog_write(0xe7, v_ref << 2 | v_ref << 4 | v_ref);
  if (v_ref == 2)
  {
    bVar1 = analog_read(0xfa);
    analog_write(0xfa, bVar1 & 0xc0 | 0x3d);
  }
  else
  {
    bVar1 = analog_read(0xfa);
    analog_write(0xfa, bVar1 & 0xc0 | 0x15);
    adc_gpio_calib_vref = adc_ref_vol[v_ref];
  }
  return;
}
void adc_set_resolution(ADC_ChTypeDef ch_n, ADC_ResTypeDef v_res)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    bVar1 = analog_read(0xeb);
    analog_write(0xeb, bVar1 & 0xfc | v_res);
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    bVar1 = analog_read(0xeb);
    analog_write(0xeb, bVar1 & 0xcf | v_res << 4);
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    bVar1 = analog_read(0xec);
    analog_write(0xec, v_res | bVar1 & 0xfc);
  }
  return;
}
void adc_set_tsample_cycle(ADC_ChTypeDef ch_n, ADC_SampCycTypeDef adcST)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    bVar1 = analog_read(0xed);
    analog_write(0xed, bVar1 & 0xf0 | adcST);
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    bVar1 = analog_read(0xed);
    analog_write(0xed, bVar1 & 0xf | (byte)((adcST & 0xf) << 4));
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    analog_write(0xee, adcST);
  }
  return;
}
void adc_set_input_mode(ADC_ChTypeDef ch_n, ADC_InputModeTypeDef m_input)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    if (m_input == SINGLE_ENDED_MODE)
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 & 0xef);
    }
    else
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 | 0x10);
    }
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    if (m_input == SINGLE_ENDED_MODE)
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 & 0xdf);
    }
    else
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 | 0x20);
    }
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    if (m_input == SINGLE_ENDED_MODE)
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 & 0xbf);
    }
    else
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 | 0x40);
    }
  }
  return;
}
void adc_set_ain_channel_differential_mode(ADC_ChTypeDef ch_n, ADC_InputPchTypeDef InPCH, ADC_InputNchTypeDef InNCH)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;

  uVar3 = (uint)InPCH;
  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    analog_write(0xe9, (byte)((uVar3 & 0xf) << 4) | InNCH);
    bVar1 = analog_read(0xec);
    analog_write(0xec, bVar1 | 0x10);
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    analog_write(0xea, (byte)((uVar3 & 0xf) << 4) | InNCH);
    bVar1 = analog_read(0xec);
    analog_write(0xec, bVar1 | 0x20);
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    analog_write(0xe8, InNCH | (byte)((uVar3 & 0xf) << 4));
    bVar1 = analog_read(0xec);
    analog_write(0xec, bVar1 | 0x40);
  }
  return;
}
void adc_vbat_pin_init(GPIO_PinTypeDef pin)

{
  char cVar1;
  byte *pbVar2;
  GPIO_PinTypeDef *pGVar3;
  ADC_InputPchTypeDef InPCH;
  int iVar4;

  gpio_set_func(pin, AS_GPIO);
  gpio_set_input_en(pin, 0);
  iVar4 = (((uint)pin << 0x10) >> 0x18) * 8;
  pbVar2 = (byte *)(iVar4 + 0x800582);
  *pbVar2 = *pbVar2 & ~(byte)pin;
  pbVar2 = (byte *)(iVar4 + 0x800583);
  *pbVar2 = (byte)pin | *pbVar2;
  pGVar3 = ADC_GPIO_tab;
  cVar1 = '\0';
  do
  {
    if ((uint)*pGVar3 == (uint)pin)
    {
      InPCH = cVar1 + B0P;
      goto LAB_00010b5e;
    }
    cVar1 = cVar1 + '\x01';
    pGVar3 = pGVar3 + 1;
  } while (cVar1 != '\n');
  InPCH = NOINPUTP;
LAB_00010b5e:
  adc_set_input_mode(ADC_MISC_CHN, DIFFERENTIAL_MODE);
  adc_set_ain_channel_differential_mode(ADC_MISC_CHN, InPCH, GND);
  return;
}
void adc_base_pin_init(GPIO_PinTypeDef pin)

{
  char cVar1;
  ADC_InputPchTypeDef InPCH;
  byte *pbVar2;
  GPIO_PinTypeDef *pGVar3;
  int iVar4;

  gpio_set_func(pin, AS_GPIO);
  gpio_set_input_en(pin, 0);
  iVar4 = (((uint)pin << 0x10) >> 0x18) * 8;
  pbVar2 = (byte *)(iVar4 + 0x800582);
  *pbVar2 = *pbVar2 | (byte)pin;
  pbVar2 = (byte *)(iVar4 + 0x800583);
  *pbVar2 = *pbVar2 & ~(byte)pin;
  pGVar3 = ADC_GPIO_tab;
  cVar1 = '\0';
  do
  {
    if ((uint)*pGVar3 == (uint)pin)
    {
      InPCH = cVar1 + B0P;
      goto LAB_00010bd2;
    }
    cVar1 = cVar1 + '\x01';
    pGVar3 = pGVar3 + 1;
  } while (cVar1 != '\n');
  InPCH = NOINPUTP;
LAB_00010bd2:
  adc_set_ain_channel_differential_mode(ADC_MISC_CHN, InPCH, GND);
  return;
}
void adc_set_ain_pre_scaler(ADC_PreScalingTypeDef v_scl)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)v_scl;
  bVar1 = analog_read(0xfa);
  analog_write(0xfa, bVar1 & 0x3f | (byte)((uVar2 & 3) << 6));
  if (uVar2 == 0)
  {
    bVar1 = analog_read(0xf9);
    analog_write(0xf9, bVar1 & 0xcf);
  }
  else
  {
    bVar1 = analog_read(0xf9);
    analog_write(0xf9, bVar1 | 0x10);
  }
  adc_pre_scale = (uchar)(1 << uVar2);
  return;
}
void adc_init(void)

{
  byte bVar1;

  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xdf | 0x20);
  DAT_00800061 = 0;
  bVar1 = analog_read(0x82);
  analog_write(0x82, bVar1 | 0x40);
  analog_write(0xf4, '\x05');
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xbf | 0x40);
  analog_read(0xfc);
  analog_write(0xfc, '\x7f');
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xfc | 1);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xf3 | 4);
  DAT_00800b10 = DAT_00800b10 & 0xfb;
  analog_write(0xef, 0xff);
  analog_write(0xf0, '\0');
  analog_write(0xf1, 0xcf);
  return;
}
void adc_set_gpio_calib_vref(ushort data)

{
  adc_gpio_calib_vref = data;
  return;
}
void adc_set_gpio_two_point_calib_offset(char offset)

{
  adc_gpio_calib_vref_offset = offset;
  return;
}
void adc_base_init(GPIO_PinTypeDef pin)

{
  byte bVar1;

  analog_write(0xf2, '$');
  adc_vref = adc_gpio_calib_vref;
  adc_vref_offset = adc_gpio_calib_vref_offset;
  adc_set_ref_voltage(ADC_MISC_CHN, ADC_VREF_1P2V);
  bVar1 = analog_read(0xf9);
  analog_write(0xf9, bVar1 & 0xf3);
  adc_base_pin_init(pin);
  adc_set_resolution(ADC_MISC_CHN, RES14);
  adc_set_tsample_cycle(ADC_MISC_CHN, SAMPLING_CYCLES_6);
  adc_set_ain_pre_scaler(ADC_PRESCALER_1F8);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xef);
  return;
}
void adc_vbat_init(GPIO_PinTypeDef pin)

{
  byte bVar1;

  analog_write(0xf2, '$');
  bVar1 = analog_read(0xf9);
  analog_write(0xf9, bVar1 & 0xf3);
  adc_vref = adc_gpio_calib_vref;
  adc_vref_offset = adc_gpio_calib_vref_offset;
  adc_vbat_pin_init(pin);
  adc_set_ref_voltage(ADC_MISC_CHN, ADC_VREF_1P2V);
  adc_set_resolution(ADC_MISC_CHN, RES14);
  adc_set_tsample_cycle(ADC_MISC_CHN, SAMPLING_CYCLES_6);
  adc_set_ain_pre_scaler(ADC_PRESCALER_1F8);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xef);
  return;
}
void flash_erase_sector(ulong addr)

{
  flash_mspi_write_ram(' ', addr, '\x01', (uchar *)0x0, 0);
  return;
}
void flash_read_page(ulong addr, ulong len, uchar *buf)

{
  flash_mspi_read_ram('\x03', addr, '\x01', '\0', buf, len);
  return;
}
void flash_write_page(ulong addr, ulong len, uchar *buf)

{
  uint data_len;

  data_len = 0x100 - (addr & 0xff);
  while (true)
  {
    if (len < data_len)
    {
      data_len = len;
    }
    flash_mspi_write_ram('\x02', addr, '\x01', buf, data_len);
    addr = addr + data_len;
    buf = buf + data_len;
    len = len - data_len;
    if (len == 0)
      break;
    data_len = 0x100;
  }
  return;
}
uchar flash_read_status(uchar cmd)

{
  uchar local_9[5];

  local_9[0] = '\0';
  flash_mspi_read_ram(cmd, 0, '\0', '\0', local_9, 1);
  return local_9[0];
}
void flash_write_status(flash_status_typedef_e type, ushort data)

{
  ushort local_8[4];

  local_8[0] = data;
  if (type == FLASH_TYPE_8BIT_STATUS)
  {
    flash_mspi_write_ram('\x01', 0, '\0', (uchar *)local_8, 1);
  }
  else if (type == FLASH_TYPE_16BIT_STATUS_ONE_CMD)
  {
    flash_mspi_write_ram('\x01', 0, '\0', (uchar *)local_8, 2);
  }
  return;
}
// WARNING: Variable defined which should be unmapped: flash_mid
uint flash_read_mid(void)

{
  uchar buf[4];
  uint auStack_10[2];
  uint flash_mid;

  auStack_10[0] = 0;
  flash_mspi_read_ram(0x9f, 0, '\0', '\0', (uchar *)auStack_10, 3);
  if (auStack_10[0] == 0x1460c8)
  {
    buf = (uchar[4])0x0;
    flash_mspi_read_ram('Z', 0, '\x01', '\x01', buf, 4);
    if ((((buf[0] == 'S') && (buf[1] == 'F')) && (buf[2] == 'D')) && (buf[3] == 'P'))
    {
      auStack_10[0] = 0x11460c8;
    }
  }
  return auStack_10[0];
}
void flash_read_uid(uchar idcmd, uchar *buf)

{
  if (idcmd == 'K')
  {
    flash_mspi_read_ram('K', 0, '\x01', '\x01', buf, 0x10);
  }
  else if (idcmd == 'Z')
  {
    flash_mspi_read_ram('Z', 0x80, '\x01', '\x01', buf, 0x10);
  }
  return;
}
int flash_read_mid_uid_with_check(uint *flash_mid, uchar *flash_uid)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  undefined4 local_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 local_18;

  uStack_1c = 0x1510151;
  uStack_20 = 0x1510151;
  local_24 = 0x1510151;
  local_18 = 0x1510151;
  uVar1 = flash_read_mid();
  *flash_mid = uVar1;
  if ((((((uVar1 == 0x11460c8) || (uVar1 == 0x1460c8)) || (uVar1 == 0x1060c8)) ||
        ((uVar1 == 0x134051 || (uVar1 == 0x136085)))) ||
       ((uVar1 == 0x1360c8 || ((uVar1 == 0x1360eb || (uVar1 == 0x13325e)))))) ||
      (uVar2 = 0, uVar1 == 0x14325e))
  {
    flash_read_uid('K', flash_uid);
    iVar3 = 0;
    iVar4 = 0;
    do
    {
      uVar1 = (uint)flash_uid[iVar4] - (uint) * (byte *)((int)&local_24 + iVar4);
      iVar3 = iVar3 + uVar1 + ~uVar1 +
              (uint)((uint) * (byte *)((int)&local_24 + iVar4) <= (uint)flash_uid[iVar4]);
      iVar4 = iVar4 + 1;
    } while (iVar4 != 0x10);
    uVar2 = (uint)(iVar3 != 0x10);
  }
  return uVar2;
}
uchar flash_is_zb(void)

{
  uchar uVar1;
  uint uVar2;

  uVar2 = flash_read_mid();
  if ((uVar2 == 0x14325e) ||
      (~(uVar2 - 0x13325e) + (uVar2 - 0x13325e) + (uint)(0x13325d < uVar2) != 0))
  {
    g_flashIsZbit = '\x01';
    uVar1 = '\x01';
  }
  else
  {
    g_flashIsZbit = '\0';
    uVar1 = '\0';
  }
  return uVar1;
}
void flash_safe_voltage_set(ushort vol)

{
  g_flashWorkVol = vol;
  return;
}
void flash_vdd_f_calib(void)

{
  uchar uVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  byte local_9[5];

  uVar4 = flash_read_mid();
  local_9[0] = 0;
  switch ((uVar4 << 8) >> 0x18)
  {
  case 0x10:
    flash_read_page(0xe1c0, 1, local_9);
    break;
  case 0x11:
    flash_read_page(0x1e1c0, 1, local_9);
    break;
  default:
    local_9[0] = 0xff;
    goto LAB_000110b6;
  case 0x13:
    flash_read_page(0x771c0, 1, local_9);
    break;
  case 0x14:
    flash_read_page(0xfe1c0, 1, local_9);
    break;
  case 0x15:
    flash_read_page(0x1fe1c0, 1, local_9);
  }
  bVar2 = local_9[0];
  if ((local_9[0] == 0xff) || ((local_9[0] & 0xf8) != 0))
  {
  LAB_000110b6:
    uVar1 = flash_is_zb();
    if (uVar1 != '\0')
    {
      bVar2 = analog_read('\f');
      analog_write('\f', bVar2 | 7);
    }
  }
  else
  {
    bVar3 = analog_read('\f');
    analog_write('\f', bVar2 | bVar3 & 0xf8);
  }
  return;
}
void flash_write_status_mid13325e(uchar data, mid13325e_write_status_bit_e bit)

{
  mid13325e_write_status_bit_e mVar1;

  mVar1 = flash_read_status('\x05');
  if ((bit & mVar1) != data)
  {
    flash_write_status(FLASH_TYPE_8BIT_STATUS, (ushort)data | (ushort)mVar1 & ~(ushort)bit);
  }
  return;
}
void flash_unlock_mid13325e(void)

{
  flash_write_status_mid13325e('\0', FLASH_WRITE_STATUS_BP_MID13325E);
  return;
}
s32 brc_toggleCb(void *arg)

{
  int iVar1;
  u8 seqNo;
  undefined4 local_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  undefined2 local_8;

  seqNo = zcl_seqNum;
  uStack_14 = 0;
  local_8 = 0;
  uStack_c = 0x1020000;
  local_18 = 0xfffe;
  uStack_10 = 0x104;
  iVar1 = (uint)brc_toggleCb::toggle + ~(uint)brc_toggleCb::toggle;
  brc_toggleCb::toggle = (u8)iVar1;
  if (iVar1 == 0)
  {
    zcl_seqNum = zcl_seqNum + '\x01';
    zcl_onOff_off('\x01', (epInfo_t *)&local_18, '\0', seqNo);
  }
  else
  {
    zcl_seqNum = zcl_seqNum + '\x01';
    zcl_onOff_on('\x01', (epInfo_t *)&local_18, '\0', seqNo);
  }
  return 0;
}
void led_on(u32 pin)

{
  drv_gpio_write(pin, '\x01');
  return;
}
void led_off(u32 pin)

{
  drv_gpio_write(pin, '\0');
  return;
}
void light_on(void)

{
  led_on(8);
  return;
}
void light_off(void)

{
  led_off(8);
  return;
}
s32 zclLightTimerCb(void *arg)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  bool bVar4;

  uVar2 = (uint)g_appGwCtx.sta;
  bVar4 = uVar2 <= g_appGwCtx.oriSta;
  if (g_appGwCtx.oriSta == uVar2)
  {
    g_appGwCtx.times = g_appGwCtx.times + 0xff;
    bVar4 = true;
    if (g_appGwCtx.times == '\0')
    {
      g_appGwCtx.timerLedEvt._0_1_ = g_appGwCtx.times;
      g_appGwCtx.timerLedEvt._1_1_ = g_appGwCtx.times;
      g_appGwCtx.timerLedEvt._2_1_ = g_appGwCtx.times;
      g_appGwCtx.timerLedEvt._3_1_ = g_appGwCtx.times;
      return -2;
    }
  }
  iVar3 = uVar2 + ~uVar2 + (uint)bVar4;
  g_appGwCtx.sta = (u8)iVar3;
  if (iVar3 == 0)
  {
    light_off();
    uVar1 = g_appGwCtx.ledOffTime;
  }
  else
  {
    light_on();
    uVar1 = g_appGwCtx.ledOnTime;
  }
  return (uint)uVar1;
}
void light_init(void)

{
  led_on(8);
  return;
}
void light_blink_start(u8 times, u16 ledOnTime, u16 ledOffTime)

{
  uint t_ms;
  bool bVar1;

  g_appGwCtx.times = times;
  if (g_appGwCtx.timerLedEvt == (ev_timer_event_t *)0x0)
  {
    bVar1 = g_appGwCtx.oriSta != '\0';
    if (bVar1)
    {
      light_off();
      t_ms = (uint)ledOffTime;
    }
    else
    {
      light_on();
      t_ms = (uint)ledOnTime;
    }
    g_appGwCtx.sta = !bVar1;
    g_appGwCtx.ledOnTime._0_1_ = (undefined)ledOnTime;
    g_appGwCtx.ledOnTime._1_1_ = (undefined)((uint)ledOnTime >> 8);
    g_appGwCtx.ledOffTime._0_1_ = (undefined)ledOffTime;
    g_appGwCtx.ledOffTime._1_1_ = (undefined)((uint)ledOffTime >> 8);
    g_appGwCtx.timerLedEvt = ev_timer_taskPost(zclLightTimerCb, (void *)0x0, t_ms);
  }
  return;
}
void light_blink_stop(void)

{
  if (g_appGwCtx.timerLedEvt != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_appGwCtx.timerLedEvt);
    g_appGwCtx.times = '\0';
    if (g_appGwCtx.oriSta == '\0')
    {
      light_off();
    }
    else
    {
      light_on();
    }
  }
  return;
}
void brc_toggle(void)

{
  if (brc_toggleEvt == (ev_timer_event_t *)0x0)
  {
    brc_toggleEvt = ev_timer_taskPost(brc_toggleCb, (void *)0x0, 1000);
  }
  else
  {
    ev_timer_taskCancel(&brc_toggleEvt);
  }
  return;
}
void buttonShortPressed(u8 btNum)

{
  bool bVar1;
  char cVar2;

  if (btNum == '\x01')
  {
    bVar1 = zb_isDeviceJoinedNwk();
    if (bVar1 != false)
    {
      brc_toggle();
    }
  }
  else if (btNum == '\x02')
  {
    bVar1 = zb_isDeviceJoinedNwk();
    cVar2 = '\x01';
    if (bVar1 != false)
    {
      bVar1 = zb_getMacAssocPermit();
      zb_nlmePermitJoiningRequest(~(bVar1 + ~bVar1 + cVar2) & 0xb4);
      gpsCommissionModeInvork();
    }
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void keyScan_keyPressedCB(kb_data_t *kbEvt)

{
  u8 btNum;

  btNum = kbEvt->keycode[0];
  buttonShortPressed(btNum);
  if (btNum == '\x01')
  {
    g_appGwCtx.keyPressedTime._0_1_ = (undefined)_DAT_00800740;
    g_appGwCtx.keyPressedTime._1_1_ = (undefined)((uint)_DAT_00800740 >> 8);
    g_appGwCtx.keyPressedTime._2_1_ = (undefined)((uint)_DAT_00800740 >> 0x10);
    g_appGwCtx.keyPressedTime._3_1_ = (undefined)((uint)_DAT_00800740 >> 0x18);
    g_appGwCtx.state = '\x01';
  }
  return;
}
void app_key_handler(void)

{
  u32 uVar1;

  uVar1 = kb_scan_key(0, 1);
  if (uVar1 != 0)
  {
    T_keyPressedNum = T_keyPressedNum + '\x01';
    if (kb_event.cnt == '\0')
    {
      g_appGwCtx.state = '\0';
      app_key_handler::valid_keyCode = 0xff;
    }
    else
    {
      keyScan_keyPressedCB(&kb_event);
      if (kb_event.cnt == '\x01')
      {
        app_key_handler::valid_keyCode = kb_event.keycode[0];
      }
    }
  }
  return;
}
void sampleGwSysException(void)

{
  DAT_0080006f = 0x20;
  return;
}
void app_task(void)

{
  bool bVar1;

  bVar1 = zb_getMacAssocPermit();
  if ((bool)app_task::assocPermit != bVar1)
  {
    app_task::assocPermit = zb_getMacAssocPermit();
    if ((bool)app_task::assocPermit == false)
    {
      led_off(4);
    }
    else
    {
      led_on(4);
    }
  }
  if (g_bdbCtx.state == '\0')
  {
    app_key_handler();
  }
  return;
}
void stack_init(void)

{
  zb_init();
  zb_zdoCbRegister(&appCbLst);
  return;
}
void user_app_init(void)

{
  af_nodeDescManuCodeUpdate(0x1141);
  zcl_init(sampleGW_zclProcessIncomingMsg);
  af_endpointRegister('\x01', &sampleGW_simpleDesc, zcl_rx_handler, sampleGW_dataSendConfirm);
  zcl_register('\x01', SAMPLE_GW_CB_CLUSTER_NUM, g_sampleGwClusterList);
  gp_init('\x01');
  ota_init(OTA_TYPE_SERVER, &sampleGW_simpleDesc, &sampleGW_otaInfo, (ota_callBack_t *)0x0);
  return;
}
void led_init(void)

{
  led_off(4);
  light_init();
  return;
}
void user_init(u8 isRetention)

{
  u8 uVar1;

  uVar1 = firmwareCheckWithUID();
  if (uVar1 != '\0')
  {
    do
    {
      // WARNING: Do nothing block with infinite loop
    } while (true);
  }
  led_init();
  stack_init();
  sys_exceptHandlerRegister(sampleGwSysException);
  user_app_init();
  ev_on_poll(EV_POLL_IDLE, app_task);
  bdb_init(&sampleGW_simpleDesc, &g_bdbCommissionSetting, &g_zbDemoBdbCb, '\x01');
  return;
}
void zbdemo_bdbIdentifyCb(u8 endpoint, u16 srcAddr, u16 identifyTime)

{
  sampleGW_zclIdentifyCmdHandler(endpoint, srcAddr, identifyTime);
  return;
}
void zbdemo_bdbCommissioningCb(u8 status, void *arg)

{
  if (status != '\0')
  {
    if (status == '\x01')
    {
      return;
    }
    if (status == '\x02')
    {
      return;
    }
    if (status == '\x03')
    {
      return;
    }
    if (status == '\x04')
    {
      return;
    }
    if (status == '\x05')
    {
      return;
    }
    if (status == '\x06')
    {
      return;
    }
    if (status == '\a')
    {
      return;
    }
    if (status == '\b')
    {
      return;
    }
    if (status == '\t')
    {
      return;
    }
    if (status == '\n')
    {
      return;
    }
    if (status != '\r')
    {
      return;
    }
    tl_zbMacChannelSet('\x0f');
  }
  heartInterval = 1000;
  return;
}
void zbdemo_bdbInitCb(u8 status, u8 joinedNetwork)

{
  if (status == '\0')
  {
    if (joinedNetwork == '\0')
    {
      bdb_networkFormationStart();
      heartInterval = 500;
    }
    else
    {
      heartInterval = 1000;
    }
  }
  else
  {
    heartInterval = 200;
  }
  return;
}
void sampleGW_devAnnHandler(zdo_device_annce_req_t *pDevAnnceReq)

{
  return;
}
void sampleGW_leaveCnfHandler(nlme_leave_cnf_t *pLeaveCnf)

{
  return;
}
void sampleGW_leaveIndHandler(nlme_leave_ind_t *pLeaveInd)

{
  return;
}
void sampleGW_dataSendConfirm(void *arg)

{
  return;
}
u8 sampleGW_nwkUpdateIndicateHandler(nwkCmd_nwkUpdate_t *pNwkUpdateCmd)

{
  return '\0';
}
u8 sampleGW_tcJoinIndHandler(zdo_tc_join_ind_t *pTcJoinInd)

{
  return '\x01';
}
void sampleGW_tcFrameCntReachedHandler(void)

{
  ss_tcUpdateNwkKey_t updateNwkKey;

  updateNwkKey.dstAddr._0_4_ = 0;
  updateNwkKey.dstAddr._4_4_ = 0;
  drv_generateRandomData(updateNwkKey.key, '\x10');
  zb_tcUpdateNwkKey(&updateNwkKey);
  return;
}
s32 sampleGW_zclIdentifyTimerCb(void *arg)

{
  s32 sVar1;

  if (g_zcl_identifyAttrs.identifyTime == 0)
  {
    identifyTimerEvt = (ev_timer_event_t *)0x0;
    sVar1 = -2;
  }
  else
  {
    g_zcl_identifyAttrs.identifyTime = g_zcl_identifyAttrs.identifyTime - 1;
    sVar1 = 0;
  }
  return sVar1;
}
void sampleGW_zclProcessIncomingMsg(zclIncoming_t *pInHdlrMsg)

{
  return;
}
status_t sampleGW_basicCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}
void sampleGW_zclIdentifyTimerStop(void)

{
  if (identifyTimerEvt != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&identifyTimerEvt);
  }
  return;
}
void sampleGW_zclIdentifyCmdHandler(u8 endpoint, u16 srcAddr, u16 identifyTime)

{
  g_zcl_identifyAttrs.identifyTime._0_1_ = (u8)identifyTime;
  g_zcl_identifyAttrs.identifyTime._1_1_ = (undefined)((uint)identifyTime >> 8);
  if (identifyTime == 0)
  {
    sampleGW_zclIdentifyTimerStop();
    light_blink_stop();
  }
  else if (identifyTimerEvt == (ev_timer_event_t *)0x0)
  {
    light_blink_start((u8)g_zcl_identifyAttrs.identifyTime, 500, 500);
    identifyTimerEvt = ev_timer_taskPost(sampleGW_zclIdentifyTimerCb, (void *)0x0, 1000);
  }
  return;
}
status_t sampleGW_identifyCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  byte bVar1;
  u8 times;

  if ((pAddrInfo->dstEp == '\x01') && ((pAddrInfo->field_0x9 & 1) == 0))
  {
    if (cmdId == '\0')
    {
      // WARNING: Load size is inaccurate
      sampleGW_zclIdentifyCmdHandler('\x01', pAddrInfo->srcAddr, *cmdPayload);
    }
    else if (cmdId == '@')
    {
      // WARNING: Load size is inaccurate
      bVar1 = *cmdPayload;
      if (bVar1 == 2)
      {
        light_blink_start('\x02', 0xfa, 0xfa);
      }
      else
      {
        if (bVar1 < 3)
        {
          if (bVar1 == 0)
          {
            light_blink_start('\x01', 500, 500);
            return '\0';
          }
          if (bVar1 != 1)
          {
            return '\0';
          }
          times = '\x0f';
        }
        else
        {
          if (bVar1 != 0xfe)
          {
            if (0xfe < bVar1)
            {
              light_blink_stop();
              return '\0';
            }
            if (bVar1 != 0xb)
            {
              return '\0';
            }
            light_blink_start('\x01', 500, 0x1d4c);
            return '\0';
          }
          times = '\x01';
        }
        light_blink_start(times, 300, 700);
      }
    }
  }
  return '\0';
}
status_t sampleGW_groupCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}
status_t sampleGW_sceneCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}
status_t sampleGW_doorLockCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}
status_t sampleGW_iasZoneCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  if (((pAddrInfo->dstEp == '\x01') && ((pAddrInfo->field_0x9 & 1) != 0)) && (cmdId == '\0'))
  {
    light_blink_start('\x05', 0xfa, 0xfa);
  }
  return '\0';
}
status_t sampleGW_pollCtrlCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  status_t sVar1;
  uint local_20;
  undefined4 uStack_1c;
  uint uStack_18;
  undefined4 uStack_14;
  undefined2 local_10;
  uint local_c;

  sVar1 = '\0';
  if (((pAddrInfo->dstEp == '\x01') && ((pAddrInfo->field_0x9 & 1) != 0)) && (cmdId == '\0'))
  {
    uStack_1c = 0;
    local_10 = 0;
    local_20 = (uint)pAddrInfo->srcAddr;
    uStack_14 = CONCAT13(pAddrInfo->srcEp, 0x20000);
    uStack_18 = (uint)pAddrInfo->profileId;
    local_c = (local_c >> 8 & 0xff0000) << 8;
    zcl_pollCtrl_chkInRsp('\x01', (epInfo_t *)&local_20, '\x01', pAddrInfo->seqNum, (zcl_chkInRsp_t *)&local_c);
    sVar1 = 0xff;
  }
  return sVar1;
}
u8 firmwareCheckWithUID(void)

{
  return '\0';
}
void main(void)

{
  u8 isRetention;
  byte bVar1;
  int iVar2;

  iVar2 = drv_platform_init();
  bVar1 = (char)iVar2 - 1;
  isRetention = bVar1 + ~bVar1 + (iVar2 != 0);
  os_init(isRetention);
  user_init(isRetention);
  drv_enable_irq();
  do
  {
    ev_main();
    tl_zbTaskProcedure();
  } while (true);
}
u8 FUN_00011e70(void)

{
  u8 uVar1;
  int iVar2;
  zb_buf_t *buf;
  code *in_r3;
  tl_zb_task_t tStack_14;

  tStack_14.tlCb = (tl_zb_callback_t)(*in_r3)();
  uVar1 = tl_zbTaskQPush('\0', &tStack_14);
  if (uVar1 != '\0')
  {
    iVar2 = buf_type_get(buf);
    if (iVar2 == 0)
    {
      sys_exceptionPost(0xc1, '\x15');
      zb_buf_free(buf);
    }
    else if (iVar2 == 1)
    {
      sys_exceptionPost(0xc5, 's');
      ev_buf_free(buf->buf);
    }
    else
    {
      sys_exceptionPost(0xc9, '\x05');
    }
  }
  return uVar1;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNBBBBF(void)

{
  code *in_r3;

  g_zbMacCtx.curChannel = (*in_r3)();
  rf_setChannel(g_zbMacCtx.curChannel);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNBBBBG(void)

{
  code *in_r3;

  (*in_r3)();
  tl_zbMacMlmeDataRequestCb();
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void tl_zbPhyMlmeIndicate_sub(void)

{
  int iVar1;
  code *in_r3;
  undefined local_20;
  char cStack_1f;
  undefined auStack_1e[8];
  undefined auStack_16[8];
  undefined uStack_e;

  iVar1 = (*in_r3)();
  if (g_zbInfo.macPib.shortAddress < 0xfffe)
  {
    local_20 = 2;
    memcpy(auStack_1e, &g_zbInfo.macPib.shortAddress, 2);
    cStack_1f = *(char *)(iVar1 + 10);
  }
  else
  {
    local_20 = 3;
    memcpy(auStack_1e, g_zbInfo.macPib.extAddress, 8);
    cStack_1f = *(char *)(iVar1 + 10);
  }
  if (cStack_1f == '\x03')
  {
    memcpy(auStack_16, (void *)(iVar1 + 2), 8);
  }
  else
  {
    memcpy(auStack_16, (void *)(iVar1 + 2), 2);
  }
  uStack_e = 1;
  tl_zbMacMlmeDataRequestCmdSend(&local_20, iVar1, 0xe8);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
int FUNBBBBH(void)

{
  int iVar1;
  code *in_r3;

  (*in_r3)();
  iVar1 = 0;
  if ((uint)tx_fifo_wptr != (uint)tx_fifo_rptr)
  {
    iVar1 = g_pTxQueue + ((uint)tx_fifo_rptr & MAC_TX_QUEUE_SIZE - 1) * 0x10;
  }
  return iVar1;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
byte FUNBBBBJ(void)

{
  code *in_r3;

  (*in_r3)();
  return g_zbNwkCtx._45_1_ & 1;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 FUNBBBBK(void)

{
  u16 uVar1;
  addrMapping_t *paVar2;
  undefined2 uVar3;
  undefined2 *in_r0;
  undefined4 uVar4;
  u16 in_r1;

  uVar4 = 0xff;
  if ((g_nwkAddrMap.activeHead != (tl_zb_addr_map_entry_t *)0x0) &&
      ((int)((uint)(byte)(g_nwkAddrMap.activeHead)->field_0x13 << 0x1f) < 0))
  {
    uVar1 = (g_nwkAddrMap.activeHead)->shortAddr;
    paVar2 = g_nwkAddrMap.activeHead;
    while (uVar1 != in_r1)
    {
      paVar2 = paVar2->activeNext;
      if ((paVar2 == (addrMapping_t *)0x0) || ((paVar2->field_0x13 & 1) == 0))
      {
        return 0xff;
      }
      uVar1 = paVar2->shortAddr;
    }
    uVar3 = FUN_0000162c(paVar2 + -0x69e53, 0x14);
    *in_r0 = uVar3;
    uVar4 = 0;
  }
  return uVar4;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked
void FUNCCCCA(void)

{
  void *in;
  void *out;
  code *in_r3;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  uint uStack_28;
  uint uStack_24;
  uint uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined2 uStack_14;
  undefined2 auStack_10[4];

  in = (void *)(*in_r3)();
  uStack_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_1c = 0;
  uStack_18 = 0;
  uStack_14 = 0;
  auStack_10[0] = 0xb;
  out = (void *)(*(int *)((int)in + 0x10) + -2);
  uStack_20 = (uint)out >> 0x18;
  uStack_24 = (int)out * 0x100 | (uint)(byte)(*(char *)((int)in + 0x14) + 2);
  memcpy(out, auStack_10, 2);
  uStack_30 = CONCAT31(uStack_30._1_3_, 3);
  uStack_28 = uStack_28 & 0xffffff | (uint) * (byte *)((int)in + 0xb) << 0x18;
  if ((dstPanID == 0) || (deviceInfoRsp == '\0'))
  {
    uStack_30 = uStack_30 | 0xffff00;
    uStack_20._0_2_ = CONCAT11(*(undefined *)((int)in + 0xf), (undefined)uStack_20);
    uStack_20 = uStack_20 & 0xffff0000 | (uint)(ushort)uStack_20;
  }
  else
  {
    deviceInfoRsp = '\0';
    uStack_30 = uStack_30 & 0xff0000ff | (uint)dstPanID << 8;
    uStack_20._0_2_ = CONCAT11(*(undefined *)((int)in + 0xf), (undefined)uStack_20);
    uStack_20 = uStack_20 & 0xffff0000 | (uint)(ushort)uStack_20;
  }
  if (*(byte *)((int)in + 0xb) == 3)
  {
    uStack_20._0_3_ = CONCAT12(1, (ushort)uStack_20);
    uStack_20 = uStack_20 & 0xff000000 | (uint)(uint3)uStack_20;
    memcpy((void *)((int)&uStack_30 + 3), in, 8);
  }
  else
  {
    uStack_30 = CONCAT13(0xfe, (undefined3)uStack_30);
    uStack_2c = CONCAT31(uStack_2c._1_3_, 0xfe);
  }
  memcpy(in, &uStack_38, 0x26);
  tl_zbMacMcpsDataRequestProc(in);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void nwk_nlmeNwkFormationCn(void)

{
  undefined *in_r0;
  undefined in_r1;

  *in_r0 = in_r1;
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf;
  tl_zbTaskPost(zdo_network_formation_confirm, in_r0);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
bool tl_zbNwkJoinAccept_clone_0(void)

{
  zb_nwk_status_t zVar1;
  u16 uVar2;
  u16 *in_r0;
  int iVar3;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  uint in_r1;
  u16 *in_r2;
  uint uVar5;
  uint uVar6;
  byte bVar7;
  int in_r3;
  byte in_stack_00000000;
  nebTbl_t *in_stack_ffffffb4;
  u16 local_28;
  undefined2 local_26;

  local_26 = 0;
  local_28 = 0xfffd;
  bVar7 = in_r3 != 0 &
          ~in_stack_00000000 + in_stack_00000000 + ((undefined *)0xffffffd5 < &stack0xffffffb0);
  if ((bVar7 != 0) && (iVar3 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8), iVar3 == 0))
  {
    return true;
  }
  ptVar4 = tl_zbNeighborTableSearchFromExtAddr(&local_28, (addrExt_t)CONCAT44(in_stack_ffffffb4, in_r2), in_r0);
  if (ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    if (g_zbInfo.nwkNib.maxDepth < g_zbInfo.nwkNib.depth)
    {
      return true;
    }
    if ((in_r1 & 0x80) == 0)
    {
      uVar2 = *in_r2;
    }
    else
    {
      uVar2 = *in_r2;
      if (*in_r2 == 0xffff)
      {
        uVar2 = tl_zbNwkStochasticAddrCal();
      }
    }
    local_28 = uVar2;
    zVar1 = tl_zbNwkAddrMapAdd(local_28, (addrExt_t)CONCAT44(in_stack_ffffffb4, in_r2), in_r0);
    if (zVar1 != NWK_STATUS_SUCCESS)
    {
      return true;
    }
  }
  else if (bVar7 != 0)
  {
    if (((byte)ptVar4->field_0x1e & 1) != -((int)(in_r1 << 0x1c) >> 0x1f))
    {
      return true;
    }
    uVar5 = (byte)ptVar4->field_0x1e & 0xe;
    uVar6 = uVar5 - 2;
    if (uVar6 + ~uVar6 + (uint)(1 < uVar5) != -((int)(in_r1 << 0x1e) >> 0x1f))
    {
      return true;
    }
  }
  bVar7 = (byte)in_r1 & 2;
  bVar7 = (bVar7 + ~bVar7 + '\x01') * '\x02';
  if ((bVar7 & 0xe) == 4)
  {
    iVar3 = 5;
    if (in_stack_00000000 != 0)
    {
      iVar3 = 1;
    }
  }
  else
  {
    if ((bVar7 & 0xe) != 2)
      goto LAB_00018c76;
    iVar3 = 5;
    if (in_stack_00000000 != 0)
    {
      iVar3 = 2;
    }
  }
  bVar7 = (byte)(iVar3 << 4);
LAB_00018c76:
  if ((bVar7 & 0x70) == 0x50)
  {
    FUN_0000162c(NWK_UNAUTH_CHILD_TABLE_LIFE_TIME, 1000);
  }
  ptVar4 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)&stack0xffffffb4, '\x01');
  if (ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    *in_r2 = local_28;
  }
  return ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 FUNDDDDA(void)

{
  bool bVar1;
  int iVar2;
  uint extraout_r1;
  code *in_r3;
  undefined4 uVar3;

  iVar2 = (*in_r3)();
  uVar3 = 0xa3;
  if (((((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) && (uVar3 = 0xaa, (extraout_r1 & 0xff) == 4)) && (bVar1 = ss_securityModeIsDistributed(), bVar1 == false)) &&
      ((uVar3 = 0xad, iVar2 != 0 && (uVar3 = 0, *(char *)(iVar2 + 0x18) == '\0'))))
  {
    uVar3 = 0xad;
  }
  return uVar3;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 FUNEEEEA(void)

{
  byte bVar1;
  ushort uVar2;
  u8 uVar3;
  zb_buf_t *buf;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  int iVar5;
  int extraout_r1;
  byte *in;
  code *in_r2;
  uint extraout_r2;
  uint uVar6;
  int extraout_r3;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint in_stack_00000004;
  undefined4 in_stack_ffffffa4;
  undefined4 in_stack_ffffffa8;
  uint local_48;
  byte bStack_44;
  u16 auStack_43[4];
  byte bStack_3b;
  undefined auStack_38[8];
  uint uStack_30;
  undefined local_2c;
  ushort local_28[2];

  buf = (zb_buf_t *)(*in_r2)();
  uVar8 = extraout_r1 * 0x1000000 + 0xf2000000U >> 0x18;
  in = (byte *)(extraout_r3 + uVar8);
  *in = *in & 0xf8 | 5;
  memcpy(&local_48, in, 0xe);
  uVar7 = ((extraout_r2 & 0xff) - 0xf) - uVar8;
  uVar2 = *(ushort *)(buf->buf + 0x14);
  uVar6 = uVar7 & 0xff;
  if ((int)(uVar7 * 0x1000000) >> 0x18 < 4)
  {
  LAB_0001f7ee:
    g_sysDiags.nwkDecryptFailures = g_sysDiags.nwkDecryptFailures + 1;
    zb_buf_free(buf);
  }
  else
  {
    ptVar4 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT44(in_stack_ffffffa8, in_stack_ffffffa4));
    if (((ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0) || (ss_ib.activeKeySeqNum != bStack_3b)) || ((ptVar4->incomingFrameCnt <= ((uint)bStack_44 << 0x18 | local_48 >> 8) &&
                                                                                                        (ptVar4->incomingFrameCnt != 0xffffffff))))
    {
      iVar5 = ss_zdoGetNwkKeyBySeqNum();
      if ((iVar5 != 0) && (ss_ib.activeKeySeqNum <= bStack_3b))
      {
        memcpy(auStack_38, auStack_43, 8);
        uStack_30 = (uint)bStack_44 << 0x18 | local_48 >> 8;
        local_2c = (undefined)local_48;
        iVar9 = extraout_r3 + uVar8 + 0xe;
        iVar5 = ss_ccmDecryption();
        if (iVar5 == 0)
        {
          uVar3 = tl_zbShortAddrByExtAddr(local_28, (addrExt_t)CONCAT44(iVar9, uVar6), auStack_43);
          if (((uVar3 == '\0') && (uVar2 != local_28[0])) && (local_28[0] < 0xfff7))
          {
            T_DBG_decFrameCnt = T_DBG_decFrameCnt + '\x01';
            zb_buf_free(buf);
            return 1;
          }
          if ((((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) &&
               (0x80000000 < ((uint)bStack_44 << 0x18 | local_48 >> 8))) &&
              ((zdoAppIndCbLst != 0 &&
                ((*(int *)(zdoAppIndCbLst + 0x24) != 0 &&
                  (-1 < (int)((uint)zdo_mgmt_nwk_flag << 0x1e)))))))
          {
            tl_cryHashFunction();
          }
          if (ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0)
          {
            ptVar4->age = '\0';
            *(char *)&ptVar4->incomingFrameCnt = (char)(local_48 >> 8);
            *(char *)((int)&ptVar4->incomingFrameCnt + 1) = (char)(local_48 >> 0x10);
            *(char *)((int)&ptVar4->incomingFrameCnt + 2) = (char)(local_48 >> 0x18);
            *(byte *)((int)&ptVar4->incomingFrameCnt + 3) = bStack_44;
            ptVar4->lqi = (u8)((int)((uint)ptVar4->lqi + (in_stack_00000004 & 0xff)) >> 1);
            bVar1 = ptVar4->field_0x1e;
            if ((bVar1 & 0x70) == 0x50)
            {
              if ((bVar1 & 0xe) == 2)
              {
                ptVar4->field_0x1e = bVar1 & 0x8f | 0x20;
              }
              else if ((bVar1 & 0xe) == 4)
              {
                ptVar4->field_0x1e = bVar1 & 0x8f | 0x10;
                ss_zdoChildTableStore();
              }
            }
          }
          if (ss_ib.activeKeySeqNum == bStack_3b)
          {
            return 0;
          }
          if ((int)((uint)zdo_mgmt_nwk_flag << 0x1d) < 0)
          {
            return 0;
          }
          ss_zdoNwkKeySwitch();
          return 0;
        }
        goto LAB_0001f7ee;
      }
      uVar3 = '\x12';
    }
    else
    {
      g_sysDiags.nwkFCFailure = g_sysDiags.nwkFCFailure + 1;
      uVar3 = '\x11';
    }
    buf->buf[2] = uVar3;
    buf->buf[0] = (u8)uVar2;
    buf->buf[1] = (u8)(uVar2 >> 8);
    tl_zbTaskPost(zdo_nlme_status_indication, buf);
  }
  return 1;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 aps_bindingTblExis(void)

{
  void *in_r0;
  aps_binding_entry_t *paVar1;
  int iVar2;
  int iVar3;
  uint uVar4;

  paVar1 = bindTblEntryGet();
  uVar4 = (uint)APS_BINDING_TABLE_SIZE;
  if (uVar4 != 0)
  {
    iVar3 = 0;
    while (true)
    {
      if (((paVar1->used == '\x01') && (paVar1->dstAddrMode == '\x03')) &&
          (iVar2 = memcmp(&paVar1->field_3, in_r0, 8), iVar2 == 0))
      {
        return 1;
      }
      iVar3 = iVar3 + 1;
      if ((int)uVar4 <= iVar3)
        break;
      paVar1 = paVar1 + 1;
    }
  }
  return 0;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 FFFFFFF(void)

{
  u8 uVar1;
  void *out;
  undefined4 uVar2;
  int iVar3;
  code *in_r3;

  (*in_r3)();
  out = (void *)c1();
  uVar2 = 0x8a;
  if (out != (void *)0x0)
  {
    g_zdo_nwk_manager[37] = 5;
    tl_zbAdditionNeighborReset();
    uVar1 = af_nodeMacCapabilityGet();
    *(undefined *)((int)out + 0xc) = 2;
    *(undefined *)((int)out + 8) = g_zdo_nwk_manager[24];
    *(undefined *)((int)out + 9) = g_zdo_nwk_manager[25];
    *(undefined *)((int)out + 10) = g_zdo_nwk_manager[26];
    *(undefined *)((int)out + 0xb) = g_zdo_nwk_manager[27];
    *(undefined *)((int)out + 0xd) = g_zdo_nwk_manager[33];
    *(u8 *)((int)out + 0xe) = uVar1;
    iVar3 = memcmp(aps_ib.aps_use_ext_panid, &g_zero_addr, 8);
    if (iVar3 == 0)
    {
      memcpy(out, g_zbInfo.nwkNib.extPANId, 8);
    }
    else
    {
      memcpy(out, aps_ib.aps_use_ext_panid, 8);
    }
    *(byte *)((int)out + 0xf) = aps_ib._18_1_ & 1 ^ 1;
    tl_zbPrimitivePost('\x03', '}', out);
    uVar2 = 0;
  }
  return uVar2;
}
void FUN_00023b08(undefined4 param_1, zb_buf_t *param_2, int param_3, int param_4)

{
  char cVar1;
  char in_ZR;

  if (in_ZR != '\0')
  {
    cVar1 = *(char *)(param_4 + 0x23) + -1;
    *(char *)(param_4 + 0x23) = cVar1;
    if (cVar1 != '\0')
    {
      zdo_nlme_edScan(param_2);
      return;
    }
    *(undefined *)(param_4 + param_3) = 0;
    if ((zdo_mgmt_nwk_flag & 1) != 0)
    {
      zdo_mgmt_nwk_flag = zdo_mgmt_nwk_flag & 0xfe;
      tl_zbTaskPost(zdo_nwkUpdateNotifyRespSend, param_2);
      return;
    }
  }
  zb_buf_free(param_2);
  return;
}
void FUN_00024188(void)

{
  return;
}
void FUN_000241a0(void)

{
  undefined4 unaff_r4;
  char in_ZR;

  if (in_ZR == '\0')
  {
    zdo_nwkAuthTimeoutStart(unaff_r4);
    FUN_00024188();
    return;
  }
  if ((int)((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1e) < 0)
  {
    zdo_nlme_start_router_req(unaff_r4);
    FUN_00024188();
    return;
  }
  zdo_startDeviceCnf(unaff_r4, 0);
  FUN_00024188();
  return;
}
void FUN_00024274(void)

{
  return;
}
void FUN_00024288(void)

{
  byte bVar1;
  u16 uVar2;
  ev_timer_event_t *peVar3;
  ev_timer_event_t **unaff_r4;
  int unaff_r5;
  undefined unaff_r6;
  uint unaff_r7;

  *(char *)((int)unaff_r4 + unaff_r5) = (char)(unaff_r7 >> 0x18);
  bVar1 = zdo_af_get_scan_attempts();
  if (unaff_r7 >> 0x18 < (uint)bVar1)
  {
    uVar2 = zdo_af_get_nwk_time_btwn_scans();
    peVar3 = ev_timer_taskPost(zdo_nwkDiscReqTimerCb, (void *)0x0, (uint)uVar2);
    *unaff_r4 = peVar3;
    FUN_00024274();
    return;
  }
  peVar3 = unaff_r4[4];
  *(undefined *)((int)unaff_r4 + unaff_r5) = unaff_r6;
  if (peVar3 != (ev_timer_event_t *)0x0)
  {
    zdoMgmtLeaveCmdProcessCb();
    FUN_00024274();
    return;
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void zdo_cluster_list_match_process_clone_1(void)

{
  uint in_r0;
  uint uVar1;
  uint uVar2;
  int in_r1;
  uint in_r2;
  byte *in_r3;
  uint uVar3;
  uint uVar4;

  if (in_r0 != 0)
  {
    uVar4 = 0;
    do
    {
      while (true)
      {
        uVar1 = (uVar4 << 0x19) >> 0x18;
        if (in_r2 != 0)
          break;
      LAB_00024380:
        uVar4 = uVar4 + 1 & 0xff;
        if (in_r0 <= uVar4)
        {
          return;
        }
      }
      uVar1 = (uint) * (byte *)(in_r1 + uVar1) + (uint) * (byte *)(in_r1 + uVar1 + 1) * 0x100;
      if (((uint)in_r3[1] * 0x100 + (uint)*in_r3) * 0x10000 + uVar1 * -0x10000 != 0)
      {
        uVar3 = 0;
        uVar2 = 2;
        while (uVar3 = uVar3 + 1 & 0xff, uVar3 < in_r2)
        {
          if ((uVar1 & 0xffff) == ((uint)in_r3[uVar2] + (uint)in_r3[uVar2 + 1] * 0x100 & 0xffff))
            goto LAB_00024394;
          uVar2 = uVar2 + 2 & 0xff;
        }
        goto LAB_00024380;
      }
    LAB_00024394:
      *(short *)(ed_binding_ctx + (ed_binding_ctx[48] + 8) * 2) = (short)(uVar1 * 0x10000 >> 0x10);
      ed_binding_ctx[48] = ed_binding_ctx[48] + 1;
      uVar4 = uVar4 + 1 & 0xff;
    } while (uVar4 < in_r0);
  }
  return;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked
void _zdo_send_req(void)

{
  u16 clusterId;
  u8 **ppuVar1;
  ushort uVar2;
  uint uVar3;
  u8 *puVar4;
  code *in_r3;
  int iVar5;
  uint uStack_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined2 uStack_1c;
  u8 uStack_19;

  ppuVar1 = (u8 **)(*in_r3)();
  uStack_19 = '\0';
  clusterId = *(u16 *)(ppuVar1 + 4);
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  uStack_1c = 4;
  if (*(char *)((int)ppuVar1 + 0x13) == '\0')
  {
    uStack_20 = 0x20000;
    uStack_2c = (uint) * (ushort *)(ppuVar1 + 2);
  }
  else if (*(char *)((int)ppuVar1 + 0x13) == '\x01')
  {
    uStack_20 = 0x20000;
    memcpy((epInfo_t *)&uStack_2c, ppuVar1 + 2, 8);
  }
  if (clusterId == 0x13)
  {
    puVar4 = *ppuVar1;
    uVar2 = (ushort)puVar4[2] * 0x100 + (ushort)puVar4[1];
    if (g_zbInfo.nwkNib.nwkAddr != uVar2)
    {
      uStack_24 = uStack_24 & 0xffff | (uint)uVar2 << 0x10;
      uStack_20 = CONCAT22((short)((uint)uStack_20 >> 0x10), 1);
    }
  }
  else
  {
    puVar4 = *ppuVar1;
  }
  af_dataSend('\0', (epInfo_t *)&uStack_2c, clusterId, (ushort) * (byte *)((int)ppuVar1 + 0x12), puVar4,
              &uStack_19);
  puVar4 = ppuVar1[5];
  if (puVar4 != (u8 *)0x0)
  {
    uVar3 = (uint)zdpCblWptr;
    zdpCblWptr = zdpCblWptr + 1;
    iVar5 = (uVar3 & 3) * 8;
    *(ushort *)(zdp_cbl + iVar5 + 4) = (ushort) * (byte *)(ppuVar1 + 6);
    *(u8 **)(zdp_cbl + iVar5) = puVar4;
    zdp_cbl[iVar5 + 6] = 1;
    zdp_cbl[iVar5 + 7] = 1;
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void zdo_dAI_sub(void)

{
  void *arg;
  u32 uVar1;
  code *in_r3;

  arg = (void *)(*in_r3)();
  uVar1 = drv_u32Rand();
  ev_timer_taskPost(zdo_parentAnnounceIndicateDelay, arg, (uVar1 & 0x1f) * 0x32 + 1000);
  return;
}
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked
void zdo_bind_unbind_after_toggle_clone_0(void)

{
  int in_r0;
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uStack_34;
  undefined4 uStack_30;
  uint uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined local_20;

  if ((in_r0 != 0) || (ed_binding_ctx[48] != 1))
  {
    uStack_34 = 0;
    uStack_30 = 0;
    uStack_28 = 0;
    uStack_24 = 0;
    local_20 = 0;
    uVar1 = 0;
    uVar2 = 0;
    if (ed_binding_ctx[48] != 0)
    {
      if (ed_binding_ctx[7] < ed_binding_ctx[48])
      {
        uStack_2c = ed_binding_ctx._12_4_ >> 0x10 & 0xff;
        tl_zbExtAddrByShortAddr(ed_binding_ctx._12_2_, (addrExt_t)0x0, (u16 *)&uStack_34);
        tl_zbExtAddrByShortAddr(ed_binding_ctx._4_2_, (addrExt_t)CONCAT44(uVar2, uVar1), (u16 *)&uStack_28);
        local_20 = ed_binding_ctx[6];
      }
      else
      {
        uStack_2c = ed_binding_ctx._4_4_ >> 0x10 & 0xff;
        tl_zbExtAddrByShortAddr(ed_binding_ctx._4_2_, (addrExt_t)0x0, (u16 *)&uStack_34);
        tl_zbExtAddrByShortAddr(ed_binding_ctx._12_2_, (addrExt_t)CONCAT44(uVar2, uVar1), (u16 *)&uStack_28);
        local_20 = ed_binding_ctx[14];
      }
      ed_binding_ctx._48_2_ =
          ed_binding_ctx._48_2_ & 0xff00 | (ushort)(byte)(ed_binding_ctx[48] - 1);
      uStack_2c = CONCAT13(3, CONCAT12((char)((ushort) * (undefined2 *)(ed_binding_ctx +
                                                                        ((byte)(ed_binding_ctx[48] - 1) + 8) * 2) >>
                                              8),
                                       CONCAT11((char)*(undefined2 *)(ed_binding_ctx +
                                                                      ((byte)(ed_binding_ctx[48] - 1) + 8) *
                                                                          2),
                                                (undefined)uStack_2c)));
      zdo_bind_unbind_req();
      return;
    }
  }
  ed_binding_ctx._48_2_ = 0;
  ed_binding_ctx._44_4_ = 0;
  ed_binding_ctx._40_4_ = 0;
  ed_binding_ctx._36_4_ = 0;
  ed_binding_ctx._32_4_ = 0;
  ed_binding_ctx._28_4_ = 0;
  ed_binding_ctx._24_4_ = 0;
  ed_binding_ctx._20_4_ = 0;
  ed_binding_ctx._16_4_ = 0;
  ed_binding_ctx._12_4_ = 0;
  ed_binding_ctx._8_4_ = 0;
  ed_binding_ctx._4_4_ = 0;
  ed_binding_ctx._0_4_ = 0;
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
byte _cgp_mcpsDataIndFilter(void)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  byte bVar4;
  code *in_r3;

  pbVar3 = (byte *)(*in_r3)();
  bVar1 = *pbVar3;
  bVar4 = 1;
  if (((((bVar1 & 0x3c) == 0xc) && ((bVar1 & 3) < 2)) && (bVar4 = 0, (bVar1 & 0x80) != 0)) &&
      (bVar4 = 1, (bVar1 & 3) != 1))
  {
    bVar2 = pbVar3[1];
    if ((((bVar1 & 0x40) == 0) || ((bVar2 & 0x40) == 0)) &&
        ((bVar4 = bVar2 >> 7, (bVar2 & 7) != 2 && (bVar4 = 1, (bVar2 & 7) == 0))))
    {
      bVar4 = bVar2 >> 7;
    }
  }
  return bVar4;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void _gpTxQueueListClear(void)

{
  zb_buf_t **ppzVar1;
  code *in_r3;

  ppzVar1 = (zb_buf_t **)(*in_r3)();
  if (*ppzVar1 != (zb_buf_t *)0x0)
  {
    zb_buf_free(*ppzVar1);
  }
  *(undefined *)ppzVar1 = 0;
  *(undefined *)((int)ppzVar1 + 1) = 0;
  *(undefined *)((int)ppzVar1 + 2) = 0;
  *(undefined *)((int)ppzVar1 + 3) = 0;
  *(undefined *)(ppzVar1 + 1) = 0;
  *(undefined *)((int)ppzVar1 + 5) = 0;
  return;
}
void FUN_00027540(void)

{
  undefined *arg;
  u16 uVar1;
  undefined4 uVar2;
  void **unaff_r5;
  undefined *unaff_r6;
  byte *unaff_r8;
  void *unaff_r9;
  undefined unaff_fp;
  undefined4 param_5;
  byte param_9;
  int param_10;

  *unaff_r6 = 0;
  param_5 = 0;
  uVar2 = gp_gpdfCreat();
  arg = (undefined *)*unaff_r5;
  *arg = (char)uVar2;
  arg[1] = (char)((uint)uVar2 >> 8);
  arg[2] = (char)((uint)uVar2 >> 0x10);
  arg[3] = (char)((uint)uVar2 >> 0x18);
  arg[0x1a] = *unaff_r6;
  uVar1 = g_zbInfo.nwkNib.panId;
  arg[4] = (char)g_zbInfo.nwkNib.panId;
  arg[5] = (char)(uVar1 >> 8);
  arg[6] = 0xfe;
  arg[7] = 0xfe;
  arg[0x18] = 0;
  if ((*unaff_r8 & 7) == 0)
  {
    arg[0x19] = 2;
    arg[0x10] = 0xfe;
    arg[0x11] = 0xfe;
  }
  else if ((*unaff_r8 & 7) == 2)
  {
    arg[0x19] = 3;
    memcpy(arg + 0x10, unaff_r9, 8);
  }
  arg[0x1b] = unaff_fp;
  arg[0x1c] = arg[0x1c] & 0xfe | param_9;
  arg[0x1c] = arg[0x1c] & 0xfd | (byte)(param_10 << 1);
  *(undefined *)((int)*unaff_r5 + 0xc1) = unaff_fp;
  ev_timer_taskPost(cGp_dataReq, arg, 0x14);
  return;
}
void FUN_00027628(void)

{
  undefined *arg;
  u16 uVar1;
  undefined uVar2;
  undefined4 uVar3;
  void **unaff_r5;
  byte *unaff_r8;
  void *unaff_r9;
  undefined *unaff_sl;
  undefined unaff_fp;
  byte in_stack_00000010;
  int in_stack_00000014;
  undefined uStack00000023;

  uVar2 = gpNwkHdrFrameCtrlBuild();
  *unaff_sl = uVar2;
  uStack00000023 = 0;
  uVar3 = gp_gpdfCreat();
  arg = (undefined *)*unaff_r5;
  *arg = (char)uVar3;
  arg[1] = (char)((uint)uVar3 >> 8);
  arg[2] = (char)((uint)uVar3 >> 0x10);
  arg[3] = (char)((uint)uVar3 >> 0x18);
  arg[0x1a] = uStack00000023;
  uVar1 = g_zbInfo.nwkNib.panId;
  arg[4] = (char)g_zbInfo.nwkNib.panId;
  arg[5] = (char)(uVar1 >> 8);
  arg[6] = 0xfe;
  arg[7] = 0xfe;
  arg[0x18] = 0;
  if ((*unaff_r8 & 7) == 0)
  {
    arg[0x19] = 2;
    arg[0x10] = 0xfe;
    arg[0x11] = 0xfe;
  }
  else if ((*unaff_r8 & 7) == 2)
  {
    arg[0x19] = 3;
    memcpy(arg + 0x10, unaff_r9, 8);
  }
  arg[0x1b] = unaff_fp;
  arg[0x1c] = arg[0x1c] & 0xfe | in_stack_00000010;
  arg[0x1c] = arg[0x1c] & 0xfd | (byte)(in_stack_00000014 << 1);
  *(undefined *)((int)*unaff_r5 + 0xc1) = unaff_fp;
  ev_timer_taskPost(cGp_dataReq, arg, 0x14);
  return;
}
void FUN_00027678(void)

{
  return;
}
void FUN_00027bde(void)

{
  return;
}
void FUN_00027c10(void)

{
  zb_buf_t *unaff_r4;
  zb_buf_t *unaff_r7;

  zb_buf_free(unaff_r7);
  zb_buf_free(unaff_r4);
  FUN_00027bde();
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void _gpTxQueueCheck(void)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  zb_buf_t *pzVar4;
  zb_buf_t *buf;
  int iVar5;
  uint n;
  code *in_r3;
  uint uVar6;

  buf = (zb_buf_t *)(*in_r3)();
  pzVar4 = (zb_buf_t *)gpTxQueue;
  uVar6 = (uint)buf->buf[0x12];
  n = 4;
  if (uVar6 != 0)
  {
    n = ((uVar6 - 2) + ~(uVar6 - 2) + (uint)(1 < uVar6)) * 8;
  }
  if (gpTxQueue._5_1_ == '\0')
  {
    bVar1 = false;
    bVar3 = false;
  }
  else
  {
    if ((((zb_buf_t *)gpTxQueue)->buf[0x12] == uVar6) &&
        (iVar5 = memcmp(((zb_buf_t *)gpTxQueue)->buf + 8, buf->buf + 8, n), iVar5 == 0))
    {
      if (buf->buf[0x11] == '\0')
      {
        if (((uVar6 != 2) || (-1 < (int)((uint)buf->buf[0x10] << 0x1a))) ||
            (buf->buf[0x13] == pzVar4->buf[0x13]))
        {
          zb_buf_free(buf);
          gpTxQueueListClear();
          gpDataCnfDeliver();
          goto LAB_00027f3a;
        }
      }
      else
      {
        bVar1 = true;
        if (((uVar6 == 0) || (bVar1 = false, -1 < (int)((uint)buf->buf[0x10] << 0x1a))) ||
            (buf->buf[0x13] == pzVar4->buf[0x13]))
        {
          gpTxQueueListReplace();
          gpDataCnfDeliver();
          if (!bVar1)
          {
            bVar1 = true;
            bVar3 = true;
            goto LAB_00027e64;
          }
        LAB_00027f3a:
          bVar1 = true;
          bVar3 = true;
          bVar2 = true;
          goto LAB_00027e66;
        }
      }
    }
    bVar1 = false;
    bVar3 = true;
  }
LAB_00027e64:
  bVar2 = false;
LAB_00027e66:
  if ((!bVar1) && (!bVar2))
  {
    if (bVar3)
    {
      zb_buf_free(buf);
    }
    else if (buf->buf[0x11] == '\0')
    {
      zb_buf_free(buf);
    }
    else if (gpTxQueue._5_1_ == '\0')
    {
      gpTxQueue._5_1_ = '\x01';
      gpTxQueue._0_4_ = buf;
      gpTxQueue._4_1_ = buf->buf[0x16];
    }
    gpDataCnfDeliver();
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
int aes_encrypt(uchar *Key, uchar *Data, uchar *Result)

{
  int iVar1;
  uchar *puVar2;

  DAT_00800540 = DAT_00800540 & 0xfe;
  puVar2 = &DAT_00800550;
  do
  {
    *puVar2 = *Key;
    Key = Key + 1;
    puVar2 = puVar2 + 1;
  } while (puVar2 != (uchar *)0x800560);
  if ((int)((uint)DAT_00800540 << 0x1e) < 0)
  {
    do
    {
      _DAT_00800548 =
          (uint)Data[1] * 0x100 + (uint)Data[2] * 0x10000 + (uint)*Data + (uint)Data[3] * 0x1000000;
      Data = Data + 4;
    } while ((DAT_00800540 & 2) != 0);
  }
  do
  {
  } while ((DAT_00800540 & 4) == 0);
  puVar2 = Result + 0x10;
  do
  {
    iVar1 = _DAT_00800548;
    *Result = (uchar)_DAT_00800548;
    Result[1] = (uchar)((uint)iVar1 >> 8);
    Result[2] = (uchar)((uint)iVar1 >> 0x10);
    Result[3] = (uchar)((uint)iVar1 >> 0x18);
    Result = Result + 4;
  } while (puVar2 != Result);
  return 0;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
int aes_decrypt(uchar *Key, uchar *Data, uchar *Result)

{
  int iVar1;
  uchar *puVar2;

  DAT_00800540 = DAT_00800540 | 1;
  puVar2 = &DAT_00800550;
  do
  {
    *puVar2 = *Key;
    Key = Key + 1;
    puVar2 = puVar2 + 1;
  } while (puVar2 != (uchar *)0x800560);
  if ((int)((uint)DAT_00800540 << 0x1e) < 0)
  {
    do
    {
      _DAT_00800548 =
          (uint)Data[1] * 0x100 + (uint)Data[2] * 0x10000 + (uint)*Data + (uint)Data[3] * 0x1000000;
      Data = Data + 4;
    } while ((DAT_00800540 & 2) != 0);
  }
  do
  {
  } while ((DAT_00800540 & 4) == 0);
  puVar2 = Result + 0x10;
  do
  {
    iVar1 = _DAT_00800548;
    *Result = (uchar)_DAT_00800548;
    Result[1] = (uchar)((uint)iVar1 >> 8);
    Result[2] = (uchar)((uint)iVar1 >> 0x10);
    Result[3] = (uchar)((uint)iVar1 >> 0x18);
    Result = Result + 4;
  } while (puVar2 != Result);
  return 0;
}
int LoadTblCmdSet(TBLCMDSET *pt, int size)

{
  byte v;
  uint uVar1;
  byte bVar2;
  int iVar3;

  if (0 < size)
  {
    iVar3 = 0;
    do
    {
      while (true)
      {
        uVar1 = (uint) * (byte *)((int)&pt->adr + 1) * 0x100 | (uint) * (byte *)&pt->adr;
        v = *(byte *)&pt->dat;
        bVar2 = *(byte *)((int)&pt->dat + 1);
        if ((bVar2 & 0x40) == 0)
          break;
        bVar2 = bVar2 & 0x3f;
        if (bVar2 != 3)
        {
          if (bVar2 == 8)
          {
            analog_write(*(byte *)&pt->adr, v);
          }
          else if (bVar2 == 7)
          {
            sleep_us(uVar1 * 0x100 + (uint)v);
          }
          break;
        }
        *(byte *)((uVar1 | 0x800000) + 0x800000) = v;
        iVar3 = iVar3 + 1;
        pt = (TBLCMDSET *)&pt->cmd;
        if (size <= iVar3)
        {
          return size;
        }
      }
      iVar3 = iVar3 + 1;
      pt = (TBLCMDSET *)&pt->cmd;
    } while (iVar3 < size);
  }
  return size;
}
void clock_init(SYS_CLK_TypeDef SYS_CLK)

{
  if (SYS_CLK == 0x20)
  {
  LAB_00028cb4:
    system_clk_mHz = 0x30;
    goto joined_r0x00028ca6;
  }
  if (SYS_CLK < 0x21)
  {
    if (SYS_CLK != 1)
    {
      if (SYS_CLK != 0)
      {
        if (SYS_CLK != 2)
        {
          DAT_00800066 = SYS_CLK;
          system_clk_type = SYS_CLK;
          return;
        }
        goto LAB_00028cb4;
      }
    LAB_00028c9e:
      system_clk_mHz = 0x18;
      goto joined_r0x00028ca6;
    }
  }
  else
  {
    if (SYS_CLK == 0x43)
    {
      DAT_00800066 = SYS_CLK;
      system_clk_mHz = 0x10;
      system_clk_type = SYS_CLK;
      return;
    }
    if (SYS_CLK < SYS_CLK_12M_Crystal)
    {
      if (SYS_CLK != 0x42)
      {
        DAT_00800066 = SYS_CLK;
        system_clk_type = SYS_CLK;
        return;
      }
      goto LAB_00028c9e;
    }
    if (SYS_CLK == SYS_CLK_12M_Crystal)
    {
      DAT_00800066 = SYS_CLK;
      system_clk_mHz = 0xc;
      system_clk_type = SYS_CLK;
      return;
    }
    if (SYS_CLK != 0x60)
    {
      DAT_00800066 = SYS_CLK;
      system_clk_type = SYS_CLK;
      return;
    }
  }
  system_clk_mHz = 0x20;
joined_r0x00028ca6:
  DAT_00800066 = SYS_CLK;
  system_clk_type = SYS_CLK;
  if (SYS_CLK == 0x20)
  {
    analog_write('\f', 0xc6);
  }
  return;
}
void rc_24m_cal(void)

{
  byte bVar1;
  uchar v;

  analog_write(200, 0x80);
  bVar1 = analog_read('0');
  analog_write('0', bVar1 | 0x7f);
  analog_write(199, '\x0e');
  analog_write(199, '\x0f');
  do
  {
    bVar1 = analog_read(0xcf);
  } while (-1 < (int)((uint)bVar1 << 0x18));
  v = analog_read(0xcb);
  analog_write('3', v);
  bVar1 = analog_read('0');
  analog_write('0', bVar1 & 0x7f);
  analog_write(199, '\x0e');
  tl_24mrc_cal = analog_read('3');
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void doubler_calibration(void)

{
  byte bVar1;
  byte bVar2;

  analog_write(0x86, 0xbb);
  bVar1 = analog_read(0x82);
  analog_write(0x82, bVar1 & 0x7f);
  bVar1 = analog_read(0x87);
  analog_write(0x87, bVar1 & 0xfc | 2);
  bVar1 = analog_read(0x87);
  analog_write(0x87, bVar1 | 4);
  bVar1 = analog_read(0x88);
  bVar2 = analog_read(0x87);
  analog_write(0x87, (byte)((bVar1 & 0x1f) << 3) | bVar2 & 7);
  bVar1 = analog_read(0x82);
  analog_write(0x82, bVar1 | 0x7f);
  bVar1 = analog_read(0x87);
  analog_write(0x87, bVar1 & 0xfd);
  analog_write(0x86, 0xfb);
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 get_sp_normal(void)

{
  undefined4 in_r0;
  undefined local_8[8];

  pm_curr_stack = local_8;
  return in_r0;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void efuse_sys_check(void)

{
  uint in_r0;
  undefined1 *puVar1;
  uint uVar2;
  uint uVar3;

  pm_bit_info_1 = (byte)((in_r0 << 6) >> 0x1e);
  uVar2 = in_r0 >> 0x1d;
  pm_bit_info_0 = (byte)(in_r0 >> 0x1d);
  uVar3 = 0;
  if (((in_r0 & 0xc0) == 0xc0) && (uVar3 = 1, (in_r0 << 6) >> 0x1e < 2))
  {
    uVar3 = (in_r0 << 0x17) >> 0x1f;
  }
  if ((uVar3 | uVar2) == 0)
  {
    return;
  }
  get_sp_normal();
  if (uVar3 == 0)
  {
    if (uVar2 == 2)
    {
      if (pm_curr_stack < g_ssTcKeyPair + 1)
      {
        return;
      }
    }
    else
    {
      if (uVar2 != 4)
      {
        return;
      }
      if (pm_curr_stack < (undefined1 *)0x84c001)
      {
        return;
      }
    }
  }
  puVar1 = pm_curr_stack + 100;
  for (uVar2 = (uint)(pm_curr_stack + -100) & 0xffffff00; uVar2 < ((uint)puVar1 & 0xffffff00);
       uVar2 = uVar2 + 0x10)
  {
    *(undefined4 *)(uVar2 + 0x800000) = 0;
  }
  return;
}
void gpio_set_input_en(GPIO_PinTypeDef pin, uint value)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  ushort uVar4;

  bVar1 = (byte)pin;
  uVar4 = pin & 0xf00;
  if (((uVar4 == 0x300) || ((pin & 0xf00) == 0)) || (uVar4 == 0x400))
  {
    if (value == 0)
    {
      pbVar3 = (byte *)((uint)(pin >> 8) * 8 + 0x800581);
      *pbVar3 = *pbVar3 & ~bVar1;
    }
    else
    {
      pbVar3 = (byte *)((uint)(pin >> 8) * 8 + 0x800581);
      *pbVar3 = bVar1 | *pbVar3;
    }
  }
  else if (uVar4 == 0x100)
  {
    if (value == 0)
    {
      bVar2 = analog_read(0xbd);
      analog_write(0xbd, bVar2 & ~bVar1);
    }
    else
    {
      bVar2 = analog_read(0xbd);
      analog_write(0xbd, bVar1 | bVar2);
    }
  }
  else if (uVar4 == 0x200)
  {
    if (value == 0)
    {
      bVar2 = analog_read(0xc0);
      analog_write(0xc0, bVar2 & ~bVar1);
    }
    else
    {
      bVar2 = analog_read(0xc0);
      analog_write(0xc0, bVar1 | bVar2);
    }
  }
  return;
}
void gpio_set_func(GPIO_PinTypeDef pin, GPIO_FuncTypeDef func)

{
  uint uVar1;
  byte *pbVar2;
  byte bVar3;
  byte bVar4;

  uVar1 = (uint)pin;
  if (func == AS_GPIO)
  {
    pbVar2 = (byte *)(((uVar1 << 0x10) >> 0x18) * 8 + 0x800586);
    *pbVar2 = (byte)pin | *pbVar2;
    return;
  }
  if (uVar1 == 0x180)
  {
    if (func == 9)
    {
      bVar3 = 0x3f;
      bVar4 = 0;
    }
    else if (func == 5)
    {
      bVar3 = 0x3f;
      bVar4 = 0x40;
    }
    else if (func == 3)
    {
      bVar3 = 0x3f;
      bVar4 = 0x80;
    }
    else
    {
      bVar3 = 0x3f;
      bVar4 = 0;
    }
    goto LAB_00029044;
  }
  if (uVar1 < 0x181)
  {
    if (uVar1 == 0x80)
    {
      if (func == 2)
      {
        bVar3 = 0x3f;
        bVar4 = 0;
      }
      else if (func == 3)
      {
        bVar3 = 0x3f;
        bVar4 = 0x40;
      }
      else
      {
        bVar3 = 0x3f;
        bVar4 = 0;
      }
      goto LAB_00029044;
    }
    if (uVar1 < 0x81)
    {
      if (uVar1 == 8)
      {
        if ((byte)(func + 0xfc) < 2)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else if (func == 0x15)
        {
          bVar3 = 0x3f;
          bVar4 = 0x80;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 9)
      {
        if (uVar1 == 2)
        {
          if (func == 8)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 6)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 4)
        {
          if (func == 5)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 0x14)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 1)
        {
          if (func == 8)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 0x1a)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if ((uVar1 == 0x20) || (uVar1 == 0x40))
        {
          gpio_set_input_en(pin, 1);
          bVar3 = 0xff;
          bVar4 = 0;
          goto LAB_00029044;
        }
        if (uVar1 == 0x10)
        {
          if ((byte)(func + 0xfc) < 2)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0x16)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
    }
    else
    {
      if (uVar1 == 0x108)
      {
        if (func == 0x1a)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 0x109)
      {
        if (uVar1 == 0x102)
        {
          if (func == 0x18)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0xd)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x104)
        {
          if (func == 0x19)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x101)
        {
          if (func == 0x17)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0xd)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if (uVar1 == 0x120)
        {
          if (func == 9)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 0x19)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0xc)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x140)
        {
          if (func == 9)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if ((byte)(func + 0xfc) < 2)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x110)
        {
          if (func == 9)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 0x18)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0xc)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
    }
  }
  else
  {
    if (uVar1 == 0x280)
    {
      if (func == 0xd)
      {
        bVar3 = 0x3f;
        bVar4 = 0x40;
      }
      else if (func == 0x1f)
      {
        bVar3 = 0x3f;
        bVar4 = 0x80;
      }
      else
      {
        bVar3 = 0x3f;
        bVar4 = 0;
      }
      goto LAB_00029044;
    }
    if (uVar1 < 0x281)
    {
      if (uVar1 == 0x208)
      {
        if (func == 0x15)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else if (func == 4)
        {
          bVar3 = 0x3f;
          bVar4 = 0x80;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 0x209)
      {
        if (uVar1 == 0x202)
        {
          if (func == 4)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 0x1b)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0x14)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x204)
        {
          if (func == 0x14)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 4)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x201)
        {
          if (func == 4)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 0x1e)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if (uVar1 == 0x220)
        {
          if (func == 0x1d)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0xd)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x240)
        {
          if (func == 0xd)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 0x1e)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x210)
        {
          if (func == 0x16)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0x1a)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
    }
    else
    {
      if (uVar1 == 0x308)
      {
        if (func == 0x1b)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 6)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x80;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 0x309)
      {
        if (uVar1 == 0x302)
        {
          if (func == 0xc)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x304)
        {
          if (func == 5)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 6)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 0x17)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x301)
        {
          if (func == 0xc)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if (uVar1 == 800)
        {
          if (func == 0x14)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 0xc)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0x1a)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 < 0x321)
        {
          if (uVar1 == 0x310)
          {
            if (func == 2)
            {
              bVar3 = 0xfc;
              bVar4 = 0;
            }
            else if (func == 6)
            {
              bVar3 = 0xfc;
              bVar4 = 1;
            }
            else if (func == 0x1c)
            {
              bVar3 = 0xfc;
              bVar4 = 2;
            }
            else
            {
              bVar3 = 0xfc;
              bVar4 = 0;
            }
            goto LAB_00029044;
          }
        }
        else
        {
          if (uVar1 == 0x340)
          {
            if (func == 5)
            {
              bVar3 = 0xcf;
              bVar4 = 0;
            }
            else if (func == 3)
            {
              bVar3 = 0xcf;
              bVar4 = 0x10;
            }
            else if (func == 0xd)
            {
              bVar3 = 0xcf;
              bVar4 = 0x20;
            }
            else
            {
              bVar3 = 0xcf;
              bVar4 = 0;
            }
            goto LAB_00029044;
          }
          if (uVar1 == 0x380)
          {
            if ((byte)(func + 0xfc) < 2)
            {
              bVar3 = 0x3f;
              bVar4 = 0;
            }
            else if (func == 6)
            {
              bVar3 = 0x3f;
              bVar4 = 0x40;
            }
            else if (func == 3)
            {
              bVar3 = 0x3f;
              bVar4 = 0x80;
            }
            else
            {
              bVar3 = 0x3f;
              bVar4 = 0;
            }
            goto LAB_00029044;
          }
        }
      }
    }
  }
  bVar3 = 0xff;
  bVar4 = 0;
LAB_00029044:
  pbVar2 = (byte *)((uint)(pin >> 8) * 2 + (uint)((pin & 0xf0) != 0) + 0x8005a8);
  *pbVar2 = bVar3 & *pbVar2 | bVar4;
  pbVar2 = (byte *)((uint)(pin >> 8) * 8 + 0x800586);
  *pbVar2 = *pbVar2 & ~(byte)pin;
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined4 pm_get_info1(void)

{
  DAT_00800074 = 0;
  return _DAT_0080004c;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void cpu_wakeup_no_deepretn_back_init(void)

{
  ushort uVar1;

  rc_24m_cal();
  doubler_calibration();
  uVar1 = pm_get_info1();
  if ((uVar1 & 0xc0) == 0xc0)
  {
    adc_set_gpio_calib_vref((uVar1 & 0x3f) * 5 + 0x3f7);
  }
  efuse_sys_check();
  flash_vdd_f_calib();
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
void cpu_wakeup_init(void)

{
  byte bVar1;

  DAT_00800060 = 0;
  DAT_00800061 = 0;
  DAT_00800062 = 0;
  DAT_00800063 = 0xff;
  DAT_00800064 = 0xff;
  DAT_00800065 = 0xff;
  analog_write(0x82, 'd');
  analog_write('4', 0x80);
  analog_write('\v', '8');
  analog_write(0x8c, '\x02');
  analog_write('\x02', 0xa2);
  analog_write('\'', '\0');
  analog_write('(', '\0');
  analog_write(')', '\0');
  analog_write('*', '\0');
  _DAT_00800c40 = 0x4040404;
  _DAT_00800c44 = 0x4040404;
  DAT_00800c48 = 4;
  _DAT_00800750 = 8000;
  if (DAT_0080007d == '\x01')
  {
    analog_write('\x01', '<');
  }
  else
  {
    analog_write('\x01', 'L');
  }
  bVar1 = analog_read('\x7f');
  if ((bVar1 & 1) == 0)
  {
    pmParam._2_1_ = 1;
  LAB_00029686:
    pmParam._1_1_ = analog_read('D');
    pmParam._0_1_ = (pmParam._1_1_ & 10) == 8;
    if (pmParam._2_1_ == 1)
    {
      cpu_get_32k_tick();
      _DAT_00800740 = _adc_rng_result();
      DAT_0080074c = 0x90;
      DAT_0080074f = 1;
      goto LAB_000296da;
    }
  }
  else
  {
    bVar1 = analog_read('<');
    pmParam._2_1_ = bVar1 & 2;
    if ((bVar1 & 2) != 0)
    {
      pmParam._2_1_ = 2;
      bVar1 = analog_read('<');
      analog_write('<', bVar1 & 0xfd);
      if ((byte)(pmParam._2_1_ - 1) < 2)
        goto LAB_00029686;
    }
  }
  DAT_0080074f = 1;
  cpu_wakeup_no_deepretn_back_init();
LAB_000296da:
  DAT_00800c20 = 0;
  DAT_00800c21 = 0;
  DAT_008005b5 = DAT_008005b5 | 0xc;
  return;
}
// WARNING: Removing unreachable block (RAM,0x0002979e)
// WARNING: Removing unreachable block (RAM,0x000297bc)
// WARNING: Removing unreachable block (RAM,0x000297be)
// WARNING: Removing unreachable block (RAM,0x000297cc)
// WARNING: Removing unreachable block (RAM,0x000297de)
// WARNING: Removing unreachable block (RAM,0x000297e6)
// WARNING: Removing unreachable block (RAM,0x00029862)
// WARNING: Removing unreachable block (RAM,0x0002982e)
// WARNING: Removing unreachable block (RAM,0x00029836)
// WARNING: Removing unreachable block (RAM,0x00029846)
// WARNING: Removing unreachable block (RAM,0x000297c4)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
void _adc_rng_result(void)

{
  code *in_r3;

  (*in_r3)();
  do
  {
  } while (true);
}
// WARNING: Removing unreachable block (RAM,0x0002979e)
// WARNING: Removing unreachable block (RAM,0x000297bc)
// WARNING: Removing unreachable block (RAM,0x000297be)
// WARNING: Removing unreachable block (RAM,0x000297cc)
// WARNING: Removing unreachable block (RAM,0x000297de)
// WARNING: Removing unreachable block (RAM,0x000297e6)
// WARNING: Removing unreachable block (RAM,0x00029862)
// WARNING: Removing unreachable block (RAM,0x0002982e)
// WARNING: Removing unreachable block (RAM,0x00029836)
// WARNING: Removing unreachable block (RAM,0x00029846)
// WARNING: Removing unreachable block (RAM,0x000297c4)
// WARNING: Unknown calling convention -- yet parameter storage is locked
void adc_rng_result(void)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void trng_init(void)

{
  byte bVar1;

  analog_write(0xef, 0xf0);
  bVar1 = analog_read(0xf1);
  analog_write(0xf1, bVar1 & 0x3f);
  bVar1 = analog_read(0xf1);
  analog_write(0xf1, bVar1 & 0xf0 | 10);
  bVar1 = analog_read(0xf2);
  analog_write(0xf2, bVar1 & 0xf0 | 4);
  bVar1 = analog_read(0xf2);
  analog_write(0xf2, bVar1 & 0x8f | 0x20);
  adc_set_ref_voltage(ADC_MISC_CHN, ADC_VREF_1P2V);
  bVar1 = analog_read(0xf9);
  analog_write(0xf9, bVar1 & 0xf3);
  adc_set_ain_channel_differential_mode(ADC_MISC_CHN, VBAT, GND);
  adc_set_resolution(ADC_MISC_CHN, RES14);
  adc_set_tsample_cycle(ADC_MISC_CHN, SAMPLING_CYCLES_6);
  adc_set_ain_pre_scaler(ADC_PRESCALER_1F8);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xef);
  return;
}
void random_generator_init(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;

  rng = 0xffff;
  adc_init();
  trng_init();
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xdf);
  iVar2 = adc_rng_result();
  uVar3 = adc_rng_result();
  rnd_m_w = iVar2 << 0x10 | uVar3;
  iVar2 = adc_rng_result();
  uVar3 = adc_rng_result();
  rnd_m_z = iVar2 << 0x10 | uVar3;
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xdf | 0x20);
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked
uint rand(void)

{
  rnd_m_w = (rnd_m_w & 0xffff) * 18000 + (rnd_m_w >> 0x10);
  rnd_m_z = (rnd_m_z & 0xffff) * 0x9069 + (rnd_m_z >> 0x10);
  return rnd_m_z * 0x10000 + rnd_m_w ^ _DAT_00800740;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void rf_drv_init(void)

{
  undefined2 in_r0;

  LoadTblCmdSet((TBLCMDSET *)tbl_rf_init, 5);
  LoadTblCmdSet((TBLCMDSET *)tbl_rf_zigbee_250k, 0x1c);
  DAT_00800c20 = DAT_00800c20 | 0xc;
  g_RFMode = in_r0;
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void rf_set_channel(void)

{
  char in_r0;
  int iVar1;
  uint uVar2;
  int in_r1;
  byte bVar3;

  iVar1 = (int)in_r0;
  if (in_r1 << 0x10 < 0)
  {
    iVar1 = (int)(char)rf_chn_table[iVar1];
  }
  uVar2 = iVar1 + 0x960U & 0xffff;
  bVar3 = 0;
  if ((((uVar2 < 0x9f6) && (bVar3 = 4, uVar2 < 0x9d8)) && (bVar3 = 8, uVar2 < 0x9bf)) &&
      (bVar3 = 0xc, uVar2 < 0x9a1))
  {
    bVar3 = 0x10;
    if (((uVar2 < 0x983) && (bVar3 = 0x14, uVar2 < 0x965)) && (bVar3 = 0x1c, 0x94b < uVar2))
    {
      bVar3 = 0x18;
    }
  }
  DAT_00801244 = (byte)((uVar2 << 0x11) >> 0xf) | 1;
  DAT_00801245 = (byte)((uVar2 << 0x11) >> 0x17) & 0x3f | DAT_00801245 & 0xc0;
  DAT_00801229 = bVar3 | DAT_00801229 & 0xc3;
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void rf_set_power_level(void)

{
  uint in_r0;

  if ((int)(in_r0 * 0x1000000) < 0)
  {
    DAT_00801225 = DAT_00801225 | 0x40;
  }
  else
  {
    DAT_00801225 = DAT_00801225 & 0xbf;
  }
  DAT_00801226 = DAT_00801226 & 0x7f | (byte)(((in_r0 & 0x3f) << 0x18) >> 0x11);
  DAT_00801227 = DAT_00801227 & 0xe0 | (byte)(in_r0 & 0x3f) >> 1;
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void rf_set_power_level_index(void)

{
  byte in_r0;

  if (in_r0 < 0x3c)
  {
    rf_set_power_level();
  }
  return;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
undefined rf_trx_state_get(void)

{
  return RF_TRxState;
}
// WARNING: Unknown calling convention -- yet parameter storage is locked
void rf_rx_cf(void)

{
  int in_r0;
  char in_r1;

  DAT_00800c0b = 1;
  if (in_r1 != '\0')
  {
    DAT_00800c0b = 3;
  }
  DAT_00800c0a = (char)((uint)(in_r0 << 0x14) >> 0x18);
  g_RFRxPingpongEn = in_r1;
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void timer_start(TIMER_TypeDef type)

{
  if (type == TIMER1)
  {
    _DAT_00800620 = _DAT_00800620 | 8;
  }
  else if (type == TIMER0)
  {
    _DAT_00800620 = _DAT_00800620 | 1;
  }
  else if (type == TIMER2)
  {
    _DAT_00800620 = _DAT_00800620 | 0x40;
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void timer_stop(TIMER_TypeDef type)

{
  if (type == TIMER1)
  {
    _DAT_00800620 = _DAT_00800620 & 0xfffffff7;
  }
  else if (type == TIMER0)
  {
    _DAT_00800620 = _DAT_00800620 & 0xfffffffe;
  }
  else if (type == TIMER2)
  {
    _DAT_00800620 = _DAT_00800620 & 0xffffffbf;
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
void timer_set_mode(TIMER_TypeDef type, TIMER_ModeTypeDef mode)

{
  uint uVar1;

  uVar1 = (uint)mode;
  if (type == TIMER1)
  {
    _DAT_00800620 = CONCAT13(2, _DAT_00800620);
    _DAT_00800620 = uVar1 << 4 | _DAT_00800620 & 0xffffffcf;
  }
  else if (type == TIMER0)
  {
    _DAT_00800620 = CONCAT13(1, _DAT_00800620);
    _DAT_00800620 = uVar1 << 1 | _DAT_00800620 & 0xfffffff9;
  }
  else if (type == TIMER2)
  {
    _DAT_00800620 = CONCAT13(4, _DAT_00800620);
    _DAT_00800620 = uVar1 << 7 | _DAT_00800620 & 0xfffffe7f;
  }
  return;
}
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
u8 uart_dma_send(u8 *pBuf)

{
  bool bVar1;

  bVar1 = (int)((uint)DAT_0080009e << 0x1f) < 0;
  if (bVar1)
  {
    _DAT_00800c04 = SUB42(pBuf, 0);
    DAT_00800c06 = 0xff;
    DAT_00800c24 = DAT_00800c24 | 2;
  }
  return bVar1;
}
