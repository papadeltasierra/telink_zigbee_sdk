typedef unsigned char undefined;

typedef unsigned char bool;
typedef unsigned char byte;
typedef unsigned int dword;
typedef long long longlong;
typedef int sdword;
typedef short sword;
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef unsigned long long ulonglong;
typedef unsigned char undefined1;
typedef unsigned short undefined2;
typedef unsigned int undefined3;
typedef unsigned int undefined4;
typedef unsigned long long undefined6;
typedef unsigned long long undefined8;
typedef unsigned short ushort;
typedef unsigned short word;
typedef uchar u8;

typedef u8 addrExt_t[8];

typedef struct ss_apsmeSwitchKeyReq_t ss_apsmeSwitchKeyReq_t, *Pss_apsmeSwitchKeyReq_t;

struct ss_apsmeSwitchKeyReq_t
{
  addrExt_t dstAddr;
  u8 keySeqNum;
};

typedef struct nwkCmd_t nwkCmd_t, *PnwkCmd_t;

typedef enum nwk_cmdId_t
{
  NWK_CMD_ROUTE_REQUEST = 1,
  NWK_CMD_ROUTE_REPLY = 2,
  NWK_CMD_NETWORK_STATUS = 3
} nwk_cmdId_t;

typedef union nwkCmd_u nwkCmd_u, *PnwkCmd_u;

typedef struct nwkCmd_routeReq_t nwkCmd_routeReq_t, *PnwkCmd_routeReq_t;

typedef addrExt_t extAddr_t;

typedef struct rreq_opt_t rreq_opt_t, *Prreq_opt_t;

typedef word u16;

struct rreq_opt_t
{
  u8 reservedL : 3;
  u8 manyToOne : 2;
  u8 dstIeeeAddr : 1;
  u8 multicast : 1;
  u8 reservedH : 1;
};

struct nwkCmd_routeReq_t
{
  extAddr_t dstIeeeAddr;
  struct rreq_opt_t options;
  u8 routeReqId;
  u16 dstAddr;
  u8 pathCost;
};

union nwkCmd_u
{
  struct nwkCmd_routeReq_t rreq;
};

struct nwkCmd_t
{
  enum nwk_cmdId_t cmdId;
  u8 reserved[3];
  union nwkCmd_u field2_0x4;
};

typedef void *tl_zb_callback_t;

typedef struct TBLCMDSET TBLCMDSET, *PTBLCMDSET;

struct TBLCMDSET
{
  ushort adr;
  ushort dat;
  ushort cmd;
};

typedef struct bdb_commissioningMode_t bdb_commissioningMode_t, *Pbdb_commissioningMode_t;

struct bdb_commissioningMode_t
{
  u8 touchlink : 1;
  u8 networkSteer : 1;
  u8 networkFormation : 1;
  u8 findOrBind : 1;
  u8 reserved : 4;
};

typedef enum ss_securityMode_e
{
  SS_SEMODE_CENTRALIZED = 0
} ss_securityMode_e;

typedef enum bdb_nodeCommissioningCap_e
{
  BDB_NODE_COMMISSION_CAP_STEER = 1,
  BDB_NODE_COMMISSION_CAP_FORMATION = 2,
  BDB_NODE_COMMISSION_CAP_FINDORBIND = 4,
  BDB_NODE_COMMISSION_CAP_TOUCHLINK = 8
} bdb_nodeCommissioningCap_e;

typedef struct bdb_attr_t bdb_attr_t, *Pbdb_attr_t;

typedef dword u32;

struct bdb_attr_t
{
  u32 primaryChannelSet;
  u32 secondaryChannelSet;
  u16 commissioningGroupId;
  struct bdb_commissioningMode_t commissioningMode;
  u8 commissioningStatus;
  addrExt_t joiningNodeEui64;
  u8 joiningNodeNewTCLinkKey[16];
  enum bdb_nodeCommissioningCap_e nodeCommissioningCapability;
  u8 joinUsesInstallCodeKey;
  u8 nodeIsOnANetwork;
  u8 nodeJoinLinkKeyType;
  u8 tcRequireKeyExchange;
  u8 scanDuration;
  u8 tcLinkKeyExchangeAttempts;
  u8 tcLinkKeyExchangeAttemptsMax;
  u8 tcLinkKeyExchangeMethod;
  u8 tcNodeJoinTimeout;
  u8 resv[2];
};

typedef struct nwkFrameCtrl_t nwkFrameCtrl_t, *PnwkFrameCtrl_t;

struct nwkFrameCtrl_t
{
  u8 frameType : 2;
  u8 protocolVer : 4;
  u8 discRoute : 2;
  u8 multicastFlg : 1;
  u8 security : 1;
  u8 srcRoute : 1;
  u8 dstIEEEAddr : 1;
  u8 srcIEEEAddr : 1;
  u8 endDevInitiator : 1;
  u8 reserved : 2;
};

typedef struct nwk_hdr_t nwk_hdr_t, *Pnwk_hdr_t;

typedef struct nwkMcastCtrl_t nwkMcastCtrl_t, *PnwkMcastCtrl_t;

typedef struct srcRouteSubframe_t srcRouteSubframe_t, *PsrcRouteSubframe_t;

struct nwkMcastCtrl_t
{
  u8 multicaseMode : 2;
  u8 nonmemberRadius : 3;
  u8 manNonmemberRadius : 3;
};

struct srcRouteSubframe_t
{
  u8 relayCnt;
  u8 relayIdx;
  u8 *relayList;
};

struct nwk_hdr_t
{
  u16 dstAddr;
  u16 srcAddr;
  struct nwkFrameCtrl_t framecontrol;
  u8 radius;
  u8 seqNum;
  extAddr_t dstIeeeAddr;
  extAddr_t srcIeeeAddr;
  struct nwkMcastCtrl_t mcaseControl;
  u8 frameHdrLen;
  struct srcRouteSubframe_t srcRouteSubFrame;
};

typedef enum SYS_CLK_TypeDef
{
  SYS_CLK_12M_Crystal = 68
} SYS_CLK_TypeDef;

typedef struct tl_zb_task_t tl_zb_task_t, *Ptl_zb_task_t;

struct tl_zb_task_t
{
  tl_zb_callback_t tlCb;
  void *data;
};

typedef enum RF_StatusTypeDef
{
  RF_MODE_TX = 0,
  RF_MODE_RX = 1,
  RF_MODE_AUTO = 2,
  RF_MODE_OFF = 3
} RF_StatusTypeDef;

typedef enum zb_nwk_status_t
{
  NWK_STATUS_SUCCESS = 0
} zb_nwk_status_t;

typedef enum TIMER_ModeTypeDef
{
  TIMER_MODE_SYSCLK = 0
} TIMER_ModeTypeDef;

typedef enum nwk_statusCode_t
{
  NWK_COMMAND_STATUS_NO_ROUTE_AVAILABLE = 0
} nwk_statusCode_t;

typedef void (*nwkDiscoveryUserCb_t)(void);

typedef enum GPIO_FuncTypeDef
{
  AS_GPIO = 0
} GPIO_FuncTypeDef;

typedef ulong size_t;

typedef sdword s32;

typedef char s8;

typedef sword s16;

typedef enum drv_gpioPoll_e
{
  RISING_EDGE = 0,
  FALLING_EDGE = 1,
  HIGH_LEVEL = 2,
  LOW_LEVEL = 3
} drv_gpioPoll_e;

typedef enum drv_gpioIrqMode_t
{
  GPIO_IRQ_INVALID = 0,
  GPIO_IRQ_MODE = 1,
  GPIO_IRQ_RISC0_MODE = 2,
  GPIO_IRQ_RISC1_MODE = 3
} drv_gpioIrqMode_t;

typedef void (*irq_callback)(void);

typedef enum GPIO_PolTypeDef
{
  POL_RISING = 0,
  pol_rising = 0,
  POL_FALLING = 1,
  pol_falling = 1
} GPIO_PolTypeDef;

typedef enum anon_enum_16.conflict3b{
    GPIO_GROUPA = 0,
    ND_SERVER_MASK_NO_SERVER = 0,
    FLD_RF_IRQ_RX = 1,
    GPIO_PA0 = 1,
    ND_SERVER_MASK_PRIMARY_TRUST_CENTER = 1,
    RF_MODE_BLE_2M = 1,
    FLD_RF_IRQ_TX = 2,
    GPIO_PA1 = 2,
    ND_SERVER_MASK_BACKUP_TRUST_CENTER = 2,
    RF_MODE_BLE_1M = 2,
    FLD_RF_IRQ_RX_TIMEOUT = 4,
    GPIO_PA2 = 4,
    ND_SERVER_MASK_PRIMARY_BINDING_TABLE_CACHE = 4,
    RF_MODE_BLE_1M_NO_PN = 4,
    GPIO_PA3 = 8,
    ND_SERVER_MASK_BACKUP_BINDING_TABLE_CACHE = 8,
    RF_MODE_ZIGBEE_250K = 8,
    FLD_RF_IRQ_RX_CRC_2 = 16,
    GPIO_PA4 = 16,
    ND_SERVER_MASK_PRIMARY_DISCOVERY_CACHE = 16,
    RF_MODE_LR_S2_500K = 16,
    FLD_RF_IRQ_CMD_DONE = 32,
    GPIO_DM = 32,
    GPIO_PA5 = 32,
    ND_SERVER_MASK_BACKUP_DISCOVERY_CACHE = 32,
    RF_MODE_LR_S8_125K = 32,
    FLD_RF_IRQ_FSM_TIMEOUT = 64,
    GPIO_DP = 64,
    GPIO_PA6 = 64,
    ND_SERVER_MASK_NETWORK_MANAGER = 64,
    RF_MODE_PRIVATE_250K = 64,
    FLD_RF_IRQ_RETRY_HIT = 128,
    GPIO_PA7 = 128,
    GPIO_SWS = 128,
    RF_MODE_PRIVATE_500K = 128,
    GPIOA_ALL = 255,
    FLD_RF_IRQ_TX_DS = 256,
    GPIO_GROUPB = 256,
    RF_MODE_PRIVATE_1M = 256,
    GPIO_PB0 = 257,
    GPIO_PB1 = 258,
    GPIO_PB2 = 260,
    GPIO_PB3 = 264,
    GPIO_PB4 = 272,
    GPIO_PB5 = 288,
    GPIO_PB6 = 320,
    GPIO_PB7 = 384,
    FLD_RF_IRQ_RX_DR = 512,
    GPIO_GROUPC = 512,
    RF_MODE_PRIVATE_2M = 512,
    GPIO_PC0 = 513,
    GPIO_PC1 = 514,
    GPIO_PC2 = 516,
    GPIO_PC3 = 520,
    GPIO_PC4 = 528,
    GPIO_PC5 = 544,
    GPIO_PC6 = 576,
    GPIO_PC7 = 640,
    GPIO_GROUPD = 768,
    GPIO_PD0 = 769,
    GPIO_PD1 = 770,
    GPIO_PD2 = 772,
    GPIO_PD3 = 776,
    GPIO_PD4 = 784,
    GPIO_PD5 = 800,
    GPIO_PD6 = 832,
    GPIO_PD7 = 896,
    FLD_RF_IRQ_FIRST_TIMEOUT = 1024,
    GPIO_GROUPE = 1024,
    RF_MODE_ANT = 1024,
    GPIO_MSDO = 1025,
    GPIO_PE0 = 1025,
    GPIO_MCLK = 1026,
    GPIO_PE1 = 1026,
    GPIO_MSCN = 1028,
    GPIO_PE2 = 1028,
    GPIO_MSDI = 1032,
    GPIO_PE3 = 1032,
    GPIO_ALL = 1280,
    FLD_RF_IRQ_INVALID_PID = 2048,
    RF_MODE_BLE_2M_NO_PN = 2048,
    FLD_RF_IRQ_STX_TIMEOUT = 4096,
    FLD_RF_IRQ_ALL = 8191,
    ND_SERVER_MASK_REV20 = 10240,
    ND_SERVER_MASK_REV21 = 10752,
    ND_SERVER_MASK_REV22 = 11264,
    NWK_BROADCAST_LOW_POWER_ROUTER = 65531,
    NWK_BROADCAST_ROUTER_COORDINATOR = 65532,
    NWK_BROADCAST_RX_ON_WHEN_IDLE = 65533,
    NWK_BROADCAST_RESERVED = 65534,
    NWK_BROADCAST_ALL_DEVICES = 65535} anon_enum_16.conflict3b;

typedef enum GPIO_PinTypeDef
{
  GPIO_GROUPA = 0,
  GPIO_PA0 = 1,
  GPIO_PA1 = 2,
  GPIO_PA2 = 4,
  GPIO_PA3 = 8,
  GPIO_PA4 = 16,
  GPIO_DM = 32,
  GPIO_PA5 = 32,
  GPIO_DP = 64,
  GPIO_PA6 = 64,
  GPIO_PA7 = 128,
  GPIO_SWS = 128,
  GPIOA_ALL = 255,
  GPIO_GROUPB = 256,
  GPIO_PB0 = 257,
  GPIO_PB1 = 258,
  GPIO_PB2 = 260,
  GPIO_PB3 = 264,
  GPIO_PB4 = 272,
  GPIO_PB5 = 288,
  GPIO_PB6 = 320,
  GPIO_PB7 = 384,
  GPIO_GROUPC = 512,
  GPIO_PC0 = 513,
  GPIO_PC1 = 514,
  GPIO_PC2 = 516,
  GPIO_PC3 = 520,
  GPIO_PC4 = 528,
  GPIO_PC5 = 544,
  GPIO_PC6 = 576,
  GPIO_PC7 = 640,
  GPIO_GROUPD = 768,
  GPIO_PD0 = 769,
  GPIO_PD1 = 770,
  GPIO_PD2 = 772,
  GPIO_PD3 = 776,
  GPIO_PD4 = 784,
  GPIO_PD5 = 800,
  GPIO_PD6 = 832,
  GPIO_PD7 = 896,
  GPIO_GROUPE = 1024,
  GPIO_MSDO = 1025,
  GPIO_PE0 = 1025,
  GPIO_MCLK = 1026,
  GPIO_PE1 = 1026,
  GPIO_MSCN = 1028,
  GPIO_PE2 = 1028,
  GPIO_MSDI = 1032,
  GPIO_PE3 = 1032,
  GPIO_ALL = 1280
} GPIO_PinTypeDef;

typedef struct zdp_funcList_t zdp_funcList_t, *Pzdp_funcList_t;

typedef enum zdp_clusterId_e
{
  NWK_ADDR_REQ_CLID = 0,
  IEEE_ADDR_REQ_CLID = 1,
  NODE_DESC_REQ_CLID = 2,
  POWER_DESC_REQ_CLID = 3,
  SIMPLE_DESC_REQ_CLID = 4,
  ACTIVE_EP_REQ_CLID = 5,
  MATCH_DESC_REQ_CLID = 6,
  COMPLEX_DESC_REQ_CLID = 16,
  USER_DESC_REQ_CLID = 17,
  DISCOVERY_CACHE_REQ_CLID = 18,
  DEVICE_ANNCE_CLID = 19,
  USER_DESC_SET_CLID = 20,
  SYSTEM_SERVER_DISCOVERY_REQ_CLID = 21,
  DISCOVERY_STORE_REQ_CLID = 22,
  NODE_DESC_STORE_REQ_CLID = 23,
  POWER_DESC_STORE_REQ_CLID = 24,
  ACTIVE_EP_STORE_REQ_CLID = 25,
  SIMPLE_DESC_STORE_REQ_CLID = 26,
  REMOVE_NODE_CACHE_REQ_CLID = 27,
  FIND_NODE_CACHE_REQ_CLID = 28,
  EXTENDED_SIMPLE_DESC_REQ_CLID = 29,
  EXTENDED_ACTIVE_EP_REQ_CLID = 30,
  PARENT_ANNCE_CLID = 31,
  END_DEVICE_BIND_REQ_CLID = 32,
  BIND_REQ_CLID = 33,
  UNBIND_REQ_CLID = 34,
  BIND_REGISTER_REQ_CLID = 35,
  REPLACE_DEVICE_REQ_CLID = 36,
  STORE_BCKUP_BIND_ENTRY_REQ_CLID = 37,
  REMOVE_BCKUP_BIND_ENTRY_REQ_CLID = 38,
  BACKUP_BIND_TABLE_REQ_CLID = 39,
  RECOVER_BIND_TABLE_REQ_CLID = 40,
  BACKUP_SOURCE_BIND_REQ_CLID = 41,
  RECOVER_SOURCE_BIND_REQ_CLID = 42,
  CLEAR_ALL_BINDINGS_REQ_CLID = 43,
  MGMT_NWK_DISC_REQ_CLID = 48,
  MGMT_LQI_REQ_CLID = 49,
  MGMT_RTG_REQ_CLID = 50,
  MGMT_BIND_REQ_CLID = 51,
  MGMT_LEAVE_REQ_CLID = 52,
  MGMT_DIRECT_JOIN_REQ_CLID = 53,
  MGMT_PERMIT_JOINING_REQ_CLID = 54,
  MGMT_CACHE_REQ_CLID = 55,
  MGMT_NWK_UPDATE_REQ_CLID = 56,
  MGMT_NWK_ENHANCED_UPDATE_REQ_CLID = 57,
  MGMT_NWK_IEEE_JOINING_LIST_REQ_CLID = 58,
  MGMT_NWK_BEACON_SURVEY_REQ_CLID = 60,
  SEC_START_KEY_NEGOTIATION_REQ_CLID = 64,
  SEC_GET_AUTH_TOKEN_REQ_CLID = 65,
  SEC_GET_AUTH_LEVEL_REQ_CLID = 66,
  SEC_SET_CFG_REQ_CLID = 67,
  SEC_GET_CFG_REQ_CLID = 68,
  SEC_START_KEY_UPDATE_REQ_CLID = 69,
  SEC_DECOMMISSION_REQ_CLID = 70,
  SEC_CHALLENGE_REQ_CLID = 71,
  NWK_ADDR_RSP_CLID = 32768,
  IEEE_ADDR_RSP_CLID = 32769,
  NODE_DESC_RSP_CLID = 32770,
  POWER_DESC_RSP_CLID = 32771,
  SIMPLE_DESC_RSP_CLID = 32772,
  ACTIVE_EP_RSP_CLID = 32773,
  MATCH_DESC_RSP_CLID = 32774,
  COMPLEX_DESC_RSP_CLID = 32784,
  USER_DESC_RSP_CLID = 32785,
  DISCOVERY_CACHE_RSP_CLID = 32786,
  USER_DESC_CONF_RSP_CLID = 32788,
  SYSTEM_SERVER_DISCOVERY_RSP_CLID = 32789,
  DISCOVERY_STORE_RSP_CLID = 32790,
  NODE_DESC_STORE_RSP_CLID = 32791,
  POWER_DESC_STORE_RSP_CLID = 32792,
  ACTIVE_EP_STORE_RSP_CLID = 32793,
  SIMPLE_DESC_STORE_RSP_CLID = 32794,
  REMOVE_NODE_CACHE_RSP_CLID = 32795,
  FIND_NODE_CACHE_RSP_CLID = 32796,
  EXTENDED_SIMPLE_DESC_RSP_CLID = 32797,
  EXTENDED_ACTIVE_EP_RSP_CLID = 32798,
  PARENT_ANNCE_RSP_CLID = 32799,
  END_DEVICE_BIND_RSP_CLID = 32800,
  BIND_RSP_CLID = 32801,
  UNBIND_RSP_CLID = 32802,
  BIND_REGISTER_RSP_CLID = 32803,
  REPLACE_DEVICE_RSP_CLID = 32804,
  STORE_BCKUP_BIND_ENTRY_RSP_CLID = 32805,
  REMOVE_BCKUP_BIND_ENTRY_RSP_CLID = 32806,
  BACKUP_BIND_TABLE_RSP_CLID = 32807,
  RECOVER_BIND_TABLE_RSP_CLID = 32808,
  BACKUP_SOURCE_BIND_RSP_CLID = 32809,
  RECOVER_SOURCE_BIND_RSP_CLID = 32810,
  CLEAR_ALL_BINDINGS_RSP_CLID = 32811,
  MGMT_NWK_DISC_RSP_CLID = 32816,
  MGMT_LQI_RSP_CLID = 32817,
  MGMT_RTG_RSP_CLID = 32818,
  MGMT_BIND_RSP_CLID = 32819,
  MGMT_LEAVE_RSP_CLID = 32820,
  MGMT_DIRECT_JOIN_RSP_CLID = 32821,
  MGMT_PERMIT_JOINING_RSP_CLID = 32822,
  MGMT_CACHE_RSP_CLID = 32823,
  MGMT_NWK_UPDATE_NOTIFY_CLID = 32824,
  MGMT_NWK_ENHANCED_UPDATE_NOTIFY_CLID = 32825,
  MGMT_NWK_IEEE_JOINING_LIST_RSP_CLID = 32826,
  MGMT_NWK_UNSOLICITED_ENHANCED_UPDATE_NOTIFY_CLID = 32827,
  MGMT_NWK_BEACON_SURVEY_RSP_CLID = 32828,
  SEC_START_KEY_NEGOTIATION_RSP_CLID = 32832,
  SEC_GET_AUTH_TOKEN_RSP_CLID = 32833,
  SEC_GET_AUTH_LEVEL_RSP_CLID = 32834,
  SEC_SET_CFG_RSP_CLID = 32835,
  SEC_GET_CFG_RSP_CLID = 32836,
  SEC_START_KEY_UPDATE_RSP_CLID = 32837,
  SEC_DECOMMISSION_RSP_CLID = 32838,
  SEC_CHALLENGE_RSP_CLID = 32839
} zdp_clusterId_e;

typedef void (*zdp_funcCb)(void *);

struct zdp_funcList_t
{
  enum zdp_clusterId_e clusterId;
  u16 restricted;
  zdp_funcCb func;
};

typedef struct capability_info_t capability_info_t, *Pcapability_info_t;

struct capability_info_t
{
  u8 altPanCoord : 1;
  u8 devType : 1;
  u8 powerSrc : 1;
  u8 rcvOnWhenIdle : 1;
  u8 reserved : 2;
  u8 secuCapability : 1;
  u8 allocAddr : 1;
};

typedef struct tl_zb_mac_ctx_t tl_zb_mac_ctx_t, *Ptl_zb_mac_ctx_t;

typedef struct anon_struct_4_1_a8adf665_for_indirectData anon_struct_4_1_a8adf665_for_indirectData, *Panon_struct_4_1_a8adf665_for_indirectData;

typedef struct ev_timer_event_t ev_timer_event_t, *Pev_timer_event_t;

typedef int (*ev_timer_callback_t)(void *);

struct ev_timer_event_t
{
  struct ev_timer_event_t *next;
  ev_timer_callback_t cb;
  void *data;
  u32 timeout;
  u32 period;
  u32 curSysTick;
  u8 resv[2];
  u8 isRunning;
  u8 used;
};

struct anon_struct_4_1_a8adf665_for_indirectData
{
  struct ev_timer_event_t *timer;
};

struct tl_zb_mac_ctx_t
{
  u8 warmStart;
  u8 status;
  u8 curChannel;
  u8 beaconTriesNum;
  struct anon_struct_4_1_a8adf665_for_indirectData indirectData;
  u8 *txRawDataBuf;
};

typedef enum mac_frame_type_e
{
  MAC_FRAME_BEACON = 0,
  MAC_FRAME_DATA = 1,
  MAC_FRAME_ACKNOWLEDGMENT = 2,
  MAC_FRAME_COMMAND = 3,
  MAC_FRAME_RESERVED1 = 4,
  MAC_FRAME_RESERVED2 = 5,
  MAC_FRAME_RESERVED3 = 6,
  MAC_FRAME_RESERVED4 = 7
} mac_frame_type_e;

typedef struct zb_mac_beacon_payload_s zb_mac_beacon_payload_s, *Pzb_mac_beacon_payload_s;

typedef struct zb_mac_beacon_payload_s zb_mac_beacon_payload_t;

typedef u8 extPANId_t[8];

struct zb_mac_beacon_payload_s
{
  u8 protocol_id;
  u8 stack_profile : 4;
  u8 protocol_version : 4;
  u8 long_uptime : 1;
  u8 tc_connectivity : 1;
  u8 router_capacity : 1;
  u8 device_depth : 4;
  u8 end_device_capacity : 1;
  extPANId_t extended_panid;
  u8 txoffset[3];
  u8 nwk_update_id;
};

typedef enum zb_addr_mode_e
{
  ZB_ADDR_NO_ADDR = 0,
  ZB_ADDR_16BIT_GROUP = 1,
  ZB_ADDR_16BIT_MULTICAST = 1,
  ZB_ADDR_16BIT_DEV_OR_BROADCAST = 2,
  ZB_ADDR_64BIT_DEV = 3
} zb_addr_mode_e;

typedef enum mac_command_frame_id
{
  MAC_CMD_ASSOCIATION_REQUEST = 1,
  MAC_CMD_ASSOCIATION_RESPONSE = 2,
  MAC_CMD_DISASSOCIATION_NOTIFICATION = 3,
  MAC_CMD_DATA_REQUEST = 4,
  MAC_CMD_PAN_ID_CONFLICT_NOTIFICATION = 5,
  MAC_CMD_ORPHAN_NOTIFICATION = 6,
  MAC_CMD_BEACON_REQUEST = 7,
  MAC_CMD_COORDINATOR_REALIGNMENT = 8,
  MAC_CMD_GTS_REQUEST = 9,
  MAC_CMD_TELINK_BASE = 160,
  MAC_CMD_TELINK_OTA = 161
} mac_command_frame_id;

typedef struct nwk_nib_t nwk_nib_t, *Pnwk_nib_t;

struct nwk_nib_t
{
  u32 passiveAckTimeout;
  u8 linkStatusPeriod;
  u8 maxBroadcastRetries;
  u8 maxChildren;
  u8 maxRouters;
  u8 maxSourceRoute;
  u8 concentratorRadius;
  u8 concentratorDiscoveryTime;
  u8 routerAgeLimit;
  u32 nwkBroadcastDeliveryTime;
  extPANId_t extPANId;
  u16 panId;
  u16 nwkAddr;
  u16 managerAddr;
  u16 txTotal;
  u16 txFail;
  u16 transactionPersistenceTime;
  u8 seqNum;
  u8 depth;
  struct capability_info_t capabilityInfo;
  u8 addrAlloc;
  u8 updateId;
  u8 stackProfile;
  u8 allFresh;
  u8 secAllFrames;
  u8 maxDepth;
  u8 reportConstantCost : 1;
  u8 symLink : 1;
  u8 useTreeRouting : 1;
  u8 useMulticast : 1;
  u8 isConcentrator : 1;
  u8 uniqueAddr : 1;
  u8 timeStamp : 1;
  u8 leaveReqAllowed : 1;
  u8 parentInfo;
  u8 endDevTimeoutDefault;
  addrExt_t ieeeAddr;
  u8 leaveReqWithoutRejoinAllowed;
  u8 resv[3];
};

typedef enum SPI_GPIO_GroupTypeDef
{
  SPI_GPIO_GROUP_A2A3A4D6 = 0,
  SPI_GPIO_GROUP_B6B7D2D7 = 1
} SPI_GPIO_GroupTypeDef;

typedef struct gpProxyTabEntry_t gpProxyTabEntry_t, *PgpProxyTabEntry_t;

typedef union gpdId_t gpdId_t, *PgpdId_t;

typedef union gpProxyEntryOpt_t gpProxyEntryOpt_t, *PgpProxyEntryOpt_t;

typedef union gpSecOpt_t gpSecOpt_t, *PgpSecOpt_t;

typedef struct gpLwSinkAddrListItem_t gpLwSinkAddrListItem_t, *PgpLwSinkAddrListItem_t;

typedef struct gpSinkGroupListItem_t gpSinkGroupListItem_t, *PgpSinkGroupListItem_t;

typedef struct anon_struct_2_14_54a3bbdc_for_bits anon_struct_2_14_54a3bbdc_for_bits, *Panon_struct_2_14_54a3bbdc_for_bits;

typedef struct anon_struct_1_3_227554d1_for_bits anon_struct_1_3_227554d1_for_bits, *Panon_struct_1_3_227554d1_for_bits;

struct anon_struct_1_3_227554d1_for_bits
{
  u8 secLevel : 2;
  u8 secKeyType : 3;
  u8 reserved : 3;
};

union gpSecOpt_t
{
  u8 opts;
  struct anon_struct_1_3_227554d1_for_bits bits;
};

struct gpSinkGroupListItem_t
{
  u16 groupId;
  u16 alias;
};

struct gpLwSinkAddrListItem_t
{
  addrExt_t sinkIeeeAddr;
  u16 sinkNwkAddr;
};

struct anon_struct_2_14_54a3bbdc_for_bits
{
  u16 appId : 3;
  u16 entryActive : 1;
  u16 entryValid : 1;
  u16 seqNumCap : 1;
  u16 lightWeightUnicastGPS : 1;
  u16 derivedGroupGPS : 1;
  u16 commGroupGPS : 1;
  u16 firstToForward : 1;
  u16 inRange : 1;
  u16 gpdFixed : 1;
  u16 hasAllUnicastRoutes : 1;
  u16 assignedAlias : 1;
  u16 secUse : 1;
  u16 optsExtension : 1;
};

union gpProxyEntryOpt_t
{
  u16 opts;
  struct anon_struct_2_14_54a3bbdc_for_bits bits;
};

union gpdId_t
{
  u32 srcId;
  addrExt_t gpdIeeeAddr;
};

struct gpProxyTabEntry_t
{
  union gpdId_t gpdId;
  union gpProxyEntryOpt_t options;
  u16 gpdAssignedAlias;
  union gpSecOpt_t secOptions;
  u8 endpoint;
  u8 groupcastRadius;
  u8 searchCnt;
  u8 gpdKey[16];
  u32 gpdSecFrameCnt;
  struct gpLwSinkAddrListItem_t lightweightSinkAddrList[2];
  struct gpSinkGroupListItem_t sinkGroupList[2];
  u8 used : 1;
  u8 lwSinkCnt : 2;
  u8 sinkGroupCnt : 2;
  u8 reserved : 3;
};

typedef struct gpp_ctx_t gpp_ctx_t, *Pgpp_ctx_t;

typedef union gpProxyCommModeOpt_t gpProxyCommModeOpt_t, *PgpProxyCommModeOpt_t;

typedef struct anon_struct_1_6_28c719c2_for_bits anon_struct_1_6_28c719c2_for_bits, *Panon_struct_1_6_28c719c2_for_bits;

struct anon_struct_1_6_28c719c2_for_bits
{
  u8 action : 1;
  u8 commWindowPresent : 1;
  u8 exitMode : 2;
  u8 channelPresent : 1;
  u8 unicastCommunication : 1;
  u8 reserved : 2;
};

union gpProxyCommModeOpt_t
{
  u8 opts;
  struct anon_struct_1_6_28c719c2_for_bits bits;
};

struct gpp_ctx_t
{
  struct ev_timer_event_t *aliasConflictTimeoutEvt;
  struct ev_timer_event_t *commissioningWindowTimeoutEvt;
  u16 gpAliasConflictAddr;
  u16 gpCommissionerAddr;
  u16 gpCommissioningWindow;
  union gpProxyCommModeOpt_t gpCommissioningModeOpt;
  u8 gppInCommMode;
  u8 firstToForward;
};

typedef struct gp_proxyTab_t gp_proxyTab_t, *Pgp_proxyTab_t;

struct gp_proxyTab_t
{
  struct gpProxyTabEntry_t gpProxyTab[5];
  u8 gpProxyTabNum;
};

typedef struct zcl_zoneTable_t zcl_zoneTable_t, *Pzcl_zoneTable_t;

typedef struct zcl_zoneTabEntry_t zcl_zoneTabEntry_t, *Pzcl_zoneTabEntry_t;

struct zcl_zoneTabEntry_t
{
  u8 zoneId;
  u16 zoneType;
  addrExt_t zoneAddr;
};

struct zcl_zoneTable_t
{
  u8 used;
  u8 endpoint;
  struct zcl_zoneTabEntry_t zone;
};

typedef struct zoneEnrollReq_t zoneEnrollReq_t, *PzoneEnrollReq_t;

struct zoneEnrollReq_t
{
  u16 zoneType;
  u16 manufacturerCode;
};

typedef struct zoneInitTestMode_t zoneInitTestMode_t, *PzoneInitTestMode_t;

struct zoneInitTestMode_t
{
  u8 testModeDuration;
  u8 currZoneSensLevel;
};

typedef struct zoneStatusChangeNoti_t zoneStatusChangeNoti_t, *PzoneStatusChangeNoti_t;

struct zoneStatusChangeNoti_t
{
  u16 zoneStatus;
  u8 extStatus;
  u8 zoneId;
  u16 delay;
};

typedef struct zoneEnrollRsp_t zoneEnrollRsp_t, *PzoneEnrollRsp_t;

struct zoneEnrollRsp_t
{
  u8 code;
  u8 zoneId;
};

typedef struct aps_binding_entry_t aps_binding_entry_t, *Paps_binding_entry_t;

typedef union anon_union_9_2_48e353f8_for_aps_binding_entry_t_3 anon_union_9_2_48e353f8_for_aps_binding_entry_t_3, *Panon_union_9_2_48e353f8_for_aps_binding_entry_t_3;

typedef struct aps_binding_extaddr_t aps_binding_extaddr_t, *Paps_binding_extaddr_t;

struct aps_binding_extaddr_t
{
  addrExt_t extAddr;
  u8 dstEp;
};

union anon_union_9_2_48e353f8_for_aps_binding_entry_t_3
{
  u16 groupAddr;
  struct aps_binding_extaddr_t dstExtAddrInfo;
};

struct aps_binding_entry_t
{
  u16 clusterId;
  u8 srcEp;
  u8 dstAddrMode;
  union anon_union_9_2_48e353f8_for_aps_binding_entry_t_3 field_3;
  u8 used;
};

typedef struct aps_tx_cache_list_t aps_tx_cache_list_t, *Paps_tx_cache_list_t;

typedef union anon_union_8_2_c5eb30e3_for_dstAddr anon_union_8_2_c5eb30e3_for_dstAddr, *Panon_union_8_2_c5eb30e3_for_dstAddr;

union anon_union_8_2_c5eb30e3_for_dstAddr
{
  u16 addr_short;
  addrExt_t addr_long;
};

struct aps_tx_cache_list_t
{
  union anon_union_8_2_c5eb30e3_for_dstAddr dstAddr;
  u8 *payload;
  u8 dstAddrMode;
  u8 dstEndpoint;
  u8 ep;
  u8 handler;
  u8 apsCount;
  u8 zdpSeqnoAddrReq;
  u8 used : 1;
  u8 addrReqNeed : 1;
  u8 ackNeed : 1;
  u8 interPAN : 1;
  u8 state : 4;
  u8 retries;
  s8 apsAckWaitTimeOut;
  s8 apsAddrWaitTimeout;
  u8 extFrameCtrl;
  u8 blockNum;
  u16 clusterId;
  u8 resv[2];
};

typedef struct aps_group_tbl_ent_t aps_group_tbl_ent_t, *Paps_group_tbl_ent_t;

struct aps_group_tbl_ent_t
{
  u16 group_addr;
  u8 endpoints[8];
  u8 n_endpoints;
  u8 group_name[16];
  u8 rsv;
};

typedef struct aps_pib_attributes_t aps_pib_attributes_t, *Paps_pib_attributes_t;

struct aps_pib_attributes_t
{
  u32 aps_channel_mask;
  addrExt_t aps_use_ext_panid;
  u8 aps_designated_coordinator;
  u8 aps_parent_announce_timer;
  u8 aps_nonmember_radius;
  u8 aps_interframe_delay;
  u8 aps_max_window_size;
  u8 aps_fragment_payload_size;
  u8 aps_use_insecure_join : 1;
  u8 aps_authenticated : 1;
  u8 aps_updateDevice_holdApsSecurity : 1;
  u8 aps_zdo_restricted_mode : 1;
  u8 aps_reserved : 4;
};

typedef struct aps_add_group_req_t aps_add_group_req_t, *Paps_add_group_req_t;

struct aps_add_group_req_t
{
  u16 group_addr;
  u8 ep;
};

typedef enum security_with_e
{
  SECURITY_IN_APSLAYER = 1,
  SECURITY_IN_NWKLAYER = 2
} security_with_e;

typedef struct aps_data_ind_t aps_data_ind_t, *Paps_data_ind_t;

typedef union anon_union_8_2_02f160e6_for_aps_data_ind_t_10 anon_union_8_2_02f160e6_for_aps_data_ind_t_10, *Panon_union_8_2_02f160e6_for_aps_data_ind_t_10;

union anon_union_8_2_02f160e6_for_aps_data_ind_t_10
{
  u16 src_short_addr;
  u8 src_ext_addr[8];
};

struct aps_data_ind_t
{
  u8 dst_addr_mode;
  u8 dst_ep;
  u16 dst_addr;
  u8 src_addr_mode;
  u8 src_ep;
  u16 profile_id;
  u16 cluster_id;
  u16 asduLength;
  u8 *asdu;
  u32 rx_tick;
  union anon_union_8_2_02f160e6_for_aps_data_ind_t_10 field_10;
  u16 srcMacAddr;
  u8 status;
  enum security_with_e security_status;
  u8 lqi;
  s8 rssi;
  u8 aps_counter;
};

typedef enum aps_tx_options
{
  APS_TX_OPT_SECURITY_ENABLED = 1,
  APS_TX_OPT_DISABLE_NWK_KEY = 2,
  APS_TX_OPT_ACK_TX = 4,
  APS_TX_OPT_FRAG_PERMITTED = 8,
  APS_TX_OPT_INCLUDE_NONCE = 16,
  APS_TX_OPT_UNICAST_SKIP_ROUTING = 32,
  APS_TX_OPT_INTRA_PAN = 128
} aps_tx_options;

typedef struct aps_add_group_req_t aps_delete_group_req_t;

typedef enum aps_status_t
{
  APS_STATUS_SUCCESS = 0,
  APS_STATUS_ASDU_TOO_LONG = 160,
  APS_STATUS_DEFRAG_DEFERRED = 161,
  APS_STATUS_DEFRAG_UNSUPPORTED = 162,
  APS_STATUS_ILLEGAL_REQUEST = 163,
  APS_STATUS_INVALID_BINDING = 164,
  APS_STATUS_INVALID_GROUP = 165,
  APS_STATUS_INVALID_PARAMETER = 166,
  APS_STATUS_NO_ACK = 167,
  APS_STATUS_NO_BOUND_DEVICE = 168,
  APS_STATUS_NO_SHORT_ADDRESS = 169,
  APS_STATUS_NOT_SUPPORTED = 170,
  APS_STATUS_SECURED_LINK_KEY = 171,
  APS_STATUS_SECURED_NWK_KEY = 172,
  APS_STATUS_SECURITY_FAIL = 173,
  APS_STATUS_TABLE_FULL = 174,
  APS_STATUS_UNSECURED = 175,
  APS_STATUS_UNSUPPORTED_ATTRIBUTE = 176,
  APS_STATUS_HANDLE_BACKING = 177,
  APS_STATUS_SHORT_ADDR_REQUESTING = 178,
  APS_STATUS_DUPLICATE_ENTRY = 184,
  APS_STATUS_INTERNAL_BUF_FULL = 185
} aps_status_t;

typedef struct ota_updateInfo_t ota_updateInfo_t, *Pota_updateInfo_t;

typedef struct ota_hdrFields_t ota_hdrFields_t, *Pota_hdrFields_t;

typedef struct ota_serverAddr_t ota_serverAddr_t, *Pota_serverAddr_t;

struct ota_hdrFields_t
{
  u32 otaUpgradeFileID;
  u16 otaHdrVer;
  u16 otaHdrLen;
  u16 otaHdrFC;
  u16 manufacturerCode;
  u16 imageType;
  u32 fileVer;
  u16 zbStackVer;
  u8 otaHdrString[32];
  u32 totalImageSize;
  u8 securityCredVer;
  addrExt_t fileDest;
  u16 minHdrVer;
  u16 maxHdrVer;
};

struct ota_serverAddr_t
{
  addrExt_t extAddr;
  u16 profileId;
  u8 endpoint;
  u8 txOptions;
};

struct ota_updateInfo_t
{
  struct ota_hdrFields_t hdrInfo;
  struct ota_serverAddr_t otaServerAddrInfo;
};

typedef void (*ota_processMsg_t)(u8, u8);

typedef struct ota_callBack_t ota_callBack_t, *Pota_callBack_t;

struct ota_callBack_t
{
  ota_processMsg_t processMsgCbFunc;
};

typedef struct ota_ctx_t ota_ctx_t, *Pota_ctx_t;

typedef struct af_simple_descriptor_t af_simple_descriptor_t, *Paf_simple_descriptor_t;

typedef struct ota_preamble_t ota_preamble_t, *Pota_preamble_t;

typedef struct epInfo_t epInfo_t, *PepInfo_t;

typedef union tl_zb_addr_t tl_zb_addr_t, *Ptl_zb_addr_t;

union tl_zb_addr_t
{
  u16 shortAddr;
  addrExt_t extAddr;
};

struct af_simple_descriptor_t
{
  u16 app_profile_id;
  u16 app_dev_id;
  u8 endpoint;
  u8 app_dev_ver : 4;
  u8 reserved : 4;
  u8 app_in_cluster_count;
  u8 app_out_cluster_count;
  u16 *app_in_cluster_lst;
  u16 *app_out_cluster_lst;
};

struct ota_preamble_t
{
  u32 fileVer;
  u32 totalImageSize;
  u16 imageType;
  u16 manufacturerCode;
};

struct epInfo_t
{
  union tl_zb_addr_t dstAddr;
  u16 profileId;
  u16 aliasSrcAddr;
  u8 useAlias;
  u8 aliasSeqNum;
  u8 dstAddrMode;
  u8 dstEp;
  enum aps_tx_options txOptions;
  u8 radius;
};

struct ota_ctx_t
{
  struct af_simple_descriptor_t *simpleDesc;
  struct ota_preamble_t *pOtaPreamble;
  u32 downloadImageSize;
  struct epInfo_t otaServerEpInfo;
  u8 imageBlockRetry;
  u8 upgradeEndRetry;
  u8 isOtaServer;
};

typedef enum ota_type_e
{
  OTA_TYPE_CLIENT = 0,
  OTA_TYPE_SERVER = 1
} ota_type_e;

typedef struct ota_clientInfo_t ota_clientInfo_t, *Pota_clientInfo_t;

struct ota_clientInfo_t
{
  u32 offset;
  u32 crcValue;
  u32 otaElementPos;
  u32 otaElementLen;
  u16 otaElementTag;
  u8 otaElementInfo1;
  u8 otaElementInfo2;
  u8 clientOtaFlg;
};

typedef void (*sys_exception_cb_t)(void);

typedef enum TIMER_TypeDef
{
  TIMER0 = 0,
  TIMER1 = 1,
  TIMER2 = 2
} TIMER_TypeDef;

typedef struct step_t step_t, *Pstep_t;

struct step_t
{
  u8 stepMode;
  u8 stepSize;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct stop_t stop_t, *Pstop_t;

struct stop_t
{
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct moveToLvl_t moveToLvl_t, *PmoveToLvl_t;

struct moveToLvl_t
{
  u8 level;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef union zcl_level_cmdPayload_t zcl_level_cmdPayload_t, *Pzcl_level_cmdPayload_t;

typedef struct move_t move_t, *Pmove_t;

struct move_t
{
  u8 moveMode;
  u8 rate;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

union zcl_level_cmdPayload_t
{
  struct moveToLvl_t moveToLevel;
  struct move_t move;
  struct step_t step;
  struct stop_t stop;
};

typedef struct tl_zb_mac_pib_t tl_zb_mac_pib_t, *Ptl_zb_mac_pib_t;

struct tl_zb_mac_pib_t
{
  u32 beaconTxTime;
  addrExt_t coordExtAddress;
  addrExt_t extAddress;
  u16 ackWaitDuration;
  u16 coordShortAddress;
  u16 panId;
  u16 shortAddress;
  u16 superframeOrder;
  u16 transactionPersistenceTime;
  u16 frameTotalWaitTime;
  u16 syncSymbolOffset;
  zb_mac_beacon_payload_t beaconPayload;
  u8 beaconPayloadLen;
  u8 associationPermit;
  u8 associatedPanCoord;
  u8 autoReq;
  u8 battLifeExt;
  u8 battLifeExtPeriods;
  u8 beaconOrder;
  u8 beaconSeqNum;
  u8 seqNum;
  u8 frameRetryNum;
  u8 respWaitTime;
  u8 maxCsmaBackoffs;
  u8 promiscuousMode;
  u8 timeStampSupported;
  u8 securityEnabled;
  u8 gtsPermit;
  u8 minBe;
  u8 maxBe;
  u8 phyPageCur;
  u8 phyChannelCur;
  u8 rxOnWhenIdle;
  u8 txPower;
  u8 resv[3];
};

typedef enum flash_status_typedef_e
{
  FLASH_TYPE_8BIT_STATUS = 0,
  FLASH_TYPE_16BIT_STATUS_ONE_CMD = 1,
  FLASH_TYPE_16BIT_STATUS_TWO_CMD = 2
} flash_status_typedef_e;

typedef enum SleepMode_TypeDef
{
  SUSPEND_MODE = 0,
  DEEPSLEEP_MODE_RET_SRAM_LOW32K = 7,
  DEEPSLEEP_MODE_RET_SRAM_LOW16K = 67,
  DEEPSLEEP_MODE_RET_SRAM_LOW8K = 97,
  DEEPSLEEP_RETENTION_FLAG = 127,
  DEEPSLEEP_MODE = 128,
  SHUTDOWN_MODE = 255
} SleepMode_TypeDef;

typedef enum SleepWakeupSrc_TypeDef
{
  PM_WAKEUP_PAD = 16,
  PM_WAKEUP_CORE = 32,
  PM_WAKEUP_TIMER = 64,
  PM_WAKEUP_COMPARATOR = 128
} SleepWakeupSrc_TypeDef;

typedef int (*cpu_pm_handler_t)(enum SleepMode_TypeDef, enum SleepWakeupSrc_TypeDef, uint);

typedef uint (*pm_tim_recover_handler_t)(uint);

typedef struct pm_para_t pm_para_t, *Ppm_para_t;

struct pm_para_t
{
  uchar is_pad_wakeup;
  uchar wakeup_src;
  uchar mcu_status;
};

typedef enum drv_spi_mode_type_def
{
  SPI_MODE_0 = 0,
  SPI_MODE_2 = 1,
  SPI_MODE_1 = 2,
  SPI_MODE_3 = 3
} drv_spi_mode_type_def;

typedef enum mid1360c8_write_status_bit_e
{
  FLASH_WRITE_STATUS_BP_MID1360C8 = 28
} mid1360c8_write_status_bit_e;

typedef enum mid1360c8_lock_block_e
{
  FLASH_LOCK_NONE_MID1360C8 = 0,
  FLASH_LOCK_LOW_504K_MID1360C8 = 4,
  FLASH_LOCK_LOW_496K_MID1360C8 = 8,
  FLASH_LOCK_LOW_480K_MID1360C8 = 12,
  FLASH_LOCK_LOW_448K_MID1360C8 = 16,
  FLASH_LOCK_LOW_384K_MID1360C8 = 20,
  FLASH_LOCK_LOW_256K_MID1360C8 = 24,
  FLASH_LOCK_ALL_512K_MID1360C8 = 28
} mid1360c8_lock_block_e;

typedef struct addrMapping_t addrMapping_t, *PaddrMapping_t;

struct addrMapping_t
{
  struct addrMapping_t *freeNext;
  struct addrMapping_t *activeNext;
  addrExt_t extAddr;
  u16 shortAddr;
  u8 aps_dup_cnt;
  u8 used : 1;
  u8 aps_dup_clock : 3;
  u8 bind : 1;
  u8 resv : 3;
};

typedef struct addrMapping_t tl_zb_addr_map_entry_t;

typedef struct tl_zb_addr_map_t tl_zb_addr_map_t, *Ptl_zb_addr_map_t;

struct tl_zb_addr_map_t
{
  tl_zb_addr_map_entry_t *freeHead;
  tl_zb_addr_map_entry_t *activeHead;
  u32 validNum;
  tl_zb_addr_map_entry_t addrMap[128];
};

typedef struct zcl_addGroupRsp_t zcl_addGroupRsp_t, *Pzcl_addGroupRsp_t;

typedef struct zcl_addGroupRsp_t zcl_removeGroupRsp_t;

struct zcl_addGroupRsp_t
{
  u8 status;
  u16 groupId;
};

typedef struct zcl_getGroupMembershipRsp_t zcl_getGroupMembershipRsp_t, *Pzcl_getGroupMembershipRsp_t;

struct zcl_getGroupMembershipRsp_t
{
  u8 capacity;
  u8 groupCnt;
  u8 *pGroupLsit;
};

typedef struct zcl_viewGroupRsp_t zcl_viewGroupRsp_t, *Pzcl_viewGroupRsp_t;

struct zcl_viewGroupRsp_t
{
  u8 status;
  u16 groupId;
  u8 *pGroupName;
};

typedef struct gp_noti_t gp_noti_t, *Pgp_noti_t;

typedef union anon_union_28_2_4c3d1b88_for_gp_noti_t_1 anon_union_28_2_4c3d1b88_for_gp_noti_t_1, *Panon_union_28_2_4c3d1b88_for_gp_noti_t_1;

typedef struct zcl_gp_notificationCmd_t zcl_gp_notificationCmd_t, *Pzcl_gp_notificationCmd_t;

typedef struct zcl_gp_commissioningNotificationCmd_t zcl_gp_commissioningNotificationCmd_t, *Pzcl_gp_commissioningNotificationCmd_t;

typedef union gpNotiOpt_t gpNotiOpt_t, *PgpNotiOpt_t;

typedef union gpGppGpdLink_t gpGppGpdLink_t, *PgpGppGpdLink_t;

typedef union gpCommNotiOpt_t gpCommNotiOpt_t, *PgpCommNotiOpt_t;

typedef struct anon_struct_2_11_1d93dd47_for_bits anon_struct_2_11_1d93dd47_for_bits, *Panon_struct_2_11_1d93dd47_for_bits;

typedef struct anon_struct_1_2_131fbad2_for_bits anon_struct_1_2_131fbad2_for_bits, *Panon_struct_1_2_131fbad2_for_bits;

typedef struct anon_struct_2_8_cacc4c01_for_bits anon_struct_2_8_cacc4c01_for_bits, *Panon_struct_2_8_cacc4c01_for_bits;

struct anon_struct_1_2_131fbad2_for_bits
{
  u8 rssi : 6;
  u8 lqi : 2;
};

union gpGppGpdLink_t
{
  u8 link;
  struct anon_struct_1_2_131fbad2_for_bits bits;
};

struct anon_struct_2_11_1d93dd47_for_bits
{
  u16 appId : 3;
  u16 alsoUnicast : 1;
  u16 alsoDerivedGroup : 1;
  u16 alsoCommGroup : 1;
  u16 secLevel : 2;
  u16 secKeyType : 3;
  u16 rxAfterTx : 1;
  u16 gpTxQueueFull : 1;
  u16 bidirectionalCap : 1;
  u16 proxyInfoPresent : 1;
  u16 reserved : 1;
};

union gpNotiOpt_t
{
  u16 opts;
  struct anon_struct_2_11_1d93dd47_for_bits bits;
};

struct zcl_gp_notificationCmd_t
{
  union gpdId_t gpdId;
  u8 *pGpdCmdPayload;
  u32 gpdSecFrameCnt;
  union gpNotiOpt_t options;
  u16 gppShortAddr;
  u8 endpoint;
  u8 gpdCmdID;
  u8 payloadLen;
  union gpGppGpdLink_t gppGpdLink;
};

struct anon_struct_2_8_cacc4c01_for_bits
{
  u16 appId : 3;
  u16 rxAfterTx : 1;
  u16 secLevel : 2;
  u16 secKeyType : 3;
  u16 secPrcFailed : 1;
  u16 bidirectionalCap : 1;
  u16 proxyInfoPresent : 1;
  u16 reserved : 4;
};

union gpCommNotiOpt_t
{
  u16 opts;
  struct anon_struct_2_8_cacc4c01_for_bits bits;
};

struct zcl_gp_commissioningNotificationCmd_t
{
  union gpdId_t gpdId;
  u8 *pGpdCmdPayload;
  u32 gpdSecFrameCnt;
  u32 mic;
  union gpCommNotiOpt_t options;
  u16 gppShortAddr;
  u8 endpoint;
  u8 gpdCmdID;
  u8 payloadLen;
  union gpGppGpdLink_t gppGpdLink;
};

union anon_union_28_2_4c3d1b88_for_gp_noti_t_1
{
  struct zcl_gp_notificationCmd_t gpNotificationCmd;
  struct zcl_gp_commissioningNotificationCmd_t gpCommissioningNotificationCmd;
};

struct gp_noti_t
{
  struct epInfo_t dstEpInfo;
  union anon_union_28_2_4c3d1b88_for_gp_noti_t_1 field_1;
};

typedef struct gp_appCb_t gp_appCb_t, *Pgp_appCb_t;

typedef u8 (*gpChangleChannelReqCb_t)(void);

typedef void (*gpCommissioningModeCb_t)(u8);

struct gp_appCb_t
{
  gpChangleChannelReqCb_t gpChangleChannelReqCb;
  gpCommissioningModeCb_t gpCommissioningModeCb;
};

typedef union gpd_channelConfigurationCmd_payload_t gpd_channelConfigurationCmd_payload_t, *Pgpd_channelConfigurationCmd_payload_t;

typedef struct anon_struct_1_3_62fe53ba_for_bits anon_struct_1_3_62fe53ba_for_bits, *Panon_struct_1_3_62fe53ba_for_bits;

struct anon_struct_1_3_62fe53ba_for_bits
{
  u8 operationChannel : 4;
  u8 basic : 1;
  u8 reserved : 3;
};

union gpd_channelConfigurationCmd_payload_t
{
  u8 channel;
  struct anon_struct_1_3_62fe53ba_for_bits bits;
};

typedef struct zcl_doorlockRsp_t zcl_doorlockRsp_t, *Pzcl_doorlockRsp_t;

struct zcl_doorlockRsp_t
{
  u8 status;
};

typedef struct zcl_doorlockReq_t zcl_doorlockReq_t, *Pzcl_doorlockReq_t;

struct zcl_doorlockReq_t
{
  void *pData;
  u8 dataLen;
};

typedef enum mid1060c8_lock_block_e
{
  FLASH_LOCK_NONE_MID1060C8 = 0,
  FLASH_LOCK_LOW_56K_MID1060C8 = 4,
  FLASH_LOCK_LOW_48K_MID1060C8 = 8,
  FLASH_LOCK_LOW_32K_MID1060C8 = 12,
  FLASH_LOCK_ALL_64K_MID1060C8 = 16
} mid1060c8_lock_block_e;

typedef enum mid1060c8_write_status_bit_e
{
  FLASH_WRITE_STATUS_BP_MID1060C8 = 28
} mid1060c8_write_status_bit_e;

typedef struct apsdeDataInd_s apsdeDataInd_s, *PapsdeDataInd_s;

typedef struct apsdeDataInd_s apsdeDataInd_t;

struct apsdeDataInd_s
{
  struct aps_data_ind_t indInfo;
  u16 asduLen;
  u8 asdu[0];
};

typedef struct zcl_zllTouckLink_t zcl_zllTouckLink_t, *Pzcl_zllTouckLink_t;

typedef struct zcl_zllTouckLinkDisc_t zcl_zllTouckLinkDisc_t, *Pzcl_zllTouckLinkDisc_t;

typedef struct zcl_zllTouckLinkNetworkStartParams zcl_zllTouckLinkNetworkStartParams, *Pzcl_zllTouckLinkNetworkStartParams;

typedef struct zll_tlZbInfo_t zll_tlZbInfo_t, *Pzll_tlZbInfo_t;

typedef struct zll_tlZllInfo_t zll_tlZllInfo_t, *Pzll_tlZllInfo_t;

typedef struct zcl_DeviceInfo zcl_DeviceInfo, *Pzcl_DeviceInfo;

typedef struct zll_touchLinkScanInfo zll_touchLinkScanInfo, *Pzll_touchLinkScanInfo;

typedef union anon_union_56_2_c042cba7_for_params anon_union_56_2_c042cba7_for_params, *Panon_union_56_2_c042cba7_for_params;

typedef union anon_union_1_2_43a74925_for_zll_tlZbInfo_t_0 anon_union_1_2_43a74925_for_zll_tlZbInfo_t_0, *Panon_union_1_2_43a74925_for_zll_tlZbInfo_t_0;

typedef union anon_union_1_2_43a74925_for_zll_tlZllInfo_t_0 anon_union_1_2_43a74925_for_zll_tlZllInfo_t_0, *Panon_union_1_2_43a74925_for_zll_tlZllInfo_t_0;

typedef struct zcl_zllSubdeviceInfo_t zcl_zllSubdeviceInfo_t, *Pzcl_zllSubdeviceInfo_t;

typedef struct zcl_zllTouchLinkNetworkStartReq_t zcl_zllTouchLinkNetworkStartReq_t, *Pzcl_zllTouchLinkNetworkStartReq_t;

typedef struct zcl_zllTouchLinkNetworkJoinReq_t zcl_zllTouchLinkNetworkJoinReq_t, *Pzcl_zllTouchLinkNetworkJoinReq_t;

typedef struct anon_struct_1_3_6bc590d9_for_bf anon_struct_1_3_6bc590d9_for_bf, *Panon_struct_1_3_6bc590d9_for_bf;

typedef struct anon_struct_1_7_11129f38_for_bf anon_struct_1_7_11129f38_for_bf, *Panon_struct_1_7_11129f38_for_bf;

struct anon_struct_1_3_6bc590d9_for_bf
{
  u8 logicDevType : 2;
  u8 rxOnWihleIdle : 1;
  u8 resv : 5;
};

struct zcl_zllTouchLinkNetworkJoinReq_t
{
  u32 transId;
  addrExt_t epanId;
  u8 keyIdx;
  u8 encryptedNwkKey[16];
  u8 nwkUpdateId;
  u8 logicalChannel;
  u16 panId;
  u16 nwkAddr;
  u16 groupIdBegin;
  u16 groupIdEnd;
  u16 freeNwkAddrRangeBegin;
  u16 freeNwkAddrRangeEnd;
  u16 freeGroupIdRangeBegin;
  u16 freeGroupIdRangeEnd;
};

struct zcl_zllTouchLinkNetworkStartReq_t
{
  u32 transId;
  addrExt_t epanId;
  u8 keyIdx;
  u8 encryptedNwkKey[16];
  u8 logicalChannel;
  u16 panId;
  u16 nwkAddr;
  u16 groupIdbegin;
  u16 groupIdEnd;
  u16 freeNwkAddrRangeBegin;
  u16 freeNwkAddrRangeEnd;
  u16 freeGroupIdRangeBegin;
  u16 freeGroupIdRangeEnd;
  addrExt_t initiatorIeeeAddr;
  u16 initiatorNwkAddr;
};

union anon_union_56_2_c042cba7_for_params
{
  struct zcl_zllTouchLinkNetworkStartReq_t networkStartCmd;
  struct zcl_zllTouchLinkNetworkJoinReq_t networkJoinCmd;
};

union anon_union_1_2_43a74925_for_zll_tlZbInfo_t_0
{
  struct anon_struct_1_3_6bc590d9_for_bf bf;
  u8 byte;
};

struct zll_tlZbInfo_t
{
  union anon_union_1_2_43a74925_for_zll_tlZbInfo_t_0 field_0;
};

struct anon_struct_1_7_11129f38_for_bf
{
  u8 factoryNew : 1;
  u8 addrAssign : 1;
  u8 resv0 : 2;
  u8 linkInitiator : 1;
  u8 priorityReq : 1;
  u8 resv1 : 1;
  u8 profileInterop : 1;
};

union anon_union_1_2_43a74925_for_zll_tlZllInfo_t_0
{
  struct anon_struct_1_7_11129f38_for_bf bf;
  u8 byte;
};

struct zcl_zllTouckLinkNetworkStartParams
{
  union anon_union_56_2_c042cba7_for_params params;
  u8 seqNo;
  u8 joinNetworkMode;
  struct epInfo_t initiatorEpInfo;
};

struct zcl_DeviceInfo
{
  addrExt_t deviceAddr;
  u8 epId;
  u16 profileId;
  u16 deviceId;
  u8 version;
  u8 groupIdCnt;
  u8 sort;
};

struct zll_tlZllInfo_t
{
  union anon_union_1_2_43a74925_for_zll_tlZllInfo_t_0 field_0;
};

struct zcl_zllTouckLink_t
{
  struct zcl_zllTouckLinkDisc_t *disc;
  struct zcl_zllTouckLinkNetworkStartParams *networkStartInfo;
  struct ev_timer_event_t *transIdLifeTimer;
  struct ev_timer_event_t *runTimer;
  u32 transId;
  u32 respId;
  u32 scanChanMask;
  u8 touchLinkChan;
  struct zll_tlZbInfo_t zbInfo;
  struct zll_tlZllInfo_t zllInfo;
  u8 seqNo;
  u8 scanListNum;
  u8 opIdx;
  struct zcl_DeviceInfo dstDevInfo;
  struct zcl_DeviceInfo devInfo;
  u8 state;
  u8 status;
  u8 workingChannelBackUp;
  u8 lqiThreshold;
  u8 commissionTxPower;
  u8 keyType;
  u8 vDoPrimaryScan : 1;
  u8 IsFirstChannel : 1;
  u8 startNetworkAllowed : 1;
  u8 resved : 5;
};

struct zcl_zllSubdeviceInfo_t
{
  u8 epId;
  u16 profileId;
  u16 deviceId;
  u8 version;
  u8 groupIdCnt;
};

struct zll_touchLinkScanInfo
{
  u32 respId;
  addrExt_t epanId;
  u16 panId;
  u16 nwkAddr;
  struct zll_tlZbInfo_t zbInfo;
  struct zll_tlZllInfo_t zllInfo;
  u8 logicalChannel;
  u8 numOfSubdevices;
  struct epInfo_t dstEp;
  u8 totalGroupIds;
  u8 keyIdx;
  u8 nwkUpdateId;
  struct zcl_zllSubdeviceInfo_t devInfo;
};

struct zcl_zllTouckLinkDisc_t
{
  u32 unscannedChannelMask;
  u8 targetNum;
  u8 primaryChannelScanComplete;
  u8 currentScannChannel;
  u8 scanCnt;
  struct zll_touchLinkScanInfo scanList[1];
};

typedef struct zcl_chkInRsp_t zcl_chkInRsp_t, *Pzcl_chkInRsp_t;

struct zcl_chkInRsp_t
{
  u8 startFastPolling;
  u16 fastPollTimeout;
};

typedef struct zcl_setLongPollInterval_t zcl_setLongPollInterval_t, *Pzcl_setLongPollInterval_t;

struct zcl_setLongPollInterval_t
{
  u32 newLongPollInterval;
};

typedef struct zcl_setShortPollInterval_t zcl_setShortPollInterval_t, *Pzcl_setShortPollInterval_t;

struct zcl_setShortPollInterval_t
{
  u16 newShortPollInterval;
};

typedef struct ev_timer_ctrl_t ev_timer_ctrl_t, *Pev_timer_ctrl_t;

typedef struct ev_timer_event_pool_s ev_timer_event_pool_s, *Pev_timer_event_pool_s;

typedef struct ev_timer_event_pool_s ev_timer_event_pool_t;

struct ev_timer_event_pool_s
{
  struct ev_timer_event_t evt[24];
  u32 used_num;
};

struct ev_timer_ctrl_t
{
  struct ev_timer_event_t *timer_head;
  struct ev_timer_event_t *timer_nearest;
  ev_timer_event_pool_t timerEventPool;
};

typedef struct srcRoute_repair_t srcRoute_repair_t, *PsrcRoute_repair_t;

struct srcRoute_repair_t
{
  u16 nwkFwdDstAddr;
  u16 nwkFwdSrcAddr;
};

typedef struct nwk_ctx_t nwk_ctx_t, *Pnwk_ctx_t;

typedef struct anon_struct_32_2_5c3d3b77_for_formationInfo anon_struct_32_2_5c3d3b77_for_formationInfo, *Panon_struct_32_2_5c3d3b77_for_formationInfo;

typedef union anon_union_4_2_bfd4ae01_for_join anon_union_4_2_bfd4ae01_for_join, *Panon_union_4_2_bfd4ae01_for_join;

typedef struct manyToOne_repair_t manyToOne_repair_t, *PmanyToOne_repair_t;

typedef struct tl_zb_addition_neighbor_entry_t tl_zb_addition_neighbor_entry_t, *Ptl_zb_addition_neighbor_entry_t;

struct manyToOne_repair_t
{
  u16 nwkFwdDstAddr;
  u16 nwkFwdSrcAddr;
  u16 senderAddr;
  u16 lastSendFailAddr;
};

struct anon_struct_32_2_5c3d3b77_for_formationInfo
{
  u8 energy_detect[16];
  u8 channel_pan_count[16];
};

union anon_union_4_2_bfd4ae01_for_join
{
  struct tl_zb_addition_neighbor_entry_t *pAssocJoinParent;
  struct tl_zb_addition_neighbor_entry_t *pRejoinParent;
};

struct nwk_ctx_t
{
  struct anon_struct_32_2_5c3d3b77_for_formationInfo formationInfo;
  union anon_union_4_2_bfd4ae01_for_join join;
  struct ev_timer_event_t *curJoiningDevTimerEvt;
  u32 scanChannels;
  u8 scanDuration;
  u8 is_factory_new : 1;
  u8 permit_join : 1;
  u8 joined : 1;
  u8 router_started : 1;
  u8 is_tc : 1;
  u8 joined_pro : 1;
  u8 panIdConflict : 1;
  u8 joinAccept : 1;
  u8 known_panids_cnt : 4;
  u8 discoverRoute : 1;
  u8 panidUpdateRecv : 1;
  u8 resv : 1;
  u8 parentIsChanged : 1;
  u8 user_state : 4;
  u8 state : 4;
  u8 leaveRejoin;
  u16 new_panid;
  u16 known_panids[8];
  struct manyToOne_repair_t manyToOneRepair;
  struct srcRoute_repair_t srcRouteRepair;
};

struct tl_zb_addition_neighbor_entry_t
{
  extPANId_t extPanId;
  addrExt_t extAddr;
  u16 shortAddr;
  u16 panId;
  u8 addrMode;
  u8 logicChannel;
  u8 depth : 4;
  u8 beaconOrder : 4;
  u8 permitJoining : 1;
  u8 potentialParent : 1;
  u8 routerCapacity : 1;
  u8 edCapacity : 1;
  u8 stackProfile : 4;
  u8 deviceType : 2;
  u8 superframeOrder : 6;
  u8 lqi;
  u8 nwkUpdateId;
  u8 rsv;
};

typedef struct nv_itemLenChk_t nv_itemLenChk_t, *Pnv_itemLenChk_t;

struct nv_itemLenChk_t
{
  u8 itemId;
  u16 len;
};

typedef enum rf_rxGainMode_t
{
  RF_GAIN_MODE_AUTO = 0,
  RF_GAIN_MODE_MANU_MAX = 1
} rf_rxGainMode_t;

typedef struct zb_buf_s zb_buf_s, *Pzb_buf_s;

typedef struct zb_buf_s zb_buf_t;

typedef struct zb_buf_hdr_t zb_buf_hdr_t, *Pzb_buf_hdr_t;

struct zb_buf_hdr_t
{
  u8 id;
  u8 handle;
  s8 rssi;
  u8 used : 1;
  u8 macTxFifo : 1;
  u8 leaveRejoin : 1;
  u8 active : 1;
  u8 pending : 1;
  u8 rejoinStartAgain : 1;
  u8 resvHdr : 2;
};

struct zb_buf_s
{
  u8 buf[192];
  struct zb_buf_hdr_t hdr;
  struct zb_buf_s *next;
  u32 allocCnt;
  u32 freeCnt;
};

typedef struct zb_buf_pool_t zb_buf_pool_t, *Pzb_buf_pool_t;

struct zb_buf_pool_t
{
  zb_buf_t *head;
  u32 usedNum;
  zb_buf_t pool[36];
};

typedef struct mac_pibTbl_t mac_pibTbl_t, *Pmac_pibTbl_t;

struct mac_pibTbl_t
{
  u8 offset;
  u8 len;
  u8 min;
  u8 max;
};

typedef struct nv_info_idx_t nv_info_idx_t, *Pnv_info_idx_t;

struct nv_info_idx_t
{
  u32 offset;
  u16 size;
  u8 itemId;
  u8 usedState;
};

typedef struct itemIfno_t itemIfno_t, *PitemIfno_t;

struct itemIfno_t
{
  u16 opIndex;
  u8 opSect;
};

typedef struct nv_sect_info_t nv_sect_info_t, *Pnv_sect_info_t;

struct nv_sect_info_t
{
  u16 usedFlag;
  u8 idName;
  u8 opSect;
};

typedef struct itemHdr_t itemHdr_t, *PitemHdr_t;

struct itemHdr_t
{
  u32 checkSum;
  u16 size;
  u8 itemId;
  u8 used;
};

typedef enum nv_sts_t
{
  NV_SUCC = 0,
  NV_INVALID_MODULS = 1,
  NV_INVALID_ID = 2,
  NV_ITEM_NOT_FOUND = 3,
  NV_NOT_ENOUGH_SAPCE = 4,
  NV_ITEM_LEN_NOT_MATCH = 5,
  NV_CHECK_SUM_ERROR = 6,
  NV_ENABLE_PROTECT_ERROR = 7,
  NV_NO_MEDIA = 8,
  NV_DATA_CHECK_ERROR = 9,
  NV_ITEM_CHECK_ERROR = 10,
  NV_MODULE_NOT_FOUND = 11,
  NV_MODULE_ERASE_NEED = 12
} nv_sts_t;

typedef struct zb_info_t zb_info_t, *Pzb_info_t;

typedef struct touchlink_attr_t touchlink_attr_t, *Ptouchlink_attr_t;

// WARNING! conflicting data type names: /DWARF/bdb.h/bdb_attr_t - /bdb_attr_t

struct touchlink_attr_t
{
  u16 freeNwkAddressRangeBegin;
  u16 freeNwkAddressRangeEnd;
  u16 freeGroupAddressRangeBegin;
  u16 freeGroupAddressRangeEnd;
};

struct zb_info_t
{
  struct tl_zb_mac_pib_t macPib;
  struct nwk_nib_t nwkNib;
  struct touchlink_attr_t touchlinkAttr;
  struct bdb_attr_t bdbAttr;
};

typedef struct sys_diagnostics_t sys_diagnostics_t, *Psys_diagnostics_t;

struct sys_diagnostics_t
{
  u16 numberOfResets;
  u16 persistentMemoryWrites;
  u32 macRxCrcFail;
  u32 macTxCcaFail;
  u32 macRxBcast;
  u32 macTxBcast;
  u32 macRxUcast;
  u32 macTxUcast;
  u16 macTxUcastRetry;
  u16 macTxUcastFail;
  u16 nwkTxCnt;
  u16 nwkTxEnDecryptFail;
  u16 apsRxBcast;
  u16 apsTxBcast;
  u16 apsRxUcast;
  u16 apsTxUcastSuccess;
  u16 apsTxUcastRetry;
  u16 apsTxUcastFail;
  u16 routeDiscInitiated;
  u16 neighborAdded;
  u16 neighborRemoved;
  u16 neighborStale;
  u16 joinIndication;
  u16 childMoved;
  u32 panIdConflictCheck;
  u16 nwkFCFailure;
  u16 apsFCFailure;
  u16 apsUnauthorizedKey;
  u16 nwkDecryptFailures;
  u16 apsDecryptFailures;
  u16 packetBufferAllocateFailures;
  u16 relayedUcast;
  u16 phytoMACqueuelimitreached;
  u16 packetValidateDropCount;
  u8 lastMessageLQI;
  s8 lastMessageRSSI;
  u8 macTxIrqTimeoutCnt;
  u8 macTxIrqCnt;
  u8 macRxIrqCnt;
  u8 phyLengthError;
  u8 panIdConflict;
  u8 panIdModified;
  u8 nwkAddrConflict;
};

typedef enum zb_ret_e
{
  RET_OK = 0,
  RET_ERROR = 1,
  RET_BLOCKED = 2,
  RET_EXIT = 3,
  RET_BUSY = 4,
  RET_EOF = 5,
  RET_OUT_OF_RANGE = 6,
  RET_EMPTY = 7,
  RET_CANCELLED = 8,
  RET_PENDING = 9,
  RET_NO_MEMORY = 10,
  RET_INVALID_PARAMETER = 11,
  RET_OPERATION_FAILED = 12,
  RET_BUFFER_TOO_SMALL = 13,
  RET_END_OF_LIST = 14,
  RET_ALREADY_EXISTS = 15,
  RET_NOT_FOUND = 16,
  RET_OVERFLOW = 17,
  RET_TIMEOUT = 18,
  RET_NOT_IMPLEMENTED = 19,
  RET_NO_RESOURCES = 20,
  RET_UNINITIALIZED = 21,
  RET_NO_SERVER = 22,
  RET_INVALID_STATE = 23,
  RET_DOES_NOT_EXIST = 24,
  RET_CONNECTION_FAILED = 25,
  RET_CONNECTION_LOST = 26,
  RET_CANCELLED_BY_USER = 27,
  RET_UNAUTHORIZED = 28,
  RET_CONFLICT = 29,
  RET_COULD_NOT_OPEN_FILE = 30,
  RET_NO_MATCH = 31,
  RET_PROTOCOL_ERROR = 32,
  RET_VERSION = 33,
  RET_MALFORMED_ADDRESS = 34,
  RET_COULD_NOT_READ_FILE = 35,
  RET_FILE_NOT_FOUND = 36,
  RET_DIRECTORY_NOT_FOUND = 37,
  RET_CONVERSION_ERROR = 38,
  RET_INCOMPATIBLE_TYPES = 39,
  RET_INCOMPATIBLE_TYPES_IN_COMPARE = 40,
  RET_INCOMPATIBLE_TYPES_IN_ASSIGNMENT = 41,
  RET_INCOMPATIBLE_TYPES_IN_EXPRESSION = 42,
  RET_ILLEGAL_COMPARE_OPERATION = 43,
  RET_FILE_CORRUPTED = 44,
  RET_PAGE_NOT_FOUND = 45,
  RET_FILE_WRITE_ERROR = 46,
  RET_FILE_READ_ERROR = 47,
  RET_FILE_PARTIAL_WRITE = 48,
  RET_TOO_MANY_OPEN_FILES = 49,
  RET_ILLEGAL_REQUEST = 50,
  RET_INVALID_BINDING = 51,
  RET_INVALID_GROUP = 52,
  RET_TABLE_FULL = 53,
  RET_NO_ACK = 54,
  RET_ACK_OK = 55,
  RET_NO_BOUND_DEVICE = 56,
  RET_BUF_FULL = 57
} zb_ret_e;

typedef struct bufm_vars bufm_vars, *Pbufm_vars;

typedef struct bufm_vars ev_buf_vars_t;

typedef struct ev_buf_groups_t ev_buf_groups_t, *Pev_buf_groups_t;

typedef struct mem_pool_t mem_pool_t, *Pmem_pool_t;

typedef struct mem_block_t mem_block_t, *Pmem_block_t;

struct ev_buf_groups_t
{
  struct mem_pool_t *qHead;
  u16 size;
  u8 availBufNum;
  u8 reserved;
};

struct bufm_vars
{
  struct ev_buf_groups_t bufGroups[4];
};

struct mem_block_t
{
  struct mem_block_t *next_block;
  char data[4];
};

struct mem_pool_t
{
  struct mem_block_t *free_list;
};

typedef enum startup_state_e
{
  SYSTEM_BOOT = 0,
  SYSTEM_DEEP_RETENTION = 1,
  SYSTEM_DEEP = 2
} startup_state_e;

typedef enum buf_sts_e
{
  BUFFER_SUCC = 0,
  BUFFER_INVALID_PARAMETER = 1,
  BUFFER_DUPLICATE_FREE = 2
} buf_sts_e;

typedef enum buf_sts_e buf_sts_t;

typedef struct ev_bufItem ev_bufItem, *Pev_bufItem;

struct ev_bufItem
{
  struct ev_bufItem *next;
  u32 groupIndex;
  u8 data[1];
};

typedef struct ev_bufItem ev_bufItem_t;

typedef struct zcl_triggerEffect_t zcl_triggerEffect_t, *Pzcl_triggerEffect_t;

struct zcl_triggerEffect_t
{
  u8 effectId;
  u8 effectVariant;
};

typedef struct zcl_identifyRspCmd_t zcl_identifyRspCmd_t, *Pzcl_identifyRspCmd_t;

struct zcl_identifyRspCmd_t
{
  u16 timeout;
};

typedef union zcl_identify_cmdPayload_t zcl_identify_cmdPayload_t, *Pzcl_identify_cmdPayload_t;

typedef struct zcl_identifyCmd_t zcl_identifyCmd_t, *Pzcl_identifyCmd_t;

struct zcl_identifyCmd_t
{
  u16 identifyTime;
};

union zcl_identify_cmdPayload_t
{
  struct zcl_identifyCmd_t identify;
  struct zcl_identifyRspCmd_t identifyRsp;
  struct zcl_triggerEffect_t triggerEffect;
};

typedef enum mid134051_write_status_bit_e
{
  FLASH_WRITE_STATUS_BP_MID134051 = 28
} mid134051_write_status_bit_e;

typedef enum mid134051_lock_block_e
{
  FLASH_LOCK_NONE_MID134051 = 0,
  FLASH_LOCK_LOW_504K_MID134051 = 4,
  FLASH_LOCK_LOW_496K_MID134051 = 8,
  FLASH_LOCK_LOW_480K_MID134051 = 12,
  FLASH_LOCK_LOW_448K_MID134051 = 16,
  FLASH_LOCK_LOW_384K_MID134051 = 20,
  FLASH_LOCK_LOW_256K_MID134051 = 24,
  FLASH_LOCK_ALL_512K_MID134051 = 28
} mid134051_lock_block_e;

typedef struct zcl_touchlinkAppCallbacks_t zcl_touchlinkAppCallbacks_t, *Pzcl_touchlinkAppCallbacks_t;

typedef void (*zcl_zllTouchLinkAppCallbacks_t)(u8, void *);

typedef void (*zcl_zllCommissionUtilityAppCallbacks_t)(u8, void *);

struct zcl_touchlinkAppCallbacks_t
{
  zcl_zllTouchLinkAppCallbacks_t touchLinkCallback;
  zcl_zllCommissionUtilityAppCallbacks_t utilityAppCallback;
};

typedef struct zcl_zllTouchLinkScanReq_t zcl_zllTouchLinkScanReq_t, *Pzcl_zllTouchLinkScanReq_t;

struct zcl_zllTouchLinkScanReq_t
{
  u32 transId;
  struct zll_tlZbInfo_t zbInfo;
  struct zll_tlZllInfo_t zllInfo;
};

typedef struct zcl_groupInfo zcl_groupInfo, *Pzcl_groupInfo;

struct zcl_groupInfo
{
  u16 groupId;
  u8 groupType;
};

typedef struct zcl_zllUtilityGetEpListResp_t zcl_zllUtilityGetEpListResp_t, *Pzcl_zllUtilityGetEpListResp_t;

typedef struct zcl_zllEndpointInfo_t zcl_zllEndpointInfo_t, *Pzcl_zllEndpointInfo_t;

struct zcl_zllEndpointInfo_t
{
  u16 nwkAddr;
  u8 epId;
  u16 profileId;
  u16 deviceId;
  u8 version;
};

struct zcl_zllUtilityGetEpListResp_t
{
  u8 total;
  u8 startIdx;
  u8 count;
  struct zcl_zllEndpointInfo_t *epInfoRecord;
};

typedef struct zcl_zllTouchLinkNetworkJoinResp_t zcl_zllTouchLinkNetworkJoinResp_t, *Pzcl_zllTouchLinkNetworkJoinResp_t;

struct zcl_zllTouchLinkNetworkJoinResp_t
{
  u32 transId;
  u8 status;
};

typedef struct zcl_zllDeviceInfoRec_t zcl_zllDeviceInfoRec_t, *Pzcl_zllDeviceInfoRec_t;

struct zcl_zllDeviceInfoRec_t
{
  addrExt_t ieeeAddr;
  u8 epId;
  u16 profileId;
  u16 deviceId;
  u8 version;
  u8 groupIdCnt;
  u8 sort;
};

typedef struct zcl_zllUtilityEndpointInfo_t zcl_zllUtilityEndpointInfo_t, *Pzcl_zllUtilityEndpointInfo_t;

struct zcl_zllUtilityEndpointInfo_t
{
  addrExt_t ieeeAddr;
  struct zcl_zllEndpointInfo_t info;
};

typedef struct zcl_zllTouchLinkNetworkStartResp_t zcl_zllTouchLinkNetworkStartResp_t, *Pzcl_zllTouchLinkNetworkStartResp_t;

struct zcl_zllTouchLinkNetworkStartResp_t
{
  u32 transId;
  u8 status;
  addrExt_t epanId;
  u8 nwkUpdateId;
  u8 logicalChannel;
  u16 panId;
};

typedef struct zcl_zllTouchLinkScanResp_t zcl_zllTouchLinkScanResp_t, *Pzcl_zllTouchLinkScanResp_t;

struct zcl_zllTouchLinkScanResp_t
{
  u32 transId;
  u8 rssiCorrection;
  struct zll_tlZbInfo_t zbInfo;
  struct zll_tlZllInfo_t zllInfo;
  u16 keyBitmask;
  u32 respId;
  addrExt_t epanId;
  u8 nwkUpdateId;
  u8 logicalChannel;
  u16 panId;
  u16 nwkAddr;
  u8 numOfSubdevices;
  u8 totalGroupIds;
  struct zcl_zllSubdeviceInfo_t subDevInfo;
};

typedef struct zcl_zllCommission_t zcl_zllCommission_t, *Pzcl_zllCommission_t;

struct zcl_zllCommission_t
{
  struct zcl_touchlinkAppCallbacks_t *appCb;
};

typedef struct zcl_zllTouchLinkDeviceInfoResp_t zcl_zllTouchLinkDeviceInfoResp_t, *Pzcl_zllTouchLinkDeviceInfoResp_t;

struct zcl_zllTouchLinkDeviceInfoResp_t
{
  u32 transId;
  u8 numOfSubdevices;
  u8 startIdx;
  u8 deviceInfoRecordCnt;
  struct zcl_zllDeviceInfoRec_t rec[0];
};

typedef struct zcl_zllUtilityGetGroupIdsResp_t zcl_zllUtilityGetGroupIdsResp_t, *Pzcl_zllUtilityGetGroupIdsResp_t;

struct zcl_zllUtilityGetGroupIdsResp_t
{
  u8 total;
  u8 startIdx;
  u8 count;
  struct zcl_groupInfo *groupInfoRecord;
};

typedef struct zcl_zllTouchLinkNetworkUpdateReq_t zcl_zllTouchLinkNetworkUpdateReq_t, *Pzcl_zllTouchLinkNetworkUpdateReq_t;

struct zcl_zllTouchLinkNetworkUpdateReq_t
{
  u32 transId;
  addrExt_t epanId;
  u8 nwkUpdateId;
  u8 logicalChannel;
  u16 panId;
  u16 nwkAddr;
};

typedef struct zcl_zllTouchLinkDeviceInfoReq_t zcl_zllTouchLinkDeviceInfoReq_t, *Pzcl_zllTouchLinkDeviceInfoReq_t;

struct zcl_zllTouchLinkDeviceInfoReq_t
{
  u32 transId;
  u8 startIdx;
};

typedef struct zcl_zllTouchLinkResetFactoryReq_t zcl_zllTouchLinkResetFactoryReq_t, *Pzcl_zllTouchLinkResetFactoryReq_t;

struct zcl_zllTouchLinkResetFactoryReq_t
{
  u32 transId;
};

typedef struct zcl_zllTouchLinkIdentifyReq_t zcl_zllTouchLinkIdentifyReq_t, *Pzcl_zllTouchLinkIdentifyReq_t;

struct zcl_zllTouchLinkIdentifyReq_t
{
  u32 transId;
  u16 identifyDuration;
};

typedef u8 kb_k_mp_t[1];

typedef struct tl_zb_neighbor_entry_t tl_zb_neighbor_entry_t, *Ptl_zb_neighbor_entry_t;

typedef struct nebTbl_t nebTbl_t, *PnebTbl_t;

typedef struct nebTbl_t tl_zb_normal_neighbor_entry_t;

struct nebTbl_t
{
  struct nebTbl_t *freeNext;
  struct nebTbl_t *activeNext;
  u32 authTimeout;
  u32 timeoutCnt;
  u32 devTimeout;
  u16 endDevCfg;
  u16 addrmapIdx;
  u32 incomingFrameCnt;
  u8 keySeqNum;
  u8 keepaliveRcvd;
  u8 rxOnWhileIdle : 1;
  u8 deviceType : 3;
  u8 relationship : 3;
  u8 used : 1;
  u8 age;
  u8 depth;
  u8 transFailure;
  u8 lqi;
  u8 outgoingCost;
};

struct tl_zb_neighbor_entry_t
{
  struct tl_zb_addition_neighbor_entry_t additionNeighborTbl[6];
  tl_zb_normal_neighbor_entry_t *freeHead;
  tl_zb_normal_neighbor_entry_t *activeHead;
  u8 additionNeighborNum;
  u8 normalNeighborNum;
  u8 childrenNum;
  u8 resv;
  tl_zb_normal_neighbor_entry_t neighborTbl[26];
};

typedef struct kb_data_t kb_data_t, *Pkb_data_t;

struct kb_data_t
{
  u8 cnt;
  u8 ctrl_key;
  u8 keycode[6];
};

typedef struct ev_poll_s ev_poll_s, *Pev_poll_s;

typedef struct ev_poll_s ev_poll_t;

typedef void (*ev_poll_callback_t)(void);

struct ev_poll_s
{
  ev_poll_callback_t cb;
  u32 valid;
};

typedef struct zcl_basicAttr_t zcl_basicAttr_t, *Pzcl_basicAttr_t;

struct zcl_basicAttr_t
{
  u8 zclVersion;
  u8 appVersion;
  u8 stackVersion;
  u8 hwVersion;
  u8 manuName[24];
  u8 modelId[24];
  u8 powerSource;
  u8 deviceEnable;
};

typedef struct zcl_identifyAttr_t zcl_identifyAttr_t, *Pzcl_identifyAttr_t;

struct zcl_identifyAttr_t
{
  u16 identifyTime;
};

typedef struct app_ctx_t app_ctx_t, *Papp_ctx_t;

struct app_ctx_t
{
  struct ev_timer_event_t *timerLedEvt;
  u32 keyPressedTime;
  u16 ledOnTime;
  u16 ledOffTime;
  u8 oriSta;
  u8 sta;
  u8 times;
  u8 state;
  u8 keyPressed;
};

typedef enum mid13325e_lock_block_e
{
  FLASH_LOCK_NONE_MID13325E = 0,
  FLASH_LOCK_LOW_504K_MID13325E = 4,
  FLASH_LOCK_LOW_496K_MID13325E = 8,
  FLASH_LOCK_LOW_480K_MID13325E = 12,
  FLASH_LOCK_LOW_448K_MID13325E = 16,
  FLASH_LOCK_LOW_384K_MID13325E = 20,
  FLASH_LOCK_LOW_256K_MID13325E = 24,
  FLASH_LOCK_ALL_512K_MID13325E = 28
} mid13325e_lock_block_e;

typedef enum mid13325e_write_status_bit_e
{
  FLASH_WRITE_STATUS_BP_MID13325E = 28
} mid13325e_write_status_bit_e;

typedef struct gpio_conf_list gpio_conf_list, *Pgpio_conf_list;

struct gpio_conf_list
{
  struct gpio_conf_list *next;
  irq_callback gpio_irq_callback;
  u32 pin;
  enum drv_gpioIrqMode_t mode;
  enum drv_gpioPoll_e polarity;
};

typedef u32 arg_t;

typedef s32 s24;

typedef u32 u24;

typedef u8 status_t;

typedef struct gp_stubCb_t gp_stubCb_t, *Pgp_stubCb_t;

typedef struct gp_data_cnf_t gp_data_cnf_t, *Pgp_data_cnf_t;

typedef void (*gpDataCnfCb_t)(struct gp_data_cnf_t *);

typedef void (*gpDataIndCb_t)(void *);

typedef void (*gpSecReqCb_t)(void *);

struct gp_data_cnf_t
{
  u8 status;
  u8 gpepHandle;
};

struct gp_stubCb_t
{
  gpDataCnfCb_t gpDataCnfCb;
  gpDataIndCb_t gpDataIndCb;
  gpSecReqCb_t gpSecReqCb;
};

typedef struct gp_data_ind_t gp_data_ind_t, *Pgp_data_ind_t;

struct gp_data_ind_t
{
  u8 *gpdAsdu;
  u32 srcId;
  u32 gpdSecFrameCnt;
  u32 mic;
  union tl_zb_addr_t srcAddr;
  u16 srcPanId;
  u8 autoCommissioning;
  u8 rxAfterTx;
  u8 status;
  s8 rssi;
  u8 lqi;
  u8 seqNum;
  u8 srcAddrMode;
  u8 appId;
  u8 gpdfSecurityLevel;
  u8 gpdfKeyType;
  u8 endpoint;
  u8 gpdCmdId;
  u8 gpdAsduLen;
  u8 frameType;
};

typedef struct gp_data_req_t gp_data_req_t, *Pgp_data_req_t;

typedef struct gpDataReq_txOpt_t gpDataReq_txOpt_t, *PgpDataReq_txOpt_t;

struct gpDataReq_txOpt_t
{
  u8 useGpTxQueue : 1;
  u8 useCSMACA : 1;
  u8 useMACACK : 1;
  u8 txFrameType : 2;
  u8 txOnMatchingEndpoint : 1;
  u8 reserved : 2;
};

struct gp_data_req_t
{
  u8 *gpdAsdu;
  u24 gpTxQueueEntryLifetime;
  union gpdId_t gpdId;
  struct gpDataReq_txOpt_t txOptions;
  u8 action;
  u8 appId;
  u8 endpoint;
  u8 gpdCmdId;
  u8 gpdAsduLen;
  u8 gpepHandle;
};

typedef struct gp_sec_rsp_t gp_sec_rsp_t, *Pgp_sec_rsp_t;

struct gp_sec_rsp_t
{
  union gpdId_t gpdId;
  u32 gpdSecFrameCnt;
  u8 status;
  u8 dgpStubHandle;
  u8 appId;
  u8 endpoint;
  u8 gpdKey[16];
  u8 gpdfSecurityLevel;
  u8 gpdfKeyType;
};

typedef u8 (*gpDeviceAnnounceCheckCb_t)(u16, u8 *);

typedef enum gpSecRsp_status_t
{
  GP_SEC_RSP_STATUS_DROP_FRAME = 0,
  GP_SEC_RSP_STATUS_MATCH = 1,
  GP_SEC_RSP_STATUS_PASS_UNPROCESSED = 2,
  GP_SEC_RSP_STATUS_TX_THEN_DROP = 3,
  GP_SEC_RSP_ERROR = 4
} gpSecRsp_status_t;

typedef struct gp_sec_req_t gp_sec_req_t, *Pgp_sec_req_t;

struct gp_sec_req_t
{
  union gpdId_t gpdId;
  u32 gpdSecFrameCnt;
  u8 appId;
  u8 endpoint;
  u8 gpdfSecurityLevel;
  u8 gpdfKeyType;
  u8 dgpStubHandle;
};

typedef enum mid14325e_lock_block_e
{
  FLASH_LOCK_NONE_MID14325E = 0,
  FLASH_LOCK_LOW_1016K_MID14325E = 4,
  FLASH_LOCK_LOW_1008K_MID14325E = 8,
  FLASH_LOCK_LOW_992K_MID14325E = 12,
  FLASH_LOCK_LOW_960K_MID14325E = 16,
  FLASH_LOCK_LOW_896K_MID14325E = 20,
  FLASH_LOCK_LOW_768K_MID14325E = 24,
  FLASH_LOCK_ALL_1M_MID14325E = 28
} mid14325e_lock_block_e;

typedef enum mid14325e_write_status_bit_e
{
  FLASH_WRITE_STATUS_BP_MID14325E = 28
} mid14325e_write_status_bit_e;

typedef struct queue_item queue_item, *Pqueue_item;

typedef struct queue_item queue_item_t;

struct queue_item
{
  struct queue_item *next;
  u32 idx;
  u8 data[1];
};

typedef enum ev_queue_sts_e
{
  QUEUE_SUCC = 0,
  QUEUE_INVALID_PARAMETER = 1,
  QUEUE_EMPTY = 2,
  QUEUE_NOT_FOUND = 3,
  QUEUE_OVERFLOW = 4
} ev_queue_sts_e;

typedef struct priQueue priQueue, *PpriQueue;

typedef u32 (*ev_priFunc_t)(arg_t);

struct priQueue
{
  queue_item_t *head;
  queue_item_t *tail;
  ev_priFunc_t priFunc;
  u32 curNum;
};

typedef enum ev_queue_sts_e ev_queue_sts_t;

typedef struct priQueue ev_queue_t;

typedef enum ADC_ModeTypeDef
{
  ADC_NORMAL_MODE = 0,
  ADC_RNS_MODE = 16
} ADC_ModeTypeDef;

typedef enum ADC_VbatDivTypeDef
{
  ADC_VBAT_DIVIDER_OFF = 0,
  ADC_VBAT_DIVIDER_1F4 = 1,
  ADC_VBAT_DIVIDER_1F3 = 2,
  ADC_VBAT_DIVIDER_1F2 = 3
} ADC_VbatDivTypeDef;

typedef enum ADC_SampCycTypeDef
{
  SAMPLING_CYCLES_3 = 0,
  SAMPLING_CYCLES_6 = 1,
  SAMPLING_CYCLES_9 = 2,
  SAMPLING_CYCLES_12 = 3,
  SAMPLING_CYCLES_15 = 4,
  SAMPLING_CYCLES_18 = 5,
  SAMPLING_CYCLES_21 = 6,
  SAMPLING_CYCLES_24 = 7,
  SAMPLING_CYCLES_27 = 8,
  SAMPLING_CYCLES_30 = 9,
  SAMPLING_CYCLES_33 = 10,
  SAMPLING_CYCLES_36 = 11,
  SAMPLING_CYCLES_39 = 12,
  SAMPLING_CYCLES_42 = 13,
  SAMPLING_CYCLES_45 = 14,
  SAMPLING_CYCLES_48 = 15
} ADC_SampCycTypeDef;

typedef enum ADC_RefVolTypeDef
{
  ADC_VREF_0P6V = 0,
  ADC_VREF_0P9V = 1,
  ADC_VREF_1P2V = 2,
  ADC_VREF_VBAT_N = 3
} ADC_RefVolTypeDef;

typedef enum ADC_InputPchTypeDef
{
  NOINPUTP = 0,
  B0P = 1,
  B1P = 2,
  B2P = 3,
  B3P = 4,
  B4P = 5,
  B5P = 6,
  B6P = 7,
  B7P = 8,
  C4P = 9,
  C5P = 10,
  PGA0P = 11,
  PGA1P = 12,
  TEMSENSORP = 13,
  RSVD_P = 14,
  VBAT = 15
} ADC_InputPchTypeDef;

typedef enum ADC_PreScalingTypeDef
{
  ADC_PRESCALER_1 = 0,
  ADC_PRESCALER_1F2 = 1,
  ADC_PRESCALER_1F4 = 2,
  ADC_PRESCALER_1F8 = 3
} ADC_PreScalingTypeDef;

typedef enum ADC_ResTypeDef
{
  RES8 = 0,
  RES10 = 1,
  RES12 = 2,
  RES14 = 3
} ADC_ResTypeDef;

typedef enum ADC_InputNchTypeDef
{
  NOINPUTN = 0,
  B0N = 1,
  B1N = 2,
  B2N = 3,
  B3N = 4,
  B4N = 5,
  B5N = 6,
  B6N = 7,
  B7N = 8,
  C4N = 9,
  C5N = 10,
  PGA0N = 11,
  PGA1N = 12,
  TEMSENSORN = 13,
  RSVD_N = 14,
  GND = 15
} ADC_InputNchTypeDef;

typedef enum ADC_InputModeTypeDef
{
  SINGLE_ENDED_MODE = 0,
  DIFFERENTIAL_MODE = 1
} ADC_InputModeTypeDef;

typedef enum ADC_Gain_BiasTypeDef
{
  GAIN_STAGE_BIAS_PER75 = 0,
  GAIN_STAGE_BIAS_PER100 = 1,
  GAIN_STAGE_BIAS_PER125 = 2,
  GAIN_STAGE_BIAS_PER150 = 3
} ADC_Gain_BiasTypeDef;

typedef enum ADC_ChTypeDef
{
  ADC_LEFT_CHN = 1,
  ADC_RIGHT_CHN = 2,
  ADC_MISC_CHN = 4,
  ADC_RNS_CHN = 8
} ADC_ChTypeDef;

typedef void (*uart_irq_callback)(void);

typedef u8 (*uart_data_send)(u8 *);

typedef struct drv_uart_t drv_uart_t, *Pdrv_uart_t;

struct drv_uart_t
{
  uart_irq_callback recvCb;
  uart_data_send send;
  u8 status;
};

typedef enum ev_poll_e
{
  EV_POLL_ED_DETECT = 0,
  EV_POLL_HCI = 1,
  EV_POLL_IDLE = 2,
  EV_POLL_MAX = 3
} ev_poll_e;

typedef struct zcl_gp_sinkTabReqCmd_t zcl_gp_sinkTabReqCmd_t, *Pzcl_gp_sinkTabReqCmd_t;

typedef union gpSinkProxyTabReqOpt_t gpSinkProxyTabReqOpt_t, *PgpSinkProxyTabReqOpt_t;

typedef struct anon_struct_1_3_f5c0072a_for_bits anon_struct_1_3_f5c0072a_for_bits, *Panon_struct_1_3_f5c0072a_for_bits;

struct anon_struct_1_3_f5c0072a_for_bits
{
  u8 appId : 3;
  u8 reqType : 2;
  u8 reserved : 3;
};

union gpSinkProxyTabReqOpt_t
{
  u8 opts;
  struct anon_struct_1_3_f5c0072a_for_bits bits;
};

struct zcl_gp_sinkTabReqCmd_t
{
  union gpdId_t gpdId;
  union gpSinkProxyTabReqOpt_t options;
  u8 endpoint;
  u8 index;
};

typedef union gpPairingCfgActions_t gpPairingCfgActions_t, *PgpPairingCfgActions_t;

typedef struct anon_struct_1_3_5e3c5bc5_for_bits anon_struct_1_3_5e3c5bc5_for_bits, *Panon_struct_1_3_5e3c5bc5_for_bits;

struct anon_struct_1_3_5e3c5bc5_for_bits
{
  u8 action : 3;
  u8 sendGpPairing : 1;
  u8 reserved : 4;
};

union gpPairingCfgActions_t
{
  u8 acts;
  struct anon_struct_1_3_5e3c5bc5_for_bits bits;
};

typedef struct gpSwitchInfo_t gpSwitchInfo_t, *PgpSwitchInfo_t;

typedef union gpGenericSwCfg_t gpGenericSwCfg_t, *PgpGenericSwCfg_t;

typedef struct anon_struct_1_3_82bade8a_for_bits anon_struct_1_3_82bade8a_for_bits, *Panon_struct_1_3_82bade8a_for_bits;

struct anon_struct_1_3_82bade8a_for_bits
{
  u8 contactNum : 4;
  u8 switchType : 2;
  u8 reserved : 2;
};

union gpGenericSwCfg_t
{
  u8 cfg;
  struct anon_struct_1_3_82bade8a_for_bits bits;
};

struct gpSwitchInfo_t
{
  u8 switchInfoLen;
  union gpGenericSwCfg_t switchCfg;
  u8 contactStatus;
};

typedef struct zcl_gp_proxyTabReqCmd_t zcl_gp_proxyTabReqCmd_t, *Pzcl_gp_proxyTabReqCmd_t;

struct zcl_gp_proxyTabReqCmd_t
{
  union gpdId_t gpdId;
  union gpSinkProxyTabReqOpt_t options;
  u8 endpoint;
  u8 index;
};

typedef struct zcl_gp_responseCmd_t zcl_gp_responseCmd_t, *Pzcl_gp_responseCmd_t;

typedef union gpResponseOpt_t gpResponseOpt_t, *PgpResponseOpt_t;

typedef struct anon_struct_1_3_7758d517_for_bits anon_struct_1_3_7758d517_for_bits, *Panon_struct_1_3_7758d517_for_bits;

struct anon_struct_1_3_7758d517_for_bits
{
  u8 appId : 3;
  u8 transmitOnEndpointMatch : 1;
  u8 reserved : 4;
};

union gpResponseOpt_t
{
  u8 opts;
  struct anon_struct_1_3_7758d517_for_bits bits;
};

struct zcl_gp_responseCmd_t
{
  union gpdId_t gpdId;
  u8 *pGpdCmdPayload;
  u16 tempMasterShortAddr;
  union gpResponseOpt_t options;
  u8 tempMasterTxChannel;
  u8 endpoint;
  u8 gpdCmdID;
  u8 payloadLen;
};

typedef union transUpdateOpt_t transUpdateOpt_t, *PtransUpdateOpt_t;

typedef struct anon_struct_2_5_6004e903_for_bits anon_struct_2_5_6004e903_for_bits, *Panon_struct_2_5_6004e903_for_bits;

struct anon_struct_2_5_6004e903_for_bits
{
  u16 appId : 3;
  u16 action : 2;
  u16 numOfTrans : 3;
  u16 addInfoPresent : 1;
  u16 reserved : 7;
};

union transUpdateOpt_t
{
  u16 opts;
  struct anon_struct_2_5_6004e903_for_bits bits;
};

typedef struct zcl_gp_sinkCommissioningModeCmd_t zcl_gp_sinkCommissioningModeCmd_t, *Pzcl_gp_sinkCommissioningModeCmd_t;

typedef union gpSinkCommModeOpt_t gpSinkCommModeOpt_t, *PgpSinkCommModeOpt_t;

typedef struct anon_struct_1_5_16a67af6_for_bits anon_struct_1_5_16a67af6_for_bits, *Panon_struct_1_5_16a67af6_for_bits;

struct anon_struct_1_5_16a67af6_for_bits
{
  u8 action : 1;
  u8 involveGpmInSec : 1;
  u8 involveGpmInPairing : 1;
  u8 involveProxies : 1;
  u8 reserved : 4;
};

union gpSinkCommModeOpt_t
{
  u8 opts;
  struct anon_struct_1_5_16a67af6_for_bits bits;
};

struct zcl_gp_sinkCommissioningModeCmd_t
{
  u16 gpmAddrForSec;
  u16 gpmAddrForPairing;
  union gpSinkCommModeOpt_t options;
  u8 sinkEndpoint;
};

typedef struct zcl_gp_transTabUpdateCmd_t zcl_gp_transTabUpdateCmd_t, *Pzcl_gp_transTabUpdateCmd_t;

struct zcl_gp_transTabUpdateCmd_t
{
  union gpdId_t gpdId;
  u8 *pBuf;
  union transUpdateOpt_t options;
  u8 endpoint;
  u8 bufLen;
};

typedef union gpAppInfo_t gpAppInfo_t, *PgpAppInfo_t;

typedef struct anon_struct_1_7_d4e04c6c_for_bits anon_struct_1_7_d4e04c6c_for_bits, *Panon_struct_1_7_d4e04c6c_for_bits;

struct anon_struct_1_7_d4e04c6c_for_bits
{
  u8 manuIdPresent : 1;
  u8 modelIdPresent : 1;
  u8 gpdCmdsPresent : 1;
  u8 clusterListPresent : 1;
  u8 switchInfoPresent : 1;
  u8 gpdAppDescCmdFollows : 1;
  u8 reserved : 2;
};

union gpAppInfo_t
{
  u8 info;
  struct anon_struct_1_7_d4e04c6c_for_bits bits;
};

typedef struct zcl_gp_pairingConfigurationCmd_t zcl_gp_pairingConfigurationCmd_t, *Pzcl_gp_pairingConfigurationCmd_t;

typedef union gpPairingCfgOpt_t gpPairingCfgOpt_t, *PgpPairingCfgOpt_t;

typedef struct anon_struct_2_9_82eff48e_for_bits anon_struct_2_9_82eff48e_for_bits, *Panon_struct_2_9_82eff48e_for_bits;

struct anon_struct_2_9_82eff48e_for_bits
{
  u16 appId : 3;
  u16 commMode : 2;
  u16 seqNumCap : 1;
  u16 rxOnCap : 1;
  u16 fixedLocation : 1;
  u16 assignedAlias : 1;
  u16 secUse : 1;
  u16 appInfoPresent : 1;
  u16 reserved : 5;
};

union gpPairingCfgOpt_t
{
  u16 opts;
  struct anon_struct_2_9_82eff48e_for_bits bits;
};

struct zcl_gp_pairingConfigurationCmd_t
{
  u8 *pGroupList;
  u8 *pPairedEndpoints;
  u8 *pGpdCmdList;
  u8 *pClusterList;
  u8 *pReportDescriptor;
  u32 gpdSecFrameCnt;
  u8 gpdSecKey[16];
  union gpdId_t gpdId;
  union gpPairingCfgOpt_t options;
  u16 gpdAssignedAlias;
  u16 manufacturerId;
  u16 modelId;
  union gpPairingCfgActions_t actions;
  union gpAppInfo_t appInfo;
  u8 endpoint;
  u8 deviceId;
  u8 groupcastRadius;
  union gpSecOpt_t secOptions;
  u8 numOfPairedEndpoints;
  struct gpSwitchInfo_t switchInfo;
  u8 numOfGpdCmds;
  u8 reportDescLen;
};

typedef struct zcl_gp_proxyCommissioningModeCmd_t zcl_gp_proxyCommissioningModeCmd_t, *Pzcl_gp_proxyCommissioningModeCmd_t;

struct zcl_gp_proxyCommissioningModeCmd_t
{
  union gpProxyCommModeOpt_t options;
  u8 channel;
  u16 commissioningWindow;
};

typedef struct zcl_gp_transTabRspCmd_t zcl_gp_transTabRspCmd_t, *Pzcl_gp_transTabRspCmd_t;

typedef union transOpt_t transOpt_t, *PtransOpt_t;

typedef struct anon_struct_1_3_e333aa94_for_bits anon_struct_1_3_e333aa94_for_bits, *Panon_struct_1_3_e333aa94_for_bits;

struct anon_struct_1_3_e333aa94_for_bits
{
  u8 appId : 3;
  u8 addInfoPresent : 1;
  u8 reserved : 4;
};

union transOpt_t
{
  u8 opts;
  struct anon_struct_1_3_e333aa94_for_bits bits;
};

struct zcl_gp_transTabRspCmd_t
{
  u8 *pBuf;
  u8 bufLen;
  u8 status;
  union transOpt_t options;
  u8 totalNumOfEntries;
  u8 startIdx;
  u8 entriesCnt;
};

typedef struct zcl_gp_pairingCmd_t zcl_gp_pairingCmd_t, *Pzcl_gp_pairingCmd_t;

typedef union gpPairingOpt_t gpPairingOpt_t, *PgpPairingOpt_t;

typedef struct anon_struct_3_13_2ec0ff9e_for_bits anon_struct_3_13_2ec0ff9e_for_bits, *Panon_struct_3_13_2ec0ff9e_for_bits;

struct anon_struct_3_13_2ec0ff9e_for_bits
{
  u24 appId : 3;
  u24 addSink : 1;
  u24 removeGPD : 1;
  u24 commMode : 2;
  u24 gpdFixed : 1;
  u24 gpdMacSeqNumCap : 1;
  u24 secLevel : 2;
  u24 secKeyType : 3;
  u24 gpdSecFrameCntPresent : 1;
  u24 gpdSecKeyPresent : 1;
  u24 assignedAliasPresent : 1;
  u24 groupcastRadiusPresent : 1;
  u24 reserved : 6;
};

union gpPairingOpt_t
{
  u24 opts;
  struct anon_struct_3_13_2ec0ff9e_for_bits bits;
};

struct zcl_gp_pairingCmd_t
{
  union gpdId_t gpdId;
  addrExt_t sinkIeeeAddr;
  union gpPairingOpt_t options;
  u32 gpdSecFrameCnt;
  u8 gpdKey[16];
  u16 sinkNwkAddr;
  u16 sinkGroupID;
  u16 assignedAlias;
  u8 endpoint;
  u8 deviceID;
  u8 groupcastRadius;
};

typedef struct zcl_gp_proxyTabRspCmd_t zcl_gp_proxyTabRspCmd_t, *Pzcl_gp_proxyTabRspCmd_t;

struct zcl_gp_proxyTabRspCmd_t
{
  u8 *proxyTabEntry;
  u8 entriesLen;
  u8 status;
  u8 totalTabEntries;
  u8 startIdx;
  u8 entriesCnt;
};

typedef struct zcl_gp_sinkTabRspCmd_t zcl_gp_sinkTabRspCmd_t, *Pzcl_gp_sinkTabRspCmd_t;

struct zcl_gp_sinkTabRspCmd_t
{
  u8 *sinkTabEntry;
  u8 entriesLen;
  u8 status;
  u8 totalTabEntries;
  u8 startIdx;
  u8 entriesCnt;
};

typedef struct zcl_gp_transTabReqCmd_t zcl_gp_transTabReqCmd_t, *Pzcl_gp_transTabReqCmd_t;

struct zcl_gp_transTabReqCmd_t
{
  u8 startIdx;
};

typedef enum mid1460c8_lock_block_e
{
  FLASH_LOCK_NONE_MID1460C8 = 0,
  FLASH_LOCK_LOW_1016K_MID1460C8 = 4,
  FLASH_LOCK_LOW_1008K_MID1460C8 = 8,
  FLASH_LOCK_LOW_992K_MID1460C8 = 12,
  FLASH_LOCK_LOW_960K_MID1460C8 = 16,
  FLASH_LOCK_LOW_896K_MID1460C8 = 20,
  FLASH_LOCK_LOW_768K_MID1460C8 = 24,
  FLASH_LOCK_ALL_1M_MID1460C8 = 28
} mid1460c8_lock_block_e;

typedef enum mid1460c8_write_status_bit_e
{
  FLASH_WRITE_STATUS_BP_MID1460C8 = 28
} mid1460c8_write_status_bit_e;

typedef enum ss_linkKeytype_e
{
  SS_UNIQUE_LINK_KEY = 0,
  SS_GLOBAL_LINK_KEY = 1
} ss_linkKeytype_e;

typedef struct ss_dev_pair_set_t ss_dev_pair_set_t, *Pss_dev_pair_set_t;

typedef enum ss_keyAttributes_e
{
  SS_PROVISIONAL_KEY = 0,
  SS_UNVERIFIED_KEY = 1,
  SS_VERIFIED_KEY = 2
} ss_keyAttributes_e;

struct ss_dev_pair_set_t
{
  addrExt_t device_address;
  u8 linkKey[16];
  enum ss_keyAttributes_e keyAttr;
  enum ss_linkKeytype_e apsLinkKeyType;
  u8 used;
  u8 rsv;
  u32 outgoingFrameCounter;
  u32 incomingFrameCounter;
};

typedef struct ss_tcUpdateNwkKey_t ss_tcUpdateNwkKey_t, *Pss_tcUpdateNwkKey_t;

struct ss_tcUpdateNwkKey_t
{
  addrExt_t dstAddr;
  u8 key[16];
};

typedef struct ss_material_set_t ss_material_set_t, *Pss_material_set_t;

struct ss_material_set_t
{
  u8 key[16];
  u8 keySeqNum;
  u8 keyType;
};

typedef struct ss_tcPolicy_t ss_tcPolicy_t, *Pss_tcPolicy_t;

struct ss_tcPolicy_t
{
  u8 useWhiteList;
  u8 allowInstallCode;
  u8 updateTCLKrequired;
  u8 allowJoins;
  u8 allowRejoins;
  u8 allowTCLKrequest;
  u8 allowAppLKrequest;
};

typedef enum ss_preconfiguredKey_e
{
  SS_PRECONFIGURED_NOKEY = 0,
  SS_PRECONFIGURED_GLOBALLINKKEY = 1,
  SS_PRECONFIGURED_UNIQUELLINKKEY = 2,
  SS_PRECONFIGURED_NWKKEY = 4
} ss_preconfiguredKey_e;

typedef enum ss_keyReqType_e
{
  SS_KEYREQ_TYPE_APPLK = 2,
  SS_KEYREQ_TYPE_TCLK = 4
} ss_keyReqType_e;

typedef struct ss_tc_keyPair_t ss_tc_keyPair_t, *Pss_tc_keyPair_t;

struct ss_tc_keyPair_t
{
  struct ss_dev_pair_set_t keyPair;
  u32 timeout;
};

typedef struct ss_apsmeRequestKeyReq_t ss_apsmeRequestKeyReq_t, *Pss_apsmeRequestKeyReq_t;

struct ss_apsmeRequestKeyReq_t
{
  union tl_zb_addr_t dstAddr;
  addrExt_t partnerAddr;
  u8 dstAddrMode;
  enum ss_keyReqType_e keyType;
};

typedef enum ss_apsmeUpdateDevStatus_e
{
  SS_STANDARD_DEV_SECURED_REJOIN = 0,
  SS_STANDARD_DEV_UNSECURED_JOIN = 1,
  SS_DEV_LEFT = 2,
  SS_STANDARD_DEV_TC_REJOIN = 3
} ss_apsmeUpdateDevStatus_e;

typedef struct ss_info_base_t ss_info_base_t, *Pss_info_base_t;

struct ss_info_base_t
{
  u32 ssTimeoutPeriod;
  u32 outgoingFrameCounter;
  u32 prevOutgoingFrameCounter;
  u8 *keyPairSetNew;
  struct ss_material_set_t nwkSecurMaterialSet[2];
  u16 devKeyPairNum;
  addrExt_t trust_center_address;
  u8 securityLevel : 3;
  u8 secureAllFresh : 1;
  u8 activeSecureMaterialIndex : 2;
  u8 reserved : 2;
  u8 activeKeySeqNum;
  enum ss_preconfiguredKey_e preConfiguredKeyType;
  struct ss_tcPolicy_t tcPolicy;
  u8 *touchLinkKey;
  u8 *distibuteLinkKey;
  u8 tcLinkKeyType;
  u8 *tcLinkKey;
};

typedef void **list_t;

typedef enum anon_enum_64.conflict2eacf{
    FLD_IRQ_EN = -16777216,
    FLD_IRQ_ALL = 0,
    FLD_IRQ_TMR0_EN = 1,
    FLD_IRQ_TMR1_EN = 2,
    FLD_IRQ_TMR2_EN = 4,
    FLD_IRQ_USB_PWDN_EN = 8,
    FLD_IRQ_DMA_EN = 16,
    FLD_IRQ_DAM_FIFO_EN = 32,
    FLD_IRQ_UART_EN = 64,
    FLD_IRQ_HOST_CMD_EN = 128,
    FLD_IRQ_MIX_CMD_EN = 128,
    FLD_IRQ_EP0_SETUP_EN = 256,
    FLD_IRQ_EP0_DAT_EN = 512,
    FLD_IRQ_EP0_STA_EN = 1024,
    FLD_IRQ_SET_INTF_EN = 2048,
    FLD_IRQ_EP_DATA_EN = 4096,
    FLD_IRQ_IRQ4_EN = 4096,
    FLD_IRQ_ZB_RT_EN = 8192,
    FLD_IRQ_SW_PWM_EN = 16384,
    FLD_IRQ_USB_250US_EN = 65536,
    FLD_IRQ_USB_RST_EN = 131072,
    FLD_IRQ_GPIO_EN = 262144,
    FLD_IRQ_PM_EN = 524288,
    FLD_IRQ_SYSTEM_TIMER = 1048576,
    FLD_IRQ_GPIO_RISC0_EN = 2097152,
    FLD_IRQ_GPIO_RISC1_EN = 4194304} anon_enum_64.conflict2eacf;

typedef enum anon_enum_32.conflict466a1{
    FLD_PWM_MAX = -65536,
    FLD_TMR0_EN = 1,
    FLD_TMR0_MODE = 6,
    FLD_TMR1_EN = 8,
    FLD_TMR1_MODE = 48,
    FLD_TMR2_EN = 64,
    FLD_TMR2_MODE = 384,
    FLD_PWM_CMP = 65535,
    FLD_TMR_WD_CAPT = 8388096,
    FLD_TMR_WD_EN = 8388608,
    FLD_TMR0_STA = 16777216,
    FLD_TMR1_STA = 33554432,
    FLD_TMR2_STA = 67108864,
    FLD_CLR_WD = 134217728} anon_enum_32.conflict466a1;

typedef struct nlme_reset_cnf_t nlme_reset_cnf_t, *Pnlme_reset_cnf_t;

typedef void (*zdo_nlmeResetCnfCb_t)(struct nlme_reset_cnf_t *);

struct nlme_reset_cnf_t
{
  u8 status;
};

typedef struct zdo_start_device_confirm_t zdo_start_device_confirm_t, *Pzdo_start_device_confirm_t;

struct zdo_start_device_confirm_t
{
  u8 status;
  u8 channel_num;
  u16 pan_id;
  u16 short_addr;
};

typedef void (*zdo_startDveCnfCb_t)(struct zdo_start_device_confirm_t *);

typedef struct nlme_leave_cnf_t nlme_leave_cnf_t, *Pnlme_leave_cnf_t;

typedef void (*zdo_leaveCnfCb_t)(struct nlme_leave_cnf_t *);

struct nlme_leave_cnf_t
{
  extAddr_t deviceAddr;
  u8 status;
};

typedef u8 (*zdo_touchLinkleaveCnfCb_t)(struct nlme_leave_cnf_t *);

typedef struct zdo_tc_join_ind_t zdo_tc_join_ind_t, *Pzdo_tc_join_ind_t;

struct zdo_tc_join_ind_t
{
  addrExt_t parentIeeeAddr;
  addrExt_t devIeeeAddr;
  u16 devShortAddr;
  enum ss_apsmeUpdateDevStatus_e sta;
};

typedef u8 (*zdo_tcJoinIndCb_t)(struct zdo_tc_join_ind_t *);

typedef void (*zdo_tcFrameCntReachedCb_t)(void);

typedef struct nlme_permitJoining_req_t nlme_permitJoining_req_t, *Pnlme_permitJoining_req_t;

typedef void (*zdo_permitJoinIndCb_t)(struct nlme_permitJoining_req_t *);

struct nlme_permitJoining_req_t
{
  u8 permitDuration;
};

typedef struct nwkCmd_nwkUpdate_t nwkCmd_nwkUpdate_t, *PnwkCmd_nwkUpdate_t;

typedef u8 (*zdo_nwkUpdateCb_t)(struct nwkCmd_nwkUpdate_t *);

typedef struct anon_struct_1_2_d8939d47_for_options anon_struct_1_2_d8939d47_for_options, *Panon_struct_1_2_d8939d47_for_options;

struct anon_struct_1_2_d8939d47_for_options
{
  u8 updateInfoCnt : 5;
  u8 updateCmdId : 3;
};

struct nwkCmd_nwkUpdate_t
{
  extPANId_t epid;
  u16 newPanId;
  struct anon_struct_1_2_d8939d47_for_options options;
  u8 updateId;
};

typedef struct zdo_device_annce_req_t zdo_device_annce_req_t, *Pzdo_device_annce_req_t;

typedef void (*zdo_dveAnnceIndCb_t)(struct zdo_device_annce_req_t *);

struct zdo_device_annce_req_t
{
  u16 nwk_addr_local;
  addrExt_t ieee_addr_local;
  struct capability_info_t mac_capability;
};

typedef struct zdo_attrCfg_t zdo_attrCfg_t, *Pzdo_attrCfg_t;

struct zdo_attrCfg_t
{
  u32 config_nwk_indirectPollRate;
  u16 config_nwk_time_btwn_scans;
  u8 config_nwk_scan_attempts;
  u8 config_permit_join_duration;
  u8 config_parent_link_retry_threshold;
  u8 config_rejoin_times;
  u16 config_rejoin_duration;
  u16 config_rejoin_backoff_time;
  u16 config_max_rejoin_backoff_time;
  u16 config_rejoin_backoff_iteration;
  u16 config_accept_nwk_update_pan_id;
  u8 config_accept_nwk_update_channel;
  u8 config_mgmt_leave_use_aps_sec;
  u8 config_use_tc_sec_on_nwk_key_rotation;
  u8 config_nwk_scan_duration;
};

typedef struct zdo_appIndCb_t zdo_appIndCb_t, *Pzdo_appIndCb_t;

typedef struct nlme_leave_ind_t nlme_leave_ind_t, *Pnlme_leave_ind_t;

typedef void (*zdo_leaveIndCb_t)(struct nlme_leave_ind_t *);

typedef struct nlme_sync_cnf_t nlme_sync_cnf_t, *Pnlme_sync_cnf_t;

typedef void (*zdo_nlmeSyncCnfCb_t)(struct nlme_sync_cnf_t *);

struct zdo_appIndCb_t
{
  zdo_startDveCnfCb_t zdpStartDevCnfCb;
  zdo_nlmeResetCnfCb_t zdpResetCnfCb;
  zdo_dveAnnceIndCb_t zdpDevAnnounceIndCb;
  zdo_leaveIndCb_t zdpLeaveIndCb;
  zdo_leaveCnfCb_t zdpLeaveCnfCb;
  zdo_nwkUpdateCb_t zdpNwkUpdateIndCb;
  zdo_permitJoinIndCb_t zdpPermitJoinIndCb;
  zdo_nlmeSyncCnfCb_t zdoNlmeSyncCnfCb;
  zdo_tcJoinIndCb_t zdoTcJoinIndCb;
  zdo_tcFrameCntReachedCb_t ssTcFrameCntReachedCb;
};

struct nlme_leave_ind_t
{
  extAddr_t deviceAddr;
  u8 rejoin;
};

struct nlme_sync_cnf_t
{
  u8 status;
};

typedef struct zdo_touchLinkCb_t zdo_touchLinkCb_t, *Pzdo_touchLinkCb_t;

typedef void (*nwk_touchLinkAttrClearCb_t)(void);

struct zdo_touchLinkCb_t
{
  zdo_touchLinkleaveCnfCb_t leaveCnfCb;
  nwk_touchLinkAttrClearCb_t attrClearCb;
};

typedef enum zdo_status_t
{
  ZDO_SUCCESS = 0,
  ZDO_NETWORK_LOST = 96,
  ZDO_INVALID_REQUEST = 128,
  ZDO_DEVICE_NOT_FOUND = 129,
  ZDO_INVALID_EP = 130,
  ZDO_NOT_ACTIVE = 131,
  ZDO_NOT_SUPPORTED = 132,
  ZDO_TIMEOUT = 133,
  ZDO_NO_MATCH = 134,
  ZDO_NO_ENTRY = 136,
  ZDO_NO_DESCRIPTOR = 137,
  ZDO_INSUFFICIENT_SPACE = 138,
  ZDO_NOT_PERMITTED = 139,
  ZDO_TABLE_FULL = 140,
  ZDO_NOT_AUTHORIZED = 141,
  ZDO_DEVICE_BINDING_TABLE_FALL = 142,
  ZDO_INVALID_INDEX = 143
} zdo_status_t;

typedef struct list list, *Plist;

struct list
{
  struct list *next;
};

typedef struct removeSceneRsp_t removeSceneRsp_t, *PremoveSceneRsp_t;

struct removeSceneRsp_t
{
  u8 status;
  u16 groupId;
  u8 sceneId;
};

typedef struct zcl_sceneTable_t zcl_sceneTable_t, *Pzcl_sceneTable_t;

typedef struct zcl_sceneEntry_t zcl_sceneEntry_t, *Pzcl_sceneEntry_t;

struct zcl_sceneEntry_t
{
  u16 groupId;
  u8 sceneId;
  u8 sceneName[16];
  u16 transTime;
  u16 transTime100ms;
  u8 extFieldLen;
  u8 extField[20];
};

struct zcl_sceneTable_t
{
  u8 used;
  u8 endpoint;
  struct zcl_sceneEntry_t scene;
};

typedef struct storeScene_t storeScene_t, *PstoreScene_t;

struct storeScene_t
{
  u16 groupId;
  u8 sceneId;
};

typedef struct recallScene_t recallScene_t, *PrecallScene_t;

struct recallScene_t
{
  u16 groupId;
  u16 transTime;
  u8 sceneId;
};

typedef struct viewScene_t viewScene_t, *PviewScene_t;

struct viewScene_t
{
  u16 groupId;
  u8 sceneId;
};

typedef struct removeAllScene_t removeAllScene_t, *PremoveAllScene_t;

struct removeAllScene_t
{
  u16 groupId;
};

typedef struct viewSceneRsp_t viewSceneRsp_t, *PviewSceneRsp_t;

struct viewSceneRsp_t
{
  u8 status;
  struct zcl_sceneEntry_t scene;
};

typedef struct addSceneRsp_t addSceneRsp_t, *PaddSceneRsp_t;

struct addSceneRsp_t
{
  u8 status;
  u16 groupId;
  u8 sceneId;
};

typedef struct getSceneMemRsp_t getSceneMemRsp_t, *PgetSceneMemRsp_t;

struct getSceneMemRsp_t
{
  u8 status;
  u8 capacity;
  u16 groupId;
  u8 sceneCnt;
  u8 *sceneList;
};

typedef struct getSceneMemship_t getSceneMemship_t, *PgetSceneMemship_t;

struct getSceneMemship_t
{
  u16 groupId;
};

typedef struct copySceneRsp_t copySceneRsp_t, *PcopySceneRsp_t;

struct copySceneRsp_t
{
  u8 status;
  u16 groupIdFrom;
  u8 sceneIdFrom;
};

typedef struct copyScene_t copyScene_t, *PcopyScene_t;

struct copyScene_t
{
  u8 mode;
  u16 groupIdFrom;
  u8 sceneIdFrom;
  u16 groupIdTo;
  u8 sceneIdTo;
};

typedef struct removeScene_t removeScene_t, *PremoveScene_t;

struct removeScene_t
{
  u16 groupId;
  u8 sceneId;
};

typedef struct removeAllSceneRsp_t removeAllSceneRsp_t, *PremoveAllSceneRsp_t;

struct removeAllSceneRsp_t
{
  u8 status;
  u16 groupId;
};

typedef struct storeSceneRsp_t storeSceneRsp_t, *PstoreSceneRsp_t;

struct storeSceneRsp_t
{
  u8 status;
  u16 groupId;
  u8 sceneId;
};

typedef struct addScene_t addScene_t, *PaddScene_t;

struct addScene_t
{
  struct zcl_sceneEntry_t scene;
};

typedef union zcl_scene_cmdPayload_t zcl_scene_cmdPayload_t, *Pzcl_scene_cmdPayload_t;

union zcl_scene_cmdPayload_t
{
  struct addSceneRsp_t addSceneRsp;
  struct viewSceneRsp_t viewSceneRsp;
  struct removeSceneRsp_t removeSceneRsp;
  struct removeAllSceneRsp_t removeAllSceneRsp;
  struct storeSceneRsp_t storeSceneRsp;
  struct getSceneMemRsp_t getSceneMembershipRsp;
  struct copySceneRsp_t copySceneRsp;
};

typedef enum mid1360eb_lock_block_e
{
  FLASH_LOCK_NONE_MID1360EB = 0,
  FLASH_LOCK_UP_64K_MID1360EB = 4,
  FLASH_LOCK_UP_128K_MID1360EB = 8,
  FLASH_LOCK_UP_256K_MID1360EB = 12,
  FLASH_LOCK_LOW_64K_MID1360EB = 36,
  FLASH_LOCK_LOW_128K_MID1360EB = 40,
  FLASH_LOCK_LOW_256K_MID1360EB = 44,
  FLASH_LOCK_UP_4K_MID1360EB = 68,
  FLASH_LOCK_UP_8K_MID1360EB = 72,
  FLASH_LOCK_UP_16K_MID1360EB = 76,
  FLASH_LOCK_UP_32K_MID1360EB = 80,
  FLASH_LOCK_LOW_4K_MID1360EB = 100,
  FLASH_LOCK_LOW_8K_MID1360EB = 104,
  FLASH_LOCK_LOW_16K_MID1360EB = 108,
  FLASH_LOCK_LOW_32K_MID1360EB = 112,
  FLASH_LOCK_ALL_512K_MID1360EB = 124,
  FLASH_LOCK_LOW_448K_MID1360EB = 16388,
  FLASH_LOCK_LOW_384K_MID1360EB = 16392,
  FLASH_LOCK_UP_448K_MID1360EB = 16420,
  FLASH_LOCK_UP_384K_MID1360EB = 16424,
  FLASH_LOCK_LOW_508K_MID1360EB = 16452,
  FLASH_LOCK_LOW_504K_MID1360EB = 16456,
  FLASH_LOCK_LOW_496K_MID1360EB = 16460,
  FLASH_LOCK_LOW_480K_MID1360EB = 16464,
  FLASH_LOCK_UP_508K_MID1360EB = 16484,
  FLASH_LOCK_UP_504K_MID1360EB = 16488,
  FLASH_LOCK_UP_496K_MID1360EB = 16492,
  FLASH_LOCK_UP_480K_MID1360EB = 16496
} mid1360eb_lock_block_e;

typedef enum mid1360eb_write_status_bit_e
{
  FLASH_WRITE_STATUS_OTP_MID1360EB = 14336,
  FLASH_WRITE_STATUS_BP_MID1360EB = 16508
} mid1360eb_write_status_bit_e;

typedef enum mid1360eb_lock_otp_e
{
  FLASH_LOCK_OTP_0x001000_512B_MID1360EB = 2048,
  FLASH_LOCK_OTP_0x002000_512B_MID1360EB = 4096,
  FLASH_LOCK_OTP_0x003000_512B_MID1360EB = 8192
} mid1360eb_lock_otp_e;

typedef enum mid1360eb_otp_block_e
{
  FLASH_OTP_0x001000_512B_MID1360EB = 4096,
  FLASH_OTP_0x002000_512B_MID1360EB = 8192,
  FLASH_OTP_0x003000_512B_MID1360EB = 12288
} mid1360eb_otp_block_e;

typedef struct zclHdr zclHdr, *PzclHdr;

typedef struct zclHdr zclHdr_t;

typedef union zclFrmCtrl zclFrmCtrl, *PzclFrmCtrl;

typedef union zclFrmCtrl zclFrmCtrl_t;

typedef struct anon_struct_1_5_6f9e5e00_for_bf anon_struct_1_5_6f9e5e00_for_bf, *Panon_struct_1_5_6f9e5e00_for_bf;

struct anon_struct_1_5_6f9e5e00_for_bf
{
  u8 type : 2;
  u8 manufSpec : 1;
  u8 dir : 1;
  u8 disDefResp : 1;
  u8 reserved : 3;
};

union zclFrmCtrl
{
  struct anon_struct_1_5_6f9e5e00_for_bf bf;
  u8 byte;
};

struct zclHdr
{
  zclFrmCtrl_t frmCtrl;
  u16 manufCode;
  u8 seqNum;
  u8 cmd;
};

typedef struct zclReportCmd_t zclReportCmd_t, *PzclReportCmd_t;

typedef struct zclReport_t zclReport_t, *PzclReport_t;

struct zclReport_t
{
  u16 attrID;
  u8 dataType;
  u8 *attrData;
};

struct zclReportCmd_t
{
  u8 numAttr;
  struct zclReport_t attrList[0];
};

typedef struct zclDefaultRspCmd_t zclDefaultRspCmd_t, *PzclDefaultRspCmd_t;

struct zclDefaultRspCmd_t
{
  u8 commandID;
  u8 statusCode;
};

typedef struct zcl_specClusterInfo_t zcl_specClusterInfo_t, *Pzcl_specClusterInfo_t;

typedef struct zclAttrInfo zclAttrInfo, *PzclAttrInfo;

typedef struct zclAttrInfo zclAttrInfo_t;

typedef struct zclIncomingAddrInfo_t zclIncomingAddrInfo_t, *PzclIncomingAddrInfo_t;

typedef status_t (*cluster_forAppCb_t)(struct zclIncomingAddrInfo_t *, u8, void *);

typedef status_t (*cluster_registerFunc_t)(u8, u16, u8, zclAttrInfo_t *, cluster_forAppCb_t);

struct zcl_specClusterInfo_t
{
  u16 clusterId;
  u16 manuCode;
  u16 attrNum;
  zclAttrInfo_t *attrTbl;
  cluster_registerFunc_t clusterRegisterFunc;
  cluster_forAppCb_t clusterAppCb;
};

struct zclIncomingAddrInfo_t
{
  u16 profileId;
  u16 srcAddr;
  u16 dstAddr;
  u8 srcEp;
  u8 dstEp;
  u8 seqNum;
  u8 dirCluster : 1;
  u8 apsSec : 1;
  u8 reserved : 6;
};

struct zclAttrInfo
{
  u16 id;
  u8 type;
  u8 access;
  u8 *data;
};

typedef struct zclReadCmd_t zclReadCmd_t, *PzclReadCmd_t;

struct zclReadCmd_t
{
  u8 numAttr;
  u16 attrID[0];
};

typedef struct zcl_reportingTab_t zcl_reportingTab_t, *Pzcl_reportingTab_t;

typedef struct reportCfgInfo_t reportCfgInfo_t, *PreportCfgInfo_t;

struct reportCfgInfo_t
{
  u16 profileID;
  u16 clusterID;
  u16 attrID;
  u16 minIntDft;
  u16 maxIntDft;
  u16 minInterval;
  u16 maxInterval;
  u16 minIntCnt;
  u16 maxIntCnt;
  u8 endPoint;
  u8 dataType;
  u8 reportableChange[8];
  u8 prevData[8];
  u8 used;
};

struct zcl_reportingTab_t
{
  u8 reportNum;
  struct reportCfgInfo_t reportCfgInfo[4];
};

typedef struct zclDiscoverAttrCmd_t zclDiscoverAttrCmd_t, *PzclDiscoverAttrCmd_t;

struct zclDiscoverAttrCmd_t
{
  u16 startAttr;
  u8 maxAttrIDs;
};

typedef struct zclCfgReportRspCmd_t zclCfgReportRspCmd_t, *PzclCfgReportRspCmd_t;

typedef struct zclCfgReportStatus_t zclCfgReportStatus_t, *PzclCfgReportStatus_t;

struct zclCfgReportStatus_t
{
  u8 status;
  u8 direction;
  u16 attrID;
};

struct zclCfgReportRspCmd_t
{
  u8 numAttr;
  struct zclCfgReportStatus_t attrList[0];
};

typedef struct zclDiscoverCmdsCmd_t zclDiscoverCmdsCmd_t, *PzclDiscoverCmdsCmd_t;

struct zclDiscoverCmdsCmd_t
{
  u8 startCmdID;
  u8 maxCmdID;
};

typedef struct clusterInfo_t clusterInfo_t, *PclusterInfo_t;

typedef struct zclIncoming_t zclIncoming_t, *PzclIncoming_t;

typedef status_t (*cluster_cmdHdlr_t)(struct zclIncoming_t *);

struct zclIncoming_t
{
  cluster_forAppCb_t clusterAppCb;
  apsdeDataInd_t *msg;
  u8 *pData;
  void *attrCmd;
  u16 dataLen;
  struct zclIncomingAddrInfo_t addrInfo;
  zclHdr_t hdr;
};

struct clusterInfo_t
{
  zclAttrInfo_t *attrTable;
  cluster_cmdHdlr_t cmdHandlerFunc;
  cluster_forAppCb_t clusterAppCb;
  u16 clusterID;
  u16 manuCode;
  u8 endpoint;
  u8 attrNum;
};

typedef struct zclReadRspCmd_t zclReadRspCmd_t, *PzclReadRspCmd_t;

typedef struct zclReadRspStatus_t zclReadRspStatus_t, *PzclReadRspStatus_t;

struct zclReadRspStatus_t
{
  u16 attrID;
  u8 status;
  u8 dataType;
  u8 *data;
};

struct zclReadRspCmd_t
{
  u8 numAttr;
  struct zclReadRspStatus_t attrList[0];
};

typedef struct zclCfgReportCmd_t zclCfgReportCmd_t, *PzclCfgReportCmd_t;

typedef struct zclCfgReportRec_t zclCfgReportRec_t, *PzclCfgReportRec_t;

struct zclCfgReportRec_t
{
  u8 direction;
  u16 attrID;
  u8 dataType;
  u16 minReportInt;
  u16 maxReportInt;
  u16 timeoutPeriod;
  u8 *reportableChange;
};

struct zclCfgReportCmd_t
{
  u8 numAttr;
  struct zclCfgReportRec_t attrList[0];
};

typedef struct zclWriteCmd_t zclWriteCmd_t, *PzclWriteCmd_t;

typedef struct zclWriteRec_t zclWriteRec_t, *PzclWriteRec_t;

struct zclWriteRec_t
{
  u16 attrID;
  u8 dataType;
  u8 *attrData;
};

struct zclWriteCmd_t
{
  u8 numAttr;
  struct zclWriteRec_t attrList[0];
};

typedef struct zclReadReportCfgCmd_t zclReadReportCfgCmd_t, *PzclReadReportCfgCmd_t;

typedef struct zclReadReportCfgRec_t zclReadReportCfgRec_t, *PzclReadReportCfgRec_t;

struct zclReadReportCfgRec_t
{
  u8 direction;
  u16 attrID;
};

struct zclReadReportCfgCmd_t
{
  u8 numAttr;
  struct zclReadReportCfgRec_t attrList[0];
};

typedef struct zclWriteRspCmd_t zclWriteRspCmd_t, *PzclWriteRspCmd_t;

typedef struct zclWriteRspStatus_t zclWriteRspStatus_t, *PzclWriteRspStatus_t;

struct zclWriteRspStatus_t
{
  u8 status;
  u16 attrID;
};

struct zclWriteRspCmd_t
{
  u8 numAttr;
  struct zclWriteRspStatus_t attrList[0];
};

typedef struct zclReadReportCfgRspCmd_t zclReadReportCfgRspCmd_t, *PzclReadReportCfgRspCmd_t;

typedef struct zclReportCfgRspRec_t zclReportCfgRspRec_t, *PzclReportCfgRspRec_t;

struct zclReportCfgRspRec_t
{
  u8 status;
  u8 direction;
  u16 attrID;
  u8 dataType;
  u16 minReportInt;
  u16 maxReportInt;
  u16 timeoutPeriod;
  u8 *reportableChange;
};

struct zclReadReportCfgRspCmd_t
{
  u8 numAttr;
  struct zclReportCfgRspRec_t attrList[0];
};

typedef struct zclExtAttrInfo_t zclExtAttrInfo_t, *PzclExtAttrInfo_t;

struct zclExtAttrInfo_t
{
  u16 attrID;
  u8 dataType;
  u8 accessControl;
};

typedef struct zclDiscoverAttrRspCmd_t zclDiscoverAttrRspCmd_t, *PzclDiscoverAttrRspCmd_t;

typedef struct zclDiscoverAttrInfo_t zclDiscoverAttrInfo_t, *PzclDiscoverAttrInfo_t;

struct zclDiscoverAttrInfo_t
{
  u16 attrID;
  u8 dataType;
};

struct zclDiscoverAttrRspCmd_t
{
  u8 discComplete;
  u8 numAttr;
  struct zclDiscoverAttrInfo_t attrList[0];
};

typedef struct zclDiscoverAttrExtRspCmd_t zclDiscoverAttrExtRspCmd_t, *PzclDiscoverAttrExtRspCmd_t;

struct zclDiscoverAttrExtRspCmd_t
{
  u8 discComplete;
  u8 numAttr;
  struct zclExtAttrInfo_t extAttrInfo[0];
};

typedef struct zcl_ctrl_t zcl_ctrl_t, *Pzcl_ctrl_t;

typedef void (*zcl_hookFn_t)(struct zclIncoming_t *);

struct zcl_ctrl_t
{
  zcl_hookFn_t hookFn;
  u16 reserved;
  u8 curState;
  u8 clusterNum;
  struct clusterInfo_t clusterList[16];
};

typedef struct mac_genFrame_t mac_genFrame_t, *Pmac_genFrame_t;

typedef struct mac_genFrame_t tx_data_queue;

struct mac_genFrame_t
{
  u8 fAck : 4;
  u8 fFramePending : 4;
  u8 psduLen;
  u8 cnfStatus;
  u8 seqNum;
  u8 *buf;
  u8 *txData;
  void *pendingList;
};

typedef struct nwk_txDataPendEntry_t nwk_txDataPendEntry_t, *Pnwk_txDataPendEntry_t;

struct nwk_txDataPendEntry_t
{
  void *srcBuf;
  u16 srcAddr;
  u16 dstAddr;
  u8 handle;
  u8 seqNum;
  u8 routeReqId;
  u8 expirationTime : 6;
  u8 needRouteDisc : 1;
  u8 used : 1;
};

typedef struct nwk_routingTabEntry_t nwk_routingTabEntry_t, *Pnwk_routingTabEntry_t;

struct nwk_routingTabEntry_t
{
  u16 dstAddr;
  u16 nextHopAddr;
  u8 status;
  u8 noRouteCache : 1;
  u8 manyToOne : 1;
  u8 routeRecordRequired : 1;
  u8 groupIdFlag : 1;
  u8 transFail : 4;
  u8 residCost;
  u8 forgetCnt;
};

typedef struct nwk_routeRecordTabEntry_t nwk_routeRecordTabEntry_t, *Pnwk_routeRecordTabEntry_t;

struct nwk_routeRecordTabEntry_t
{
  u16 nwkAddr;
  u16 path[8];
  u8 relayCnt : 7;
  u8 used : 1;
  u8 forgetCnt;
};

typedef struct nlme_leave_req_t nlme_leave_req_t, *Pnlme_leave_req_t;

struct nlme_leave_req_t
{
  extAddr_t deviceAddr;
  u8 removeChildren;
  u8 rejoin;
};

typedef struct nwk_brcTransRecordEntry_t nwk_brcTransRecordEntry_t, *Pnwk_brcTransRecordEntry_t;

struct nwk_brcTransRecordEntry_t
{
  struct nwk_txDataPendEntry_t *entry;
  struct ev_timer_event_t *retryTimer;
  u16 *passiveAckAddr;
  u16 srcAddr;
  u8 seqNum;
  u8 retries;
  u8 activeNum;
  u8 expirationTime;
  u8 status;
  u8 used;
};

typedef struct nlme_directJoin_req_t nlme_directJoin_req_t, *Pnlme_directJoin_req_t;

struct nlme_directJoin_req_t
{
  extAddr_t deviceAddr;
  u16 nwkAddr;
  struct capability_info_t capabilityInfo;
};

typedef struct ota_imageBlockRsp_t ota_imageBlockRsp_t, *Pota_imageBlockRsp_t;

typedef union imageBlockRsp_t imageBlockRsp_t, *PimageBlockRsp_t;

typedef struct ota_imageBlcokRspSuccess_t ota_imageBlcokRspSuccess_t, *Pota_imageBlcokRspSuccess_t;

typedef struct ota_imageBlcokRspWait_t ota_imageBlcokRspWait_t, *Pota_imageBlcokRspWait_t;

struct ota_imageBlcokRspSuccess_t
{
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
  u32 fileOffset;
  u8 dataSize;
  u8 *data;
};

struct ota_imageBlcokRspWait_t
{
  u32 currTime;
  u32 reqTime;
  u16 blockReqDelay;
};

union imageBlockRsp_t
{
  struct ota_imageBlcokRspSuccess_t success;
  struct ota_imageBlcokRspWait_t wait;
};

struct ota_imageBlockRsp_t
{
  u8 st;
  union imageBlockRsp_t rsp;
};

typedef struct ota_imagePageReq_t ota_imagePageReq_t, *Pota_imagePageReq_t;

struct ota_imagePageReq_t
{
  u8 fc;
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
  u32 fileOffset;
  u8 maxDataSize;
  u16 pageSize;
  u16 rspSpacing;
  addrExt_t reqNodeAddr;
};

typedef struct ota_querySpecFileRsp_t ota_querySpecFileRsp_t, *Pota_querySpecFileRsp_t;

struct ota_querySpecFileRsp_t
{
  u8 st;
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
  u32 imageSize;
};

typedef struct ota_imageNotify_t ota_imageNotify_t, *Pota_imageNotify_t;

struct ota_imageNotify_t
{
  u8 payloadType;
  u8 queryJitter;
  u16 manuCode;
  u16 imageType;
  u32 newFileVer;
};

typedef struct ota_imageBlockReq_t ota_imageBlockReq_t, *Pota_imageBlockReq_t;

struct ota_imageBlockReq_t
{
  u8 fc;
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
  u32 fileOffset;
  u8 maxDataSize;
  addrExt_t reqNodeAddr;
  u16 blockReqDelay;
};

typedef struct ota_queryNextImageReq_t ota_queryNextImageReq_t, *Pota_queryNextImageReq_t;

struct ota_queryNextImageReq_t
{
  u8 fc;
  u16 manuCode;
  u16 imageType;
  u32 curFileVer;
  u16 hdrwareVer;
};

typedef struct ota_upgradeEndRsp_t ota_upgradeEndRsp_t, *Pota_upgradeEndRsp_t;

struct ota_upgradeEndRsp_t
{
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
  u32 currentTime;
  u32 upgradeTime;
};

typedef struct ota_querySpecFileReq_t ota_querySpecFileReq_t, *Pota_querySpecFileReq_t;

struct ota_querySpecFileReq_t
{
  addrExt_t reqNodeAddr;
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
  u16 zbStackVer;
};

typedef struct ota_upgradeEndReq_t ota_upgradeEndReq_t, *Pota_upgradeEndReq_t;

struct ota_upgradeEndReq_t
{
  u8 st;
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
};

typedef struct ota_queryNextImageRsp_t ota_queryNextImageRsp_t, *Pota_queryNextImageRsp_t;

struct ota_queryNextImageRsp_t
{
  u8 st;
  u16 manuCode;
  u16 imageType;
  u32 fileVer;
  u32 imageSize;
};

typedef enum drv_adc_mode_t
{
  DRV_ADC_BASE_MODE = 0,
  DRV_ADC_VBAT_MODE = 1
} drv_adc_mode_t;

typedef enum zcl_colorLoopSetDir_t
{
  COLOR_LOOP_SET_DECREMENT = 0,
  COLOR_LOOP_SET_INCREMENT = 1
} zcl_colorLoopSetDir_t;

typedef struct zcl_colorCtrlEnhancedStepHueCmd_t zcl_colorCtrlEnhancedStepHueCmd_t, *Pzcl_colorCtrlEnhancedStepHueCmd_t;

typedef enum zcl_colorCtrlStepMode_t
{
  COLOR_CTRL_STEP_MODE_RESERVED1 = 0,
  COLOR_CTRL_STEP_MODE_UP = 1,
  COLOR_CTRL_STEP_MODE_RESERVED2 = 2,
  COLOR_CTRL_STEP_MODE_DOWN = 3
} zcl_colorCtrlStepMode_t;

struct zcl_colorCtrlEnhancedStepHueCmd_t
{
  enum zcl_colorCtrlStepMode_t stepMode;
  u16 stepSize;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveToColorTemperatureCmd_t zcl_colorCtrlMoveToColorTemperatureCmd_t, *Pzcl_colorCtrlMoveToColorTemperatureCmd_t;

struct zcl_colorCtrlMoveToColorTemperatureCmd_t
{
  u16 colorTemperature;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveColorTemperatureCmd_t zcl_colorCtrlMoveColorTemperatureCmd_t, *Pzcl_colorCtrlMoveColorTemperatureCmd_t;

typedef enum zcl_colorCtrlMoveMode_t
{
  COLOR_CTRL_MOVE_STOP = 0,
  COLOR_CTRL_MOVE_UP = 1,
  COLOR_CTRL_MOVE_RESERVED = 2,
  COLOR_CTRL_MOVE_DOWN = 3
} zcl_colorCtrlMoveMode_t;

struct zcl_colorCtrlMoveColorTemperatureCmd_t
{
  u16 rate;
  u16 colorTempMinMireds;
  u16 colorTempMaxMireds;
  enum zcl_colorCtrlMoveMode_t moveMode;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlColorLoopSetCmd_t zcl_colorCtrlColorLoopSetCmd_t, *Pzcl_colorCtrlColorLoopSetCmd_t;

typedef union zcl_colorLoopSetUpdateFlags_t zcl_colorLoopSetUpdateFlags_t, *Pzcl_colorLoopSetUpdateFlags_t;

typedef enum zcl_colorLoopSetAction_t
{
  COLOR_LOOP_SET_DEACTION = 0,
  COLOR_LOOP_SET_ACTION_FROM_COLOR_LOOP_START_ENHANCED_HUE = 1,
  COLOR_LOOP_SET_ACTION_FROM_ENHANCED_CURRENT_HUE = 2
} zcl_colorLoopSetAction_t;

typedef struct anon_struct_1_5_be55b9f2_for_bits anon_struct_1_5_be55b9f2_for_bits, *Panon_struct_1_5_be55b9f2_for_bits;

struct anon_struct_1_5_be55b9f2_for_bits
{
  u8 action : 1;
  u8 direction : 1;
  u8 time : 1;
  u8 startHue : 1;
  u8 reserved : 4;
};

union zcl_colorLoopSetUpdateFlags_t
{
  u8 updateFlags;
  struct anon_struct_1_5_be55b9f2_for_bits bits;
};

struct zcl_colorCtrlColorLoopSetCmd_t
{
  u16 time;
  u16 startHue;
  union zcl_colorLoopSetUpdateFlags_t updateFlags;
  enum zcl_colorLoopSetAction_t action;
  enum zcl_colorLoopSetDir_t direction;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef enum zcl_colorCtrlDir_t
{
  COLOR_CTRL_DIRECTION_SHORTEST_DISTANCE = 0,
  COLOR_CTRL_DIRECTION_LONGEST_DISTANCE = 1,
  COLOR_CTRL_DIRECTION_UP = 2,
  COLOR_CTRL_DIRECTION_DOWN = 3
} zcl_colorCtrlDir_t;

typedef struct zcl_colorCtrlStepColorTemperatureCmd_t zcl_colorCtrlStepColorTemperatureCmd_t, *Pzcl_colorCtrlStepColorTemperatureCmd_t;

struct zcl_colorCtrlStepColorTemperatureCmd_t
{
  u16 stepSize;
  u16 transitionTime;
  u16 colorTempMinMireds;
  u16 colorTempMaxMireds;
  enum zcl_colorCtrlStepMode_t stepMode;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlEnhancedMoveHueCmd_t zcl_colorCtrlEnhancedMoveHueCmd_t, *Pzcl_colorCtrlEnhancedMoveHueCmd_t;

struct zcl_colorCtrlEnhancedMoveHueCmd_t
{
  enum zcl_colorCtrlMoveMode_t moveMode;
  u16 rate;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveHueCmd_t zcl_colorCtrlMoveHueCmd_t, *Pzcl_colorCtrlMoveHueCmd_t;

struct zcl_colorCtrlMoveHueCmd_t
{
  enum zcl_colorCtrlMoveMode_t moveMode;
  u8 rate;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveToSaturationCmd_t zcl_colorCtrlMoveToSaturationCmd_t, *Pzcl_colorCtrlMoveToSaturationCmd_t;

struct zcl_colorCtrlMoveToSaturationCmd_t
{
  u8 saturation;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveToHueCmd_t zcl_colorCtrlMoveToHueCmd_t, *Pzcl_colorCtrlMoveToHueCmd_t;

struct zcl_colorCtrlMoveToHueCmd_t
{
  u8 hue;
  enum zcl_colorCtrlDir_t direction;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveSaturationCmd_t zcl_colorCtrlMoveSaturationCmd_t, *Pzcl_colorCtrlMoveSaturationCmd_t;

struct zcl_colorCtrlMoveSaturationCmd_t
{
  enum zcl_colorCtrlMoveMode_t moveMode;
  u8 rate;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlStepColorCmd_t zcl_colorCtrlStepColorCmd_t, *Pzcl_colorCtrlStepColorCmd_t;

struct zcl_colorCtrlStepColorCmd_t
{
  s16 stepX;
  s16 stepY;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlEnhancedMoveToHueCmd_t zcl_colorCtrlEnhancedMoveToHueCmd_t, *Pzcl_colorCtrlEnhancedMoveToHueCmd_t;

struct zcl_colorCtrlEnhancedMoveToHueCmd_t
{
  u16 enhancedHue;
  u16 transitionTime;
  enum zcl_colorCtrlDir_t direction;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlStopMoveStepCmd_t zcl_colorCtrlStopMoveStepCmd_t, *Pzcl_colorCtrlStopMoveStepCmd_t;

struct zcl_colorCtrlStopMoveStepCmd_t
{
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveToHueAndSaturationCmd_t zcl_colorCtrlMoveToHueAndSaturationCmd_t, *Pzcl_colorCtrlMoveToHueAndSaturationCmd_t;

struct zcl_colorCtrlMoveToHueAndSaturationCmd_t
{
  u8 hue;
  u8 saturation;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlStepSaturationCmd_t zcl_colorCtrlStepSaturationCmd_t, *Pzcl_colorCtrlStepSaturationCmd_t;

struct zcl_colorCtrlStepSaturationCmd_t
{
  enum zcl_colorCtrlStepMode_t stepMode;
  u8 stepSize;
  u8 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef struct zcl_colorCtrlMoveColorCmd_t zcl_colorCtrlMoveColorCmd_t, *Pzcl_colorCtrlMoveColorCmd_t;

struct zcl_colorCtrlMoveColorCmd_t
{
  s16 rateX;
  s16 rateY;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

typedef union zcl_colorCtrl_cmdPayload_t zcl_colorCtrl_cmdPayload_t, *Pzcl_colorCtrl_cmdPayload_t;

typedef struct zcl_colorCtrlStepHueCmd_t zcl_colorCtrlStepHueCmd_t, *Pzcl_colorCtrlStepHueCmd_t;

typedef struct zcl_colorCtrlMoveToColorCmd_t zcl_colorCtrlMoveToColorCmd_t, *Pzcl_colorCtrlMoveToColorCmd_t;

typedef struct zcl_colorCtrlEnhancedMoveToHueAndSaturationCmd_t zcl_colorCtrlEnhancedMoveToHueAndSaturationCmd_t, *Pzcl_colorCtrlEnhancedMoveToHueAndSaturationCmd_t;

struct zcl_colorCtrlStepHueCmd_t
{
  enum zcl_colorCtrlStepMode_t stepMode;
  u8 stepSize;
  u8 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

struct zcl_colorCtrlEnhancedMoveToHueAndSaturationCmd_t
{
  u16 enhancedHue;
  u16 transitionTime;
  u8 saturation;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

struct zcl_colorCtrlMoveToColorCmd_t
{
  u16 colorX;
  u16 colorY;
  u16 transitionTime;
  u8 optPresent;
  u8 optionsMask;
  u8 optionsOverride;
};

union zcl_colorCtrl_cmdPayload_t
{
  struct zcl_colorCtrlMoveToHueCmd_t moveToHue;
  struct zcl_colorCtrlMoveHueCmd_t moveHue;
  struct zcl_colorCtrlStepHueCmd_t stepHue;
  struct zcl_colorCtrlMoveToSaturationCmd_t moveToSaturation;
  struct zcl_colorCtrlMoveSaturationCmd_t moveSaturation;
  struct zcl_colorCtrlStepSaturationCmd_t stepSaturation;
  struct zcl_colorCtrlMoveToHueAndSaturationCmd_t moveToHueAndSaturation;
  struct zcl_colorCtrlMoveToColorCmd_t moveToColor;
  struct zcl_colorCtrlMoveColorCmd_t moveColor;
  struct zcl_colorCtrlStepColorCmd_t stepColor;
  struct zcl_colorCtrlMoveToColorTemperatureCmd_t moveToColorTemperature;
  struct zcl_colorCtrlEnhancedMoveToHueCmd_t enhancedMoveToHue;
  struct zcl_colorCtrlEnhancedMoveHueCmd_t enhancedMoveHue;
  struct zcl_colorCtrlEnhancedStepHueCmd_t enhancedStepHue;
  struct zcl_colorCtrlEnhancedMoveToHueAndSaturationCmd_t enhancedMoveToHueAndSaturation;
  struct zcl_colorCtrlColorLoopSetCmd_t colorLoopSet;
  struct zcl_colorCtrlStopMoveStepCmd_t stopMoveStep;
  struct zcl_colorCtrlMoveColorTemperatureCmd_t moveColorTemperature;
  struct zcl_colorCtrlStepColorTemperatureCmd_t stepColorTemperature;
};

typedef enum pwm_id
{
  PWM0_ID = 0,
  PWM1_ID = 1,
  PWM2_ID = 2,
  PWM3_ID = 3,
  PWM4_ID = 4,
  PWM5_ID = 5
} pwm_id;

typedef enum pwm_mode
{
  PWM_NORMAL_MODE = 0,
  PWM_COUNT_MODE = 1,
  PWM_IR_MODE = 3,
  PWM_IR_FIFO_MODE = 7,
  PWM_IR_DMA_FIFO_MODE = 15
} pwm_mode;

typedef enum drv_pm_wakeup_src_e
{
  PM_WAKEUP_SRC_PAD = 1,
  PM_WAKEUP_SRC_TIMER = 2
} drv_pm_wakeup_src_e;

typedef struct drv_pm_pinCfg_t drv_pm_pinCfg_t, *Pdrv_pm_pinCfg_t;

typedef enum drv_pm_wakeup_level_e
{
  PM_WAKEUP_LEVEL_LOW = 0,
  PM_WAKEUP_LEVEL_HIGH = 1
} drv_pm_wakeup_level_e;

struct drv_pm_pinCfg_t
{
  u32 wakeupPin;
  enum drv_pm_wakeup_level_e wakeupLevel;
};

typedef enum drv_pm_sleep_mode_e
{
  PM_SLEEP_MODE_SUSPEND = 0,
  PM_SLEEP_MODE_DEEPSLEEP = 1,
  PM_SLEEP_MODE_DEEP_WITH_RETENTION = 2,
  PM_SLEEP_MODE_MCU_STALL = 3
} drv_pm_sleep_mode_e;

typedef enum mid011460c8_lock_otp_e
{
  FLASH_LOCK_OTP_0x001000_512B_MID011460C8 = 2048,
  FLASH_LOCK_OTP_0x002000_512B_MID011460C8 = 4096,
  FLASH_LOCK_OTP_0x003000_512B_MID011460C8 = 8192
} mid011460c8_lock_otp_e;

typedef enum mid011460c8_lock_block_e
{
  FLASH_LOCK_NONE_MID011460C8 = 0,
  FLASH_LOCK_UP_64K_MID011460C8 = 4,
  FLASH_LOCK_UP_128K_MID011460C8 = 8,
  FLASH_LOCK_UP_256K_MID011460C8 = 12,
  FLASH_LOCK_UP_512K_MID011460C8 = 16,
  FLASH_LOCK_LOW_64K_MID011460C8 = 36,
  FLASH_LOCK_LOW_128K_MID011460C8 = 40,
  FLASH_LOCK_LOW_256K_MID011460C8 = 44,
  FLASH_LOCK_LOW_512K_MID011460C8 = 48,
  FLASH_LOCK_UP_4K_MID011460C8 = 68,
  FLASH_LOCK_UP_8K_MID011460C8 = 72,
  FLASH_LOCK_UP_16K_MID011460C8 = 76,
  FLASH_LOCK_UP_32K_MID011460C8 = 80,
  FLASH_LOCK_LOW_4K_MID011460C8 = 100,
  FLASH_LOCK_LOW_8K_MID011460C8 = 104,
  FLASH_LOCK_LOW_16K_MID011460C8 = 108,
  FLASH_LOCK_LOW_32K_MID011460C8 = 112,
  FLASH_LOCK_ALL_1M_MID011460C8 = 124,
  FLASH_LOCK_LOW_960K_MID011460C8 = 16388,
  FLASH_LOCK_LOW_896K_MID011460C8 = 16392,
  FLASH_LOCK_LOW_768K_MID011460C8 = 16396,
  FLASH_LOCK_UP_960K_MID011460C8 = 16420,
  FLASH_LOCK_UP_896K_MID011460C8 = 16424,
  FLASH_LOCK_UP_768K_MID011460C8 = 16428,
  FLASH_LOCK_LOW_1020K_MID011460C8 = 16452,
  FLASH_LOCK_LOW_1016K_MID011460C8 = 16456,
  FLASH_LOCK_LOW_1008K_MID011460C8 = 16460,
  FLASH_LOCK_LOW_992K_MID011460C8 = 16464,
  FLASH_LOCK_UP_1020K_MID011460C8 = 16484,
  FLASH_LOCK_UP_1016K_MID011460C8 = 16488,
  FLASH_LOCK_UP_1008K_MID011460C8 = 16492,
  FLASH_LOCK_UP_992K_MID011460C8 = 16496
} mid011460c8_lock_block_e;

typedef enum mid011460c8_write_status_bit_e
{
  FLASH_WRITE_STATUS_OTP_MID011460C8 = 14336,
  FLASH_WRITE_STATUS_BP_MID011460C8 = 16508
} mid011460c8_write_status_bit_e;

typedef enum mid011460c8_otp_block_e
{
  FLASH_OTP_0x001000_512B_MID011460C8 = 4096,
  FLASH_OTP_0x002000_512B_MID011460C8 = 8192,
  FLASH_OTP_0x003000_512B_MID011460C8 = 12288
} mid011460c8_otp_block_e;

typedef enum mid136085_lock_block_e
{
  FLASH_LOCK_NONE_MID136085 = 0,
  FLASH_LOCK_UP_64K_MID136085 = 4,
  FLASH_LOCK_UP_128K_MID136085 = 8,
  FLASH_LOCK_UP_256K_MID136085 = 12,
  FLASH_LOCK_LOW_64K_MID136085 = 36,
  FLASH_LOCK_LOW_128K_MID136085 = 40,
  FLASH_LOCK_LOW_256K_MID136085 = 44,
  FLASH_LOCK_UP_4K_MID136085 = 68,
  FLASH_LOCK_UP_8K_MID136085 = 72,
  FLASH_LOCK_UP_16K_MID136085 = 76,
  FLASH_LOCK_UP_32K_MID136085 = 80,
  FLASH_LOCK_LOW_4K_MID136085 = 100,
  FLASH_LOCK_LOW_8K_MID136085 = 104,
  FLASH_LOCK_LOW_16K_MID136085 = 108,
  FLASH_LOCK_LOW_32K_MID136085 = 112,
  FLASH_LOCK_ALL_512K_MID136085 = 124,
  FLASH_LOCK_LOW_448K_MID136085 = 16388,
  FLASH_LOCK_LOW_384K_MID136085 = 16392,
  FLASH_LOCK_UP_448K_MID136085 = 16420,
  FLASH_LOCK_UP_384K_MID136085 = 16424,
  FLASH_LOCK_LOW_508K_MID136085 = 16452,
  FLASH_LOCK_LOW_504K_MID136085 = 16456,
  FLASH_LOCK_LOW_496K_MID136085 = 16460,
  FLASH_LOCK_LOW_480K_MID136085 = 16464,
  FLASH_LOCK_UP_508K_MID136085 = 16484,
  FLASH_LOCK_UP_504K_MID136085 = 16488,
  FLASH_LOCK_UP_496K_MID136085 = 16492,
  FLASH_LOCK_UP_480K_MID136085 = 16496
} mid136085_lock_block_e;

typedef enum mid136085_otp_block_e
{
  FLASH_OTP_0x001000_512B_MID136085 = 4096,
  FLASH_OTP_0x002000_512B_MID136085 = 8192,
  FLASH_OTP_0x003000_512B_MID136085 = 12288
} mid136085_otp_block_e;

typedef enum mid136085_lock_otp_e
{
  FLASH_LOCK_OTP_0x001000_512B_MID136085 = 2048,
  FLASH_LOCK_OTP_0x002000_512B_MID136085 = 4096,
  FLASH_LOCK_OTP_0x003000_512B_MID136085 = 8192
} mid136085_lock_otp_e;

typedef enum mid136085_write_status_bit_e
{
  FLASH_WRITE_STATUS_OTP_MID136085 = 14336,
  FLASH_WRITE_STATUS_BP_MID136085 = 16508
} mid136085_write_status_bit_e;

typedef struct hwTmr_ctrl_t hwTmr_ctrl_t, *PhwTmr_ctrl_t;

typedef struct hwTmr_info_t hwTmr_info_t, *PhwTmr_info_t;

typedef struct ext_clk_t ext_clk_t, *Pext_clk_t;

typedef int (*timerCb_t)(void *);

typedef union anon_union_4_2_52a65ef8_for_flags anon_union_4_2_52a65ef8_for_flags, *Panon_union_4_2_52a65ef8_for_flags;

typedef struct anon_struct_4_2_fa1e252b_for_bf anon_struct_4_2_fa1e252b_for_bf, *Panon_struct_4_2_fa1e252b_for_bf;

struct anon_struct_4_2_fa1e252b_for_bf
{
  u32 status : 2;
  u32 reserved : 30;
};

union anon_union_4_2_52a65ef8_for_flags
{
  struct anon_struct_4_2_fa1e252b_for_bf bf;
  u32 byteVal;
};

struct ext_clk_t
{
  u32 low;
  u32 high;
};

struct hwTmr_info_t
{
  struct ext_clk_t expireInfo;
  timerCb_t cb;
  void *arg;
  union anon_union_4_2_52a65ef8_for_flags flags;
};

struct hwTmr_ctrl_t
{
  struct hwTmr_info_t timerInfo[4];
};

typedef enum anon_enum_8.conflict461{
    ADC_SAMPLE_RATE_23K = 0,
    APP_STATE_NORMAL = 0,
    APS_DSTADDR_EP_NOTPRESETNT = 0,
    APS_STATUS_SUCCESS = 0,
    AS_GPIO = 0,
    BDB_COMMISSIONING_ROLE_NONE = 0,
    BDB_COMMISSION_STA_SUCCESS = 0,
    BDB_EVT_IDLE = 0,
    BDB_INIT_STATUS_SUCCESS = 0,
    BDB_STATE_IDLE = 0,
    DEVELOPMENT_KEY = 0,
    DEVICE_TYPE_COORDINATOR = 0,
    DRV_ADC_BASE_MODE = 0,
    EV_POLL_ED_DETECT = 0,
    FLASH_TYPE_8BIT_STATUS = 0,
    FLASH_VOLTAGE_1V6 = 0,
    GPS_COMM_MODE_FULL_UNICAST = 0,
    GP_DATA_CNF_STATUS_TX_QUEUE_FULL = 0,
    GP_DATA_IND_STATUS_SEC_SUCCESS = 0,
    GP_NWK_FRAME_TYPE_DATA = 0,
    GP_SEC_KEY_TYPE_NO_KEY = 0,
    GP_SEC_LEVEL_NO_SECURITY = 0,
    IDENTIFY_EFFECT_BLINK = 0,
    LINKKEY_TYPE_TC = 0,
    MAC_CAP_DEVICE_TYPE_RFD = 0,
    MAC_PHY_ATTR_CURRENT_CHANNEL = 0,
    MAC_SUCCESS = 0,
    MCU_STATUS_BOOT = 0,
    NO_ACTION = 0,
    NV_ERASE_NONE = 0,
    NV_ITEM_ID_INVALID = 0,
    NV_MODULE_ZB_INFO = 0,
    NV_SUCC = 0,
    NWK_ADDRESS_ALLOC_METHOD_DISTRIBUTED = 0,
    OTA_EVT_START = 0,
    OTA_FLAG_INIT_DONE = 0,
    OTA_TYPE_CLIENT = 0,
    PARITY_NONE = 0,
    PHY_CCA_BUSY = 0,
    PM_PIN_UP_DOWN_FLOAT = 0,
    REJOIN_INSECURITY = 0,
    REQUEST_TABLE_ENTRIES_BY_GPD_ID = 0,
    RF_MODE_TX = 0,
    RF_POWER_INDEX_P10p46dBm = 0,
    RF_STATE_TX = 0,
    SS_SEMODE_CENTRALIZED = 0,
    SS_UNIQUE_LINK_KEY = 0,
    STOP_BIT_ONE = 0,
    SYS_CLK_24M_RC = 0,
    SYS_EXCEPTTION_COMMON_MEM_ACCESS = 0,
    TCKEY_EXCHANGE_METHOD_APSRK = 0,
    UART_STA_IDLE = 0,
    ZB_MAC_STATE_NORMAL = 0,
    ZB_RET_OK = 0,
    ZB_STACKVER_2006 = 0,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_TO_HUE = 0,
    ZCL_ZLL_COMMISSIONING_TOUCH_LICK_MODE_START = 0,
    ZCL_ZLL_COMMISSION_STATE_IDLE = 0,
    ZCL_ZLL_TOUCH_LINK_STA_SUCC = 0,
    ZDO_SUCCESS = 0,
    ADC_SAMPLE_RATE_96K = 1,
    APP_FACTORY_NEW_SET_CHECK = 1,
    APS_SHORT_GROUPADDR_NOEP = 1,
    AS_MSPI = 1,
    BDB_COMMISSIONING_ROLE_INITIATOR = 1,
    BDB_COMMISSION_STA_IN_PROGRESS = 1,
    BDB_EVT_INIT_DONE = 1,
    BDB_INIT_STATUS_FAILURE = 1,
    BDB_STATE_INIT = 1,
    DEVICE_TYPE_ROUTER = 1,
    DRV_ADC_VBAT_MODE = 1,
    EV_POLL_HCI = 1,
    EXIT_ON_FIRST_PAIRING_SUCCESS = 1,
    EXTEND_SINK_TABLE_ENTRY = 1,
    FLASH_TYPE_16BIT_STATUS_ONE_CMD = 1,
    FLASH_VOLTAGE_1V65 = 1,
    FLASH_WRITE_STATUS_CMD_LOWBYTE = 1,
    FLD_AUD_DFIFO0_IN = 1,
    FLD_DMA_CHN0 = 1,
    FLD_DMA_CHN_UART_RX = 1,
    FLD_MSPI_CS = 1,
    FLD_RST0_SPI = 1,
    FLD_RST1_ZB = 1,
    FLD_SYSTEM_TICK_START = 1,
    FLD_TMR_STA_TMR0 = 1,
    GPS_COMM_MODE_GROUP_DGROUPID = 1,
    GP_DATA_CNF_STATUS_ENTRY_REPLACED = 1,
    GP_DATA_IND_STATUS_NO_SECURITY = 1,
    GP_NWK_FRAME_TYPE_MAINTENANCE = 1,
    GP_SEC_KEY_TYPE_NWK_KEY = 1,
    GP_SEC_LEVEL_RESERVED = 1,
    IDENTIFY_EFFECT_BREATHE = 1,
    LINKKEY_TYPE_GB = 1,
    MAC_CAP_ALTERNATE_PAN_COORDINATOR = 1,
    MAC_STA_PAN_AT_CAPACITY = 1,
    MCU_STATUS_DEEPRET_BACK = 1,
    NV_INVALID_MODULS = 1,
    NV_ITEM_ZB_INFO = 1,
    NV_MODULE_ADDRESS_TABLE = 1,
    NWK_ADDRESS_ALLOC_METHOD_RESERVER = 1,
    OTA_EVT_IMAGE_DONE = 1,
    OTA_FLAG_IMAGE_PULL_READY = 1,
    OTA_TYPE_SERVER = 1,
    PARITY_EVEN = 1,
    PM_PIN_PULLUP_1M = 1,
    REJOIN_SECURITY = 1,
    REQUEST_TABLE_ENTRIES_BY_INDEX = 1,
    RF_MODE_RX = 1,
    RF_POWER_INDEX_P10p29dBm = 1,
    RF_STATE_RX = 1,
    RX_BUSY = 1,
    SS_GLOBAL_LINK_KEY = 1,
    SS_SEMODE_DISTRIBUTED = 1,
    SYS_CLK_32M_RC = 1,
    SYS_EXCEPTTION_COMMON_TIMER_EVEVT = 1,
    TCKEY_EXCHANGE_METHOD_CBKE = 1,
    UART_STA_TX_DOING = 1,
    VK_SW1 = 1,
    ZB_MAC_STATE_ED_SCAN = 1,
    ZB_RET_OVERFLOW = 1,
    ZB_STACKVER_2007 = 1,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_HUE = 1,
    ZCL_ZLL_COMMISSIONING_TOUCH_LICK_MODE_JOIN = 1,
    ZCL_ZLL_COMMISSION_STATE_TOUCHLINK_DISCOVERY = 1,
    ZCL_ZLL_TOUCH_LINK_FAIL = 1,
    ADC_SAMPLE_RATE_192K = 2,
    APS_SHORT_DSTADDR_WITHEP = 2,
    AS_SWIRE = 2,
    BDB_COMMISSIONING_ROLE_TARGET = 2,
    BDB_COMMISSION_STA_NOT_AA_CAPABLE = 2,
    BDB_EVT_COMMISSIONING_START = 2,
    BDB_STATE_COMMISSIONING_TOUCHLINK = 2,
    DEVICE_TYPE_END_DEVICE = 2,
    EV_POLL_IDLE = 2,
    EXIT_ON_GP_PROXY_COMMISSIONING_MODE = 2,
    FLASH_TYPE_16BIT_STATUS_TWO_CMD = 2,
    FLASH_VOLTAGE_1V7 = 2,
    FLASH_WRITE_CMD = 2,
    FLD_AUD_DFIFO1_IN = 2,
    FLD_DMA_CHN1 = 2,
    FLD_DMA_CHN_UART_TX = 2,
    FLD_MSPI_SDO = 2,
    FLD_RST0_I2C = 2,
    FLD_RST1_SYS_TIMER = 2,
    FLD_SYSTEM_TICK_IRQ_EN = 2,
    FLD_SYSTEM_TICK_RUNNING = 2,
    FLD_SYSTEM_TICK_STOP = 2,
    FLD_TMR_STA_TMR1 = 2,
    GPS_COMM_MODE_GROUP_PRE_COMMISSIONED_GROUPID = 2,
    GP_DATA_CNF_STATUS_ENTRY_ADDED = 2,
    GP_DATA_IND_STATUS_CNT_FAILURE = 2,
    GP_SEC_KEY_TYPE_GPD_GROUP_KEY = 2,
    GP_SEC_LEVEL_4BFC_4BMIC = 2,
    IDENTIFY_EFFECT_OKAY = 2,
    LINKKEY_TYPE_PRECONFIG = 2,
    MAC_CAP_DEVICE_TYPE_FFD = 2,
    MAC_STA_PAN_ACCESS_DENIED = 2,
    MCU_STATUS_DEEP_BACK = 2,
    NV_INVALID_ID = 2,
    NV_ITEM_ADDRESS_FOR_NEIGHBOR = 2,
    NV_MODULE_APS = 2,
    NWK_ADDRESS_ALLOC_METHOD_STOCHASTIC = 2,
    OTA_EVT_COMPLETE = 2,
    OTA_FLAG_IMAGE_PULL_CONTINUE = 2,
    PARITY_ODD = 2,
    PM_PIN_PULLDOWN_100K = 2,
    REPLACE_SINK_TABLE_ENTRY = 2,
    RF_MODE_AUTO = 2,
    RF_POWER_INDEX_P10p01dBm = 2,
    RF_STATE_ED = 2,
    SYS_CLK_48M_RC = 2,
    SYS_EXCEPTTION_COMMON_BUFFER_OVERFLOWN = 2,
    TCKEY_EXCHANGE_METHOD_RESV = 2,
    TX_BUSY = 2,
    UART_STA_TX_DONE = 2,
    VK_SW2 = 2,
    ZB_MAC_STATE_ACTIVE_SCAN = 2,
    ZB_STACKVER_PRO = 2,
    ZCL_CMD_LIGHT_COLOR_CONTROL_STEP_HUE = 2,
    ZCL_ZLL_COMMISSION_STATE_TOUCHLINK_DEVICE_INFO_EXCHANGE = 2,
    ZCL_ZLL_TOUCH_LINK_STA_NO_SERVER = 2,
    APS_LONG_DSTADDR_WITHEP = 3,
    AS_UART = 3,
    BDB_COMMISSION_STA_NO_NETWORK = 3,
    BDB_EVT_COMMISSIONING_TOUCHLINK_NO_RESP = 3,
    BDB_STATE_COMMISSIONING_NETWORK_STEER = 3,
    EV_POLL_MAX = 3,
    FLASH_READ_CMD = 3,
    FLASH_VOLTAGE_1V75 = 3,
    FLD_ADC_ITRIM_PREAMP = 3,
    FLD_ADC_RES_L = 3,
    FLD_ADC_RES_M = 3,
    FLD_PGA_ITRIM_GAIN_L = 3,
    GPS_COMM_MODE_LIGHTWEIGHT_UNICAST = 3,
    GP_DATA_CNF_STATUS_ENTRY_EXPIRED = 3,
    GP_DATA_IND_STATUS_AUTH_FAILURE = 3,
    GP_SEC_KEY_TYPE_NWK_KEY_DERIVED_GPD_GROUP_KEY = 3,
    GP_SEC_LEVEL_4BFC_4BMIC_ENCRYPTION = 3,
    LINKKEY_TYPE_TL_PRECONFIG = 3,
    MAC_PHY_ATTR_MODE_CCA = 3,
    NV_ITEM_ADDRESS_FOR_BIND = 3,
    NV_ITEM_NOT_FOUND = 3,
    NV_MODULE_ZCL = 3,
    OTA_FLAG_IMAGE_MAGIC_0 = 3,
    PHY_CCA_TRX_OFF = 3,
    PM_PIN_PULLUP_10K = 3,
    REMOVE_A_PAIRING = 3,
    RF_MODE_OFF = 3,
    RF_POWER_INDEX_P9p81dBm = 3,
    RF_STATE_OFF = 3,
    SYS_EXCEPTTION_COMMON_STACK_OVERFLOWN = 3,
    UART_STA_RX_DONE = 3,
    ZB_MAC_STATE_ORPHAN_SCAN = 3,
    ZB_STACKVER_IP = 3,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_TO_SATURATION = 3,
    ZCL_ZLL_COMMISSION_STATE_TOUCHLINK_IDENTIFY = 3,
    ZCL_ZLL_TOUCH_LINK_STA_EXIST = 3,
    AS_I2C = 4,
    BDB_COMMISSION_STA_TARGET_FAILURE = 4,
    BDB_EVT_COMMISSIONING_TOUCHLINK_FINISH = 4,
    BDB_STATE_COMMISSIONING_NETWORK_FORMATION = 4,
    FLASH_VOLTAGE_1V8 = 4,
    FLASH_WRITE_DISABLE_CMD = 4,
    FLD_AUD_DFIFO2_IN = 4,
    FLD_DMA_CHN2 = 4,
    FLD_DMA_CHN_RF_RX = 4,
    FLD_GPIO_CORE_WAKEUP_EN = 4,
    FLD_MSPI_CONT = 4,
    FLD_RST0_UART = 4,
    FLD_RST1_DMA = 4,
    FLD_TMR_STA_TMR2 = 4,
    GP_DATA_CNF_STATUS_ENTRY_REMOVED = 4,
    GP_DATA_IND_STATUS_UNPROCESSED = 4,
    GP_SEC_KEY_TYPE_OUT_OF_THE_BOX_GPD_KEY = 4,
    MAC_CAP_POWER_SOURCE_MAINS = 4,
    MAC_PHY_ATTR_CURRENT_PAGE = 4,
    MASTER_KEY = 4,
    NV_ITEM_APS_SSIB = 4,
    NV_MODULE_NWK_FRAME_COUNT = 4,
    NV_NOT_ENOUGH_SAPCE = 4,
    OTA_FLAG_IMAGE_MAGIC_1 = 4,
    PHY_CCA_IDLE = 4,
    REMOVE_GPD = 4,
    RF_POWER_INDEX_P9p48dBm = 4,
    SYS_EXCEPTTION_COMMON_PARAM_ERROR = 4,
    TX_ACKPACKET = 4,
    ZB_MAC_STATE_PASSIVE_SCAN = 4,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_SATURATION = 4,
    ZCL_ZLL_TOUCH_LINK_STA_NOT_PERMITTED = 4,
    APPLICATION_DESCRIPTION = 5,
    AS_SPI = 5,
    BDB_COMMISSION_STA_FORMATION_FAILURE = 5,
    BDB_EVT_COMMISSIONING_NETWORK_STEER_PERMITJOIN = 5,
    BDB_STATE_COMMISSIONING_FINDORBIND = 5,
    FLASH_READ_STATUS_CMD_LOWBYTE = 5,
    FLASH_VOLTAGE_1V85 = 5,
    GP_DATA_CNF_STATUS_GPDF_SENDING_FINALIZED = 5,
    NV_ITEM_APS_GROUP_TABLE = 5,
    NV_ITEM_LEN_NOT_MATCH = 5,
    NV_MODULE_OTA = 5,
    OTA_FLAG_IMAGE_MAGIC_2 = 5,
    RF_POWER_INDEX_P9p24dBm = 5,
    SYS_EXCEPTTION_COMMON_TASK_POST = 5,
    ZB_MAC_STATE_INDIRECT_DATA = 5,
    ZCL_CMD_LIGHT_COLOR_CONTROL_STEP_SATURATION = 5,
    ZCL_ZLL_TOUCH_LINK_STA_TIMEOUT = 5,
    AS_I2S = 6,
    BDB_COMMISSION_STA_NO_IDENTIFY_QUERY_RESPONSE = 6,
    BDB_EVT_COMMISSIONING_NETWORK_STEER_RETRIEVE_TCLINK_KEY = 6,
    BDB_STATE_COMMISSIONING_BUSY = 6,
    FLASH_VOLTAGE_1V9 = 6,
    FLASH_WRITE_ENABLE_CMD = 6,
    NV_CHECK_SUM_ERROR = 6,
    NV_ITEM_APS_BINDING_TABLE = 6,
    NV_MODULE_APP = 6,
    OTA_FLAG_IMAGE_MAGIC_3 = 6,
    RF_POWER_INDEX_P8p97dBm = 6,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_TO_HUE_AND_SATURATION = 6,
    ZCL_ZLL_TOUCH_LINK_STA_STARTORJOIN_TIMEOUT = 6,
    AS_AMIC = 7,
    BDB_COMMISSION_STA_BINDING_TABLE_FULL = 7,
    BDB_EVT_COMMISSIONING_NETWORK_STEER_FINISH = 7,
    BDB_STATE_REJOIN_DONE = 7,
    FLASH_VOLTAGE_1V95 = 7,
    GP_SEC_KEY_TYPE_DERIVED_INDIVIDUAL_GPD_KEY = 7,
    NV_ENABLE_PROTECT_ERROR = 7,
    NV_ITEM_NWK_FRAME_COUNT = 7,
    NV_MODULE_KEYPAIR = 7,
    OTA_FLAG_IMAGE_HDR_VER1 = 7,
    RF_POWER_INDEX_P8p73dBm = 7,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_TO_COLOR = 7,
    ZCL_ZLL_TOUCH_LINK_STA_TARGET_START = 7,
    AS_DMIC = 8,
    BDB_COMMISSION_STA_NO_SCAN_RESPONSE = 8,
    BDB_EVT_COMMISSIONING_NETWORK_FORMATION_PERMITJOIN = 8,
    FLD_AUD_DFIFO0_OUT = 8,
    FLD_DCCC_DOUBLER_POWER_DOWN = 8,
    FLD_DMA_CHN3 = 8,
    FLD_DMA_CHN_RF_TX = 8,
    FLD_GPIO_CORE_INTERRUPT_EN = 8,
    FLD_MSPI_RD = 8,
    FLD_RST0_USB = 8,
    FLD_RST1_ALGM = 8,
    FLD_TMR_STA_WD = 8,
    MAC_CAP_RX_ON_WHEN_IDLE = 8,
    NV_ITEM_SS_KEY_PAIR = 8,
    NV_MAX_MODULS = 8,
    NV_NO_MEDIA = 8,
    OTA_FLAG_IMAGE_HDR_VER2 = 8,
    RF_POWER_INDEX_P8p44dBm = 8,
    RX_WAITINGACK = 8,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_COLOR = 8,
    ZCL_ZLL_TOUCH_LINK_STA_NO_CAPACITY = 8,
    AS_SDM = 9,
    BDB_COMMISSION_STA_NOT_PERMITTED = 9,
    BDB_EVT_COMMISSIONING_NETWORK_FORMATION_FINISH = 9,
    NV_DATA_CHECK_ERROR = 9,
    NV_ITEM_OTA_HDR_SERVERINFO = 9,
    OTA_FLAG_IMAGE_HDR_LEN1 = 9,
    RF_POWER_INDEX_P8p13dBm = 9,
    ZCL_CMD_LIGHT_COLOR_CONTROL_STEP_COLOR = 9,
    ZCL_ZLL_TOUCH_LINK_BUSY = 9,
    AS_USB = 10,
    BDB_COMMISSION_STA_TCLK_EX_FAILURE = 10,
    BDB_EVT_COMMISSIONING_FINDORBIND_FINISH = 10,
    NV_ITEM_CHECK_ERROR = 10,
    NV_ITEM_OTA_CODE = 10,
    OTA_FLAG_IMAGE_HDR_LEN2 = 10,
    RF_POWER_INDEX_P7p79dBm = 10,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_TO_COLOR_TEMPERATURE = 10,
    AS_ADC = 11,
    BDB_COMMISSION_STA_PARENT_LOST = 11,
    BDB_EVT_COMMISSIONING_FINDORBIND_SIMPLE_DESC_REQ = 11,
    IDENTIFY_EFFECT_CHANNEL_CHANGE = 11,
    NV_ITEM_ED_TIMEOUT = 11,
    NV_MODULE_NOT_FOUND = 11,
    OTA_FLAG_IMAGE_HDR_FC1 = 11,
    RF_POWER_INDEX_P7p41dBm = 11,
    AS_CMP = 12,
    BDB_COMMISSION_STA_REJOIN_FAILURE = 12,
    FLD_ADC_ITRIM_VREFBUF = 12,
    FLD_ADC_VREF_VBAT_DIV = 12,
    FLD_PGA_ITRIM_GAIN_R = 12,
    NV_MODULE_ERASE_NEED = 12,
    OTA_FLAG_IMAGE_HDR_FC2 = 12,
    RF_POWER_INDEX_P7p02dBm = 12,
    AS_ATS = 13,
    BDB_COMMISSION_STA_FORMATION_DONE = 13,
    OTA_FLAG_IMAGE_MANU_CODE1 = 13,
    RF_POWER_INDEX_P6p60dBm = 13,
    OTA_FLAG_IMAGE_MANU_CODE2 = 14,
    RF_POWER_INDEX_P6p14dBm = 14,
    CERTIFICATION_KEY = 15,
    FLD_ADC_AIN_NEGATIVE = 15,
    FLD_ADC_TSAMPLE_CYCLE_CHN_L = 15,
    FLD_R_MAX_S = 15,
    OTA_FLAG_IMAGE_TYPE1 = 15,
    RF_POWER_INDEX_P5p65dBm = 15,
    FLASH_SIZE_64K = 16,
    FLD_ADC_EN_DIFF_CHN_L = 16,
    FLD_ADC_MODE = 16,
    FLD_AUD_DFIFO0_L_INT = 16,
    FLD_CLK_48M_TO_RX_EN = 16,
    FLD_DMA_CHN4 = 16,
    FLD_DMA_CHN_AES_OUT = 16,
    FLD_MSPI_BUSY = 16,
    FLD_RST0_PWM = 16,
    FLD_RST1_AES = 16,
    OTA_FLAG_IMAGE_TYPE2 = 16,
    RF_POWER_INDEX_P5p13dBm = 16,
    RX_DATAPENDING = 16,
    STOP_BIT_ONE_DOT_FIVE = 16,
    SYS_CLK_RC_THRES = 16,
    SYS_EXCEPTTION_ZB_BUFFER_OVERFLOWN = 16,
    FLASH_SIZE_128K = 17,
    OTA_FLAG_IMAGE_FILE_VER1 = 17,
    RF_POWER_INDEX_P4p57dBm = 17,
    SYS_EXCEPTTION_ZB_BUFFER_EXCEPTION_FREE_OVERFLON = 17,
    FLASH_SIZE_256K = 18,
    OTA_FLAG_IMAGE_FILE_VER2 = 18,
    RF_POWER_INDEX_P3p94dBm = 18,
    SYS_EXCEPTTION_ZB_BUFFER_EXCEPTION_FREE_MULIT = 18,
    FLASH_SIZE_512K = 19,
    OTA_FLAG_IMAGE_FILE_VER3 = 19,
    RF_POWER_INDEX_P3p23dBm = 19,
    SYS_EXCEPTTION_ZB_BUFFER_EXCEPTION = 19,
    AS_PWM0 = 20,
    FLASH_SIZE_1M = 20,
    OTA_FLAG_IMAGE_FILE_VER4 = 20,
    RF_POWER_INDEX_P3p01dBm = 20,
    SYS_EXCEPTTION_ZB_TIMER_TASK = 20,
    AS_PWM1 = 21,
    FLASH_SIZE_2M = 21,
    OTA_FLAG_IMAGE_STACK_VER1 = 21,
    RF_POWER_INDEX_P2p81dBm = 21,
    SYS_EXCEPTTION_ZB_TASK_POST = 21,
    AS_PWM2 = 22,
    FLASH_SIZE_4M = 22,
    OTA_FLAG_IMAGE_STACK_VER2 = 22,
    RF_POWER_INDEX_P2p61dBm = 22,
    AS_PWM3 = 23,
    FLASH_SIZE_8M = 23,
    OTA_FLAG_IMAGE_CONT_HDR = 23,
    RF_POWER_INDEX_P2p39dBm = 23,
    AS_PWM4 = 24,
    MAC_STA_UNSUPPORTED = 24,
    OTA_FLAG_IMAGE_ELEM_TAG1 = 24,
    RF_POWER_INDEX_P1p99dBm = 24,
    AS_PWM5 = 25,
    MAC_STA_BAD_STATE = 25,
    OTA_FLAG_IMAGE_ELEM_TAG2 = 25,
    RF_POWER_INDEX_P1p73dBm = 25,
    AS_PWM0_N = 26,
    MAC_STA_NO_RESOURCES = 26,
    OTA_FLAG_IMAGE_ELEM_LEN1 = 26,
    RF_POWER_INDEX_P1p45dBm = 26,
    AS_PWM1_N = 27,
    OTA_FLAG_IMAGE_ELEM_LEN2 = 27,
    RF_POWER_INDEX_P1p17dBm = 27,
    AS_PWM2_N = 28,
    OTA_FLAG_IMAGE_ELEM_LEN3 = 28,
    RF_POWER_INDEX_P0p90dBm = 28,
    AS_PWM3_N = 29,
    MAC_TX_ABORTED = 29,
    OTA_FLAG_IMAGE_ELEM_LEN4 = 29,
    RF_POWER_INDEX_P0p58dBm = 29,
    AS_PWM4_N = 30,
    OTA_FLAG_IMAGE_ELEM_INFO1 = 30,
    RF_POWER_INDEX_P0p04dBm = 30,
    AS_PWM5_N = 31,
    OTA_FLAG_IMAGE_ELEM_INFO2 = 31,
    RF_POWER_INDEX_N0p14dBm = 31,
    FLASH_SECT_ERASE_CMD = 32,
    FLD_ADC_EN_DIFF_CHN_R = 32,
    FLD_AUD_DFIFO0_H_INT = 32,
    FLD_CLK_48M_TO_DIG_EN = 32,
    FLD_DMA_CHN5 = 32,
    FLD_DMA_CHN_AES_IN = 32,
    FLD_RST0_QDEC = 32,
    FLD_RST1_ADC = 32,
    FLD_SAR_ADC_POWER_DOWN = 32,
    MAC_STA_FRAME_PENDING = 32,
    NV_ITEM_ZCL_REPORT = 32,
    OTA_FLAG_IMAGE_ELEMENT = 32,
    RF_POWER_INDEX_N0p97dBm = 32,
    STOP_BIT_TWO = 32,
    SYS_CLK_48M_Crystal = 32,
    SYS_EXCEPTTION_ZB_MAC_TX_IRQ = 32,
    TX_UNDERWAY = 32,
    NV_ITEM_ZCL_ON_OFF = 33,
    RF_POWER_INDEX_N1p42dBm = 33,
    SYS_EXCEPTTION_ZB_MAC_TX_TIMER = 33,
    NV_ITEM_ZCL_LEVEL = 34,
    RF_POWER_INDEX_N1p89dBm = 34,
    SYS_EXCEPTTION_ZB_MAC_CSMA = 34,
    NV_ITEM_ZCL_COLOR_CTRL = 35,
    RF_POWER_INDEX_N2p48dBm = 35,
    SYS_EXCEPTTION_ZB_MAC_TRX_TASK = 35,
    NV_ITEM_ZCL_SCENE_TABLE = 36,
    RF_POWER_INDEX_N3p03dBm = 36,
    NV_ITEM_ZCL_GP_PROXY_TABLE = 37,
    RF_POWER_INDEX_N3p61dBm = 37,
    NV_ITEM_ZCL_GP_SINK_TABLE = 38,
    RF_POWER_INDEX_N4p26dBm = 38,
    NV_ITEM_ZCL_WWAH_APS_AUTH_INFO = 39,
    RF_POWER_INDEX_N5p03dBm = 39,
    NV_ITEM_ZCL_WWAH_APS_ACKS_INFO = 40,
    RF_POWER_INDEX_N5p81dBm = 40,
    NV_ITEM_ZCL_WWAH_USE_TC_CLUSTER_INFO = 41,
    RF_POWER_INDEX_N6p67dBm = 41,
    NV_ITEM_APP_SIMPLE_DESC = 42,
    RF_POWER_INDEX_N7p65dBm = 42,
    NV_ITEM_APP_POWER_CNT = 43,
    RF_POWER_INDEX_N8p65dBm = 43,
    NV_ITEM_APP_GP_TRANS_TABLE = 44,
    RF_POWER_INDEX_N9p89dBm = 44,
    RF_POWER_INDEX_N11p4dBm = 45,
    RF_POWER_INDEX_N13p29dBm = 46,
    RF_POWER_INDEX_N15p88dBm = 47,
    FLD_ADC_ITRIM_VCMBUF = 48,
    FLD_ADC_RES_R = 48,
    FLD_R_MAX_C1 = 48,
    RF_POWER_INDEX_N19p27dBm = 48,
    SYS_EXCEPTTION_ZB_NWK_ADDR_IDX = 48,
    FLASH_WRITE_STATUS_CMD_HIGHBYTE = 49,
    RF_POWER_INDEX_N25p18dBm = 49,
    SYS_EXCEPTTION_ZB_NWK_BRC_INFO = 49,
    SYS_EXCEPTTION_ZB_NWK_GET_ENTRY = 50,
    NV_ERASE_FOR_FN = 51,
    SYS_EXCEPTTION_ZB_NWK_NEIGHBOR_TABLE = 51,
    SYS_EXCEPTTION_ZB_NWK_ROUTE_TABLE = 52,
    FLASH_READ_STATUS_CMD_HIGHBYTE = 53,
    SYS_EXCEPTTION_ZB_NWK_LINK_STA_MEM_ALLOC_FAIL = 53,
    FLD_ADC_EN_DIFF_CHN_M = 64,
    FLD_AUD_DFIFO1_H_INT = 64,
    FLD_CLK_24M_TO_SAR_EN = 64,
    FLD_POWER_DOWN_PGA_CHN_L = 64,
    FLD_RST1_ALG = 64,
    MAC_ATTR_ACK_WAIT_DURATION = 64,
    MAC_CAP_SECURITY_CAPABLE = 64,
    MAC_PIB_ATTRIBUTE_START = 64,
    SYS_EXCEPTTION_ZB_SS_KEY_INDEX = 64,
    ZCL_CMD_LIGHT_COLOR_CONTROL_ENHANCED_MOVE_TO_HUE = 64,
    MAC_ATTR_ASSOCIATION_PERMIT = 65,
    ZCL_CMD_LIGHT_COLOR_CONTROL_ENHANCED_MOVE_HUE = 65,
    FLASH_WRITE_SECURITY_REGISTERS_CMD = 66,
    MAC_ATTR_AUTO_REQUEST = 66,
    SYS_CLK_24M_Crystal = 66,
    ZCL_CMD_LIGHT_COLOR_CONTROL_ENHANCED_STEP_HUE = 66,
    MAC_ATTR_BATTERY_LIFE_EXT = 67,
    SYS_CLK_16M_Crystal = 67,
    ZCL_CMD_LIGHT_COLOR_CONTROL_ENHANCED_MOVE_TO_HUE_AND_SATURATION = 67,
    FLASH_ERASE_SECURITY_REGISTERS_CMD = 68,
    MAC_ATTR_BATTERY_LIFE_EXT_PERIODS = 68,
    SYS_CLK_12M_Crystal = 68,
    ZCL_CMD_LIGHT_COLOR_CONTROL_COLOR_LOOP_SET = 68,
    MAC_ATTR_BEACON_PAYLOAD = 69,
    MAC_ATTR_BEACON_PAYLOAD_LENGTH = 70,
    MAC_ATTR_BEACON_ORDER = 71,
    ZCL_CMD_LIGHT_COLOR_CONTROL_STOP_MOVE_STEP = 71,
    FLASH_READ_SECURITY_REGISTERS_CMD = 72,
    MAC_ATTR_BEACON_TX_TIME = 72,
    MAC_ATTR_BSN = 73,
    MAC_ATTR_COORDINATOR_EXTENDED_ADDRESS = 74,
    FLASH_READ_UID_CMD_GD_PUYA_ZB_UT = 75,
    FLASH_UID_CMD_GD_PUYA = 75,
    MAC_ATTR_OORDINATOR_SHORT_ADDRESS = 75,
    ZCL_CMD_LIGHT_COLOR_CONTROL_MOVE_COLOR_TEMPERATURE = 75,
    MAC_ATTR_DSN = 76,
    ZCL_CMD_LIGHT_COLOR_CONTROL_STEP_COLOR_TEMPERATURE = 76,
    MAC_ATTR_GTS_PERMIT = 77,
    MAC_ATTR_MAX_CSMA_BACKOFFS = 78,
    MAC_ATTR_MIN_BE = 79,
    MAC_ATTR_PAN_ID = 80,
    SYS_EXCEPTTION_ZB_APS_PARAM = 80,
    MAC_ATTR_PROMISCUOUS_MODE = 81,
    SYS_EXCEPTTION_ZB_APS_FRAGMENT_TRANS = 81,
    MAC_ATTR_RX_ON_WHEN_IDLE = 82,
    SYS_EXCEPTTION_ZB_APS_FRAGMENT_RCV = 82,
    MAC_ATTR_SHORT_ADDRESS = 83,
    MAC_ATTR_SUPERFRAME_ORDER = 84,
    MAC_ATTR_TRANSACTION_PERSISTENCE_TIME = 85,
    NV_ERASE_ALL = 85,
    MAC_ATTR_PAN_COORDASSOCIATED = 86,
    MAC_ATTR_MAX_BE = 87,
    MAC_ATTR_MAX_FRAME_TOTAL_WAIT_TIME = 88,
    MAC_ATTR_MAX_FRAME_RETRIES = 89,
    FLASH_READ_UID_CMD_XTX = 90,
    FLASH_XTX_READ_UID_CMD = 90,
    MAC_ATTR_RESPONSE_WAIT_TIME = 90,
    MAC_ATTR_SYNC_SYMBOL_OFFSET = 91,
    MAC_ATTR_TIMESTAMP_SUPPORTED = 92,
    MAC_ATTR_SECURITY_ENABLED = 93,
    MAC_CONST_EXT_ADDR = 94,
    MAC_PIB_ATTRIBUTE_STOP = 95,
    MAC_TX_POWER = 95,
    BDB_ATTR_PRIMARY_CHANNEL_SET = 96,
    SYS_CLK_32M_Crystal = 96,
    SYS_EXCEPTTION_ZB_ZCL_ENTRY = 96,
    ZDO_NETWORK_LOST = 96,
    BDB_ATTR_SECONDARY_CHANNEL_SET = 97,
    BDB_ATTR_COMMISSIONING_GROUP_ID = 98,
    BDB_ATTR_COMMISSIONING_MODE = 99,
    BDB_ATTR_COMMISSIONING_STATUS = 100,
    BDB_ATTR_JOINING_NODE_EUI64 = 101,
    BDB_ATTR_JOINING_NODE_TC_LNKKEY = 102,
    BDB_ATTR_COMMISSIONING_CAP = 103,
    BDB_ATTR_JOIN_USE_INSTALL_CODE_KEY = 104,
    BDB_ATTR_NODE_IS_ON_NETWORK = 105,
    BDB_ATTR_NODE_JOIN_LNKKEY_TYPE = 106,
    BDB_ATTR_TC_REQUIRE_KEY_EXCHANGE = 107,
    BDB_ATTR_SCAN_DURATION = 108,
    BDB_ATTR_TC_LNKKEY_EXCHANGE_ATTEMPT = 109,
    BDB_ATTR_TC_LNKKEY_EXCHANGE_ATTEMPT_MAX = 110,
    BDB_ATTR_TC_LNKKEY_EXCHANGE_METHOD = 111,
    BDB_ATTR_TC_NODE_JOIN_TIMEOUT = 112,
    SYS_EXCEPTTION_EV_BUFFER_OVERFLOWN = 112,
    SYS_EXCEPTTION_EV_BUFFER_EXCEPTION_FREE_OVERFLON = 113,
    SYS_EXCEPTTION_EV_BUFFER_EXCEPTION_FREE_MULIT = 114,
    SYS_EXCEPTTION_EV_TASK_POST = 115,
    FLD_AUD_DFIFO2_H_INT = 128,
    FLD_CLK_48M_TO_CAL_DIG_MAN_EN = 128,
    FLD_DMA_CHN7 = 128,
    FLD_DMA_CHN_PWM = 128,
    FLD_POWER_DOWN_PGA_CHN_R = 128,
    FLD_RST0_SWIRE = 128,
    MAC_CAP_ALLOCATE_ADDRESS = 128,
    NV_ITEM_APS_BINDING_TABLE_V2 = 128,
    SYS_EXCEPTTION_NV_CHECK_TABLE_FULL = 128,
    ZCL_ZLL_COMMISSION_STATE_TOUCHLINK_STARTORJOIN = 128,
    ZDO_INVALID_REQUEST = 128,
    ZCL_ZLL_COMMISSION_STATE_TOUCHLINK_START = 129,
    ZDO_DEVICE_NOT_FOUND = 129,
    ZCL_ZLL_COMMISSION_STATE_TOUCHLINK_JOIN_ED = 130,
    ZDO_INVALID_EP = 130,
    ZCL_ZLL_COMMISSION_STATE_TOUCHLINK_JOIN_ROUTE = 131,
    ZDO_NOT_ACTIVE = 131,
    ZDO_NOT_SUPPORTED = 132,
    ZDO_TIMEOUT = 133,
    ZDO_NO_MATCH = 134,
    ZDO_NO_ENTRY = 136,
    ZDO_NO_DESCRIPTOR = 137,
    ZDO_INSUFFICIENT_SPACE = 138,
    ZDO_NOT_PERMITTED = 139,
    ZDO_TABLE_FULL = 140,
    ZDO_NOT_AUTHORIZED = 141,
    ZDO_DEVICE_BINDING_TABLE_FALL = 142,
    ZDO_INVALID_INDEX = 143,
    FLASH_GET_JEDEC_ID = 159,
    APS_STATUS_ASDU_TOO_LONG = 160,
    APS_STATUS_DEFRAG_DEFERRED = 161,
    APS_STATUS_DEFRAG_UNSUPPORTED = 162,
    APS_STATUS_ILLEGAL_REQUEST = 163,
    APS_STATUS_INVALID_BINDING = 164,
    APS_STATUS_INVALID_GROUP = 165,
    APS_STATUS_INVALID_PARAMETER = 166,
    APS_STATUS_NO_ACK = 167,
    APS_STATUS_NO_BOUND_DEVICE = 168,
    APS_STATUS_NO_SHORT_ADDRESS = 169,
    APS_STATUS_NOT_SUPPORTED = 170,
    APS_STATUS_SECURED_LINK_KEY = 171,
    APS_STATUS_SECURED_NWK_KEY = 172,
    APS_STATUS_SECURITY_FAIL = 173,
    APS_STATUS_TABLE_FULL = 174,
    APS_STATUS_UNSECURED = 175,
    APS_STATUS_UNSUPPORTED_ATTRIBUTE = 176,
    APS_STATUS_HANDLE_BACKING = 177,
    APS_STATUS_SHORT_ADDR_REQUESTING = 178,
    APS_STATUS_DUPLICATE_ENTRY = 184,
    APS_STATUS_INTERNAL_BUF_FULL = 185,
    FLD_R_MAX_MC1 = 192,
    FLD_SEL_AIN_SCALE = 192,
    MAC_STA_COUNTER_ERROR = 219,
    MAC_STA_IMPROPER_KEY_TYPE = 220,
    MAC_STA_IMPROPER_SECURITY_LEVEL = 221,
    MAC_STA_UNSUPPORTED_LEGACY = 222,
    MAC_STA_UNSUPPORTED_SECURITY = 223,
    MAC_STA_BEACON_LOSS = 224,
    MAC_STA_CHANNEL_ACCESS_FAILURE = 225,
    MAC_STA_DENIED = 226,
    MAC_STA_DISABLE_TRX_FAILURE = 227,
    MAC_STA_SECURITY_ERROR = 228,
    MAC_STA_FRAME_TOO_LONG = 229,
    MAC_STA_INVALID_GTS = 230,
    MAC_STA_INVALID_HANDLE = 231,
    MAC_STA_INVALID_PARAMETER = 232,
    MAC_STA_NO_ACK = 233,
    MAC_STA_NO_BEACON = 234,
    MAC_STA_NO_DATA = 235,
    MAC_STA_NO_SHORT_ADDRESS = 236,
    MAC_STA_OUT_OF_CAP = 237,
    MAC_STA_PAN_ID_CONFLICT = 238,
    MAC_STA_REALIGNMENT_GOT = 239,
    FLD_ADC_AIN_POSITIVE = 240,
    FLD_ADC_TSAMPLE_CYCLE_CHN_R = 240,
    MAC_STA_TRANSACTION_EXPIRED = 240,
    MAC_STA_TRANSACTION_OVERFLOW = 241,
    MAC_STA_TX_ACTIVE = 242,
    MAC_STA_KEY_UNAVAILABLE = 243,
    MAC_STA_UNSUPPORTED_ATTRIBUTE = 244,
    MAC_STA_INVALID_ADDRESS = 245,
    MAC_STA_ON_TIME_TOO_LONG = 246,
    MAC_STA_PAST_TIME = 247,
    MAC_STA_TRACKING_OFF = 248,
    MAC_STA_INVALID_INDEX = 249,
    MAC_STA_LIMIT_REACHED = 250,
    MAC_STA_READ_ONLY = 251,
    MAC_STA_IN_SCAN_DOING = 252,
    MAC_STA_SUPERFRAME_OVERLAP = 253,
    IDENTIFY_EFFECT_FINISH_EFFECT = 254,
    MAC_STA_AUTOACK_PENDING_ALL_ON = 254,
    IDENTIFY_EFFECT_STOP_EFFECT = 255,
    MAC_STA_AUTOACK_PENDING_ALL_OFF = 255,
    NV_ITEM_ID_MAX = 255} anon_enum_8.conflict461;

typedef enum hw_timer_sts_e
{
  HW_TIMER_SUCC = 0,
  HW_TIMER_IS_RUNNING = 1,
  HW_TIMER_INVALID = 2
} hw_timer_sts_e;

typedef enum hw_timer_sts_e hw_timer_sts_t;

typedef struct zdo_bind_dstAddr_t zdo_bind_dstAddr_t, *Pzdo_bind_dstAddr_t;

typedef union anon_union_9_2_e93a25ab_for_dstAddr anon_union_9_2_e93a25ab_for_dstAddr, *Panon_union_9_2_e93a25ab_for_dstAddr;

typedef struct anon_struct_9_2_0b3bd1ce_for_anon_union_9_2_e93a25ab_for_dstAddr_0 anon_struct_9_2_0b3bd1ce_for_anon_union_9_2_e93a25ab_for_dstAddr_0, *Panon_struct_9_2_0b3bd1ce_for_anon_union_9_2_e93a25ab_for_dstAddr_0;

struct anon_struct_9_2_0b3bd1ce_for_anon_union_9_2_e93a25ab_for_dstAddr_0
{
  addrExt_t dstExtAddr;
  u8 dstEp;
};

union anon_union_9_2_e93a25ab_for_dstAddr
{
  struct anon_struct_9_2_0b3bd1ce_for_anon_union_9_2_e93a25ab_for_dstAddr_0 field_0;
  u16 dstGroupId;
};

struct zdo_bind_dstAddr_t
{
  u8 dstAddrMode;
  union anon_union_9_2_e93a25ab_for_dstAddr dstAddr;
};

typedef struct findBindQ_t findBindQ_t, *PfindBindQ_t;

typedef struct findBindDst_t findBindDst_t, *PfindBindDst_t;

struct findBindDst_t
{
  u16 addr;
  u8 endpoint;
  u8 resv;
};

struct findBindQ_t
{
  struct findBindDst_t findBindDstInfo[5];
  u8 front;
  u8 rear;
};

typedef void (*bdb_zclIdentifyCb_t)(u8, u16, u16);

typedef enum ha_device_id
{
  HA_DEV_ONOFF_SWITCH = 0,
  HA_DEV_LEVEL_CTRL_SWITCH = 1,
  HA_DEV_ONOFF_OUTPUT = 2,
  HA_DEV_LEVEL_CTRLABLE_OUTPUT = 3,
  HA_DEV_SCENE_SELECTOR = 4,
  HA_DEV_CONFIG_TOOL = 5,
  HA_DEV_REMOTE_CTRL = 6,
  HA_DEV_COMBINED_INTERFACE = 7,
  HA_DEV_RANGE_EXTENDER = 8,
  HA_DEV_MAINS_PWR_OUTLET = 9,
  HA_DEV_DOOR_LOCK = 10,
  HA_DEV_DOOR_LOCK_CTRLER = 11,
  HA_DEV_SIMPLE_SENSOR = 12,
  HA_DEV_CONSUMPTION_AWARENESS = 13,
  HA_DEV_HOME_GATEWAY = 80,
  HA_DEV_SMART_PLUG = 81,
  HA_DEV_WHITE_GOOD = 82,
  HA_DEV_METER_INTERFACE = 83,
  HA_DEV_ONOFF_LIGHT = 256,
  HA_DEV_DIMMABLE_LIGHT = 257,
  HA_DEV_COLOR_DIMMABLE_LIGHT = 258,
  HA_DEV_ONOFF_LIGHT_SWITCH = 259,
  HA_DEV_DIMMER_SWITCH = 260,
  HA_DEV_COLOR_DIMMER_SWITCH = 261,
  HA_DEV_LIGHT_SENSOR = 262,
  HA_DEV_OCCUPANCY_SENSOR = 263,
  HA_DEV_ONOFF_BALLAST = 264,
  HA_DEV_DIMMABLE_BALLAST = 265,
  HA_DEV_ONOFF_PLUG_IN_UNIT = 266,
  HA_DEV_DIMMANLE_PLUG_IN_UNIT = 267,
  HA_DEV_COLOR_TEMPERATURE_LIGHT = 268,
  HA_DEV_EXTENDED_COLOR_LIGHT = 269,
  HA_DEV_LIGHT_LEVEL_SENSOR = 270,
  HA_DEV_SHADE = 512,
  HA_DEV_SHADE_CTRLER = 513,
  HA_DEV_WINDOW_COVERING_DEVICE = 514,
  HA_DEV_WINDOW_COVERING_CTRLER = 515,
  HA_DEV_HEATING_COOLING_UNIT = 768,
  HA_DEV_THERMOSTAT = 769,
  HA_DEV_TEMPERATURE_SENSOR = 770,
  HA_DEV_PUMP = 771,
  HA_DEV_PUMP_CTRLER = 772,
  HA_DEV_PRESSURE_SENSOR = 773,
  HA_DEV_FLOW_SENSOR = 774,
  HA_DEV_IAS_CIE = 1024,
  HA_DEV_IAS_ACE = 1025,
  HA_DEV_IAS_ZONE = 1026,
  HA_DEV_IAS_WD = 1027,
  HA_DEV_COLOR_CONTROLLER = 2048,
  HA_DEV_COLOR_SCENE_CONTROLLER = 2064,
  HA_DEV_NON_COLOR_CONTROLLER = 2080,
  HA_DEV_NON_COLOR_SCENE_CONTROLLER = 2096,
  HA_DEV_CONTROL_BRIDGE = 2112,
  HA_DEV_ONOFF_SENSOR = 2128
} ha_device_id;

typedef void (*bdb_initAppCb_t)(u8, u8);

typedef struct bdb_appCb_t bdb_appCb_t, *Pbdb_appCb_t;

typedef void (*bdb_commissioningAppCb_t)(u8, void *);

typedef void (*bdb_findBindSuccessCb_t)(struct findBindDst_t *);

struct bdb_appCb_t
{
  bdb_initAppCb_t bdbInitCb;
  bdb_commissioningAppCb_t bdbcommissioningCb;
  bdb_zclIdentifyCb_t bdbIdentifyCb;
  bdb_findBindSuccessCb_t bdbFindBindSuccessCb;
};

typedef struct bdb_attrTbl_t bdb_attrTbl_t, *Pbdb_attrTbl_t;

struct bdb_attrTbl_t
{
  u8 offset;
  u8 len;
};

typedef struct bdb_linkKey_info_t bdb_linkKey_info_t, *Pbdb_linkKey_info_t;

typedef struct bdb_linkKey_t bdb_linkKey_t, *Pbdb_linkKey_t;

struct bdb_linkKey_t
{
  u8 *key;
  u8 keyType;
};

struct bdb_linkKey_info_t
{
  struct bdb_linkKey_t tcLinkKey;
  struct bdb_linkKey_t distributeLinkKey;
  struct bdb_linkKey_t touchLinkKey;
};

typedef struct bdb_ctx_t bdb_ctx_t, *Pbdb_ctx_t;

typedef struct bdb_commissionSetting_t bdb_commissionSetting_t, *Pbdb_commissionSetting_t;

typedef union anon_union_4_2_85b55d36_for_bdb_ctx_t_2 anon_union_4_2_85b55d36_for_bdb_ctx_t_2, *Panon_union_4_2_85b55d36_for_bdb_ctx_t_2;

union anon_union_4_2_85b55d36_for_bdb_ctx_t_2
{
  struct ev_timer_event_t *identifyTimer;
  struct ev_timer_event_t *retrieveTcLkKeyTimer;
};

struct bdb_ctx_t
{
  struct af_simple_descriptor_t *simpleDesc;
  struct bdb_commissionSetting_t *commissionSettings;
  union anon_union_4_2_85b55d36_for_bdb_ctx_t_2 field_2;
  struct bdb_appCb_t *bdbAppCb;
  struct findBindQ_t *pFindBindQ;
  u16 *clusterList;
  u16 *matchClusterList;
  struct findBindDst_t findDstInfo;
  struct findBindDst_t bindDstInfo;
  u8 clusterNum;
  u8 matchClusterNum;
  u8 networkType;
  u8 state;
  u8 status;
  u8 role;
  u8 channel;
  u8 inited : 1;
  u8 factoryNew : 1;
  u8 leaveDoing : 1;
  u8 forceJoin : 1;
  u8 securityDisable : 1;
  u8 resv : 3;
  u8 initResult;
};

struct bdb_commissionSetting_t
{
  struct bdb_linkKey_info_t linkKey;
  u8 touchlinkEnable;
  u8 touchlinkChannel;
  u8 touchlinkLqiThreshold;
};

// WARNING! conflicting data type names: /DWARF/bdb.h/bdb_commissioningMode_t - /bdb_commissioningMode_t

typedef enum I2C_GPIO_GroupTypeDef
{
  I2C_GPIO_GROUP_A3A4 = 0,
  I2C_GPIO_GROUP_B6D7 = 1,
  I2C_GPIO_GROUP_C0C1 = 2,
  I2C_GPIO_GROUP_C2C3 = 3
} I2C_GPIO_GroupTypeDef;

typedef struct node_descriptor_t node_descriptor_t, *Pnode_descriptor_t;

typedef enum device_type_t
{
  DEVICE_TYPE_COORDINATOR = 0,
  DEVICE_TYPE_ROUTER = 1,
  DEVICE_TYPE_END_DEVICE = 2
} device_type_t;

struct node_descriptor_t
{
  enum device_type_t logical_type : 3;
  u8 complex_descriptor_ava : 1;
  u8 user_descriptor_ava : 1;
  u8 reserved : 3;
  u8 aps_flag : 3;
  u8 freq_band : 5;
  u8 mac_capability_flag;
  u8 mcL8;
  u8 mcH8;
  u8 max_buff_size;
  u16 max_in_tr_size;
  u16 server_mask;
  u16 max_out_tr_size;
  u8 desc_capability_field;
};

typedef enum power_mode_t
{
  POWER_MODE_RECEIVER_SYNCRONIZED_WHEN_ON_IDLE = 0,
  POWER_MODE_RECEIVER_COMES_PERIODICALLY = 1,
  POWER_MODE_RECEIVER_COMES_WHEN_STIMULATED = 2
} power_mode_t;

typedef struct power_descriptor_t power_descriptor_t, *Ppower_descriptor_t;

typedef enum power_source_t
{
  POWER_SRC_MAINS_POWER = 1,
  POWER_SRC_RECHARGEABLE_BATTERY = 2,
  POWER_SRC_DISPOSABLE_BATTERY = 4
} power_source_t;

typedef enum power_source_level_t
{
  POWER_LEVEL_CRITICAL_0 = 0,
  POWER_LEVEL_PERCENT_33 = 4,
  POWER_LEVEL_PERCENT_66 = 8,
  POWER_LEVEL_PERCENT_100 = 12
} power_source_level_t;

struct power_descriptor_t
{
  enum power_mode_t current_power_mode : 4;
  enum power_source_t available_power_sources : 4;
  enum power_source_t current_power_source : 4;
  enum power_source_level_t current_power_source_level : 4;
};

typedef struct af_endpoint_descriptor_t af_endpoint_descriptor_t, *Paf_endpoint_descriptor_t;

typedef void (*af_endpoint_cb_t)(void *);

typedef void (*af_dataCnf_cb_t)(void *);

struct af_endpoint_descriptor_t
{
  af_endpoint_cb_t cb_rx;
  af_dataCnf_cb_t cb_cnf;
  struct af_simple_descriptor_t *correspond_simple_desc;
  u8 ep;
  u8 rsv[3];
};

typedef char *va_list;

typedef struct zdo_nwk_addr_resp_t zdo_nwk_addr_resp_t, *Pzdo_nwk_addr_resp_t;

struct zdo_nwk_addr_resp_t
{
  u8 seq_num;
  u8 status;
  addrExt_t ieee_addr_remote;
  u16 nwk_addr_remote;
  u8 num_assoc_dev;
  u8 start_index;
  u16 nwk_addr_assoc_dev_lst[6];
};

typedef struct zdo_zdp_req_t zdo_zdp_req_t, *Pzdo_zdp_req_t;

typedef union anon_union_8_2_b0e468e8_for_zdo_zdp_req_t_2 anon_union_8_2_b0e468e8_for_zdo_zdp_req_t_2, *Panon_union_8_2_b0e468e8_for_zdo_zdp_req_t_2;

typedef enum addr_mode_t
{
  SHORT_ADDR_MODE = 0,
  EXT_ADDR_MODE = 1
} addr_mode_t;

typedef void (*zdo_callback)(void *);

union anon_union_8_2_b0e468e8_for_zdo_zdp_req_t_2
{
  u16 dst_nwk_addr;
  addrExt_t st_ext_addr;
};

struct zdo_zdp_req_t
{
  u8 *zdu;
  u8 *buff_addr;
  union anon_union_8_2_b0e468e8_for_zdo_zdp_req_t_2 field_2;
  u16 cluster_id;
  u8 zduLen;
  enum addr_mode_t dst_addr_mode;
  zdo_callback zdoRspReceivedIndCb;
  u8 zdpSeqNum;
};

typedef struct simple_descriptor_field_t simple_descriptor_field_t, *Psimple_descriptor_field_t;

struct simple_descriptor_field_t
{
  u8 endpoint;
  u16 app_profile_id;
  u16 app_dev_id;
  u8 app_dev_ver : 4;
  u8 reserved : 4;
  u8 listInfo[1];
};

typedef struct zdo_nwk_addr_resp_t zdo_ieee_addr_resp_t;

typedef struct zdo_nwk_addr_req_t zdo_nwk_addr_req_t, *Pzdo_nwk_addr_req_t;

typedef enum zdo_addr_req_type
{
  ZDO_ADDR_REQ_SINGLE_REQ = 0,
  ZDO_ADDR_REQ_SINGLE_RESP = 0,
  ZDO_ADDR_REQ_EXTENDED_REQ = 1,
  ZDO_ADDR_REQ_EXTENDED_RESP = 1
} zdo_addr_req_type;

struct zdo_nwk_addr_req_t
{
  addrExt_t ieee_addr_interest;
  enum zdo_addr_req_type req_type;
  u8 start_index;
};

typedef struct zdo_bind_req_t zdo_bind_req_t, *Pzdo_bind_req_t;

typedef enum bind_req_dst_addr_mode
{
  SHORT_GROUPADDR_NODSTENDPOINT = 1,
  LONG_EXADDR_DSTENDPOINT = 3
} bind_req_dst_addr_mode;

typedef union anon_union_9_2_55c67021_for_zdo_bind_req_t_5 anon_union_9_2_55c67021_for_zdo_bind_req_t_5, *Panon_union_9_2_55c67021_for_zdo_bind_req_t_5;

typedef struct anon_struct_9_2_b26e43ff_for_anon_union_9_2_55c67021_for_zdo_bind_req_t_5_0 anon_struct_9_2_b26e43ff_for_anon_union_9_2_55c67021_for_zdo_bind_req_t_5_0, *Panon_struct_9_2_b26e43ff_for_anon_union_9_2_55c67021_for_zdo_bind_req_t_5_0;

struct anon_struct_9_2_b26e43ff_for_anon_union_9_2_55c67021_for_zdo_bind_req_t_5_0
{
  addrExt_t dst_ext_addr;
  u8 dst_endpoint;
};

union anon_union_9_2_55c67021_for_zdo_bind_req_t_5
{
  struct anon_struct_9_2_b26e43ff_for_anon_union_9_2_55c67021_for_zdo_bind_req_t_5_0 field_0;
  u16 dst_group_addr;
};

struct zdo_bind_req_t
{
  addrExt_t src_addr;
  u8 src_endpoint;
  u8 cid16_l;
  u8 cid16_h;
  enum bind_req_dst_addr_mode dst_addr_mode;
  union anon_union_9_2_55c67021_for_zdo_bind_req_t_5 field_5;
};

typedef struct zdo_zdpDataInd_t zdo_zdpDataInd_t, *Pzdo_zdpDataInd_t;

struct zdo_zdpDataInd_t
{
  u8 *zpdu;
  u16 src_addr;
  u16 clusterId;
  u8 seq_num;
  u8 status;
  u8 length;
};

typedef struct zdo_simple_descriptor_resp_t zdo_simple_descriptor_resp_t, *Pzdo_simple_descriptor_resp_t;

struct zdo_simple_descriptor_resp_t
{
  u8 seq_num;
  u8 status;
  u16 nwk_addr_interest;
  u8 length;
  struct simple_descriptor_field_t simple_descriptor;
};

typedef struct zdo_node_descriptor_req_t zdo_node_descriptor_req_t, *Pzdo_node_descriptor_req_t;

struct zdo_node_descriptor_req_t
{
  u16 nwk_addr_interest;
};

typedef struct zdo_match_descriptor_req_t zdo_match_descriptor_req_t, *Pzdo_match_descriptor_req_t;

struct zdo_match_descriptor_req_t
{
  u16 nwk_addr_interest;
  u16 profile_id;
  u8 num_in_clusters;
  u8 num_out_clusters;
  u16 cluster_list[16];
};

typedef struct zdo_simple_descriptor_req_t zdo_simple_descriptor_req_t, *Pzdo_simple_descriptor_req_t;

struct zdo_simple_descriptor_req_t
{
  u16 nwk_addr_interest;
  u8 endpoint;
};

typedef struct zdo_node_descript_resp_t zdo_node_descript_resp_t, *Pzdo_node_descript_resp_t;

struct zdo_node_descript_resp_t
{
  u8 seq_num;
  u8 status;
  u16 nwk_addr_interest;
  struct node_descriptor_t node_descriptor;
};

typedef struct zdo_ieee_addr_req_t zdo_ieee_addr_req_t, *Pzdo_ieee_addr_req_t;

struct zdo_ieee_addr_req_t
{
  u16 nwk_addr_interest;
  enum zdo_addr_req_type req_type;
  u8 start_index;
};

typedef struct zdo_match_descriptor_resp_t zdo_match_descriptor_resp_t, *Pzdo_match_descriptor_resp_t;

struct zdo_match_descriptor_resp_t
{
  u8 seq_num;
  u8 status;
  u16 nwk_addr_interest;
  u8 matchLen;
  u8 matchList[8];
};

typedef struct zcl_onoff_offWithEffectCmd_t zcl_onoff_offWithEffectCmd_t, *Pzcl_onoff_offWithEffectCmd_t;

struct zcl_onoff_offWithEffectCmd_t
{
  u8 effectId;
  u8 effectVariant;
};

typedef struct zcl_onoff_onWithTimeOffCmd_t zcl_onoff_onWithTimeOffCmd_t, *Pzcl_onoff_onWithTimeOffCmd_t;

typedef union zcl_onoffCtrl_t zcl_onoffCtrl_t, *Pzcl_onoffCtrl_t;

typedef struct anon_struct_1_2_1911eebc_for_bits anon_struct_1_2_1911eebc_for_bits, *Panon_struct_1_2_1911eebc_for_bits;

struct anon_struct_1_2_1911eebc_for_bits
{
  u8 acceptOnlyWhenOn : 1;
  u8 reserved : 7;
};

union zcl_onoffCtrl_t
{
  struct anon_struct_1_2_1911eebc_for_bits bits;
  u8 onOffCtrl;
};

struct zcl_onoff_onWithTimeOffCmd_t
{
  union zcl_onoffCtrl_t onOffCtrl;
  u16 onTime;
  u16 offWaitTime;
};

typedef union zcl_onoff_cmdPayload_t zcl_onoff_cmdPayload_t, *Pzcl_onoff_cmdPayload_t;

union zcl_onoff_cmdPayload_t
{
  struct zcl_onoff_offWithEffectCmd_t offWithEffect;
  struct zcl_onoff_onWithTimeOffCmd_t onWithTimeOff;
};

typedef enum TOUCHLINK_KEY_TYPE
{
  DEVELOPMENT_KEY = 0,
  MASTER_KEY = 4,
  CERTIFICATION_KEY = 15
} TOUCHLINK_KEY_TYPE;

typedef struct div_t div_t, *Pdiv_t;

struct div_t
{
  int quot;
  int rem;
};

typedef enum Elf_ProgramHeaderType
{
  PT_NULL = 0,
  PT_LOAD = 1,
  PT_DYNAMIC = 2,
  PT_INTERP = 3,
  PT_NOTE = 4,
  PT_SHLIB = 5,
  PT_PHDR = 6,
  PT_TLS = 7,
  PT_GNU_EH_FRAME = 1685382480,
  PT_GNU_STACK = 1685382481,
  PT_GNU_RELRO = 1685382482
} Elf_ProgramHeaderType;

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType
{
  SHT_NULL = 0,
  SHT_PROGBITS = 1,
  SHT_SYMTAB = 2,
  SHT_STRTAB = 3,
  SHT_RELA = 4,
  SHT_HASH = 5,
  SHT_DYNAMIC = 6,
  SHT_NOTE = 7,
  SHT_NOBITS = 8,
  SHT_REL = 9,
  SHT_SHLIB = 10,
  SHT_DYNSYM = 11,
  SHT_INIT_ARRAY = 14,
  SHT_FINI_ARRAY = 15,
  SHT_PREINIT_ARRAY = 16,
  SHT_GROUP = 17,
  SHT_SYMTAB_SHNDX = 18,
  SHT_ANDROID_REL = 1610612737,
  SHT_ANDROID_RELA = 1610612738,
  SHT_GNU_ATTRIBUTES = 1879048181,
  SHT_GNU_HASH = 1879048182,
  SHT_GNU_LIBLIST = 1879048183,
  SHT_CHECKSUM = 1879048184,
  SHT_SUNW_move = 1879048186,
  SHT_SUNW_COMDAT = 1879048187,
  SHT_SUNW_syminfo = 1879048188,
  SHT_GNU_verdef = 1879048189,
  SHT_GNU_verneed = 1879048190,
  SHT_GNU_versym = 1879048191
} Elf_SectionHeaderType;

struct Elf32_Shdr
{
  dword sh_name;
  enum Elf_SectionHeaderType sh_type;
  dword sh_flags;
  dword sh_addr;
  dword sh_offset;
  dword sh_size;
  dword sh_link;
  dword sh_info;
  dword sh_addralign;
  dword sh_entsize;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym
{
  dword st_name;
  dword st_value;
  dword st_size;
  byte st_info;
  byte st_other;
  word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

struct Elf32_Phdr
{
  enum Elf_ProgramHeaderType p_type;
  dword p_offset;
  dword p_vaddr;
  dword p_paddr;
  dword p_filesz;
  dword p_memsz;
  dword p_flags;
  dword p_align;
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr
{
  byte e_ident_magic_num;
  char e_ident_magic_str[3];
  byte e_ident_class;
  byte e_ident_data;
  byte e_ident_version;
  byte e_ident_osabi;
  byte e_ident_abiversion;
  byte e_ident_pad[7];
  word e_type;
  word e_machine;
  dword e_version;
  dword e_entry;
  dword e_phoff;
  dword e_shoff;
  dword e_flags;
  word e_ehsize;
  word e_phentsize;
  word e_phnum;
  word e_shentsize;
  word e_shnum;
  word e_shstrndx;
};

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ll_reset(void)

{
  undefined1 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  u16 *puVar4;

  for (puVar1 = sdk_version; (int)puVar1 < (int)&_stack_end_;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0xffffffff;
  }
  setExecutionMode(0x12);
  setExecutionMode(0x13);
  for (puVar2 = (undefined4 *)&_ictag_start_; (int)puVar2 < (int)&_ictag_end_; puVar2 = puVar2 + 1)
  {
    *puVar2 = 0;
  }
  DAT_0080060c = 0x17;
  DAT_0080060d = 0x18;
  _DAT_00800060 = 0xff000000;
  DAT_00800064 = 0xff;
  DAT_00800065 = 0xff;
  DAT_0080000c = 0xab;
  iVar3 = 0;
  do
  {
    iVar3 = iVar3 + 1;
  } while (iVar3 < 7);
  DAT_0080000d = 1;
  DAT_008000b8 = 0x7e;
  DAT_008000ba = 0x40;
  if (DAT_008000b9 == '\0')
  {
    puVar2 = (undefined4 *)&_code_size_;
    for (puVar4 = &zcl_attr_currZigbeeStackVer; (int)puVar4 < (int)&_end_data_;
         puVar4 = (u16 *)((int)puVar4 + 4))
    {
      *(undefined4 *)puVar4 = *puVar2;
      puVar2 = puVar2 + 1;
    }
    for (puVar1 = irq_stk; (int)puVar1 < (int)&_end_bss_; puVar1 = (undefined1 *)((int)puVar1 + 4))
    {
      *(undefined4 *)puVar1 = 0;
    }
  }
  else
  {
    DAT_0080063e = tl_multi_addr;
  }
  puVar2 = (undefined4 *)&_custom_stored_bin_;
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = *puVar2;
    puVar2 = puVar2 + 1;
  }
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0;
  }
  main();
  do
  {
    // WARNING: Do nothing block with infinite loop
  } while (true);
}

int __LOAD_RAM(int param_1, int param_2)

{
  int unaff_r6;
  byte in_CY;

  param_2 = param_1 + unaff_r6 + (uint)in_CY << param_2;
  getState(param_2);
  irq_handler();
  setState(param_2);
  return param_2;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void a1(void)

{
  undefined1 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  u16 *puVar4;

  for (puVar1 = sdk_version; (int)puVar1 < (int)&_stack_end_;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0xffffffff;
  }
  setExecutionMode(0x12);
  setExecutionMode(0x13);
  for (puVar2 = (undefined4 *)&_ictag_start_; (int)puVar2 < (int)&_ictag_end_; puVar2 = puVar2 + 1)
  {
    *puVar2 = 0;
  }
  DAT_0080060c = 0x17;
  DAT_0080060d = 0x18;
  _DAT_00800060 = 0xff000000;
  DAT_00800064 = 0xff;
  DAT_00800065 = 0xff;
  DAT_0080000c = 0xab;
  iVar3 = 0;
  do
  {
    iVar3 = iVar3 + 1;
  } while (iVar3 < 7);
  DAT_0080000d = 1;
  DAT_008000b8 = 0x7e;
  DAT_008000ba = 0x40;
  if (DAT_008000b9 == '\0')
  {
    puVar2 = (undefined4 *)&_code_size_;
    for (puVar4 = &zcl_attr_currZigbeeStackVer; (int)puVar4 < (int)&_end_data_;
         puVar4 = (u16 *)((int)puVar4 + 4))
    {
      *(undefined4 *)puVar4 = *puVar2;
      puVar2 = puVar2 + 1;
    }
    for (puVar1 = irq_stk; (int)puVar1 < (int)&_end_bss_; puVar1 = (undefined1 *)((int)puVar1 + 4))
    {
      *(undefined4 *)puVar1 = 0;
    }
  }
  else
  {
    DAT_0080063e = tl_multi_addr;
  }
  puVar2 = (undefined4 *)&_custom_stored_bin_;
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = *puVar2;
    puVar2 = puVar2 + 1;
  }
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0;
  }
  main();
  do
  {
    // WARNING: Do nothing block with infinite loop
  } while (true);
}

void _ramcode_size_div_16_align_256_(undefined4 param_1, undefined4 *param_2, undefined4 *param_3, int param_4)

{
  undefined1 *puVar1;

  while (param_3 = param_3 + 1, (int)param_3 < param_4)
  {
    *param_3 = *param_2;
    param_2 = param_2 + 1;
  }
  for (puVar1 = sdk_version; (int)puVar1 < (int)sdk_version;
       puVar1 = (undefined1 *)((int)puVar1 + 4))
  {
    *(undefined4 *)puVar1 = 0;
  }
  main();
  do
  {
    // WARNING: Do nothing block with infinite loop
  } while (true);
}

undefined4 __irq(undefined4 param_1)

{
  getState(param_1);
  irq_handler();
  setState(param_1);
  return param_1;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u32 mac_currentTickGet(void)

{
  return _DAT_00800740;
}

void rf_setTrxState(u8 state)

{
  RF_StatusTypeDef rf_status;
  int iVar1;

  if ((uint)state * 0x1000000 - 0x1000000 >> 0x18 < 2)
  {
    if ((rfMode == '\x01') && (iVar1 = rf_trx_state_get(), iVar1 == 1))
    {
      return;
    }
    rfMode = '\x01';
    if (fPaEn != '\0')
    {
      drv_gpio_write(rf_pa_txen_pin, '\0');
      drv_gpio_write(rf_pa_rxen_pin, '\x01');
    }
    if (fPtaEn != '\0')
    {
      drv_gpio_write(rf_pta_priority_pin, '\0');
    }
    rf_status = RF_MODE_RX;
  }
  else
  {
    if (state == 0)
    {
      if ((rfMode != '\0') || (iVar1 = rf_trx_state_get(), iVar1 != 0))
      {
        rfMode = '\0';
        if (fPaEn != '\0')
        {
          drv_gpio_write(rf_pa_txen_pin, '\x01');
          drv_gpio_write(rf_pa_rxen_pin, '\0');
        }
        if (fPtaEn != '\0')
        {
          drv_gpio_write(rf_pta_priority_pin, '\x01');
        }
        rf_trx_state_set(RF_MODE_TX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
      }
      sleep_us(0x78);
      return;
    }
    if ((rfMode == '\x03') && (iVar1 = rf_trx_state_get(), iVar1 == 3))
    {
      return;
    }
    rfMode = '\x03';
    if (fPtaEn != '\0')
    {
      drv_gpio_write(rf_pta_priority_pin, '\0');
    }
    rf_status = RF_MODE_OFF;
  }
  rf_trx_state_set(rf_status, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
  return;
}

// WARNING: Removing unreachable block (RAM,0x000003c4)
// WARNING: Removing unreachable block (RAM,0x000003d2)
// WARNING: Removing unreachable block (RAM,0x000003e0)

void rf_performCCA(void)

{
  do
  {
  } while (true);
}

void rf802154_tx(void)

{
  rf_setTrxState('\0');
  DAT_00800f20 = 1;
  rf_tx_pkt(rf_tx_buf);
  return;
}

void rf_paShutDown(void)

{
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_rx_irq_handler(void)

{
  byte len;
  u16 frameCtrl;
  u8 *rxBuf;
  u8 uVar1;
  u8 *addr;
  int iVar2;
  u8 *puVar3;
  int iVar4;
  byte bVar5;
  uint uVar6;
  u8 *macPld;
  u8 local_26;
  u8 local_25;

  rxBuf = rf_rxBuf;
  local_25 = '\0';
  local_26 = '\0';
  if ((int)((uint)DAT_00800448 << 0x1a) < 0)
  {
    return;
  }
  DAT_00800c20 = DAT_00800c20 & 0xfb;
  g_sysDiags.macRxIrqCnt = g_sysDiags.macRxIrqCnt + '\x01';
  if ((((rf_rxBuf[*rf_rxBuf + 3] & 0x51) == 0x10) && (len = rf_rxBuf[4], (uint)*rf_rxBuf == len + 9)) && (bVar5 = rf_busyFlag & 2, (rf_busyFlag & 2) == 0))
  {
    macPld = rf_rxBuf + 5;
    addr = zb_macDataFilter(macPld, len, &local_26, &local_25);
    if (local_26 != '\0')
    {
      *rf_rxBuf = bVar5;
      rf_rxBuf[4] = bVar5;
      DAT_00800c20 = DAT_00800c20 | 4;
      return;
    }
    iVar4 = 0;
    if (((int)((uint)rxBuf[5] << 0x1a) < 0) &&
        ((rfMode != '\0' || (iVar2 = rf_trx_state_get(), iVar4 = _DAT_00800740, iVar2 != 0))))
    {
      rfMode = '\0';
      if (fPaEn != '\0')
      {
        drv_gpio_write(rf_pa_txen_pin, '\x01');
        drv_gpio_write(rf_pa_rxen_pin, '\0');
      }
      if (fPtaEn != '\0')
      {
        drv_gpio_write(rf_pta_priority_pin, '\x01');
      }
      rf_trx_state_set(RF_MODE_TX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
      iVar4 = _DAT_00800740;
    }
    puVar3 = tl_getRxBuf();
    if (puVar3 != (u8 *)0x0)
    {
      rf_rxBuf = puVar3;
      *puVar3 = '\0';
      rf_rxBuf[4] = '\0';
      _DAT_00800c08 = rf_rxBuf._0_2_;
      if ((int)((uint)rxBuf[5] << 0x1a) < 0)
      {
        rf_ack_buf[7] = rxBuf[7];
        rf_ack_buf[5] = '\x02';
        frameCtrl = *(u16 *)(rxBuf + 5);
        bVar5 = tl_zbMacHdrSize(frameCtrl);
        iVar2 = 0;
        if ((frameCtrl & 7) == 3)
        {
          uVar6 = macPld[bVar5] - 4;
          iVar2 = uVar6 + ~uVar6 + (uint)(3 < macPld[bVar5]);
        }
        bVar5 = 2;
        if ((rxBuf[6] & 0xc0) != 0x80)
        {
          bVar5 = ~((0xbf < (rxBuf[6] & 0xc0)) - 1U) & 3;
        }
        if (((bVar5 != 0) && (iVar2 != 0)) &&
            (uVar1 = tl_zbMacPendingDataCheck(bVar5, addr, '\x01'), uVar1 == '\0'))
        {
          rf_ack_buf[5] = rf_ack_buf[5] | 0x10;
        }
        iVar4 = FUN_0000162c(_DAT_00800740 - iVar4, sysTimerPerUs);
        if (iVar4 < 0x78)
        {
          sleep_us(0x78 - iVar4);
        }
        _DAT_00800640 = _DAT_00800640 & 0xffffdfff;
        rf_tx_pkt(rf_ack_buf);
        do
        {
        } while ((DAT_00800f20 & 2) == 0);
        DAT_00800f20 = 2;
        _DAT_00800640 = _DAT_00800640 | 0x2000;
        if ((rfMode != '\x01') || (iVar4 = rf_trx_state_get(), iVar4 != 1))
        {
          rfMode = '\x01';
          if (fPaEn != '\0')
          {
            drv_gpio_write(rf_pa_txen_pin, '\0');
            drv_gpio_write(rf_pa_rxen_pin, '\x01');
          }
          if (fPtaEn != '\0')
          {
            drv_gpio_write(rf_pta_priority_pin, '\0');
          }
          rf_trx_state_set(RF_MODE_RX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
        }
      }
      DAT_00800c20 = DAT_00800c20 | 4;
      bVar5 = *rxBuf;
      zb_macDataRecvHander(rxBuf, macPld, len, local_25,
                           (uint)rxBuf[bVar5 - 2] << 0x10 | (uint)rxBuf[bVar5 - 3] << 8 |
                               (uint)rxBuf[bVar5 - 4] | (uint)rxBuf[bVar5 - 1] << 0x18,
                           rxBuf[bVar5 + 2] + 0x92);
      return;
    }
    if (((int)((uint)rxBuf[5] << 0x1a) < 0) &&
        ((rfMode != '\x01' || (iVar4 = rf_trx_state_get(), iVar4 != 1))))
    {
      rfMode = '\x01';
      if (fPaEn != '\0')
      {
        drv_gpio_write(rf_pa_txen_pin, '\0');
        drv_gpio_write(rf_pa_rxen_pin, '\x01');
      }
      if (fPtaEn != '\0')
      {
        drv_gpio_write(rf_pta_priority_pin, '\0');
      }
      rf_trx_state_set(RF_MODE_RX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
    }
    g_sysDiags.phytoMACqueuelimitreached = g_sysDiags.phytoMACqueuelimitreached + 1;
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  else
  {
    g_sysDiags.macRxCrcFail = g_sysDiags.macRxCrcFail + 1;
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  DAT_00800c20 = DAT_00800c20 | 4;
  return;
}

void rf_tx_irq_handler(void)

{
  int iVar1;

  rf_busyFlag = rf_busyFlag & 0xfd;
  g_sysDiags.macTxIrqCnt = g_sysDiags.macTxIrqCnt + '\x01';
  if ((rfMode != '\x01') || (iVar1 = rf_trx_state_get(), iVar1 != 1))
  {
    rfMode = '\x01';
    if (fPaEn != '\0')
    {
      drv_gpio_write(rf_pa_txen_pin, '\0');
      drv_gpio_write(rf_pa_rxen_pin, '\x01');
    }
    if (fPtaEn != '\0')
    {
      drv_gpio_write(rf_pta_priority_pin, '\0');
    }
    rf_trx_state_set(RF_MODE_RX, g_zbInfo.macPib.phyChannelCur * '\x05' + -0x32);
  }
  zb_macDataSendHander();
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void irq_handler(void)

{
  uint uVar1;
  ushort uVar2;

  uVar2 = _DAT_00800f20;
  if ((_DAT_00800f20 & 2) != 0)
  {
    _DAT_00800f20 = 2;
    T_DBG_irqTest[0] = T_DBG_irqTest[0] + '\x01';
    rf_tx_irq_handler();
  }
  if ((uVar2 & 1) != 0)
  {
    _DAT_00800f20 = 1;
    T_DBG_irqTest[1] = T_DBG_irqTest[1] + '\x01';
    rf_rx_irq_handler();
  }
  uVar1 = _DAT_00800648;
  if ((uVar2 & 4) != 0)
  {
    _DAT_00800f20 = 4;
  }
  if ((uVar2 & 0x400) != 0)
  {
    _DAT_00800f20 = 0x400;
  }
  if ((_DAT_00800648 & 1) != 0)
  {
    _DAT_00800648 = 1;
    DAT_00800623 = 1;
    T_DBG_irqTest[2] = T_DBG_irqTest[2] + '\x01';
    drv_timer_irq0_handler();
  }
  if ((uVar1 & 2) != 0)
  {
    _DAT_00800648 = 2;
    DAT_00800623 = 2;
    T_DBG_irqTest[3] = T_DBG_irqTest[3] + '\x01';
    drv_timer_irq1_handler();
  }
  if ((uVar1 & 0x100000) != 0)
  {
    _DAT_00800648 = 0x100000;
    T_DBG_irqTest[4] = T_DBG_irqTest[4] + '\x01';
    drv_timer_irq3_handler();
  }
  if ((uVar1 & 0x40000) != 0)
  {
    _DAT_00800648 = 0x40000;
    T_DBG_irqTest[5] = T_DBG_irqTest[5] + '\x01';
    drv_gpio_irq_handler();
  }
  if ((uVar1 & 0x200000) != 0)
  {
    _DAT_00800648 = 0x200000;
    T_DBG_irqTest[6] = T_DBG_irqTest[6] + '\x01';
    drv_gpio_irq_risc0_handler();
  }
  if ((uVar1 & 0x400000) != 0)
  {
    _DAT_00800648 = 0x400000;
    T_DBG_irqTest[7] = T_DBG_irqTest[7] + '\x01';
    drv_gpio_irq_risc1_handler();
  }
  if ((DAT_00800c26 & 1) == 0)
  {
    if ((DAT_00800c26 & 2) == 0)
    {
      DAT_00800c26 = 0xfc;
    }
    else
    {
      DAT_00800c26 = 2;
      T_DBG_irqTest[9] = T_DBG_irqTest[9] + '\x01';
      drv_uart_tx_irq_handler();
    }
  }
  else
  {
    DAT_00800c26 = 1;
    T_DBG_irqTest[8] = T_DBG_irqTest[8] + '\x01';
    drv_uart_rx_irq_handler();
  }
  return;
}

// WARNING: Removing unreachable block (RAM,0x00000a2c)
// WARNING: Removing unreachable block (RAM,0x00000a50)
// WARNING: Removing unreachable block (RAM,0x00000aa4)
// WARNING: Removing unreachable block (RAM,0x00000a60)
// WARNING: Removing unreachable block (RAM,0x00000a64)
// WARNING: Removing unreachable block (RAM,0x00000a6a)
// WARNING: Removing unreachable block (RAM,0x00000a74)
// WARNING: Removing unreachable block (RAM,0x00000a7c)
// WARNING: Removing unreachable block (RAM,0x00000a82)
// WARNING: Removing unreachable block (RAM,0x00000a8a)
// WARNING: Removing unreachable block (RAM,0x00000a92)
// WARNING: Removing unreachable block (RAM,0x00000ab0)
// WARNING: Removing unreachable block (RAM,0x00000ad8)
// WARNING: Removing unreachable block (RAM,0x00000af8)
// WARNING: Removing unreachable block (RAM,0x00000b08)
// WARNING: Removing unreachable block (RAM,0x00000a98)
// WARNING: Removing unreachable block (RAM,0x00000a48)

uint adc_sample_and_get_result_op(char mode, uint *d)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}

uint adc_get_result_with_fluct(uint *v)

{
  uint uVar1;

  uVar1 = adc_sample_and_get_result_op('\x01', v);
  return uVar1;
}

void flash_send_addr(uint addr)

{
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  DAT_0080000c = (char)addr;
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  return;
}

void flash_send_cmd(uchar cmd)

{
  DAT_0080000d = 1;
  sleep_us(1);
  DAT_0080000d = 0;
  DAT_0080000c = cmd;
  return;
}

// WARNING: Removing unreachable block (RAM,0x00000bd8)

void flash_wait_done(void)

{
  sleep_us(100);
  flash_send_cmd('\x05');
  DAT_0080000c = 0;
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  DAT_0080000d = 1;
  return;
}

void flash_mspi_read_ram(uchar cmd, ulong addr, uchar addr_en, uchar dummy_cnt, uchar *data,
                         ulong data_len)

{
  undefined uVar1;
  int iVar2;
  ulong uVar3;

  uVar1 = DAT_00800643;
  DAT_00800643 = 0;
  flash_send_cmd(cmd);
  if (addr_en != '\0')
  {
    flash_send_addr(addr);
  }
  if (dummy_cnt != 0)
  {
    iVar2 = 0;
    do
    {
      do
      {
      } while ((DAT_0080000d & 0x10) != 0);
      iVar2 = iVar2 + 1;
    } while (iVar2 < (int)(uint)dummy_cnt);
  }
  DAT_0080000c = '\0';
  do
  {
  } while ((DAT_0080000d & 0x10) != 0);
  DAT_0080000d = 0;
  if (data_len != 0)
  {
    uVar3 = 0;
    do
    {
      data[uVar3] = DAT_0080000c;
      do
      {
      } while ((DAT_0080000d & 0x10) != 0);
      uVar3 = uVar3 + 1;
    } while (uVar3 != data_len);
  }
  DAT_0080000d = 1;
  DAT_00800643 = uVar1;
  return;
}

void flash_mspi_write_ram(uchar cmd, ulong addr, uchar addr_en, uchar *data, ulong data_len)

{
  undefined uVar1;
  uint uVar2;
  ulong uVar3;
  uint local_20;

  uVar1 = DAT_00800643;
  DAT_00800643 = 0;
  flash_send_cmd('\x06');
  flash_send_cmd(cmd);
  if (addr_en != '\0')
  {
    if ((g_flashIsZbit != '\0') &&
        ((uVar2 = adc_get_result_with_fluct(&local_20), uVar2 <= g_flashWorkVol || (499 < local_20))))
      goto LAB_00000cf4;
    flash_send_addr(addr);
  }
  if (data_len != 0)
  {
    uVar3 = 0;
    do
    {
      DAT_0080000c = data[uVar3];
      do
      {
      } while ((DAT_0080000d & 0x10) != 0);
      uVar3 = uVar3 + 1;
    } while (uVar3 != data_len);
  }
LAB_00000cf4:
  DAT_0080000d = 1;
  flash_wait_done();
  DAT_00800643 = uVar1;
  return;
}

zb_buf_t *b1(void)

{
  zb_buf_s **ppzVar1;
  zb_buf_t *dest;
  u32 en;
  int iVar2;

  en = drv_disable_irq();
  if (g_mPool.usedNum < ZB_BUF_POOL_SIZE)
  {
    if (((g_mPool.head < g_mPool.pool) && (g_mPool.head != (zb_buf_t *)0x0)) ||
        ((zb_buf_t *)((int)&g_mPool + (ZB_BUF_POOL_SIZE - 1) * 0xd0 + 8) < g_mPool.head))
    {
      sys_exceptionPost(0x45, '\x13');
    }
    dest = g_mPool.head;
    if (g_mPool.head != (zb_buf_t *)0x0)
    {
      ppzVar1 = &(g_mPool.head)->next;
      g_mPool.head = (g_mPool.head)->next;
      *(undefined *)ppzVar1 = 0;
      *(undefined *)((int)&dest->next + 1) = 0;
      *(undefined *)((int)&dest->next + 2) = 0;
      *(undefined *)((int)&dest->next + 3) = 0;
      (dest->hdr).id = '\0';
      (dest->hdr).handle = '\0';
      (dest->hdr).rssi = '\0';
      (dest->hdr).field_0x3 = 0;
      memset(dest, 0, 0xc0);
      g_mPool.usedNum = g_mPool.usedNum + 1;
      (dest->hdr).field_0x3 = (dest->hdr).field_0x3 | 1;
      iVar2 = dest->allocCnt + 1;
      *(char *)&dest->allocCnt = (char)iVar2;
      *(char *)((int)&dest->allocCnt + 1) = (char)((uint)iVar2 >> 8);
      *(char *)((int)&dest->allocCnt + 2) = (char)((uint)iVar2 >> 0x10);
      *(char *)((int)&dest->allocCnt + 3) = (char)((uint)iVar2 >> 0x18);
      drv_restore_irq(en);
      return dest;
    }
    if (g_mPool.usedNum < ZB_BUF_POOL_SIZE)
    {
      sys_exceptionPost(0x57, '\x13');
    }
  }
  drv_restore_irq(en);
  g_sysDiags.packetBufferAllocateFailures = g_sysDiags.packetBufferAllocateFailures + 1;
  return (zb_buf_t *)0x0;
}

void c1(void)

{
  b1();
  return;
}

u8 *tl_getRxBuf(void)

{
  int iVar1;
  u8 *puVar2;

  iVar1 = b1();
  puVar2 = (u8 *)0x0;
  if (iVar1 != 0)
  {
    puVar2 = (u8 *)(iVar1 + (uint)RX_ZBBUF_OFFSET);
  }
  return puVar2;
}

u8 tl_zbTaskQPush(u8 idx, tl_zb_task_t *task)

{
  byte bVar1;
  tl_zb_callback_t pvVar2;
  void *pvVar3;
  u32 en;
  int iVar4;
  undefined1 *puVar5;

  en = drv_disable_irq();
  if (idx == 0)
  {
    if (0x1f < (int)((uint)taskQ_user[256] - (uint)taskQ_user[257]))
    {
    LAB_00000fe6:
      drv_restore_irq(en);
      return '\x01';
    }
    puVar5 = taskQ_user + (taskQ_user[256] & 0x1f) * 8;
    taskQ_user[256] = taskQ_user[256] + 1;
  }
  else
  {
    iVar4 = (idx - 1) * 0x84;
    bVar1 = g_zbTaskQ[iVar4 + 0x80];
    if (0xf < (int)((uint)bVar1 - (uint)(byte)g_zbTaskQ[iVar4 + 0x81]))
      goto LAB_00000fe6;
    puVar5 = g_zbTaskQ + (bVar1 & 0xf) * 8 + iVar4;
    g_zbTaskQ[iVar4 + 0x80] = bVar1 + 1;
  }
  pvVar2 = task->tlCb;
  *puVar5 = (char)pvVar2;
  puVar5[1] = (char)((uint)pvVar2 >> 8);
  puVar5[2] = (char)((uint)pvVar2 >> 0x10);
  puVar5[3] = (char)((uint)pvVar2 >> 0x18);
  pvVar3 = task->data;
  puVar5[4] = (char)pvVar3;
  puVar5[5] = (char)((uint)pvVar3 >> 8);
  puVar5[6] = (char)((uint)pvVar3 >> 0x10);
  puVar5[7] = (char)((uint)pvVar3 >> 0x18);
  iVar4 = buf_type_get(task->data);
  if ((iVar4 == 0) && (-1 < (int)((uint) * (byte *)((int)task->data + 0xc3) << 0x1f)))
  {
    T_DBG_taskQPush_cb = task->tlCb;
    T_DBG_taskQPush_idx = idx;
    T_DBG_taskQPush_data = task->data;
    sys_exceptionPost(0x80, '\x13');
  }
  drv_restore_irq(en);
  return '\0';
}

u8 tl_zbMacHdrSize(u16 frameCtrl)

{
  u8 uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;

  uVar2 = (uint)frameCtrl;
  uVar3 = (uVar2 << 0x14) >> 0x1e;
  uVar4 = (uVar2 << 0x10) >> 0x1e;
  uVar1 = '\x03';
  if ((uVar3 != 0) && (uVar1 = '\a', uVar3 == 3))
  {
    uVar1 = '\r';
  }
  if (uVar4 != 0)
  {
    if (uVar4 == 3)
    {
      uVar1 = uVar1 + '\b';
    }
    else
    {
      uVar1 = uVar1 + '\x02';
    }
    if (-1 < (int)(uVar2 << 0x19))
    {
      uVar1 = uVar1 + '\x02';
    }
  }
  return uVar1;
}

u8 tl_zbMacPendingDataCheck(u8 addrMode, u8 *addr, u8 send)

{
  int iVar1;
  undefined4 *puVar2;

  iVar1 = listLength((list_t)&macPendingQueue_list);
  if (iVar1 != 0)
  {
    for (puVar2 = (undefined4 *)listHead((list_t)&macPendingQueue_list); puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2)
    {
      if ((puVar2[1] != 0) && (*(u8 *)(puVar2 + 4) == addrMode))
      {
        if (addrMode == '\x03')
        {
          iVar1 = 0;
          while (addr[iVar1] == *(u8 *)((int)puVar2 + iVar1 + 8))
          {
            iVar1 = iVar1 + 1;
            if (iVar1 == 8)
              goto LAB_000010f2;
          }
        }
        else if (*(short *)(puVar2 + 2) == (ushort)((ushort)addr[1] * 0x100 + (ushort)*addr))
        {
        LAB_000010f2:
          if (send == '\0')
          {
            return 0xed;
          }
          if (1 < (byte)(*(char *)((int)puVar2 + 0x13) - 1U))
          {
            return 0xed;
          }
          *(undefined *)((int)puVar2 + 0x13) = 2;
          return '\0';
        }
      }
    }
  }
  return 0xed;
}


void zb_macDataRecvHander(u8 *rxBuf, u8 *data, u8 len, u8 ackPkt, u32 timestamp, s8 rssi)

{
  byte bVar1;
  zb_buf_t *buf;

  buf = (zb_buf_t *)tl_phyRxBufTozbBuf(rxBuf);
  if (ackPkt == '\0')
  {
    buf->buf[0] = (u8)data;
    buf->buf[1] = (u8)((uint)data >> 8);
    buf->buf[2] = (u8)((uint)data >> 0x10);
    buf->buf[3] = (u8)((uint)data >> 0x18);
    buf->buf[9] = len + 0xfd;
    buf->buf[4] = (u8)timestamp;
    buf->buf[5] = (u8)(timestamp >> 8);
    buf->buf[6] = (u8)(timestamp >> 0x10);
    buf->buf[7] = (u8)(timestamp >> 0x18);
    buf->buf[8] = rssi;
    rf_busyFlag = rf_busyFlag & 0xfe;
    bVar1 = tl_zbUserTaskQNum();
    if (bVar1 < 0x1b)
    {
      tl_zbTaskPost(mac_rxDataParse, buf);
      return;
    }
  }
  else if ((mac_trx_vars[4] == '\x03') && (mac_trx_vars[11] == data[2]))
  {
    mac_trxTask();
  }
  zb_buf_free(buf);
  return;
}

void zb_macDataSendHander(void)

{
  mac_trxTask();
  return;
}

uchar analog_read(uchar addr)

{
  DAT_008000b8 = addr;
  DAT_008000ba = 0;
  return DAT_008000b9;
}

void analog_write(uchar addr, uchar v)

{
  DAT_008000b8 = addr;
  DAT_008000b9 = v;
  DAT_008000ba = 0;
  return;
}

// WARNING: Removing unreachable block (RAM,0x00001508)
// WARNING: Removing unreachable block (RAM,0x0000150e)
// WARNING: Removing unreachable block (RAM,0x00001514)
// WARNING: Removing unreachable block (RAM,0x00001522)
// WARNING: Removing unreachable block (RAM,0x00001524)
// WARNING: Removing unreachable block (RAM,0x0000151c)

uint cpu_get_32k_tick(void)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}

int rf_trx_state_set(RF_StatusTypeDef rf_status, char rf_channel)

{
  int iVar1;

  DAT_00800f02 = 0x45;
  rf_set_channel();
  if (rf_status == RF_MODE_TX)
  {
    DAT_00800f02 = 0x55;
    DAT_00800428 = DAT_00800428 & 0xfe;
    RF_TRxState = 0;
    iVar1 = 0;
  }
  else if (rf_status == RF_MODE_RX)
  {
    DAT_00800f02 = 0x65;
    DAT_00800428 = DAT_00800428 | 1;
    RF_TRxState = 1;
    iVar1 = 0;
  }
  else if (rf_status == RF_MODE_OFF)
  {
    DAT_00800f16 = 0x29;
    DAT_00800428 = 0xe0;
    DAT_00800f02 = 0x45;
    RF_TRxState = 3;
    iVar1 = 0;
  }
  else if (rf_status == RF_MODE_AUTO)
  {
    DAT_00800f00 = 0x80;
    DAT_00800f16 = 0x29;
    DAT_00800428 = DAT_00800428 & 0xfe;
    DAT_00800f02 = DAT_00800f02 & 0xce;
    RF_TRxState = 2;
    iVar1 = 0;
  }
  else
  {
    iVar1 = -2;
  }
  return iVar1;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_tx_pkt(uchar *rf_txaddr)

{
  DAT_00800c43 = 4;
  _DAT_00800c0c = (short)rf_txaddr;
  DAT_00800c24 = DAT_00800c24 | 8;
  return;
}

// WARNING: Removing unreachable block (RAM,0x00001612)

void sleep_us(ulong us)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAB(void)

{
  div();
  return;
}

void FUN_00001624(void)

{
  div();
  return;
}

void FUN_00001628(void)

{
  div();
  return;
}

void FUN_0000162c(void)

{
  div();
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 div(void)

{
  undefined4 in_r0;
  undefined4 in_r1;
  uint in_r2;
  uint in_r3;

  getExecutionMode(in_r3);
  setExecutionMode(in_r3 | 0x80);
  _DAT_00800664 = in_r0;
  _DAT_00800668 = in_r1;
  DAT_00800660 = (char)in_r2;
  do
  {
  } while ((char)in_r2 != '\0');
  if (1 < in_r2)
  {
    in_r0 = in_r1;
  }
  setExecutionMode(in_r3);
  return in_r0;
}

void zdp_txCnfCb(void *arg)

{
  return;
}

void zdp_serverCmdHandler(void *ind)

{
  undefined uVar1;
  undefined uVar2;
  short sVar3;
  undefined2 *local_18;
  undefined2 uStack_14;
  undefined2 uStack_12;
  undefined2 local_10;
  undefined local_e;

  uVar1 = *(undefined *)(short *)((int)ind + 8);
  uVar2 = *(undefined *)((int)ind + 9);
  sVar3 = *(short *)((int)ind + 8);
  if (sVar3 == -0x7fe1)
  {
    zdo_parentAnnounceNotify(ind);
    zb_buf_free((zb_buf_t *)ind);
  }
  else
  {
    if ((ushort)(sVar3 + 0x8000U) < 2)
    {
      zdo_remoteAddrNotify(ind);
      uVar1 = *(undefined *)((int)ind + 8);
      uVar2 = *(undefined *)((int)ind + 9);
    }
    uStack_14 = *(undefined2 *)((int)ind + 0x14);
    uStack_12 = CONCAT11(uVar2, uVar1);
    local_18 = *(undefined2 **)((int)ind + 0xc);
    local_10 = *local_18;
    local_e = *(undefined *)((int)ind + 10);
    memcpy(ind, &local_18, 0xb);
    zdp_cb_process((ushort) * (byte *)((int)ind + 8), ind);
    zb_buf_free((zb_buf_t *)ind);
  }
  return;
}

void _ramcode_size_align_256_(void)

{
  zb_buf_t *unaff_r4;

  zb_buf_free(unaff_r4);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdp_rxDataIndication(void *ind)

{
  int iVar1;
  u8 uVar2;
  undefined local_30[12];
  undefined4 uStack_24;
  uint uStack_20;
  zdo_callback p_Stack_1c;
  u8 local_18;

  if ((int)((uint) * (ushort *)((int)ind + 8) * 0x10000) < 0)
  {
    zdp_serverCmdHandler(ind);
  }
  else
  {
    iVar1 = 0;
    do
    {
      if (((uint)g_zdpClientFunc[iVar1].clusterId == (uint) * (ushort *)((int)ind + 8)) &&
          (g_zdpClientFunc[iVar1].func != ll_reset))
      {
        if (((g_zdpClientFunc[iVar1].restricted != 1) || (-1 < (int)((uint)aps_ib._18_1_ << 0x1c))) || ((uVar2 = 0x8d, *(u16 *)((int)ind + 0x14) == g_zbInfo.nwkNib.managerAddr &&
                                                                                                                           ((*(byte *)((int)ind + 0x1f) & 1) != 0))))
        {
          zz1(ind);
          return;
        }
        goto LAB_0000177c;
      }
      iVar1 = iVar1 + 1;
    } while (iVar1 != 0x12);
    uVar2 = 0x84;
  LAB_0000177c:
    // WARNING: Load size is inaccurate
    if ((*ind != '\x02') || ((*(ushort *)((int)ind + 2) & 0xfff8) != 0xfff8))
    {
      local_30._0_4_ = (u8 *)0x0;
      local_30._4_4_ = (u8 *)0x0;
      local_30._8_4_ = 0;
      uStack_24 = 0;
      uStack_20 = 0;
      p_Stack_1c = ll_reset;
      local_18 = '\0';
      local_30._0_4_ = (u8 *)tl_bufInitalloc((zb_buf_t *)ind, '\x02');
      *local_30._0_4_ = **(u8 **)((int)ind + 0xc);
      local_30._0_4_[1] = uVar2;
      uStack_20 = (uint)(uint3)(CONCAT12(2, *(undefined2 *)((int)ind + 8)) | 0x8000);
      local_30._8_4_ = local_30._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)ind + 0x14);
      p_Stack_1c = ll_reset;
      local_30._4_4_ = (u8 *)ind;
      zdo_send_req((zdo_zdp_req_t *)local_30);
    }
    zb_buf_free((zb_buf_t *)ind);
  }
  return;
}

void zz1(void)

{
  code *in_r3;

  (*in_r3)();
  af_endpointRegister('\0', &zdoSd, zdp_rxDataIndication, zdp_txCnfCb);
  return;
}

void zdp_init(void)

{
  af_endpointRegister('\0', &zdoSd, zdp_rxDataIndication, zdp_txCnfCb);
  return;
}

void zcl_reset(void)

{
  u8 *puVar1;
  int iVar2;

  zcl_vars.hookFn = ll_reset;
  zcl_vars.clusterNum = '\0';
  puVar1 = &zcl_vars.clusterList[0].endpoint;
  iVar2 = 0;
  do
  {
    *puVar1 = 0xfe;
    zcl_vars.clusterList[iVar2].clusterID = 0xfffe;
    puVar1[1] = '\0';
    *(undefined2 *)&zcl_vars.clusterList[iVar2].attrTable = 0;
    *(undefined2 *)((int)&zcl_vars.clusterList[iVar2].attrTable + 2) = 0;
    *(undefined2 *)&zcl_vars.clusterList[iVar2].cmdHandlerFunc = 0;
    *(undefined2 *)((int)&zcl_vars.clusterList[iVar2].cmdHandlerFunc + 2) = 0;
    *(undefined2 *)&zcl_vars.clusterList[iVar2].clusterAppCb = 0;
    *(undefined2 *)((int)&zcl_vars.clusterList[iVar2].clusterAppCb + 2) = 0;
    iVar2 = iVar2 + 1;
    puVar1 = puVar1 + 0x12;
  } while (iVar2 != 0x10);
  return;
}

void zcl_init(zcl_hookFn_t fn)

{
  u32 uVar1;

  zcl_reset();
  uVar1 = drv_u32Rand();
  zcl_seqNum = (u8)uVar1;
  zcl_vars.hookFn = fn;
  return;
}

void zcl_register(u8 endpoint, u8 clusterNum, zcl_specClusterInfo_t *info)

{
  int iVar1;
  uint uVar2;

  if (clusterNum == 0)
  {
    return;
  }
  uVar2 = 0;
  while ((info->clusterRegisterFunc == ll_reset ||
          (iVar1 = FUN_0000192a(endpoint, info->manuCode, *(undefined *)&info->attrNum, info->attrTbl,
                                info->clusterAppCb),
           iVar1 != 0x89)))
  {
    uVar2 = uVar2 + 1;
    if (clusterNum <= uVar2)
    {
      return;
    }
    info = info + 1;
  }
  return;
}

undefined4 FUN_0000192a(void)

{
  u8 uVar1;
  undefined4 uVar2;
  uint extraout_r1;
  uint uVar3;
  u16 extraout_r2;
  u8 *puVar4;
  u8 extraout_r3;
  int iVar5;
  code *unaff_ip;
  undefined4 in_stack_00000000;
  undefined2 uStack00000004;
  undefined2 uStack00000008;

  uVar1 = (*unaff_ip)();
  uVar3 = (uint)zcl_vars.clusterNum;
  uVar2 = 0x89;
  if (uVar3 < 0x10)
  {
    puVar4 = &zcl_vars.clusterList[0].endpoint;
    iVar5 = 0;
    do
    {
      if ((*puVar4 == uVar1) &&
          ((uint)zcl_vars.clusterList[iVar5].clusterID == (extraout_r1 & 0xffff)))
      {
        return 0x8a;
      }
      iVar5 = iVar5 + 1;
      puVar4 = puVar4 + 0x12;
    } while (iVar5 != 0x10);
    zcl_vars.clusterList[uVar3].endpoint = uVar1;
    zcl_vars.clusterList[uVar3].clusterID = (u16)extraout_r1;
    zcl_vars.clusterList[uVar3].manuCode = extraout_r2;
    zcl_vars.clusterList[uVar3].attrNum = extraout_r3;
    *(undefined2 *)&zcl_vars.clusterList[uVar3].cmdHandlerFunc = uStack00000004;
    *(short *)((int)&zcl_vars.clusterList[uVar3].cmdHandlerFunc + 2) =
        (short)((uint)_uStack00000004 >> 0x10);
    *(undefined2 *)&zcl_vars.clusterList[uVar3].clusterAppCb = uStack00000008;
    *(short *)((int)&zcl_vars.clusterList[uVar3].clusterAppCb + 2) =
        (short)((uint)_uStack00000008 >> 0x10);
    *(short *)&zcl_vars.clusterList[uVar3].attrTable = (short)in_stack_00000000;
    *(short *)((int)&zcl_vars.clusterList[uVar3].attrTable + 2) =
        (short)((uint)in_stack_00000000 >> 0x10);
    zcl_vars.clusterNum = zcl_vars.clusterNum + '\x01';
    uVar2 = 0;
  }
  return uVar2;
}

status_t zcl_registerCluster(u8 endpoint, u16 clusterId, u16 manuCode, u8 attrNum,
                             zclAttrInfo_t *pAttrTbl, cluster_cmdHdlr_t cmdHdlrFn,
                             cluster_forAppCb_t cb)

{
  status_t sVar1;
  uint uVar2;
  u8 *puVar3;
  int iVar4;

  uVar2 = (uint)zcl_vars.clusterNum;
  sVar1 = 0x89;
  if (uVar2 < 0x10)
  {
    puVar3 = &zcl_vars.clusterList[0].endpoint;
    iVar4 = 0;
    do
    {
      if ((*puVar3 == endpoint) && (zcl_vars.clusterList[iVar4].clusterID == clusterId))
      {
        return 0x8a;
      }
      iVar4 = iVar4 + 1;
      puVar3 = puVar3 + 0x12;
    } while (iVar4 != 0x10);
    zcl_vars.clusterList[uVar2].endpoint = endpoint;
    zcl_vars.clusterList[uVar2].clusterID = clusterId;
    zcl_vars.clusterList[uVar2].manuCode = manuCode;
    zcl_vars.clusterList[uVar2].attrNum = attrNum;
    zcl_vars.clusterList[uVar2].cmdHandlerFunc = cmdHdlrFn;
    zcl_vars.clusterList[uVar2].clusterAppCb = cb;
    zcl_vars.clusterList[uVar2].attrTable = pAttrTbl;
    zcl_vars.clusterNum = zcl_vars.clusterNum + '\x01';
    sVar1 = '\0';
  }
  return sVar1;
}

u8 zcl_getDataTypeLen(u8 dataType)

{
  u8 uVar1;
  uint uVar2;

  uVar2 = (uint)dataType * 0x1000000 + 0xf8000000 >> 0x18;
  uVar1 = '\0';
  if (uVar2 < 0xea)
  {
    uVar1 = CSWTCH_32[uVar2];
  }
  return uVar1;
}

u8 zcl_analogDataType(u8 dataType)

{
  uint uVar1;

  uVar1 = (uint)dataType;
  if (uVar1 < 0x3b)
  {
    if (uVar1 < 0x38)
    {
      if (0xf < uVar1 - 0x20)
      {
        return '\0';
      }
      return '\x01';
    }
  }
  else if (2 < uVar1 - 0xe0)
  {
    return '\0';
  }
  return '\x01';
}

u16 zcl_getAttrSize(u8 dataType, u8 *pData)

{
  uint uVar1;
  int iVar2;
  byte bVar3;
  uint uVar4;

  uVar1 = (uint)dataType;
  if (uVar1 * 0x1000000 + 0xbd000000 >> 0x18 < 2)
  {
    uVar1 = *pData + 2 + (uint)pData[1] * 0x100 & 0xffff;
  }
  else if ((uVar1 - 0x41 & 0xff) < 2)
  {
    uVar1 = *pData + 1;
  }
  else if (uVar1 == 0x4c)
  {
    uVar1 = 2;
    if (*pData != 0)
    {
      bVar3 = 0;
      do
      {
        uVar4 = pData[uVar1] - 8 & 0xff;
        iVar2 = 1;
        if (uVar4 < 0xea)
        {
          iVar2 = (byte)CSWTCH_32[uVar4] + 1;
        }
        uVar1 = iVar2 + uVar1 & 0xffff;
        bVar3 = bVar3 + 1;
      } while (bVar3 < *pData);
    }
  }
  else
  {
    uVar4 = uVar1 - 8 & 0xff;
    uVar1 = 0;
    if (uVar4 < 0xea)
    {
      uVar1 = (uint)(byte)CSWTCH_32[uVar4];
    }
  }
  return (u16)uVar1;
}

// WARNING: Removing unreachable block (RAM,0x00001ace)

void zcl_analogDataBuild(u8 dataType, u8 *pData, u8 *pBuf)

{
  u16 uVar1;
  uint uVar2;

  uVar1 = zcl_getAttrSize(dataType, pData);
  if (uVar1 != 0)
  {
    uVar2 = 0;
    do
    {
      *pData = pBuf[uVar2];
      uVar2 = uVar2 + 1;
      pData = pData + 1;
    } while (uVar2 != uVar1);
  }
  return;
}

zclAttrInfo_t *zcl_findAttribute(u8 endpoint, u16 clusterId, u16 attrId)

{
  byte bVar1;
  zclAttrInfo_t *pzVar2;
  u8 *puVar3;
  byte bVar4;
  uint uVar5;

  puVar3 = &zcl_vars.clusterList[0].endpoint;
  uVar5 = 0;
  while ((*puVar3 != endpoint || (zcl_vars.clusterList[uVar5].clusterID != clusterId)))
  {
    uVar5 = uVar5 + 1;
    puVar3 = puVar3 + 0x12;
    if (uVar5 == 0x10)
    {
      return (zclAttrInfo_t *)0x0;
    }
  }
  bVar1 = zcl_vars.clusterList[uVar5 & 0xff].attrNum;
  if (bVar1 == 0)
  {
    return (zclAttrInfo_t *)0x0;
  }
  pzVar2 = zcl_vars.clusterList[uVar5 & 0xff].attrTable;
  if (pzVar2->id == attrId)
  {
    return pzVar2;
  }
  bVar4 = 0;
  do
  {
    pzVar2 = pzVar2 + 1;
    bVar4 = bVar4 + 1;
    if (bVar1 <= bVar4)
    {
      return (zclAttrInfo_t *)0x0;
    }
  } while (pzVar2->id != attrId);
  return pzVar2;
}

status_t zcl_getAttrVal(u8 endpoint, u16 clusterId, u16 attrId, u16 *len, u8 *val)

{
  u8 *pData;
  status_t sVar1;
  u16 uVar2;
  zclAttrInfo_t *pzVar3;

  pzVar3 = zcl_findAttribute(endpoint, clusterId, attrId);
  if (pzVar3 == (zclAttrInfo_t *)0x0)
  {
    *len = 0;
    sVar1 = 0x8b;
  }
  else
  {
    pData = pzVar3->data;
    if (pData == (u8 *)0x0)
    {
      *len = 0;
      sVar1 = 0x8b;
    }
    else
    {
      uVar2 = zcl_getAttrSize(pzVar3->type, pData);
      *len = uVar2;
      memcpy(val, pData, (uint)uVar2);
      sVar1 = '\0';
    }
  }
  return sVar1;
}

status_t zcl_setAttrVal(u8 endpoint, u16 clusterId, u16 attrId, u8 *val)

{
  status_t sVar1;
  u16 uVar2;
  zclAttrInfo_t *pzVar3;

  pzVar3 = zcl_findAttribute(endpoint, clusterId, attrId);
  sVar1 = 0x86;
  if (pzVar3 != (zclAttrInfo_t *)0x0)
  {
    uVar2 = zcl_getAttrSize(pzVar3->type, val);
    memcpy(pzVar3->data, val, (uint)uVar2);
    sVar1 = '\0';
  }
  return sVar1;
}

zclAttrInfo_t *zcl_attrRead(u8 endpoint, u16 clusterId, u16 attrId, status_t *status)

{
  zclAttrInfo_t *pzVar1;

  pzVar1 = zcl_findAttribute(endpoint, clusterId, attrId);
  if (pzVar1 == (zclAttrInfo_t *)0x0)
  {
    *status = 0x86;
  }
  else if ((int)((uint)pzVar1->access << 0x1f) < 0)
  {
    if (pzVar1->data == (u8 *)0x0)
    {
      *status = 0x86;
      pzVar1 = (zclAttrInfo_t *)0x0;
    }
    else
    {
      *status = '\0';
    }
  }
  else
  {
    *status = 0x8f;
    pzVar1 = (zclAttrInfo_t *)0x0;
  }
  return pzVar1;
}

status_t zcl_attrWrite(u8 endpoint, u16 clusterId, zclWriteRec_t *pWriteRec, u8 enable)

{
  u16 attrId;
  status_t sVar1;
  zclAttrInfo_t *pzVar2;

  attrId = pWriteRec->attrID;
  pzVar2 = zcl_findAttribute(endpoint, clusterId, attrId);
  sVar1 = 0x86;
  if ((((pzVar2 != (zclAttrInfo_t *)0x0) && (sVar1 = 0x8d, pzVar2->type == pWriteRec->dataType)) &&
       (sVar1 = 0x88, (int)((uint)pzVar2->access << 0x1e) < 0)) &&
      ((sVar1 = 0x86, pzVar2->data != (u8 *)0x0 && (sVar1 = '\0', enable != '\0'))))
  {
    sVar1 = zcl_setAttrVal(endpoint, clusterId, attrId, pWriteRec->attrData);
  }
  return sVar1;
}

status_t zcl_sendCmd(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u8 cmd, u8 specific, u8 direction,
                     u8 disableDefaultRsp, u16 manuCode, u8 seqNo, u16 cmdPldLen, u8 *cmdPld)

{
  u8 uVar1;
  byte *cmdPld_00;
  byte *pbVar2;
  byte bVar3;
  u8 local_25;

  _cmdPldLen = (uint)cmdPldLen;
  cmdPld_00 = ev_buf_allocate((u16)(_cmdPldLen * 0x10000 + 0x50000 >> 0x10));
  bVar3 = 0x89;
  if (cmdPld_00 != (byte *)0x0)
  {
    *cmdPld_00 = 1U - (specific == '\0') | *cmdPld_00 & 0xfc;
    *cmdPld_00 = *cmdPld_00 & 0xfb | (manuCode != 0) * '\x04';
    *cmdPld_00 = *cmdPld_00 & 0xf7 | (byte)((direction & 1) << 3);
    *cmdPld_00 = *cmdPld_00 & 0xef | (byte)((disableDefaultRsp & 1) << 4);
    *cmdPld_00 = *cmdPld_00 & 0x1f;
    pbVar2 = cmdPld_00 + 1;
    if (manuCode != 0)
    {
      *(u16 *)(cmdPld_00 + 1) = manuCode;
      pbVar2 = cmdPld_00 + 3;
    }
    *pbVar2 = seqNo;
    pbVar2[1] = cmd;
    memcpy(cmdPld_00 + ((uint)(pbVar2 + (2 - (int)cmdPld_00)) & 0xff), cmdPld, (uint)cmdPldLen);
    local_25 = '\0';
    uVar1 = af_dataSend(srcEp, pDstEpInfo, clusterId,
                        (cmdPldLen - (short)cmdPld_00) +
                            (short)(cmdPld_00 + ((uint)(pbVar2 + (2 - (int)cmdPld_00)) & 0xff)),
                        cmdPld_00, &local_25);
    ev_buf_free(cmdPld_00);
    bVar3 = ~(1U - (uVar1 == '\0')) & 0x89;
  }
  return bVar3;
}

void zcl_rx_handler(void *pData)

{
  tl_zbTaskPost(zcl_cmdHandler, pData);
  return;
}

status_t zcl_readRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                     u8 direction, u8 seqNo, zclReadRspCmd_t *readRspCmd)

{
  byte bVar1;
  status_t sVar2;
  u16 uVar3;
  u16 uVar4;
  u8 *cmdPld;
  zclReadRspCmd_t *pzVar5;
  u8 *puVar6;
  u8 *out;
  uint uVar7;

  bVar1 = readRspCmd->numAttr;
  if (bVar1 == 0)
  {
    uVar3 = 0;
  }
  else
  {
    uVar7 = 0;
    pzVar5 = readRspCmd;
    uVar4 = 0;
    do
    {
      uVar3 = uVar4 + 3;
      if (pzVar5[3].numAttr == '\0')
      {
        if (*(u8 **)(readRspCmd + uVar7 * 8 + 5) == (u8 *)0x0)
        {
          return 0x85;
        }
        uVar3 = zcl_getAttrSize(pzVar5[4].numAttr, *(u8 **)(readRspCmd + uVar7 * 8 + 5));
        uVar3 = uVar4 + 4 + uVar3;
      }
      uVar7 = uVar7 + 1;
      pzVar5 = pzVar5 + 8;
      uVar4 = uVar3;
    } while ((uVar7 & 0xff) < (uint)bVar1);
  }
  cmdPld = ev_buf_allocate(uVar3);
  sVar2 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (readRspCmd->numAttr != '\0')
    {
      uVar7 = 0;
      puVar6 = cmdPld;
      do
      {
        *puVar6 = readRspCmd[uVar7 * 8 + 1].numAttr;
        puVar6[1] = readRspCmd[uVar7 * 8 + 2].numAttr;
        puVar6[2] = readRspCmd[uVar7 * 8 + 3].numAttr;
        out = puVar6 + 3;
        if (readRspCmd[uVar7 * 8 + 3].numAttr == '\0')
        {
          puVar6[3] = readRspCmd[uVar7 * 8 + 4].numAttr;
          out = puVar6 + 4;
          puVar6 = *(u8 **)(readRspCmd + uVar7 * 8 + 5);
          if (puVar6 != (u8 *)0x0)
          {
            uVar4 = zcl_getAttrSize(readRspCmd[uVar7 * 8 + 4].numAttr, puVar6);
            memcpy(out, puVar6, (uint)uVar4);
            out = out + uVar4;
          }
        }
        uVar7 = uVar7 + 1 & 0xff;
        puVar6 = out;
      } while (uVar7 < readRspCmd->numAttr);
    }
    sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\x01', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, uVar3, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar2;
}

zclReadRspCmd_t *zcl_parseInReadRspCmd(zclIncoming_t *pCmd)

{
  byte bVar1;
  u8 *puVar2;
  u16 uVar3;
  zclReadRspCmd_t *pzVar4;
  uint length;
  int iVar5;
  u8 *puVar6;
  byte *pbVar7;
  uint uVar8;
  u8 *puVar9;
  zclReadRspCmd_t *out;
  short sVar10;
  uint uVar11;

  puVar9 = pCmd->pData + pCmd->dataLen;
  uVar11 = 0;
  uVar8 = 0;
  puVar2 = pCmd->pData;
  while (puVar6 = puVar2, sVar10 = (short)uVar11, puVar6 < puVar9)
  {
    while (true)
    {
      uVar8 = uVar8 + 1 & 0xff;
      puVar2 = puVar6 + 3;
      if (puVar6[2] != '\0')
        break;
      uVar3 = zcl_getAttrSize(puVar6[3], puVar6 + 4);
      puVar6 = puVar6 + 4 + uVar3;
      uVar11 = uVar3 + uVar11 & 0xffff;
      sVar10 = (short)uVar11;
      if (puVar9 <= puVar6)
        goto LAB_00001fbc;
    }
  }
LAB_00001fbc:
  uVar11 = uVar8 * 0x80000 + 0x10000;
  pzVar4 = (zclReadRspCmd_t *)ev_buf_allocate((short)(uVar11 >> 0x10) + sVar10);
  if (pzVar4 != (zclReadRspCmd_t *)0x0)
  {
    pbVar7 = pCmd->pData;
    pzVar4->numAttr = (u8)uVar8;
    if (uVar8 != 0)
    {
      out = pzVar4 + (uVar11 >> 0x10);
      uVar8 = 0;
      do
      {
        while (true)
        {
          iVar5 = (uint)pbVar7[1] * 0x100 + (uint)*pbVar7;
          pzVar4[uVar8 * 8 + 1].numAttr = (u8)iVar5;
          pzVar4[uVar8 * 8 + 2].numAttr = (u8)((uint)iVar5 >> 8);
          bVar1 = pbVar7[2];
          pzVar4[uVar8 * 8 + 3].numAttr = bVar1;
          if (bVar1 != 0)
            break;
          bVar1 = pbVar7[3];
          pzVar4[uVar8 * 8 + 4].numAttr = bVar1;
          pbVar7 = pbVar7 + 4;
          uVar3 = zcl_getAttrSize(bVar1, pbVar7);
          length = (uint)uVar3;
          memcpy(out, pbVar7, length);
          pzVar4[uVar8 * 8 + 5].numAttr = (u8)out;
          pzVar4[uVar8 * 8 + 6].numAttr = (u8)((uint)out >> 8);
          pzVar4[uVar8 * 8 + 7].numAttr = (u8)((uint)out >> 0x10);
          pzVar4[uVar8 * 8 + 8].numAttr = (u8)((uint)out >> 0x18);
          out = out + length;
          uVar8 = uVar8 + 1 & 0xff;
          pbVar7 = pbVar7 + length;
          if (pzVar4->numAttr <= uVar8)
          {
            return pzVar4;
          }
        }
        uVar8 = uVar8 + 1 & 0xff;
        pbVar7 = pbVar7 + 3;
      } while (uVar8 < pzVar4->numAttr);
    }
  }
  return pzVar4;
}

status_t zcl_readRspHandler(zclIncoming_t *pCmd)

{
  zclReadRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInReadRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclReadRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}

zclReadCmd_t *zcl_parseInReadCmd(zclIncoming_t *pCmd)

{
  zclReadCmd_t *pzVar1;
  int iVar2;
  byte *pbVar3;
  uint uVar4;
  uint uVar5;

  pbVar3 = pCmd->pData;
  pzVar1 = (zclReadCmd_t *)ev_buf_allocate(pCmd->dataLen + 1);
  if (pzVar1 != (zclReadCmd_t *)0x0)
  {
    uVar4 = (uint)pCmd->dataLen << 0x17;
    uVar5 = uVar4 >> 0x18;
    pzVar1->numAttr = (u8)(uVar4 >> 0x18);
    if (uVar5 != 0)
    {
      uVar4 = 0;
      do
      {
        iVar2 = (uint)pbVar3[1] * 0x100 + (uint)*pbVar3;
        pzVar1[uVar4 * 2 + 1].numAttr = (u8)iVar2;
        pzVar1[uVar4 * 2 + 2].numAttr = (u8)((uint)iVar2 >> 8);
        pbVar3 = pbVar3 + 2;
        uVar4 = uVar4 + 1;
      } while ((uVar4 & 0xff) < uVar5);
    }
  }
  return pzVar1;
}

status_t zcl_readHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  apsdeDataInd_t *paVar1;
  u16 clusterId;
  u8 *puVar2;
  undefined2 uVar3;
  zclReadRspCmd_t zVar4;
  zclReadCmd_t *pzVar5;
  zclReadRspCmd_t *readRspCmd;
  zclAttrInfo_t *pzVar6;
  int iVar7;
  byte bVar8;
  uint uVar9;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;
  zclReadRspCmd_t local_25;

  local_25.numAttr = '\0';
  paVar1 = pCmd->msg;
  clusterId = (paVar1->indInfo).cluster_id;
  endpoint = (paVar1->indInfo).dst_ep;
  g_sysDiags.lastMessageLQI = (paVar1->indInfo).lqi;
  g_sysDiags.lastMessageRSSI = (pCmd->msg->indInfo).rssi;
  pzVar5 = zcl_parseInReadCmd(pCmd);
  zVar4.numAttr = 0x89;
  if (pzVar5 != (zclReadCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    zVar4.numAttr = '\x01';
    if ((pCmd->msg->indInfo).security_status != 0)
    {
      readRspCmd = (zclReadRspCmd_t *)
          ev_buf_allocate((u16)((uint)pzVar5->numAttr * 0x80000 + 0x10000 >> 0x10));
      zVar4.numAttr = 0x89;
      if (readRspCmd != (zclReadRspCmd_t *)0x0)
      {
        readRspCmd->numAttr = pzVar5->numAttr;
        uVar9 = 0;
        if (pzVar5->numAttr != '\0')
        {
          do
          {
            pzVar6 = zcl_attrRead(endpoint, clusterId, *(u16 *)(pzVar5 + uVar9 * 2 + 1),
                                  &local_25.numAttr);
            iVar7 = uVar9 * 8;
            if (pzVar6 != (zclAttrInfo_t *)0x0)
            {
              readRspCmd[iVar7 + 4].numAttr = pzVar6->type;
              puVar2 = pzVar6->data;
              readRspCmd[iVar7 + 5].numAttr = (u8)puVar2;
              readRspCmd[iVar7 + 6].numAttr = (u8)((uint)puVar2 >> 8);
              readRspCmd[iVar7 + 7].numAttr = (u8)((uint)puVar2 >> 0x10);
              readRspCmd[iVar7 + 8].numAttr = (u8)((uint)puVar2 >> 0x18);
            }
            uVar3 = *(undefined2 *)(pzVar5 + uVar9 * 2 + 1);
            readRspCmd[iVar7 + 1].numAttr = (u8)uVar3;
            readRspCmd[iVar7 + 2].numAttr = (u8)((ushort)uVar3 >> 8);
            readRspCmd[iVar7 + 3].numAttr = local_25.numAttr;
            uVar9 = uVar9 + 1 & 0xff;
          } while (uVar9 < pzVar5->numAttr);
        }
        uStack_34 = 0;
        paVar1 = pCmd->msg;
        uStack_30 = (uint)(paVar1->indInfo).profile_id;
        uStack_2c = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
        local_38 = (uint)(paVar1->indInfo).field_10.src_short_addr;
        local_28 = 4;
        if ((int)((uint)(paVar1->indInfo).security_status << 0x1f) < 0)
        {
          local_28 = 5;
        }
        bVar8 = (pCmd->hdr).frmCtrl.byte & 8;
        local_25.numAttr =
            zcl_readRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                        bVar8 + ~bVar8, (pCmd->hdr).seqNum, readRspCmd);
        ev_buf_free((u8 *)readRspCmd);
        zVar4.numAttr = local_25.numAttr;
        if (local_25.numAttr == '\0')
        {
          zVar4.numAttr = 0xff;
        }
      }
    }
  }
  return zVar4.numAttr;
}

status_t zcl_writeRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                      u8 direction, u8 seqNo, zclWriteRspCmd_t *writeRspCmd)

{
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  uint uVar3;
  u16 size;

  size = (ushort)writeRspCmd->numAttr * 3;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (writeRspCmd->numAttr != '\0')
    {
      uVar3 = 0;
      puVar2 = cmdPld;
      do
      {
        *puVar2 = writeRspCmd[uVar3 * 3 + 1].numAttr;
        puVar2[1] = writeRspCmd[uVar3 * 3 + 2].numAttr;
        puVar2[2] = writeRspCmd[uVar3 * 3 + 3].numAttr;
        puVar2 = puVar2 + 3;
        uVar3 = uVar3 + 1 & 0xff;
      } while (uVar3 < writeRspCmd->numAttr);
      if ((writeRspCmd->numAttr == 1) && (writeRspCmd[1].numAttr == '\0'))
      {
        size = 1;
      }
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\x04', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}

zclWriteRspCmd_t *zcl_parseInWriteRspCmd(zclIncoming_t *pCmd)

{
  zclWriteRspCmd_t *pzVar1;
  int iVar2;
  uint uVar3;
  u8 *puVar4;

  puVar4 = pCmd->pData;
  pzVar1 = (zclWriteRspCmd_t *)ev_buf_allocate(pCmd->dataLen + 1);
  if (pzVar1 != (zclWriteRspCmd_t *)0x0)
  {
    if (pCmd->dataLen == 1)
    {
      pzVar1[1].numAttr = *puVar4;
      uVar3 = 1;
    }
    else
    {
      uVar3 = 0;
      if (puVar4 < pCmd->pData + pCmd->dataLen)
      {
        do
        {
          pzVar1[uVar3 * 3 + 1].numAttr = *puVar4;
          iVar2 = (uint)puVar4[2] * 0x100 + (uint)puVar4[1];
          pzVar1[uVar3 * 3 + 2].numAttr = (u8)iVar2;
          pzVar1[uVar3 * 3 + 3].numAttr = (u8)((uint)iVar2 >> 8);
          uVar3 = uVar3 + 1 & 0xff;
          puVar4 = puVar4 + 3;
        } while (puVar4 < pCmd->pData + pCmd->dataLen);
      }
    }
    pzVar1->numAttr = (u8)uVar3;
  }
  return pzVar1;
}

status_t zcl_writeRspHandler(zclIncoming_t *pCmd)

{
  zclWriteRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInWriteRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclWriteRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}

zclWriteCmd_t *zcl_parseInWriteCmd(zclIncoming_t *pCmd)

{
  byte dataType;
  u16 uVar1;
  zclWriteCmd_t *pzVar2;
  uint length;
  u8 *puVar3;
  int iVar4;
  zclWriteCmd_t *out;
  uint uVar5;
  u8 *puVar6;
  byte *pbVar7;
  zclWriteCmd_t *pzVar8;
  uint uVar9;

  puVar3 = pCmd->pData;
  puVar6 = puVar3 + pCmd->dataLen;
  if (puVar3 < puVar6)
  {
    uVar5 = 0;
    uVar9 = 0;
    do
    {
      uVar9 = uVar9 + 1 & 0xff;
      uVar1 = zcl_getAttrSize(puVar3[2], puVar3 + 3);
      puVar3 = puVar3 + 3 + uVar1;
      uVar5 = uVar5 + uVar1 & 0xffff;
    } while (puVar3 < puVar6);
    iVar4 = uVar9 * 7 + 1;
    uVar1 = (short)iVar4 + (short)uVar5;
  }
  else
  {
    uVar1 = 1;
    iVar4 = 1;
    uVar9 = 0;
  }
  pzVar2 = (zclWriteCmd_t *)ev_buf_allocate(uVar1);
  if (pzVar2 != (zclWriteCmd_t *)0x0)
  {
    pbVar7 = pCmd->pData;
    pzVar2->numAttr = (u8)uVar9;
    if (uVar9 != 0)
    {
      out = pzVar2 + iVar4;
      uVar5 = 0;
      pzVar8 = pzVar2;
      do
      {
        iVar4 = (uint)pbVar7[1] * 0x100 + (uint)*pbVar7;
        pzVar2[uVar5 * 7 + 1].numAttr = (u8)iVar4;
        pzVar2[uVar5 * 7 + 2].numAttr = (u8)((uint)iVar4 >> 8);
        dataType = pbVar7[2];
        pzVar8[3].numAttr = dataType;
        pbVar7 = pbVar7 + 3;
        uVar1 = zcl_getAttrSize(dataType, pbVar7);
        length = (uint)uVar1;
        memcpy(out, pbVar7, length);
        pzVar2[uVar5 * 7 + 4].numAttr = (u8)out;
        pzVar2[uVar5 * 7 + 5].numAttr = (u8)((uint)out >> 8);
        pzVar2[uVar5 * 7 + 6].numAttr = (u8)((uint)out >> 0x10);
        pzVar2[uVar5 * 7 + 7].numAttr = (u8)((uint)out >> 0x18);
        pbVar7 = pbVar7 + length;
        out = out + length;
        uVar5 = uVar5 + 1;
        pzVar8 = pzVar8 + 7;
      } while ((uVar5 & 0xff) < uVar9);
    }
  }
  return pzVar2;
}

status_t zcl_writeHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  u16 clusterId;
  undefined2 uVar1;
  bool bVar2;
  apsdeDataInd_t *paVar3;
  status_t sVar4;
  zclWriteCmd_t *pzVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uStack_44;
  zclWriteRspCmd_t *pzStack_40;
  u8 uStack_3c;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  endpoint = (pCmd->msg->indInfo).dst_ep;
  pzVar5 = zcl_parseInWriteCmd(pCmd);
  sVar4 = 0x89;
  if (pzVar5 != (zclWriteCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    if ((pCmd->hdr).cmd == '\x02')
    {
      pzStack_40 = (zclWriteRspCmd_t *)ev_buf_allocate((ushort)pzVar5->numAttr * 3 + 1);
      if (pzStack_40 == (zclWriteRspCmd_t *)0x0)
      {
        return 0x89;
      }
      bVar2 = true;
    }
    else
    {
      bVar2 = false;
      pzStack_40 = (zclWriteRspCmd_t *)0x0;
    }
    uVar7 = (uint)pzVar5->numAttr;
    if (uVar7 == 0)
    {
      uStack_3c = '\0';
      uStack_44 = 0;
      sVar4 = '\0';
    }
    else
    {
      uVar8 = 0;
      uStack_44 = 0;
      uVar9 = 0;
      do
      {
        while (sVar4 = zcl_attrWrite(endpoint, clusterId, (zclWriteRec_t *)(pzVar5 + uVar8 * 7 + 1),
                                     '\x01'),
               !bVar2)
        {
        LAB_000025ec:
          uVar8 = uVar8 + 1 & 0xff;
          uVar7 = (uint)pzVar5->numAttr;
          if (uVar7 <= uVar8)
            goto LAB_0000264a;
        }
        if (sVar4 == '\0')
        {
          uStack_44 = uStack_44 + 1 & 0xff;
          goto LAB_000025ec;
        }
        pzStack_40[uVar9 * 3 + 1].numAttr = sVar4;
        uVar1 = *(undefined2 *)(pzVar5 + uVar8 * 7 + 1);
        pzStack_40[uVar9 * 3 + 2].numAttr = (u8)uVar1;
        pzStack_40[uVar9 * 3 + 3].numAttr = (u8)((ushort)uVar1 >> 8);
        uVar9 = uVar9 + 1 & 0xff;
        uVar8 = uVar8 + 1 & 0xff;
        uVar7 = (uint)pzVar5->numAttr;
      } while (uVar8 < uVar7);
    LAB_0000264a:
      uStack_3c = (u8)uVar9;
    }
    if (bVar2)
    {
      if (uVar7 == uStack_44)
      {
        pzStack_40->numAttr = '\x01';
        pzStack_40[1].numAttr = '\0';
      }
      else
      {
        pzStack_40->numAttr = uStack_3c;
      }
      uStack_34 = 0;
      paVar3 = pCmd->msg;
      uStack_30 = (uint)(paVar3->indInfo).profile_id;
      uStack_2c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
      local_38 = (uint)(paVar3->indInfo).field_10.src_short_addr;
      local_28 = 4;
      if ((int)((uint)(paVar3->indInfo).security_status << 0x1f) < 0)
      {
        local_28 = 5;
      }
      bVar6 = (pCmd->hdr).frmCtrl.byte & 8;
      sVar4 = zcl_writeRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                           bVar6 + ~bVar6, (pCmd->hdr).seqNum, pzStack_40);
      if (sVar4 == '\0')
      {
        sVar4 = 0xff;
      }
      ev_buf_free(&pzStack_40->numAttr);
    }
  }
  return sVar4;
}

status_t zcl_writeUndividedHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  u16 clusterId;
  ushort uVar1;
  apsdeDataInd_t *paVar2;
  byte bVar3;
  status_t sVar4;
  zclWriteCmd_t *pzVar5;
  zclWriteRspCmd_t *writeRspCmd;
  uint uVar6;
  byte bVar7;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  endpoint = (pCmd->msg->indInfo).dst_ep;
  pzVar5 = zcl_parseInWriteCmd(pCmd);
  if (pzVar5 == (zclWriteCmd_t *)0x0)
  {
    return 0x89;
  }
  *(char *)&pCmd->attrCmd = (char)pzVar5;
  *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
  *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
  *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
  writeRspCmd = (zclWriteRspCmd_t *)ev_buf_allocate((ushort)pzVar5->numAttr * 3 + 1);
  if (writeRspCmd == (zclWriteRspCmd_t *)0x0)
  {
    return 0x89;
  }
  if (pzVar5->numAttr == '\0')
  {
    writeRspCmd->numAttr = '\0';
  }
  else
  {
    uVar6 = 0;
    bVar7 = 1;
    do
    {
      bVar3 = zcl_attrWrite(endpoint, clusterId, (zclWriteRec_t *)(pzVar5 + uVar6 * 7 + 1), '\0');
      writeRspCmd[uVar6 * 3 + 1].numAttr = bVar3;
      uVar1 = *(ushort *)(pzVar5 + uVar6 * 7 + 1);
      writeRspCmd[uVar6 * 3 + 2].numAttr = (u8)uVar1;
      writeRspCmd[uVar6 * 3 + 3].numAttr = (u8)(uVar1 >> 8);
      bVar7 = bVar7 & ~(bVar3 + ~bVar3 + ((uVar1 >> 7 & 1) != 0));
      uVar6 = uVar6 + 1 & 0xff;
    } while (uVar6 < pzVar5->numAttr);
    writeRspCmd->numAttr = pzVar5->numAttr;
    if (bVar7 == 0)
      goto LAB_000027ea;
  }
  if (pzVar5->numAttr != '\0')
  {
    uVar6 = 0;
    do
    {
      zcl_attrWrite(endpoint, clusterId, (zclWriteRec_t *)(pzVar5 + uVar6 * 7 + 1), '\x01');
      uVar6 = uVar6 + 1 & 0xff;
    } while (uVar6 < pzVar5->numAttr);
  }
  writeRspCmd->numAttr = '\x01';
  writeRspCmd[1].numAttr = '\0';
LAB_000027ea:
  uStack_34 = 0;
  paVar2 = pCmd->msg;
  uStack_30 = (uint)(paVar2->indInfo).profile_id;
  uStack_2c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
  local_38 = (uint)(paVar2->indInfo).field_10.src_short_addr;
  local_28 = (ushort)(((paVar2->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
  bVar7 = (pCmd->hdr).frmCtrl.byte & 8;
  sVar4 = zcl_writeRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                       bVar7 + ~bVar7, (pCmd->hdr).seqNum, writeRspCmd);
  if (sVar4 == '\0')
  {
    sVar4 = 0xff;
  }
  ev_buf_free((u8 *)writeRspCmd);
  return sVar4;
}

status_t zcl_configReportRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode,
                             u8 disableDefaultRsp, u8 direction, u8 seqNo,
                             zclCfgReportRspCmd_t *cfgReportRspCmd)

{
  u16 size;
  status_t sVar1;
  u8 *cmdPld;
  uint uVar2;
  u8 *puVar3;

  size = (ushort)cfgReportRspCmd->numAttr * 4;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (cfgReportRspCmd->numAttr != '\0')
    {
      uVar2 = 0;
      puVar3 = cmdPld;
      do
      {
        *puVar3 = cfgReportRspCmd[uVar2 * 4 + 1].numAttr;
        puVar3[1] = cfgReportRspCmd[uVar2 * 4 + 2].numAttr;
        puVar3[2] = cfgReportRspCmd[uVar2 * 4 + 3].numAttr;
        puVar3[3] = cfgReportRspCmd[uVar2 * 4 + 4].numAttr;
        puVar3 = puVar3 + 4;
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < cfgReportRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\a', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}

status_t zcl_readReportConfigRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                                 u8 direction, u8 seqNo, zclReadReportCfgRspCmd_t *readReportCfgRspCmd)

{
  status_t sVar1;
  u16 uVar2;
  u16 uVar3;
  u8 *cmdPld;
  uint uVar4;
  u8 *out;
  zclReadReportCfgRspCmd_t *pzVar5;
  u8 *puVar6;
  uint uVar7;
  uint uVar8;

  uVar4 = (uint)readReportCfgRspCmd->numAttr;
  uVar2 = 0;
  if (uVar4 != 0)
  {
    uVar7 = 0;
    uVar2 = 0;
    pzVar5 = readReportCfgRspCmd;
  LAB_000029c2:
    do
    {
      uVar3 = uVar2 + 4;
      if (pzVar5[1].numAttr == '\0')
      {
        if (pzVar5[2].numAttr == '\0')
        {
          uVar3 = uVar2 + 9;
          uVar8 = (uint)pzVar5[5].numAttr;
          if (uVar8 < 0x3b)
          {
            if ((uVar8 < 0x38) && (0xf < uVar8 - 0x20))
              goto joined_r0x00002b58;
          }
          else if (2 < uVar8 - 0xe0)
            goto joined_r0x00002b58;
          uVar2 = zcl_getAttrSize(pzVar5[5].numAttr,
                                  *(u8 **)(readReportCfgRspCmd + uVar7 * 0xf + 0xc));
          uVar2 = uVar2 + uVar3;
          uVar7 = uVar7 + 1;
          pzVar5 = pzVar5 + 0xf;
          if (uVar4 <= (uVar7 & 0xff))
            break;
          goto LAB_000029c2;
        }
        uVar3 = uVar2 + 6;
      }
    joined_r0x00002b58:
      uVar2 = uVar3;
      uVar8 = uVar7 + 1;
      pzVar5 = pzVar5 + 0xf;
      uVar7 = uVar7 + 1;
    } while ((uVar8 & 0xff) < uVar4);
  }
  cmdPld = ev_buf_allocate(uVar2);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    if (readReportCfgRspCmd->numAttr != '\0')
    {
      uVar4 = 0;
      puVar6 = cmdPld;
    LAB_00002a1a:
      do
      {
        *puVar6 = readReportCfgRspCmd[uVar4 * 0xf + 1].numAttr;
        puVar6[1] = readReportCfgRspCmd[uVar4 * 0xf + 2].numAttr;
        puVar6[2] = readReportCfgRspCmd[uVar4 * 0xf + 3].numAttr;
        puVar6[3] = readReportCfgRspCmd[uVar4 * 0xf + 4].numAttr;
        out = puVar6 + 4;
        if (readReportCfgRspCmd[uVar4 * 0xf + 1].numAttr != '\0')
          goto LAB_00002a76;
        if (readReportCfgRspCmd[uVar4 * 0xf + 2].numAttr == '\0')
        {
          puVar6[4] = readReportCfgRspCmd[uVar4 * 0xf + 5].numAttr;
          puVar6[5] = readReportCfgRspCmd[uVar4 * 0xf + 6].numAttr;
          puVar6[6] = readReportCfgRspCmd[uVar4 * 0xf + 7].numAttr;
          puVar6[7] = readReportCfgRspCmd[uVar4 * 0xf + 8].numAttr;
          puVar6[8] = readReportCfgRspCmd[uVar4 * 0xf + 9].numAttr;
          out = puVar6 + 9;
          uVar7 = (uint)readReportCfgRspCmd[uVar4 * 0xf + 5].numAttr;
          if (uVar7 < 0x3b)
          {
            if ((0x37 < uVar7) || (uVar7 - 0x20 < 0x10))
            {
            LAB_00002b08:
              puVar6 = *(u8 **)(readReportCfgRspCmd + uVar4 * 0xf + 0xc);
              uVar3 = zcl_getAttrSize(readReportCfgRspCmd[uVar4 * 0xf + 5].numAttr, puVar6);
              memcpy(out, puVar6, (uint)uVar3);
              puVar6 = out + uVar3;
              uVar4 = uVar4 + 1 & 0xff;
              if (readReportCfgRspCmd->numAttr <= uVar4)
                break;
              goto LAB_00002a1a;
            }
          }
          else if (uVar7 - 0xe0 < 3)
            goto LAB_00002b08;
        LAB_00002a76:
          puVar6 = out;
          uVar4 = uVar4 + 1 & 0xff;
          if (readReportCfgRspCmd->numAttr <= uVar4)
            break;
          goto LAB_00002a1a;
        }
        puVar6[4] = readReportCfgRspCmd[uVar4 * 0xf + 10].numAttr;
        puVar6[5] = readReportCfgRspCmd[uVar4 * 0xf + 0xb].numAttr;
        puVar6 = puVar6 + 6;
        uVar4 = uVar4 + 1 & 0xff;
      } while (uVar4 < readReportCfgRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\t', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, uVar2, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}

zclCfgReportCmd_t *zcl_parseInCfgReportCmd(zclIncoming_t *pCmd)

{
  zclCfgReportCmd_t *dest;
  u8 *puVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  u8 *puVar5;
  uint uVar6;
  zclCfgReportCmd_t *pzVar7;
  uint uVar8;
  zclCfgReportCmd_t *pData;

  puVar5 = pCmd->pData;
  puVar1 = puVar5 + pCmd->dataLen;
  uVar6 = 0;
  uVar8 = 0;
LAB_00002bae:
  if (puVar5 < puVar1)
  {
    while (uVar8 = uVar8 + 1 & 0xff, *puVar5 == '\0')
    {
      uVar2 = (uint)puVar5[3];
      if (uVar2 < 0x3b)
      {
        if ((0x37 < uVar2) || (uVar2 - 0x20 < 0x10))
          goto LAB_00002cf4;
      }
      else if (uVar2 - 0xe0 < 3)
      {
      LAB_00002cf4:
        puVar5 = puVar5 + (byte)CSWTCH_32[uVar2 - 8 & 0xff] + 8;
        uVar6 = uVar6 + (byte)CSWTCH_32[uVar2 - 8 & 0xff] & 0xffff;
        goto LAB_00002bae;
      }
      puVar5 = puVar5 + 9;
      if (puVar1 <= puVar5)
        goto LAB_00002be0;
    }
    puVar5 = puVar5 + 5;
    goto LAB_00002bae;
  }
LAB_00002be0:
  uVar2 = uVar8 * 0xe000000 + 0x1000000 >> 0x18;
  uVar6 = uVar2 + uVar6;
  dest = (zclCfgReportCmd_t *)ev_buf_allocate((u16)uVar6);
  if (dest != (zclCfgReportCmd_t *)0x0)
  {
    memset(dest, 0, uVar6);
    puVar5 = pCmd->pData;
    dest->numAttr = (u8)uVar8;
    if (uVar8 != 0)
    {
      pData = dest + uVar2;
      uVar6 = 0;
      pzVar7 = dest;
      do
      {
        while (true)
        {
          pzVar7[1].numAttr = *puVar5;
          iVar3 = (uint)puVar5[2] * 0x100 + (uint)puVar5[1];
          dest[uVar6 * 0xe + 2].numAttr = (u8)iVar3;
          dest[uVar6 * 0xe + 3].numAttr = (u8)((uint)iVar3 >> 8);
          if (pzVar7[1].numAttr == '\0')
            break;
          iVar3 = (uint)puVar5[4] * 0x100 + (uint)puVar5[3];
          dest[uVar6 * 0xe + 9].numAttr = (u8)iVar3;
          dest[uVar6 * 0xe + 10].numAttr = (u8)((uint)iVar3 >> 8);
          puVar5 = puVar5 + 5;
        joined_r0x00002cda:
          uVar2 = uVar6 + 1;
          pzVar7 = pzVar7 + 0xe;
          uVar6 = uVar6 + 1;
          if (uVar8 <= (uVar2 & 0xff))
          {
            return dest;
          }
        }
        pzVar7[4].numAttr = puVar5[3];
        iVar3 = (uint)puVar5[5] * 0x100 + (uint)puVar5[4];
        dest[uVar6 * 0xe + 5].numAttr = (u8)iVar3;
        dest[uVar6 * 0xe + 6].numAttr = (u8)((uint)iVar3 >> 8);
        iVar3 = (uint)puVar5[7] * 0x100 + (uint)puVar5[6];
        dest[uVar6 * 0xe + 7].numAttr = (u8)iVar3;
        dest[uVar6 * 0xe + 8].numAttr = (u8)((uint)iVar3 >> 8);
        puVar5 = puVar5 + 8;
        uVar2 = (uint)pzVar7[4].numAttr;
        if (uVar2 < 0x3b)
        {
          if ((0x37 < uVar2) || (uVar2 - 0x20 < 0x10))
            goto LAB_00002c96;
          goto joined_r0x00002cda;
        }
        if (uVar2 - 0xe0 < 3)
        {
        LAB_00002c96:
          zcl_analogDataBuild(pzVar7[4].numAttr, &pData->numAttr, puVar5);
          dest[uVar6 * 0xe + 0xb].numAttr = (u8)pData;
          dest[uVar6 * 0xe + 0xc].numAttr = (u8)((uint)pData >> 8);
          dest[uVar6 * 0xe + 0xd].numAttr = (u8)((uint)pData >> 0x10);
          dest[uVar6 * 0xe + 0xe].numAttr = (u8)((uint)pData >> 0x18);
          uVar2 = pzVar7[4].numAttr - 8 & 0xff;
          uVar4 = 0;
          if (uVar2 < 0xea)
          {
            uVar4 = (uint)(byte)CSWTCH_32[uVar2];
          }
          puVar5 = puVar5 + uVar4;
          pData = pData + uVar4;
          goto joined_r0x00002cda;
        }
        uVar6 = uVar6 + 1;
        pzVar7 = pzVar7 + 0xe;
      } while ((uVar6 & 0xff) < uVar8);
    }
  }
  return dest;
}

status_t zcl_configureReporting(u8 endpoint, u16 profileId, u16 clusterId, zclCfgReportRec_t *pCfgReportRec)

{
  u16 attrId;
  zclAttrInfo_t *pzVar1;
  reportCfgInfo_t *pEntry;
  status_t sVar2;

  attrId = pCfgReportRec->attrID;
  pzVar1 = zcl_findAttribute(endpoint, clusterId, attrId);
  if (pzVar1 == (zclAttrInfo_t *)0x0)
  {
    return 0x86;
  }
  if (pzVar1->type != pCfgReportRec->dataType)
  {
    return 0x8d;
  }
  if (-1 < (int)((uint)pzVar1->access << 0x1d))
  {
    return 0x86;
  }
  if (pCfgReportRec->direction == '\x01')
  {
    return 0x86;
  }
  pEntry = zcl_reportCfgInfoEntryFind(endpoint, clusterId, attrId);
  if (pCfgReportRec->maxReportInt == 0xffff)
  {
    sVar2 = 0x8b;
  }
  else
  {
    if ((pCfgReportRec->maxReportInt == 0) && (pCfgReportRec->minReportInt == 0xffff))
    {
      if (pEntry == (reportCfgInfo_t *)0x0)
      {
        return 0x8b;
      }
      zcl_reportCfgInfoEntryRst(pEntry);
      return '\0';
    }
    if (pEntry != (reportCfgInfo_t *)0x0)
      goto LAB_00002de2;
    pEntry = zcl_reportCfgInfoEntryFreeGet();
    sVar2 = 0x89;
  }
  if (pEntry == (reportCfgInfo_t *)0x0)
  {
    return sVar2;
  }
LAB_00002de2:
  zcl_reportCfgInfoEntryUpdate(pEntry, endpoint, profileId, clusterId, pCfgReportRec);
  return '\0';
}

status_t zcl_configReportHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  apsdeDataInd_t *paVar1;
  u16 profileId;
  u16 clusterId;
  undefined2 uVar2;
  bool bVar3;
  status_t sVar4;
  zclCfgReportCmd_t *pzVar5;
  zclCfgReportRspCmd_t *cfgReportRspCmd;
  byte bVar6;
  uint uVar7;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  paVar1 = pCmd->msg;
  profileId = (paVar1->indInfo).profile_id;
  clusterId = (paVar1->indInfo).cluster_id;
  endpoint = (paVar1->indInfo).dst_ep;
  pzVar5 = zcl_parseInCfgReportCmd(pCmd);
  sVar4 = 0x89;
  if (pzVar5 != (zclCfgReportCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    sVar4 = 0x85;
    if (pzVar5->numAttr != 0)
    {
      cfgReportRspCmd =
          (zclCfgReportRspCmd_t *)
              ev_buf_allocate((ushort)(byte)((uint)pzVar5->numAttr * 0x4000000 + 0x1000000 >> 0x18));
      sVar4 = 0x89;
      if (cfgReportRspCmd != (zclCfgReportRspCmd_t *)0x0)
      {
        cfgReportRspCmd->numAttr = pzVar5->numAttr;
        if (pzVar5->numAttr != '\0')
        {
          uVar7 = 0;
          bVar3 = false;
          do
          {
            sVar4 = zcl_configureReporting(endpoint, profileId, clusterId,
                                           (zclCfgReportRec_t *)(pzVar5 + uVar7 * 0xe + 1));
            if (sVar4 == '\0')
            {
              bVar3 = true;
            }
            cfgReportRspCmd[uVar7 * 4 + 1].numAttr = sVar4;
            uVar2 = *(undefined2 *)(pzVar5 + uVar7 * 0xe + 2);
            cfgReportRspCmd[uVar7 * 4 + 3].numAttr = (u8)uVar2;
            cfgReportRspCmd[uVar7 * 4 + 4].numAttr = (u8)((ushort)uVar2 >> 8);
            cfgReportRspCmd[uVar7 * 4 + 2].numAttr = pzVar5[uVar7 * 0xe + 1].numAttr;
            uVar7 = uVar7 + 1 & 0xff;
          } while (uVar7 < pzVar5->numAttr);
          if (bVar3)
          {
            zcl_reportingTab_save();
          }
        }
        uStack_34 = 0;
        paVar1 = pCmd->msg;
        uStack_30 = (uint)(paVar1->indInfo).profile_id;
        uStack_2c = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
        local_38 = (uint)(paVar1->indInfo).field_10.src_short_addr;
        local_28 = (ushort)(((paVar1->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
        bVar6 = (pCmd->hdr).frmCtrl.byte & 8;
        sVar4 = zcl_configReportRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode,
                                    '\x01', bVar6 + ~bVar6, (pCmd->hdr).seqNum, cfgReportRspCmd);
        if (sVar4 == '\0')
        {
          sVar4 = 0xff;
        }
        ev_buf_free((u8 *)cfgReportRspCmd);
      }
    }
  }
  return sVar4;
}

zclCfgReportRspCmd_t *zcl_parseInCfgReportRspCmd(zclIncoming_t *pCmd)

{
  zclCfgReportRspCmd_t *pzVar1;
  zclCfgReportRspCmd_t *pzVar2;
  u8 *puVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;

  puVar3 = pCmd->pData;
  uVar4 = (uint)pCmd->dataLen << 0x16;
  uVar5 = uVar4 >> 0x18;
  pzVar1 = (zclCfgReportRspCmd_t *)ev_buf_allocate((u16)(uVar5 * 0x40000 + 0x10000 >> 0x10));
  if ((pzVar1 != (zclCfgReportRspCmd_t *)0x0) && (pzVar1->numAttr = (u8)(uVar4 >> 0x18), uVar5 != 0))
  {
    uVar4 = 0;
    pzVar2 = pzVar1;
    do
    {
      pzVar2[1].numAttr = *puVar3;
      pzVar2[2].numAttr = puVar3[1];
      iVar6 = (uint)puVar3[3] * 0x100 + (uint)puVar3[2];
      pzVar1[uVar4 * 4 + 3].numAttr = (u8)iVar6;
      pzVar1[uVar4 * 4 + 4].numAttr = (u8)((uint)iVar6 >> 8);
      puVar3 = puVar3 + 4;
      uVar4 = uVar4 + 1;
      pzVar2 = pzVar2 + 4;
    } while ((uVar4 & 0xff) < uVar5);
  }
  return pzVar1;
}

u8 zcl_configReportRspHandler(zclIncoming_t *pCmd)

{
  zclCfgReportRspCmd_t *pzVar1;
  u8 uVar2;

  pzVar1 = zcl_parseInCfgReportRspCmd(pCmd);
  uVar2 = 0x89;
  if (pzVar1 != (zclCfgReportRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    uVar2 = '\0';
  }
  return uVar2;
}

zclReadReportCfgCmd_t *zcl_parseInReadReportCfgCmd(zclIncoming_t *pCmd)

{
  byte bVar1;
  zclReadReportCfgCmd_t *pzVar2;
  zclReadReportCfgCmd_t *pzVar3;
  uint uVar4;
  u8 *puVar5;
  int iVar6;

  puVar5 = pCmd->pData;
  bVar1 = FUN_0000162c(pCmd->dataLen, 3);
  pzVar2 = (zclReadReportCfgCmd_t *)ev_buf_allocate((ushort)bVar1 * 3 + 1);
  if ((pzVar2 != (zclReadReportCfgCmd_t *)0x0) && (pzVar2->numAttr = bVar1, bVar1 != 0))
  {
    uVar4 = 0;
    pzVar3 = pzVar2;
    do
    {
      pzVar3[1].numAttr = *puVar5;
      iVar6 = (uint)puVar5[2] * 0x100 + (uint)puVar5[1];
      pzVar2[uVar4 * 3 + 2].numAttr = (u8)iVar6;
      pzVar2[uVar4 * 3 + 3].numAttr = (u8)((uint)iVar6 >> 8);
      puVar5 = puVar5 + 3;
      uVar4 = uVar4 + 1;
      pzVar3 = pzVar3 + 3;
    } while ((uVar4 & 0xff) < (uint)bVar1);
  }
  return pzVar2;
}

status_t zcl_readReportCfgHandler(zclIncoming_t *pCmd)

{
  u8 endpoint;
  u16 clusterId;
  undefined2 uVar1;
  u16 uVar2;
  apsdeDataInd_t *paVar3;
  status_t sVar4;
  zclReadReportCfgCmd_t *pzVar5;
  zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
  zclAttrInfo_t *pzVar6;
  reportCfgInfo_t *prVar7;
  u8 *puVar8;
  byte bVar9;
  uint uVar10;
  uint uVar11;
  u8 uVar12;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  endpoint = (pCmd->msg->indInfo).dst_ep;
  pzVar5 = zcl_parseInReadReportCfgCmd(pCmd);
  sVar4 = 0x89;
  if (pzVar5 != (zclReadReportCfgCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar5;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar5 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar5 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar5 >> 0x18);
    readReportCfgRspCmd =
        (zclReadReportCfgRspCmd_t *)ev_buf_allocate((ushort)pzVar5->numAttr * 0xf + 1 & 0xff);
    if (readReportCfgRspCmd != (zclReadReportCfgRspCmd_t *)0x0)
    {
      readReportCfgRspCmd->numAttr = pzVar5->numAttr;
      if (pzVar5->numAttr != '\0')
      {
        uVar11 = 0;
        uVar12 = '\0';
        do
        {
          uVar2 = *(u16 *)(pzVar5 + uVar11 * 3 + 2);
          pzVar6 = zcl_findAttribute(endpoint, clusterId, uVar2);
          if (pzVar6 == (zclAttrInfo_t *)0x0)
          {
            uVar12 = 0x86;
          }
          else if (pzVar5[uVar11 * 3 + 1].numAttr == '\0')
          {
            if ((pzVar6->access & 4) == 0)
            {
              uVar12 = 0x8c;
            }
            else
            {
              prVar7 = zcl_reportCfgInfoEntryFind(endpoint, clusterId, uVar2);
              if (prVar7 == (reportCfgInfo_t *)0x0)
              {
                uVar12 = 0x8b;
              }
              else
              {
                readReportCfgRspCmd[uVar11 * 0xf + 5].numAttr = prVar7->dataType;
                uVar2 = prVar7->minInterval;
                readReportCfgRspCmd[uVar11 * 0xf + 6].numAttr = (u8)uVar2;
                readReportCfgRspCmd[uVar11 * 0xf + 7].numAttr = (u8)(uVar2 >> 8);
                uVar2 = prVar7->maxInterval;
                readReportCfgRspCmd[uVar11 * 0xf + 8].numAttr = (u8)uVar2;
                readReportCfgRspCmd[uVar11 * 0xf + 9].numAttr = (u8)(uVar2 >> 8);
                uVar10 = (uint)prVar7->dataType;
                if (uVar10 < 0x3b)
                {
                  if ((0x37 < uVar10) || (uVar10 - 0x20 < 0x10))
                    goto LAB_00003246;
                }
                else if (uVar10 - 0xe0 < 3)
                {
                LAB_00003246:
                  puVar8 = prVar7->reportableChange;
                  readReportCfgRspCmd[uVar11 * 0xf + 0xc].numAttr = (u8)puVar8;
                  readReportCfgRspCmd[uVar11 * 0xf + 0xd].numAttr = (u8)((uint)puVar8 >> 8);
                  readReportCfgRspCmd[uVar11 * 0xf + 0xe].numAttr = (u8)((uint)puVar8 >> 0x10);
                  readReportCfgRspCmd[uVar11 * 0xf + 0xf].numAttr = (u8)((uint)puVar8 >> 0x18);
                }
              }
            }
          }
          else
          {
            uVar12 = 0x86;
          }
          readReportCfgRspCmd[uVar11 * 0xf + 1].numAttr = uVar12;
          readReportCfgRspCmd[uVar11 * 0xf + 2].numAttr = pzVar5[uVar11 * 3 + 1].numAttr;
          uVar1 = *(undefined2 *)(pzVar5 + uVar11 * 3 + 2);
          readReportCfgRspCmd[uVar11 * 0xf + 3].numAttr = (u8)uVar1;
          readReportCfgRspCmd[uVar11 * 0xf + 4].numAttr = (u8)((ushort)uVar1 >> 8);
          uVar11 = uVar11 + 1 & 0xff;
        } while (uVar11 < pzVar5->numAttr);
      }
      uStack_34 = 0;
      paVar3 = pCmd->msg;
      uStack_30 = (uint)(paVar3->indInfo).profile_id;
      uStack_2c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
      local_38 = (uint)(paVar3->indInfo).field_10.src_short_addr;
      local_28 = (ushort)(((paVar3->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
      bVar9 = (pCmd->hdr).frmCtrl.byte & 8;
      sVar4 = zcl_readReportConfigRsp(endpoint, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                                      bVar9 + ~bVar9, (pCmd->hdr).seqNum, readReportCfgRspCmd);
      if (sVar4 == '\0')
      {
        sVar4 = 0xff;
      }
      ev_buf_free((u8 *)readReportCfgRspCmd);
    }
  }
  return sVar4;
}

zclReadReportCfgRspCmd_t *zcl_parseInReadReportCfgRspCmd(zclIncoming_t *pCmd)

{
  zclReadReportCfgRspCmd_t *pzVar1;
  uint uVar2;
  byte *pbVar3;
  byte *pbVar4;
  uint uVar5;
  byte *pbVar6;
  zclReadReportCfgRspCmd_t *pzVar7;
  int iVar8;
  uint uVar9;
  zclReadReportCfgRspCmd_t *pData;
  short sVar10;
  uint uVar11;

  pbVar3 = pCmd->pData;
  pbVar6 = pbVar3 + pCmd->dataLen;
  uVar11 = 0;
  uVar9 = 0;
LAB_000032a8:
  sVar10 = (short)uVar11;
  pbVar4 = pbVar3;
  if (pbVar3 < pbVar6)
  {
    while (true)
    {
      uVar9 = uVar9 + 1 & 0xff;
      pbVar3 = pbVar4 + 4;
      if (*pbVar4 != 0)
        break;
      if (pbVar4[1] != 0)
      {
        pbVar3 = pbVar4 + 6;
        break;
      }
      uVar2 = (uint)*pbVar3;
      pbVar3 = pbVar4 + 9;
      if (uVar2 < 0x3b)
      {
        if ((uVar2 < 0x38) && (0xf < uVar2 - 0x20))
          break;
      }
      else if (2 < uVar2 - 0xe0)
        break;
      pbVar4 = pbVar3 + (byte)CSWTCH_32[uVar2 - 8 & 0xff];
      uVar11 = (byte)CSWTCH_32[uVar2 - 8 & 0xff] + uVar11 & 0xffff;
      sVar10 = (short)uVar11;
      if (pbVar6 <= pbVar4)
        goto LAB_000032f0;
    }
    goto LAB_000032a8;
  }
LAB_000032f0:
  iVar8 = uVar9 * 0xf + 1;
  pzVar1 = (zclReadReportCfgRspCmd_t *)ev_buf_allocate((short)iVar8 + sVar10);
  if (pzVar1 != (zclReadReportCfgRspCmd_t *)0x0)
  {
    pbVar3 = pCmd->pData;
    pzVar1->numAttr = (u8)uVar9;
    if (uVar9 != 0)
    {
      pData = pzVar1 + iVar8;
      uVar11 = 0;
      pzVar7 = pzVar1;
      do
      {
        while (true)
        {
          pzVar7[1].numAttr = *pbVar3;
          pzVar7[2].numAttr = pbVar3[1];
          iVar8 = (uint)pbVar3[3] * 0x100 + (uint)pbVar3[2];
          pzVar1[uVar11 * 0xf + 3].numAttr = (u8)iVar8;
          pzVar1[uVar11 * 0xf + 4].numAttr = (u8)((uint)iVar8 >> 8);
          pbVar6 = pbVar3 + 4;
          if (pzVar7[1].numAttr != '\0')
            goto joined_r0x0000343e;
          if (pzVar7[2].numAttr != '\0')
            break;
          pzVar7[5].numAttr = *pbVar6;
          iVar8 = (uint)pbVar3[6] * 0x100 + (uint)pbVar3[5];
          pzVar1[uVar11 * 0xf + 6].numAttr = (u8)iVar8;
          pzVar1[uVar11 * 0xf + 7].numAttr = (u8)((uint)iVar8 >> 8);
          iVar8 = (uint)pbVar3[8] * 0x100 + (uint)pbVar3[7];
          pzVar1[uVar11 * 0xf + 8].numAttr = (u8)iVar8;
          pzVar1[uVar11 * 0xf + 9].numAttr = (u8)((uint)iVar8 >> 8);
          pbVar6 = pbVar3 + 9;
          uVar2 = (uint)pzVar7[5].numAttr;
          if (uVar2 < 0x3b)
          {
            if ((0x37 < uVar2) || (uVar2 - 0x20 < 0x10))
              goto LAB_000033a4;
          }
          else if (uVar2 - 0xe0 < 3)
          {
          LAB_000033a4:
            zcl_analogDataBuild(pzVar7[5].numAttr, &pData->numAttr, pbVar6);
            pzVar1[uVar11 * 0xf + 0xc].numAttr = (u8)pData;
            pzVar1[uVar11 * 0xf + 0xd].numAttr = (u8)((uint)pData >> 8);
            pzVar1[uVar11 * 0xf + 0xe].numAttr = (u8)((uint)pData >> 0x10);
            pzVar1[uVar11 * 0xf + 0xf].numAttr = (u8)((uint)pData >> 0x18);
            uVar2 = pzVar7[5].numAttr - 8 & 0xff;
            uVar5 = 0;
            if (uVar2 < 0xea)
            {
              uVar5 = (uint)(byte)CSWTCH_32[uVar2];
            }
            pData = pData + uVar5;
            pbVar6 = pbVar6 + uVar5;
          }
        joined_r0x0000343e:
          pbVar3 = pbVar6;
          uVar2 = uVar11 + 1;
          pzVar7 = pzVar7 + 0xf;
          uVar11 = uVar11 + 1;
          if (uVar9 <= (uVar2 & 0xff))
          {
            return pzVar1;
          }
        }
        iVar8 = (uint)pbVar3[5] * 0x100 + (uint)*pbVar6;
        pzVar1[uVar11 * 0xf + 10].numAttr = (u8)iVar8;
        pzVar1[uVar11 * 0xf + 0xb].numAttr = (u8)((uint)iVar8 >> 8);
        pbVar3 = pbVar3 + 6;
        uVar11 = uVar11 + 1;
        pzVar7 = pzVar7 + 0xf;
      } while ((uVar11 & 0xff) < uVar9);
    }
  }
  return pzVar1;
}

status_t zcl_readReportCfgRspHandler(zclIncoming_t *pCmd)

{
  zclReadReportCfgRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInReadReportCfgRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclReadReportCfgRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}

zclReportCmd_t *zcl_parseInReportCmd(zclIncoming_t *pCmd)

{
  byte dataType;
  u16 uVar1;
  zclReportCmd_t *pzVar2;
  uint length;
  u8 *puVar3;
  int iVar4;
  zclReportCmd_t *out;
  uint uVar5;
  u8 *puVar6;
  byte *pbVar7;
  zclReportCmd_t *pzVar8;
  uint uVar9;

  puVar3 = pCmd->pData;
  puVar6 = puVar3 + pCmd->dataLen;
  if (puVar3 < puVar6)
  {
    uVar5 = 0;
    uVar9 = 0;
    do
    {
      uVar9 = uVar9 + 1 & 0xff;
      uVar1 = zcl_getAttrSize(puVar3[2], puVar3 + 3);
      puVar3 = puVar3 + 3 + uVar1;
      uVar5 = uVar5 + uVar1 & 0xffff;
    } while (puVar3 < puVar6);
    iVar4 = uVar9 * 7 + 1;
    uVar1 = (short)iVar4 + (short)uVar5;
  }
  else
  {
    uVar1 = 1;
    iVar4 = 1;
    uVar9 = 0;
  }
  pzVar2 = (zclReportCmd_t *)ev_buf_allocate(uVar1);
  if (pzVar2 != (zclReportCmd_t *)0x0)
  {
    pbVar7 = pCmd->pData;
    pzVar2->numAttr = (u8)uVar9;
    if (uVar9 != 0)
    {
      out = pzVar2 + iVar4;
      uVar5 = 0;
      pzVar8 = pzVar2;
      do
      {
        iVar4 = (uint)pbVar7[1] * 0x100 + (uint)*pbVar7;
        pzVar2[uVar5 * 7 + 1].numAttr = (u8)iVar4;
        pzVar2[uVar5 * 7 + 2].numAttr = (u8)((uint)iVar4 >> 8);
        dataType = pbVar7[2];
        pzVar8[3].numAttr = dataType;
        pbVar7 = pbVar7 + 3;
        uVar1 = zcl_getAttrSize(dataType, pbVar7);
        length = (uint)uVar1;
        memcpy(out, pbVar7, length);
        pzVar2[uVar5 * 7 + 4].numAttr = (u8)out;
        pzVar2[uVar5 * 7 + 5].numAttr = (u8)((uint)out >> 8);
        pzVar2[uVar5 * 7 + 6].numAttr = (u8)((uint)out >> 0x10);
        pzVar2[uVar5 * 7 + 7].numAttr = (u8)((uint)out >> 0x18);
        pbVar7 = pbVar7 + length;
        out = out + length;
        uVar5 = uVar5 + 1;
        pzVar8 = pzVar8 + 7;
      } while ((uVar5 & 0xff) < uVar9);
    }
  }
  return pzVar2;
}

status_t zcl_reportHandler(zclIncoming_t *pCmd)

{
  zclReportCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInReportCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclReportCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}

status_t zcl_sendDfltRsp(zclIncoming_t *inMsg, u8 cmdId, u8 status)

{
  apsdeDataInd_t *paVar1;
  status_t sVar2;
  byte bVar3;
  uint local_30;
  undefined4 uStack_2c;
  uint uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  u8 local_1c;
  u8 uStack_1b;

  paVar1 = inMsg->msg;
  uStack_2c = 0;
  bVar3 = (inMsg->hdr).frmCtrl.byte & 8;
  local_30 = (uint)(paVar1->indInfo).field_10.src_short_addr;
  uStack_24 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
  uStack_28 = (uint)(paVar1->indInfo).profile_id;
  local_20 = 4;
  if ((int)((uint)(paVar1->indInfo).security_status << 0x1f) < 0)
  {
    local_20 = 5;
  }
  local_1c = cmdId;
  uStack_1b = status;
  sVar2 = zcl_sendCmd((paVar1->indInfo).dst_ep, (epInfo_t *)&local_30, (paVar1->indInfo).cluster_id,
                      '\v', '\0', ~bVar3 + bVar3, '\x01', (inMsg->hdr).manufCode, (inMsg->hdr).seqNum, 2,
                      &local_1c);
  return sVar2;
}

zclDefaultRspCmd_t *zcl_parseInDftRspCmd(zclIncoming_t *pCmd)

{
  u8 *puVar1;
  zclDefaultRspCmd_t *pzVar2;

  puVar1 = pCmd->pData;
  pzVar2 = (zclDefaultRspCmd_t *)ev_buf_allocate(2);
  if (pzVar2 != (zclDefaultRspCmd_t *)0x0)
  {
    pzVar2->commandID = *puVar1;
    pzVar2->statusCode = puVar1[1];
  }
  return pzVar2;
}

status_t zcl_dfltRspHandler(zclIncoming_t *pCmd)

{
  byte bVar1;
  zclDefaultRspCmd_t *pzVar2;
  status_t sVar3;

  bVar1 = (pCmd->hdr).frmCtrl.byte;
  if (-1 < (int)((uint)bVar1 << 0x1b))
  {
    (pCmd->hdr).frmCtrl.byte = bVar1 | 0x10;
  }
  pzVar2 = zcl_parseInDftRspCmd(pCmd);
  sVar3 = 0x89;
  if (pzVar2 != (zclDefaultRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar2;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar2 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar2 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar2 >> 0x18);
    sVar3 = '\0';
  }
  return sVar3;
}

status_t zcl_discAttrsRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode,
                          u8 disableDefaultRsp, u8 direction, u8 seqNo,
                          zclDiscoverAttrRspCmd_t *discAttrRspCmd)

{
  u16 size;
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  uint uVar3;

  size = (ushort)discAttrRspCmd->numAttr * 3 + 1;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = discAttrRspCmd->discComplete;
    if (discAttrRspCmd->numAttr != '\0')
    {
      puVar2 = cmdPld + 1;
      uVar3 = 0;
      do
      {
        *puVar2 = *(u8 *)((int)discAttrRspCmd + uVar3 * 3 + 2);
        puVar2[1] = *(u8 *)((int)discAttrRspCmd + uVar3 * 3 + 3);
        puVar2[2] = *(u8 *)((int)discAttrRspCmd + uVar3 * 3 + 4);
        puVar2 = puVar2 + 3;
        uVar3 = uVar3 + 1 & 0xff;
      } while (uVar3 < discAttrRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\r', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}

status_t zcl_discAttrsExtendedRsp(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 manuCode, u8 disableDefaultRsp,
                                  u8 direction, u8 seqNo, zclDiscoverAttrExtRspCmd_t *discAttrExtRspCmd)

{
  u16 size;
  status_t sVar1;
  u8 *cmdPld;
  uint uVar2;
  u8 *puVar3;

  size = (u16)((uint)discAttrExtRspCmd->numAttr * 0x40000 + 0x10000 >> 0x10);
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = discAttrExtRspCmd->discComplete;
    if (discAttrExtRspCmd->numAttr != '\0')
    {
      puVar3 = cmdPld + 1;
      uVar2 = 0;
      do
      {
        *puVar3 = discAttrExtRspCmd[uVar2 * 2 + 1].discComplete;
        puVar3[1] = discAttrExtRspCmd[uVar2 * 2 + 1].numAttr;
        puVar3[2] = discAttrExtRspCmd[uVar2 * 2 + 2].discComplete;
        puVar3[3] = discAttrExtRspCmd[uVar2 * 2 + 2].numAttr;
        puVar3 = puVar3 + 4;
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < discAttrExtRspCmd->numAttr);
    }
    sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, clusterId, '\x16', '\0', direction, disableDefaultRsp, manuCode,
                        seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
  }
  return sVar1;
}

zclDiscoverAttrCmd_t *zcl_parseInDiscAttrsCmd(zclIncoming_t *pCmd)

{
  byte *pbVar1;
  zclDiscoverAttrCmd_t *pzVar2;
  int iVar3;

  pbVar1 = pCmd->pData;
  pzVar2 = (zclDiscoverAttrCmd_t *)ev_buf_allocate(3);
  if (pzVar2 != (zclDiscoverAttrCmd_t *)0x0)
  {
    iVar3 = (uint)pbVar1[1] * 0x100 + (uint)*pbVar1;
    *(char *)&pzVar2->startAttr = (char)iVar3;
    *(char *)((int)&pzVar2->startAttr + 1) = (char)((uint)iVar3 >> 8);
    pzVar2->maxAttrIDs = pbVar1[2];
  }
  return pzVar2;
}

status_t zcl_discAttrsHandler(zclIncoming_t *pCmd)

{
  u8 srcEp;
  u16 clusterId;
  ushort uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  u16 size;
  zclDiscoverAttrCmd_t *pzVar4;
  zclDiscoverAttrRspCmd_t *discAttrRspCmd;
  uint uVar5;
  byte bVar6;
  byte bVar7;
  u8 uVar8;
  uint uVar9;
  zclAttrInfo_t *pzVar10;
  uint uVar11;
  u8 *puVar12;
  uint uVar13;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  srcEp = (pCmd->msg->indInfo).dst_ep;
  pzVar4 = zcl_parseInDiscAttrsCmd(pCmd);
  if (pzVar4 == (zclDiscoverAttrCmd_t *)0x0)
  {
    return 0x89;
  }
  *(char *)&pCmd->attrCmd = (char)pzVar4;
  *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar4 >> 8);
  *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar4 >> 0x10);
  *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar4 >> 0x18);
  puVar12 = &zcl_vars.clusterList[0].endpoint;
  uVar9 = 0;
  do
  {
    if ((*puVar12 == srcEp) && (zcl_vars.clusterList[uVar9].clusterID == clusterId))
    {
      bVar7 = zcl_vars.clusterList[uVar9 & 0xff].attrNum;
      if ((bVar7 != 0) && (pzVar4->maxAttrIDs != 0))
      {
        pzVar10 = zcl_vars.clusterList[uVar9 & 0xff].attrTable;
        bVar6 = 0;
        uVar9 = 0;
        goto LAB_00003906;
      }
      break;
    }
    uVar9 = uVar9 + 1;
    puVar12 = puVar12 + 0x12;
  } while (uVar9 != 0x10);
  size = 2;
  uVar9 = 0;
  goto LAB_0000393c;
LAB_0000399a:
  do
  {
    pzVar10 = zcl_vars.clusterList[uVar5].attrTable + uVar11;
    uVar1 = pzVar10->id;
    if ((uint)pzVar4->startAttr <= (uint)uVar1)
    {
      if (uVar9 <= uVar13)
      {
        uVar8 = '\0';
        goto LAB_000039fc;
      }
      *(char *)((int)discAttrRspCmd + uVar13 * 3 + 2) = (char)uVar1;
      *(char *)((int)discAttrRspCmd + uVar13 * 3 + 3) = (char)((uint)uVar1 >> 8);
      *(u8 *)((int)discAttrRspCmd + uVar13 * 3 + 4) = pzVar10->type;
      uVar13 = uVar13 + 1 & 0xff;
    }
    uVar11 = uVar11 + 1 & 0xff;
  } while (uVar11 < zcl_vars.clusterList[uVar5].attrNum);
  goto LAB_000039fa;
  while (pzVar10 = pzVar10 + 1, uVar9 < pzVar4->maxAttrIDs)
  {
  LAB_00003906:
    if (pzVar4->startAttr <= pzVar10->id)
    {
      uVar9 = uVar9 + 1 & 0xff;
    }
    bVar6 = bVar6 + 1;
    if (bVar7 <= bVar6)
    {
      size = (u16)(uVar9 * 0x30000 + 0x20000 >> 0x10);
      goto LAB_0000393c;
    }
  }
  size = (short)uVar9 * 3 + 2;
LAB_0000393c:
  puVar12 = &zcl_vars.clusterList[0].endpoint;
  discAttrRspCmd = (zclDiscoverAttrRspCmd_t *)ev_buf_allocate(size);
  sVar3 = 0x89;
  if (discAttrRspCmd != (zclDiscoverAttrRspCmd_t *)0x0)
  {
    uVar8 = '\x01';
    if (uVar9 != 0)
    {
      uVar11 = 0;
      do
      {
        uVar5 = uVar11 & 0xff;
        if ((*puVar12 == srcEp) && (zcl_vars.clusterList[uVar11].clusterID == clusterId))
        {
          if (zcl_vars.clusterList[uVar5].attrNum != '\0')
          {
            uVar11 = 0;
            uVar13 = 0;
            goto LAB_0000399a;
          }
          break;
        }
        uVar11 = uVar11 + 1;
        puVar12 = puVar12 + 0x12;
      } while (uVar11 != 0x10);
    LAB_000039fa:
      uVar8 = '\x01';
    }
  LAB_000039fc:
    discAttrRspCmd->discComplete = uVar8;
    discAttrRspCmd->numAttr = (u8)uVar9;
    uStack_34 = 0;
    paVar2 = pCmd->msg;
    uStack_30 = (uint)(paVar2->indInfo).profile_id;
    uStack_2c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
    local_38 = (uint)(paVar2->indInfo).field_10.src_short_addr;
    local_28 = (ushort)(((paVar2->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
    bVar7 = (pCmd->hdr).frmCtrl.byte & 8;
    sVar3 = zcl_discAttrsRsp(srcEp, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                             bVar7 + ~bVar7, (pCmd->hdr).seqNum, discAttrRspCmd);
    if (sVar3 == '\0')
    {
      sVar3 = 0xff;
    }
    ev_buf_free((u8 *)discAttrRspCmd);
  }
  return sVar3;
}

status_t zcl_discAttrsExtendedHandler(zclIncoming_t *pCmd)

{
  u8 srcEp;
  u16 clusterId;
  ushort uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  u16 size;
  zclDiscoverAttrCmd_t *pzVar4;
  zclDiscoverAttrExtRspCmd_t *discAttrExtRspCmd;
  uint uVar5;
  byte bVar6;
  byte bVar7;
  uint uVar8;
  u8 uVar9;
  uint uVar10;
  zclAttrInfo_t *pzVar11;
  uint uVar12;
  u8 *puVar13;
  uint local_38;
  undefined4 uStack_34;
  uint uStack_30;
  undefined4 uStack_2c;
  ushort local_28;

  clusterId = (pCmd->msg->indInfo).cluster_id;
  srcEp = (pCmd->msg->indInfo).dst_ep;
  pzVar4 = zcl_parseInDiscAttrsCmd(pCmd);
  if (pzVar4 == (zclDiscoverAttrCmd_t *)0x0)
  {
    return 0x89;
  }
  *(char *)&pCmd->attrCmd = (char)pzVar4;
  *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar4 >> 8);
  *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar4 >> 0x10);
  *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar4 >> 0x18);
  puVar13 = &zcl_vars.clusterList[0].endpoint;
  uVar10 = 0;
LAB_00003b1c:
  if ((*puVar13 != srcEp) || (zcl_vars.clusterList[uVar10].clusterID != clusterId))
    goto LAB_00003b14;
  bVar7 = zcl_vars.clusterList[uVar10 & 0xff].attrNum;
  if ((bVar7 != 0) && (pzVar4->maxAttrIDs != 0))
  {
    pzVar11 = zcl_vars.clusterList[uVar10 & 0xff].attrTable;
    bVar6 = 0;
    uVar10 = 0;
    do
    {
      if (pzVar4->startAttr <= pzVar11->id)
      {
        uVar10 = uVar10 + 1 & 0xff;
      }
      bVar6 = bVar6 + 1;
    } while ((bVar6 < bVar7) && (pzVar11 = pzVar11 + 1, uVar10 < pzVar4->maxAttrIDs));
    size = (u16)(uVar10 * 0x40000 + 0x20000 >> 0x10);
    goto LAB_00003b9e;
  }
  goto LAB_00003b9a;
LAB_00003b14:
  uVar10 = uVar10 + 1;
  puVar13 = puVar13 + 0x12;
  if (uVar10 == 0x10)
    goto LAB_00003b9a;
  goto LAB_00003b1c;
LAB_00003b9a:
  size = 2;
  uVar10 = 0;
LAB_00003b9e:
  puVar13 = &zcl_vars.clusterList[0].endpoint;
  discAttrExtRspCmd = (zclDiscoverAttrExtRspCmd_t *)ev_buf_allocate(size);
  if (discAttrExtRspCmd == (zclDiscoverAttrExtRspCmd_t *)0x0)
  {
    return 0x89;
  }
  uVar9 = '\x01';
  if (uVar10 == 0)
    goto LAB_00003c64;
  uVar12 = 0;
  do
  {
    uVar5 = uVar12 & 0xff;
    if ((*puVar13 == srcEp) && (zcl_vars.clusterList[uVar12].clusterID == clusterId))
    {
      if (zcl_vars.clusterList[uVar5].attrNum != '\0')
      {
        uVar8 = 0;
        uVar12 = 0;
        goto LAB_00003bfa;
      }
      break;
    }
    uVar12 = uVar12 + 1;
    puVar13 = puVar13 + 0x12;
  } while (uVar12 != 0x10);
  goto LAB_00003c62;
LAB_00003bfa:
  do
  {
    pzVar11 = zcl_vars.clusterList[uVar5].attrTable + uVar8;
    uVar1 = pzVar11->id;
    if ((uint)pzVar4->startAttr <= (uint)uVar1)
    {
      if (uVar10 <= uVar12)
      {
        uVar9 = '\0';
        goto LAB_00003c64;
      }
      discAttrExtRspCmd[uVar12 * 2 + 1].discComplete = (u8)uVar1;
      discAttrExtRspCmd[uVar12 * 2 + 1].numAttr = (u8)((uint)uVar1 >> 8);
      discAttrExtRspCmd[uVar12 * 2 + 2].discComplete = pzVar11->type;
      discAttrExtRspCmd[uVar12 * 2 + 2].numAttr = pzVar11->access & 7;
      uVar12 = uVar12 + 1 & 0xff;
    }
    uVar8 = uVar8 + 1 & 0xff;
  } while (uVar8 < zcl_vars.clusterList[uVar5].attrNum);
LAB_00003c62:
  uVar9 = '\x01';
LAB_00003c64:
  discAttrExtRspCmd->discComplete = uVar9;
  discAttrExtRspCmd->numAttr = (u8)uVar10;
  uStack_34 = 0;
  paVar2 = pCmd->msg;
  uStack_30 = (uint)(paVar2->indInfo).profile_id;
  uStack_2c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
  local_38 = (uint)(paVar2->indInfo).field_10.src_short_addr;
  local_28 = (ushort)(((paVar2->indInfo).security_status & SECURITY_IN_APSLAYER) != 0);
  bVar7 = (pCmd->hdr).frmCtrl.byte & 8;
  sVar3 = zcl_discAttrsExtendedRsp(srcEp, (epInfo_t *)&local_38, clusterId, (pCmd->hdr).manufCode, '\x01',
                                   bVar7 + ~bVar7, (pCmd->hdr).seqNum, discAttrExtRspCmd);
  if (sVar3 == '\0')
  {
    sVar3 = 0xff;
  }
  ev_buf_free((u8 *)discAttrExtRspCmd);
  return sVar3;
}

zclDiscoverAttrRspCmd_t *zcl_parseInDiscAttrsRspCmd(zclIncoming_t *pCmd)

{
  u8 *puVar1;
  byte bVar2;
  zclDiscoverAttrRspCmd_t *pzVar3;
  zclDiscoverAttrRspCmd_t *pzVar4;
  uint uVar5;
  byte *pbVar6;
  int iVar7;

  puVar1 = pCmd->pData;
  bVar2 = FUN_00001624(pCmd->dataLen - 1, 3);
  pzVar3 = (zclDiscoverAttrRspCmd_t *)ev_buf_allocate((ushort)bVar2 * 3 + 2);
  if (pzVar3 != (zclDiscoverAttrRspCmd_t *)0x0)
  {
    pzVar3->discComplete = *puVar1;
    pzVar3->numAttr = bVar2;
    if (bVar2 != 0)
    {
      pbVar6 = puVar1 + 1;
      uVar5 = 0;
      pzVar4 = pzVar3;
      do
      {
        iVar7 = (uint)pbVar6[1] * 0x100 + (uint)*pbVar6;
        *(char *)((int)pzVar3 + uVar5 * 3 + 2) = (char)iVar7;
        *(char *)((int)pzVar3 + uVar5 * 3 + 3) = (char)((uint)iVar7 >> 8);
        pzVar4[2].discComplete = pbVar6[2];
        pbVar6 = pbVar6 + 3;
        uVar5 = uVar5 + 1;
        pzVar4 = (zclDiscoverAttrRspCmd_t *)&pzVar4[1].numAttr;
      } while ((uVar5 & 0xff) < (uint)bVar2);
    }
  }
  return pzVar3;
}

status_t zcl_discAttrsRspHandler(zclIncoming_t *pCmd)

{
  zclDiscoverAttrRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInDiscAttrsRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclDiscoverAttrRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}

zclDiscoverAttrExtRspCmd_t *zcl_parseInDiscAttrsExtRspCmd(zclIncoming_t *pCmd)

{
  u8 *puVar1;
  zclDiscoverAttrExtRspCmd_t *pzVar2;
  zclDiscoverAttrExtRspCmd_t *pzVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  byte *pbVar7;

  puVar1 = pCmd->pData;
  iVar4 = pCmd->dataLen - 1;
  uVar5 = (((uint)(iVar4 >> 0x1f) >> 0x1e) + iVar4) * 0x400000;
  uVar6 = uVar5 >> 0x18;
  pzVar2 = (zclDiscoverAttrExtRspCmd_t *)ev_buf_allocate((u16)(uVar6 * 0x40000 + 0x20000 >> 0x10));
  if (pzVar2 != (zclDiscoverAttrExtRspCmd_t *)0x0)
  {
    pzVar2->discComplete = *puVar1;
    pzVar2->numAttr = (u8)(uVar5 >> 0x18);
    if (uVar6 != 0)
    {
      pbVar7 = puVar1 + 1;
      uVar5 = 0;
      pzVar3 = pzVar2;
      do
      {
        iVar4 = (uint)*pbVar7 + (uint)pbVar7[1] * 0x100;
        pzVar2[uVar5 * 2 + 1].discComplete = (u8)iVar4;
        pzVar2[uVar5 * 2 + 1].numAttr = (u8)((uint)iVar4 >> 8);
        pzVar3[2].discComplete = pbVar7[2];
        pzVar3[2].numAttr = pbVar7[3];
        pbVar7 = pbVar7 + 4;
        uVar5 = uVar5 + 1;
        pzVar3 = pzVar3 + 2;
      } while ((uVar5 & 0xff) < uVar6);
    }
  }
  return pzVar2;
}

status_t zcl_discAttrsExtRspHandler(zclIncoming_t *pCmd)

{
  zclDiscoverAttrExtRspCmd_t *pzVar1;
  status_t sVar2;

  pzVar1 = zcl_parseInDiscAttrsExtRspCmd(pCmd);
  sVar2 = 0x89;
  if (pzVar1 != (zclDiscoverAttrExtRspCmd_t *)0x0)
  {
    *(char *)&pCmd->attrCmd = (char)pzVar1;
    *(char *)((int)&pCmd->attrCmd + 1) = (char)((uint)pzVar1 >> 8);
    *(char *)((int)&pCmd->attrCmd + 2) = (char)((uint)pzVar1 >> 0x10);
    *(char *)((int)&pCmd->attrCmd + 3) = (char)((uint)pzVar1 >> 0x18);
    sVar2 = '\0';
  }
  return sVar2;
}

status_t zcl_foundationCmdHandler(zclIncoming_t *pCmd)

{
  status_t sVar1;

  switch ((pCmd->hdr).cmd)
  {
  case '\0':
    sVar1 = zcl_readHandler(pCmd);
    break;
  case '\x01':
    sVar1 = zcl_readRspHandler(pCmd);
    break;
  case '\x02':
  case '\x05':
    sVar1 = zcl_writeHandler(pCmd);
    break;
  case '\x03':
    sVar1 = zcl_writeUndividedHandler(pCmd);
    break;
  case '\x04':
    sVar1 = zcl_writeRspHandler(pCmd);
    break;
  case '\x06':
    sVar1 = zcl_configReportHandler(pCmd);
    break;
  case '\a':
    sVar1 = zcl_configReportRspHandler(pCmd);
    break;
  case '\b':
    sVar1 = zcl_readReportCfgHandler(pCmd);
    break;
  case '\t':
    sVar1 = zcl_readReportCfgRspHandler(pCmd);
    break;
  case '\n':
    sVar1 = zcl_reportHandler(pCmd);
    break;
  case '\v':
    sVar1 = zcl_dfltRspHandler(pCmd);
    break;
  case '\f':
    sVar1 = zcl_discAttrsHandler(pCmd);
    break;
  case '\r':
    sVar1 = zcl_discAttrsRspHandler(pCmd);
    break;
  default:
    sVar1 = 0x84;
    if ((pCmd->hdr).manufCode == 0)
    {
      sVar1 = 0x82;
    }
    break;
  case '\x15':
    sVar1 = zcl_discAttrsExtendedHandler(pCmd);
    break;
  case '\x16':
    sVar1 = zcl_discAttrsExtRspHandler(pCmd);
  }
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps

void zcl_cmdHandler(void *pCmd)

{
  byte bVar1;
  uint uVar2;
  u8 *puVar3;
  ushort uVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  undefined auStack_4c[28];
  undefined4 uStack_30;
  u8 local_2c;
  u16 uStack_28;
  u8 local_25;
  uint extraout_r0;

  auStack_4c._0_4_ = ll_reset;
  auStack_4c._8_4_ = (u8 *)0x0;
  auStack_4c._12_4_ = (u8 *)0x0;
  auStack_4c._16_4_ = 0;
  auStack_4c._20_4_ = 0;
  auStack_4c._24_4_ = 0;
  uStack_30 = 0;
  local_2c = '\0';
  bVar1 = *(byte *)((int)pCmd + 0x25);
  auStack_4c._4_4_ = (apsdeDataInd_t *)pCmd;
  if ((int)((uint)bVar1 << 0x1d) < 0)
  {
    if (*(ushort *)((int)pCmd + 0x23) < 5)
      goto LAB_00003fb0;
    uStack_30 = (uint)bVar1 |
                ((uint) * (byte *)((int)pCmd + 0x27) * 0x100 + (uint) * (byte *)((int)pCmd + 0x26)) *
                        0x10000 >>
                    8 |
                (uint) * (byte *)((int)pCmd + 0x28) << 0x18;
    local_2c = *(u8 *)((int)pCmd + 0x29);
    auStack_4c._8_4_ = (u8 *)((int)pCmd + 0x2a);
    uVar4 = *(ushort *)((int)pCmd + 0x23) - 5;
  }
  else
  {
    if (*(ushort *)((int)pCmd + 0x23) < 3)
      goto LAB_00003fb0;
    uStack_30 = CONCAT13(*(undefined *)((int)pCmd + 0x26), (uint3)bVar1);
    local_2c = *(u8 *)((int)pCmd + 0x27);
    auStack_4c._8_4_ = (u8 *)((int)pCmd + 0x28);
    uVar4 = *(ushort *)((int)pCmd + 0x23) - 3;
  }
  auStack_4c._16_4_ = (uint)uVar4;
  uStack_28 = 0;
  local_25 = '\x01';
  uVar2 = uStack_30 & 0xff;
  if ((uStack_30 & 3) == 0)
  {
    bVar1 = zcl_foundationCmdHandler((zclIncoming_t *)auStack_4c);
    extraout_r0 = (uint)bVar1;
    uVar5 = extraout_r0;
    if ((((extraout_r0 != 0x84) && (extraout_r0 != 0x82)) && (extraout_r0 != 0xff)) &&
        (extraout_r0 != 0))
    {
      uVar5 = 1;
    }
    if (local_25 != '\0')
    {
      uVar2 = uStack_30 & 0xff;
      bVar7 = uVar5 != 0;
      bVar1 = 1;
      goto LAB_00003f64;
    }
    bVar7 = zcl_vars.hookFn != ll_reset;
  }
  else
  {
    puVar3 = &zcl_vars.clusterList[0].endpoint;
    uVar5 = 0;
    do
    {
      uVar6 = uVar5 & 0xff;
      if ((*puVar3 == *(u8 *)((int)pCmd + 1)) &&
          (zcl_vars.clusterList[uVar5].clusterID == *(u16 *)((int)pCmd + 8)))
      {
        uVar5 = (uStack_30 << 8) >> 0x10;
        if (zcl_vars.clusterList[uVar6].manuCode != uVar5)
          goto LAB_00003f58;
        zcl_getAttrVal(*(u8 *)((int)pCmd + 1), 0, 0x12, &uStack_28, &local_25);
        if ((local_25 == '\0') && (zcl_vars.clusterList[uVar6].clusterID != 3))
          goto LAB_00003fb0;
        auStack_4c._0_4_ = zcl_vars.clusterList[uVar6].clusterAppCb;
        auStack_4c._16_4_ = auStack_4c._16_4_ & 0xffff | (uint) * (ushort *)((int)pCmd + 6) << 0x10;
        auStack_4c._20_4_ =
            CONCAT22(*(undefined2 *)((int)pCmd + 2), *(undefined2 *)((int)pCmd + 0x14));
        auStack_4c._24_4_ =
            CONCAT13(auStack_4c[27] & 0xfe | uStack_30._0_1_ >> 3 & 1,
                     CONCAT12(uStack_30._3_1_,
                              CONCAT11(*(undefined *)((int)pCmd + 1), *(undefined *)((int)pCmd + 5))));
        uVar5 = FUNAAAAA();
        uVar2 = uStack_30 & 0xff;
        bVar7 = uVar5 != 0;
        goto LAB_00003f62;
      }
      uVar5 = uVar5 + 1;
      puVar3 = puVar3 + 0x12;
    } while (uVar5 != 0x10);
    uVar5 = (uStack_30 << 8) >> 0x10;
  LAB_00003f58:
    if (uVar5 == 0)
    {
      bVar7 = true;
      uVar5 = 0x81;
    }
    else
    {
      bVar7 = true;
      uVar5 = 0x83;
    }
  LAB_00003f62:
    local_25 = '\x01';
    bVar1 = 0;
  LAB_00003f64:
    if ((((-1 < (int)(uVar2 << 0x1b)) || (bVar7)) &&
         (((auStack_4c._4_4_)->indInfo).dst_addr < 0xfffc)) &&
        ((((auStack_4c._4_4_)->indInfo).dst_addr_mode != '\x01' && (uVar5 != 0xff))))
    {
      zcl_sendDfltRsp((zclIncoming_t *)auStack_4c, local_2c, (u8)uVar5);
    }
    bVar7 = (bool)(bVar1 & zcl_vars.hookFn != ll_reset);
  }
  if ((bVar7) && (auStack_4c._12_4_ != (u8 *)0x0))
  {
    FUNAAAAA();
    ev_buf_free(auStack_4c._12_4_);
  }
LAB_00003fb0:
  ev_buf_free((u8 *)pCmd);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAA(void)

{
  code *in_r3;

  (*in_r3)();
  nv_flashWriteNew('\x01', 3, ' ', 0x95, &reportingTab.reportNum);
  return;
}

nv_sts_t zcl_reportingTab_save(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashWriteNew('\x01', 3, ' ', 0x95, &reportingTab.reportNum);
  return nVar1;
}

nv_sts_t zcl_sceneTable_save(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashWriteNew('\x01', 3, '$', 0x170, &g_zcl_sceneTab[0].used);
  return nVar1;
}

nv_sts_t zcl_sceneTable_restore(void)

{
  nv_sts_t nVar1;

  nv_itemLengthCheckAdd('$', 0x170);
  nVar1 = nv_flashReadNew('\x01', '\x03', '$', 0x2e, &g_zcl_sceneTab[0].used);
  return nVar1;
}

reportCfgInfo_t *zcl_reportCfgInfoEntryFind(u8 endpoint, u16 clusterId, u16 attrID)

{
  u8 *puVar1;
  uint uVar2;

  puVar1 = &reportingTab.reportCfgInfo[0].used;
  uVar2 = 0;
  while ((((*puVar1 == '\0' || (reportingTab.reportCfgInfo[uVar2].clusterID != clusterId)) ||
           (reportingTab.reportCfgInfo[uVar2].attrID != attrID)) ||
          (puVar1[-0x12] != endpoint)))
  {
    uVar2 = uVar2 + 1;
    puVar1 = puVar1 + 0x25;
    if (uVar2 == 4)
    {
      return (reportCfgInfo_t *)0x0;
    }
  }
  return reportingTab.reportCfgInfo + (uVar2 & 0xff);
}

reportCfgInfo_t *zcl_reportCfgInfoEntryFreeGet(void)

{
  u8 *puVar1;
  uint uVar2;

  puVar1 = &reportingTab.reportCfgInfo[0].used;
  uVar2 = 0;
  do
  {
    if (*puVar1 == '\0')
    {
      return reportingTab.reportCfgInfo + uVar2;
    }
    uVar2 = uVar2 + 1 & 0xff;
    puVar1 = puVar1 + 0x25;
  } while (uVar2 != 4);
  return (reportCfgInfo_t *)0x0;
}

void zcl_reportCfgInfoEntryRst(reportCfgInfo_t *pEntry)

{
  undefined uVar1;
  undefined uVar2;
  undefined uVar3;
  undefined uVar4;

  if (pEntry->used != '\0')
  {
    uVar1 = (undefined)pEntry->minIntDft;
    *(undefined *)&pEntry->minInterval = uVar1;
    uVar4 = (undefined)(pEntry->minIntDft >> 8);
    *(undefined *)((int)&pEntry->minInterval + 1) = uVar4;
    uVar2 = (undefined)pEntry->maxIntDft;
    *(undefined *)&pEntry->maxInterval = uVar2;
    uVar3 = (undefined)(pEntry->maxIntDft >> 8);
    *(undefined *)((int)&pEntry->maxInterval + 1) = uVar3;
    *(undefined *)&pEntry->minIntCnt = uVar1;
    *(undefined *)((int)&pEntry->minIntCnt + 1) = uVar4;
    *(undefined *)&pEntry->maxIntCnt = uVar2;
    *(undefined *)((int)&pEntry->maxIntCnt + 1) = uVar3;
    pEntry->reportableChange[0] = '\0';
    pEntry->reportableChange[1] = '\0';
    pEntry->reportableChange[2] = '\0';
    pEntry->reportableChange[3] = '\0';
    pEntry->reportableChange[4] = '\0';
    pEntry->reportableChange[5] = '\0';
    pEntry->reportableChange[6] = '\0';
    pEntry->reportableChange[7] = '\0';
  }
  return;
}

void zcl_reportCfgInfoEntryUpdate(reportCfgInfo_t *pEntry, u8 endPoint, u16 profileId, u16 clusterId,
                                  zclCfgReportRec_t *pCfgReportRec)

{
  u16 uVar1;
  undefined uVar2;
  u8 *puVar3;
  undefined uVar4;
  u8 uVar5;
  byte bVar6;
  zclAttrInfo_t *pzVar7;
  undefined uVar8;
  undefined uVar9;

  if (pEntry->used == '\0')
  {
    *(char *)&pEntry->profileID = (char)profileId;
    *(char *)((int)&pEntry->profileID + 1) = (char)((uint)profileId >> 8);
    *(char *)&pEntry->clusterID = (char)clusterId;
    *(char *)((int)&pEntry->clusterID + 1) = (char)((uint)clusterId >> 8);
    pEntry->endPoint = endPoint;
    uVar1 = pCfgReportRec->attrID;
    *(char *)&pEntry->attrID = (char)uVar1;
    *(char *)((int)&pEntry->attrID + 1) = (char)(uVar1 >> 8);
    uVar1 = pCfgReportRec->minReportInt;
    uVar2 = (undefined)uVar1;
    *(undefined *)&pEntry->minIntDft = uVar2;
    uVar8 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->minIntDft + 1) = uVar8;
    uVar1 = pCfgReportRec->maxReportInt;
    uVar4 = (undefined)uVar1;
    *(undefined *)&pEntry->maxIntDft = uVar4;
    uVar9 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->maxIntDft + 1) = uVar9;
    *(undefined *)&pEntry->minInterval = uVar2;
    *(undefined *)((int)&pEntry->minInterval + 1) = uVar8;
    *(undefined *)&pEntry->maxInterval = uVar4;
    *(undefined *)((int)&pEntry->maxInterval + 1) = uVar9;
    uVar5 = pCfgReportRec->dataType;
    pEntry->dataType = uVar5;
    uVar5 = zcl_analogDataType(uVar5);
    if (uVar5 != '\0')
    {
      puVar3 = pCfgReportRec->reportableChange;
      bVar6 = zcl_getDataTypeLen(pEntry->dataType);
      memcpy(pEntry->reportableChange, puVar3, (uint)bVar6);
    }
    pzVar7 = zcl_findAttribute(pEntry->endPoint, pEntry->clusterID, pEntry->attrID);
    if (pzVar7 == (zclAttrInfo_t *)0x0)
    {
      sys_exceptionPost(0xcd, '`');
    }
    uVar1 = pCfgReportRec->minReportInt;
    *(char *)&pEntry->minIntCnt = (char)uVar1;
    *(char *)((int)&pEntry->minIntCnt + 1) = (char)(uVar1 >> 8);
    uVar1 = pCfgReportRec->maxReportInt;
    *(char *)&pEntry->maxIntCnt = (char)uVar1;
    *(char *)((int)&pEntry->maxIntCnt + 1) = (char)(uVar1 >> 8);
    pEntry->used = '\x01';
    reportingTab.reportNum = reportingTab.reportNum + '\x01';
  }
  else
  {
    uVar1 = pCfgReportRec->minReportInt;
    uVar2 = (undefined)uVar1;
    *(undefined *)&pEntry->minInterval = uVar2;
    uVar8 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->minInterval + 1) = uVar8;
    uVar1 = pCfgReportRec->maxReportInt;
    uVar4 = (undefined)uVar1;
    *(undefined *)&pEntry->maxInterval = uVar4;
    uVar9 = (undefined)(uVar1 >> 8);
    *(undefined *)((int)&pEntry->maxInterval + 1) = uVar9;
    *(undefined *)&pEntry->minIntCnt = uVar2;
    *(undefined *)((int)&pEntry->minIntCnt + 1) = uVar8;
    *(undefined *)&pEntry->maxIntCnt = uVar4;
    *(undefined *)((int)&pEntry->maxIntCnt + 1) = uVar9;
    uVar5 = zcl_analogDataType(pEntry->dataType);
    if (uVar5 != '\0')
    {
      puVar3 = pCfgReportRec->reportableChange;
      bVar6 = zcl_getDataTypeLen(pEntry->dataType);
      memcpy(pEntry->reportableChange, puVar3, (uint)bVar6);
    }
  }
  return;
}

void zcl_zoneClearEntry(zcl_zoneTable_t *pZoneTab)

{
  if (pZoneTab != (zcl_zoneTable_t *)0x0)
  {
    pZoneTab->used = '\0';
    pZoneTab->endpoint = 0xfe;
    (pZoneTab->zone).zoneId = '\0';
    *(undefined *)&(pZoneTab->zone).zoneType = 0;
    *(undefined *)((int)&(pZoneTab->zone).zoneType + 1) = 0;
    (pZoneTab->zone).zoneAddr[0] = '\0';
    (pZoneTab->zone).zoneAddr[1] = '\0';
    (pZoneTab->zone).zoneAddr[2] = '\0';
    (pZoneTab->zone).zoneAddr[3] = '\0';
    (pZoneTab->zone).zoneAddr[4] = '\0';
    (pZoneTab->zone).zoneAddr[5] = '\0';
    (pZoneTab->zone).zoneAddr[6] = '\0';
    (pZoneTab->zone).zoneAddr[7] = '\0';
  }
  return;
}

void zcl_zoneTabClear(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    zcl_zoneClearEntry(g_zcl_zoneTab + iVar1);
    iVar1 = iVar1 + 1;
  } while (iVar1 != 5);
  return;
}

status_t zcl_iasZone_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  zcl_zoneTabClear();
  sVar1 = zcl_registerCluster(endpoint, 0x500, manuCode, attrNum, attrTbl, zcl_iasZone_cmdHandler, cb);
  return sVar1;
}

void zcl_getZoneId(void)

{
  u8 uVar1;
  zcl_zoneTable_t *pzVar2;

  uVar1 = '\0';
  pzVar2 = g_zcl_zoneTab;
  do
  {
    while ((pzVar2->used != '\0' && ((pzVar2->zone).zoneId == uVar1)))
    {
      uVar1 = uVar1 + '\x01';
      pzVar2 = g_zcl_zoneTab;
      if (uVar1 == 0xff)
      {
        return;
      }
    }
    pzVar2 = pzVar2 + 1;
  } while (pzVar2 != (zcl_zoneTable_t *)0x84293d);
  return;
}

zcl_zoneTable_t *zcl_addZoneEntry(u8 endpoint, u16 zoneType, u8 *rspCode)

{
  int iVar1;
  zcl_zoneTable_t *pzVar2;
  int iVar3;

  pzVar2 = g_zcl_zoneTab;
  iVar3 = 0;
  do
  {
    if (pzVar2->used == '\0')
    {
      iVar1 = zcl_getZoneId();
      if (iVar1 != 0xff)
      {
        g_zcl_zoneTab[iVar3].used = '\x01';
        g_zcl_zoneTab[iVar3].endpoint = endpoint;
        *(char *)&g_zcl_zoneTab[iVar3].zone.zoneType = (char)zoneType;
        *(char *)((int)&g_zcl_zoneTab[iVar3].zone.zoneType + 1) = (char)((uint)zoneType >> 8);
        g_zcl_zoneTab[iVar3].zone.zoneId = (u8)iVar1;
        memset(g_zcl_zoneTab[iVar3].zone.zoneAddr, 0xff, 8);
        *rspCode = '\0';
        return g_zcl_zoneTab + iVar3;
      }
      break;
    }
    iVar3 = iVar3 + 1;
    pzVar2 = pzVar2 + 1;
  } while (iVar3 != 5);
  *rspCode = '\x03';
  return (zcl_zoneTable_t *)0x0;
}

status_t zcl_iasZone_enrollRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                               zoneEnrollRsp_t *pEnrollRsp)

{
  status_t sVar1;
  u8 local_14;
  u8 uStack_13;

  local_14 = pEnrollRsp->code;
  uStack_13 = pEnrollRsp->zoneId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 0x500, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, 2, &local_14);
  return sVar1;
}

status_t zcl_iasZone_cmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  zcl_zoneTable_t *pzVar4;
  u16 zoneType;
  undefined4 in_stack_ffffffb8;
  undefined2 in_stack_ffffffbc;
  undefined2 in_stack_ffffffbe;
  zoneEnrollRsp_t local_24[2];
  u8 local_20;
  u8 uStack_1f;

  if (-1 < (int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c))
  {
    uVar1 = (pInMsg->hdr).cmd;
    if (uVar1 == '\x01')
    {
      if (pInMsg->clusterAppCb != ll_reset)
      {
        sVar3 = FUNAAAAC();
        return sVar3;
      }
      return '\0';
    }
    if (uVar1 == '\0')
    {
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_24[0] = *(zoneEnrollRsp_t *)pInMsg->pData;
        FUNAAAAC();
        return '\0';
      }
      return '\0';
    }
    if (uVar1 != '\x02')
    {
      return 0x81;
    }
    if (pInMsg->clusterAppCb != ll_reset)
    {
      local_20 = *pInMsg->pData;
      uStack_1f = pInMsg->pData[1];
      sVar3 = FUNAAAAC();
      return sVar3;
    }
    return '\0';
  }
  uVar1 = (pInMsg->hdr).cmd;
  if (uVar1 == '\0')
  {
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAC();
      return '\0';
    }
    return '\0';
  }
  if (uVar1 != '\x01')
  {
    return 0x81;
  }
  paVar2 = pInMsg->msg;
  uVar1 = (paVar2->indInfo).dst_ep;
  zoneType = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
  local_24[0] = (zoneEnrollRsp_t)0xff00;
  if (zoneType < 0x2e)
  {
    if (zoneType < 0x2a)
    {
      if (zoneType < 0x17)
      {
        if (((zoneType < 0x15) && (zoneType != 0)) && (zoneType != 0xd))
          goto LAB_000047a2;
      }
      else if (zoneType != 0x28)
        goto LAB_000047a2;
    }
  }
  else if (zoneType != 0x21d)
  {
    if (zoneType < 0x21e)
    {
      if ((zoneType != 0x10f) && (zoneType != 0x115))
        goto LAB_000047a2;
    }
    else if ((zoneType < 0x225) || ((0x226 < zoneType && (zoneType != 0x229))))
    {
    LAB_000047a2:
      local_24[0] = (zoneEnrollRsp_t)0xff01;
      goto LAB_00004656;
    }
  }
  pzVar4 = zcl_addZoneEntry(uVar1, zoneType, &local_24[0].code);
  if ((pzVar4 != (zcl_zoneTable_t *)0x0) && (local_24[0].code == '\0'))
  {
    zb_address_ieee_by_short((paVar2->indInfo).field_10.src_short_addr,
                             (addrExt_t)CONCAT26(in_stack_ffffffbe, CONCAT24(in_stack_ffffffbc, in_stack_ffffffb8)));
    local_24[0] = (zoneEnrollRsp_t)((ushort)local_24[0] & 0xff | (ushort)(pzVar4->zone).zoneId << 8);
  }
LAB_00004656:
  if (pInMsg->clusterAppCb != ll_reset)
  {
    FUNAAAAC();
  }
  zcl_iasZone_enrollRsp(uVar1, (epInfo_t *)&stack0xffffffbc, '\x01', (pInMsg->hdr).seqNum, local_24);
  return 0xff;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 FUNAAAAC(void)

{
  byte bVar1;
  byte *pbVar2;
  void *in;
  int *piVar3;
  undefined4 uVar4;
  int iVar5;
  byte *in_00;
  code *in_r3;
  uint uVar6;
  uint uVar7;
  uint uStack_d0;
  uint uStack_cc;
  uint uStack_c8;
  undefined uStack_c4;
  byte bStack_c3;
  short sStack_c2;
  short sStack_c0;
  undefined auStack_be[10];
  uint uStack_b4;
  uint uStack_b0;
  uint uStack_ac;
  undefined uStack_a8;
  byte bStack_a7;
  undefined auStack_a6[8];
  short sStack_9e;
  uint uStack_9c;
  uint uStack_98;
  uint uStack_94;
  undefined uStack_90;
  byte bStack_8f;
  byte *pbStack_8e;
  undefined auStack_88[8];
  short sStack_80;
  short sStack_7e;
  int iStack_7c;
  short sStack_78;
  short sStack_74;
  short sStack_72;
  int iStack_70;
  int iStack_6c;
  int iStack_68;
  uint uStack_64;
  uint uStack_60;
  uint uStack_5c;
  undefined uStack_58;
  uint uStack_54;
  uint uStack_50;
  uint uStack_4c;
  undefined uStack_48;
  uint uStack_44;
  uint uStack_40;
  uint uStack_3c;
  byte bStack_38;
  byte bStack_37;
  short sStack_36;
  short sStack_34;
  int iStack_32;
  uint uStack_2c;
  uint uStack_28;
  undefined uStack_24;

  piVar3 = (int *)(*in_r3)();
  uVar6 = uStack_3c;
  if ((int)((uint) * (byte *)(piVar3 + 7) << 0x1c) < 0)
  {
    switch (*(undefined *)(piVar3 + 8))
    {
    case 0:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bStack_38 = *pbVar2;
        bStack_37 = pbVar2[1];
        if (((bStack_38 != 0) &&
             (sStack_36 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2], 1 < bStack_38)) &&
            (sStack_34 = (ushort)pbVar2[5] * 0x100 + (ushort)pbVar2[4], bStack_38 == 3))
        {
          iStack_32 = (uint)pbVar2[9] * 0x1000000 + (uint)pbVar2[8] * 0x10000 + (uint)pbVar2[6] +
                      (uint)pbVar2[7] * 0x100;
        }
        uVar4 = FUNAAAAD();
      }
      break;
    default:
    switchD_00004814_caseD_0:
      uVar4 = 0x81;
      break;
    case 2:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_54 = uStack_54 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          uStack_54 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_50 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_4c = iVar5 * 0x100 | uVar6 >> 0x18;
          uStack_48 = (undefined)((uint)iVar5 >> 0x18);
        }
        uVar4 = FUNAAAAD();
      }
      break;
    case 5:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uVar6 = (uint)bVar1;
        uStack_9c = uStack_9c & 0xffffff00 | uVar6;
        if (bVar1 == 0)
        {
          uStack_9c = uVar6 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_94 = iVar5 * 0x100 | uVar6 >> 0x18;
          uStack_90 = (undefined)((uint)iVar5 >> 0x18);
          bStack_8f = pbVar2[0xd];
          pbStack_8e = pbVar2 + 0xe;
        }
        else if (bVar1 == 0x97)
        {
          uVar7 = (uint)pbVar2[4] * 0x1000000 + (uint)pbVar2[3] * 0x10000 + (uint)pbVar2[1] +
                  (uint)pbVar2[2] * 0x100;
          uStack_9c = uVar7 * 0x100 | uVar6;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar6 * 0x100 | uVar7 >> 0x18;
          uStack_94 = uStack_94 & 0xff000000 | uVar6 >> 0x18 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        uVar4 = FUNAAAAD();
      }
      break;
    case 7:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        sStack_74 = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
        sStack_72 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2];
        iStack_70 = (uint)pbVar2[7] * 0x1000000 + (uint)pbVar2[6] * 0x10000 + (uint)pbVar2[4] +
                    (uint)pbVar2[5] * 0x100;
        iStack_6c = (uint)pbVar2[0xb] * 0x1000000 + (uint)pbVar2[10] * 0x10000 + (uint)pbVar2[8] +
                    (uint)pbVar2[9] * 0x100;
        iStack_68 = (uint)pbVar2[0xf] * 0x1000000 + (uint)pbVar2[0xe] * 0x10000 + (uint)pbVar2[0xc] + (uint)pbVar2[0xd] * 0x100;
        uVar4 = FUNAAAAD();
      }
      break;
    case 9:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_64 = uStack_64 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          uStack_64 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_60 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_5c = iVar5 * 0x100 | uVar6 >> 0x18;
          uStack_58 = (undefined)((uint)iVar5 >> 0x18);
        }
        uVar4 = FUNAAAAD();
      }
    }
  }
  else
  {
    switch (*(undefined *)(piVar3 + 8))
    {
    default:
      goto switchD_00004814_caseD_0;
    case 1:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        uStack_44 = ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 | (uint)*pbVar2 |
                    (uint)pbVar2[3] << 0x18;
        uVar7 = (uint)pbVar2[6] * 0x100 +
                (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000;
        uStack_40 = (uint)pbVar2[3] + (uint)pbVar2[4] * 0x100 >> 8 & 0xff | uVar7 * 0x100;
        uVar7 = uVar7 >> 0x18;
        uStack_3c = uStack_3c & 0xffffff00 | uVar7;
        if ((*pbVar2 & 1) != 0)
        {
          uStack_3c = uVar6 & 0xff000000 | uVar7 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        uVar4 = FUN_00004f2a((int)piVar3 + 0x12, 1);
      }
      break;
    case 3:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_b4 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                    (uint)pbVar2[3] << 0x18;
        uVar6 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                (uint)pbVar2[6] * 0x100;
        uStack_b0 = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar5 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                (uint)pbVar2[10] * 0x100;
        uStack_ac = iVar5 * 0x100 | uVar6 >> 0x18;
        uStack_a8 = (undefined)((uint)iVar5 >> 0x18);
        bStack_a7 = pbVar2[0xd];
        in_00 = pbVar2 + 0xe;
        if ((bVar1 & 1) != 0)
        {
          memcpy(auStack_a6, in_00, 8);
          in_00 = pbVar2 + 0x16;
        }
        if ((int)((uint)bVar1 << 0x1e) < 0)
        {
          sStack_9e = (ushort)in_00[1] * 0x100 + (ushort)*in_00;
        }
        uVar4 = FUN_00004f28((int)piVar3 + 0x12, 3, &uStack_b4);
      }
      break;
    case 4:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        uStack_d0 = (uint)*pbVar2 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                    (uint)pbVar2[3] << 0x18;
        uVar6 = (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 +
                (uint)pbVar2[6] * 0x100;
        uStack_cc = uVar6 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar5 = (uint)pbVar2[9] + (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 +
                (uint)pbVar2[10] * 0x100;
        uStack_c8 = iVar5 * 0x100 | uVar6 >> 0x18;
        uStack_c4 = (undefined)((uint)iVar5 >> 0x18);
        bStack_c3 = pbVar2[0xd];
        sStack_c2 = (ushort)pbVar2[0xf] * 0x100 + (ushort)pbVar2[0xe];
        sStack_c0 = (ushort)pbVar2[0x11] * 0x100 + (ushort)pbVar2[0x10];
        if ((*pbVar2 & 1) != 0)
        {
          memcpy(auStack_be, pbVar2 + 0x12, 8);
        }
        uVar4 = FUN_00004f2c((int)piVar3 + 0x12, 4, &uStack_d0);
      }
      break;
    case 6:
      pbVar2 = (byte *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        bVar1 = *pbVar2;
        uStack_2c = uStack_2c & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          uStack_2c = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                      (uint)pbVar2[3] << 0x18;
          iVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_28 = iVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          uStack_24 = (undefined)((uint)iVar5 >> 0x18);
        }
        uVar4 = FUNAAAAD();
      }
      break;
    case 8:
      in = (void *)piVar3[2];
      uVar4 = 1;
      if (*piVar3 != 0)
      {
        memcpy(auStack_88, in, 8);
        sStack_80 = (ushort) * (byte *)((int)in + 9) * 0x100 + (ushort) * (byte *)((int)in + 8);
        sStack_7e = (ushort) * (byte *)((int)in + 0xb) * 0x100 + (ushort) * (byte *)((int)in + 10);
        iStack_7c = (uint) * (byte *)((int)in + 0xf) * 0x1000000 +
                    (uint) * (byte *)((int)in + 0xe) * 0x10000 + (uint) * (byte *)((int)in + 0xc) +
                    (uint) * (byte *)((int)in + 0xd) * 0x100;
        sStack_78 = (ushort) * (byte *)((int)in + 0x11) * 0x100 + (ushort) * (byte *)((int)in + 0x10);
        uVar4 = FUN_00004f26((int)piVar3 + 0x12, 8, auStack_88);
      }
    }
  }
  return uVar4;
}

status_t zcl_ota_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  byte *pbVar2;
  u8 *in;
  status_t sVar3;
  int iVar4;
  byte *in_00;
  uint uVar5;
  uint uVar6;
  uint local_d0;
  uint uStack_cc;
  uint uStack_c8;
  undefined uStack_c4;
  byte bStack_c3;
  short sStack_c2;
  short sStack_c0;
  undefined auStack_be[10];
  uint local_b4;
  uint uStack_b0;
  uint uStack_ac;
  undefined uStack_a8;
  byte bStack_a7;
  undefined auStack_a6[8];
  short sStack_9e;
  uint local_9c;
  uint uStack_98;
  uint uStack_94;
  undefined uStack_90;
  byte bStack_8f;
  byte *pbStack_8e;
  undefined auStack_88[8];
  short sStack_80;
  short sStack_7e;
  int iStack_7c;
  short sStack_78;
  short local_74;
  short sStack_72;
  int iStack_70;
  int iStack_6c;
  int iStack_68;
  uint local_64;
  uint uStack_60;
  uint uStack_5c;
  undefined uStack_58;
  uint local_54;
  uint uStack_50;
  uint uStack_4c;
  undefined uStack_48;
  uint local_44;
  uint uStack_40;
  uint uStack_3c;
  byte local_38;
  byte bStack_37;
  short sStack_36;
  short sStack_34;
  int iStack_32;
  uint local_2c;
  uint uStack_28;
  undefined uStack_24;

  uVar5 = uStack_3c;
  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    switch ((pInMsg->hdr).cmd)
    {
    case '\0':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_38 = *pbVar2;
        bStack_37 = pbVar2[1];
        if (((local_38 != 0) &&
             (sStack_36 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2], 1 < local_38)) &&
            (sStack_34 = (ushort)pbVar2[5] * 0x100 + (ushort)pbVar2[4], local_38 == 3))
        {
          iStack_32 = (uint)pbVar2[9] * 0x1000000 + (uint)pbVar2[8] * 0x10000 + (uint)pbVar2[6] +
                      (uint)pbVar2[7] * 0x100;
        }
        sVar3 = FUNAAAAD();
      }
      break;
    default:
    switchD_00004814_caseD_0:
      sVar3 = 0x81;
      break;
    case '\x02':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_54 = local_54 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          local_54 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_50 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_4c = iVar4 * 0x100 | uVar5 >> 0x18;
          uStack_48 = (undefined)((uint)iVar4 >> 0x18);
        }
        sVar3 = FUNAAAAD();
      }
      break;
    case '\x05':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        uVar5 = (uint)bVar1;
        local_9c = local_9c & 0xffffff00 | uVar5;
        if (bVar1 == 0)
        {
          local_9c = uVar5 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_94 = iVar4 * 0x100 | uVar5 >> 0x18;
          uStack_90 = (undefined)((uint)iVar4 >> 0x18);
          bStack_8f = pbVar2[0xd];
          pbStack_8e = pbVar2 + 0xe;
        }
        else if (bVar1 == 0x97)
        {
          uVar6 = (uint)pbVar2[4] * 0x1000000 + (uint)pbVar2[3] * 0x10000 + (uint)pbVar2[1] +
                  (uint)pbVar2[2] * 0x100;
          local_9c = uVar6 * 0x100 | uVar5;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_98 = uVar5 * 0x100 | uVar6 >> 0x18;
          uStack_94 = uStack_94 & 0xff000000 | uVar5 >> 0x18 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        sVar3 = FUNAAAAD();
      }
      break;
    case '\a':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_74 = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
        sStack_72 = (ushort)pbVar2[3] * 0x100 + (ushort)pbVar2[2];
        iStack_70 = (uint)pbVar2[7] * 0x1000000 + (uint)pbVar2[6] * 0x10000 + (uint)pbVar2[4] +
                    (uint)pbVar2[5] * 0x100;
        iStack_6c = (uint)pbVar2[0xb] * 0x1000000 + (uint)pbVar2[10] * 0x10000 + (uint)pbVar2[8] +
                    (uint)pbVar2[9] * 0x100;
        iStack_68 = (uint)pbVar2[0xf] * 0x1000000 + (uint)pbVar2[0xe] * 0x10000 + (uint)pbVar2[0xc] + (uint)pbVar2[0xd] * 0x100;
        sVar3 = FUNAAAAD();
      }
      break;
    case '\t':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_64 = local_64 & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          local_64 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_60 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                  (uint)pbVar2[10] * 0x100;
          uStack_5c = iVar4 * 0x100 | uVar5 >> 0x18;
          uStack_58 = (undefined)((uint)iVar4 >> 0x18);
        }
        sVar3 = FUNAAAAD();
      }
    }
  }
  else
  {
    switch ((pInMsg->hdr).cmd)
    {
    default:
      goto switchD_00004814_caseD_0;
    case '\x01':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_44 = ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 | (uint)*pbVar2 |
                   (uint)pbVar2[3] << 0x18;
        uVar6 = (uint)pbVar2[6] * 0x100 +
                (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000;
        uStack_40 = (uint)pbVar2[3] + (uint)pbVar2[4] * 0x100 >> 8 & 0xff | uVar6 * 0x100;
        uVar6 = uVar6 >> 0x18;
        uStack_3c = uStack_3c & 0xffffff00 | uVar6;
        if ((*pbVar2 & 1) != 0)
        {
          uStack_3c = uVar5 & 0xff000000 | uVar6 |
                      ((uint)pbVar2[10] * 0x100 + (uint)pbVar2[9]) * 0x10000 >> 8;
        }
        sVar3 = FUN_00004f2a(&pInMsg->addrInfo, 1);
      }
      break;
    case '\x03':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_b4 = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                   (uint)pbVar2[3] << 0x18;
        uVar5 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                (uint)pbVar2[6] * 0x100;
        uStack_b0 = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar4 = (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 + (uint)pbVar2[9] +
                (uint)pbVar2[10] * 0x100;
        uStack_ac = iVar4 * 0x100 | uVar5 >> 0x18;
        uStack_a8 = (undefined)((uint)iVar4 >> 0x18);
        bStack_a7 = pbVar2[0xd];
        in_00 = pbVar2 + 0xe;
        if ((bVar1 & 1) != 0)
        {
          memcpy(auStack_a6, in_00, 8);
          in_00 = pbVar2 + 0x16;
        }
        if ((int)((uint)bVar1 << 0x1e) < 0)
        {
          sStack_9e = (ushort)in_00[1] * 0x100 + (ushort)*in_00;
        }
        sVar3 = FUN_00004f28(&pInMsg->addrInfo, 3, &local_b4);
      }
      break;
    case '\x04':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_d0 = (uint)*pbVar2 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                   (uint)pbVar2[3] << 0x18;
        uVar5 = (uint)pbVar2[5] + (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 +
                (uint)pbVar2[6] * 0x100;
        uStack_cc = uVar5 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
        iVar4 = (uint)pbVar2[9] + (uint)pbVar2[0xc] * 0x1000000 + (uint)pbVar2[0xb] * 0x10000 +
                (uint)pbVar2[10] * 0x100;
        uStack_c8 = iVar4 * 0x100 | uVar5 >> 0x18;
        uStack_c4 = (undefined)((uint)iVar4 >> 0x18);
        bStack_c3 = pbVar2[0xd];
        sStack_c2 = (ushort)pbVar2[0xf] * 0x100 + (ushort)pbVar2[0xe];
        sStack_c0 = (ushort)pbVar2[0x11] * 0x100 + (ushort)pbVar2[0x10];
        if ((*pbVar2 & 1) != 0)
        {
          memcpy(auStack_be, pbVar2 + 0x12, 8);
        }
        sVar3 = FUN_00004f2c(&pInMsg->addrInfo, 4, &local_d0);
      }
      break;
    case '\x06':
      pbVar2 = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        bVar1 = *pbVar2;
        local_2c = local_2c & 0xffffff00 | (uint)bVar1;
        if (bVar1 == 0)
        {
          local_2c = (uint)bVar1 | ((uint)pbVar2[2] * 0x100 + (uint)pbVar2[1]) * 0x10000 >> 8 |
                     (uint)pbVar2[3] << 0x18;
          iVar4 = (uint)pbVar2[8] * 0x1000000 + (uint)pbVar2[7] * 0x10000 + (uint)pbVar2[5] +
                  (uint)pbVar2[6] * 0x100;
          uStack_28 = iVar4 * 0x100 | (uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8 & 0xff;
          uStack_24 = (undefined)((uint)iVar4 >> 0x18);
        }
        sVar3 = FUNAAAAD();
      }
      break;
    case '\b':
      in = pInMsg->pData;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        memcpy(auStack_88, in, 8);
        sStack_80 = (ushort)in[9] * 0x100 + (ushort)in[8];
        sStack_7e = (ushort)in[0xb] * 0x100 + (ushort)in[10];
        iStack_7c = (uint)in[0xf] * 0x1000000 + (uint)in[0xe] * 0x10000 + (uint)in[0xc] +
                    (uint)in[0xd] * 0x100;
        sStack_78 = (ushort)in[0x11] * 0x100 + (ushort)in[0x10];
        sVar3 = FUN_00004f26(&pInMsg->addrInfo, 8, auStack_88);
      }
    }
  }
  return sVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAD(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r7;
  code *unaff_r8;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*in_r3)();
  (*unaff_r7)();
  (*unaff_r8)();
  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}

void FUN_00004f26(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r7;
  code *unaff_r8;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r7)();
  (*unaff_r8)();
  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}

void FUN_00004f28(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r8;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r8)();
  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}

void FUN_00004f2a(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r9;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r9)();
  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}

void FUN_00004f2c(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_sl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*unaff_sl)();
  zcl_registerCluster(endpoint, 0x19, manuCode, attrNum, pAttrTbl, zcl_ota_cmdHandler, in_stack_00000000);
  return;
}

status_t zcl_ota_register(u8 endpoint, u16 manuCode, u8 arrtNum, zclAttrInfo_t *attrTbl,
                          cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x19, manuCode, arrtNum, attrTbl, zcl_ota_cmdHandler, cb);
  return sVar1;
}

status_t zcl_ota_queryNextImageReqSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                       ota_queryNextImageReq_t *pReq)

{
  u32 uVar1;
  short sVar2;
  status_t sVar3;
  byte local_24;
  undefined uStack_23;
  undefined uStack_22;
  undefined uStack_21;
  undefined uStack_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;

  local_24 = pReq->fc;
  uStack_23 = (undefined)pReq->manuCode;
  uStack_22 = (undefined)(pReq->manuCode >> 8);
  uStack_21 = (undefined)pReq->imageType;
  uStack_20 = (undefined)(pReq->imageType >> 8);
  uVar1 = pReq->curFileVer;
  uStack_1f = (undefined)uVar1;
  uStack_1e = (undefined)(uVar1 >> 8);
  uStack_1d = (undefined)(uVar1 >> 0x10);
  uStack_1c = (undefined)(uVar1 >> 0x18);
  sVar2 = (short)&stack0x0000000d;
  if ((int)((uint)local_24 << 0x1f) < 0)
  {
    uStack_1b = (undefined)pReq->hdrwareVer;
    uStack_1a = (undefined)(pReq->hdrwareVer >> 8);
    sVar2 = (short)&stack0x0000000f;
  }
  sVar3 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      (sVar2 + -0x28) - (short)&local_24 & 0xff, &local_24);
  return sVar3;
}

status_t zcl_ota_queryNextImageRspSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                       ota_queryNextImageRsp_t *pRsp)

{
  u32 uVar1;
  status_t sVar2;
  short sVar3;
  u8 local_24;
  undefined uStack_23;
  undefined uStack_22;
  undefined uStack_21;
  undefined uStack_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;
  undefined uStack_19;
  undefined uStack_18;
  undefined auStack_17[7];

  local_24 = pRsp->st;
  sVar3 = (short)&uStack_23;
  if (local_24 == '\0')
  {
    uStack_23 = (undefined)pRsp->manuCode;
    uStack_22 = (undefined)(pRsp->manuCode >> 8);
    uStack_21 = (undefined)pRsp->imageType;
    uStack_20 = (undefined)(pRsp->imageType >> 8);
    uVar1 = pRsp->fileVer;
    uStack_1f = (undefined)uVar1;
    uStack_1e = (undefined)(uVar1 >> 8);
    uStack_1d = (undefined)(uVar1 >> 0x10);
    uStack_1c = (undefined)(uVar1 >> 0x18);
    uVar1 = pRsp->imageSize;
    uStack_1b = (undefined)uVar1;
    uStack_1a = (undefined)(uVar1 >> 8);
    uStack_19 = (undefined)(uVar1 >> 0x10);
    uStack_18 = (undefined)(uVar1 >> 0x18);
    sVar3 = (short)auStack_17;
  }
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x02', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      sVar3 - (short)&local_24 & 0xff, &local_24);
  return sVar2;
}

status_t zcl_ota_imageBlockReqSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_imageBlockReq_t *pReq)

{
  u32 uVar1;
  u16 uVar2;
  status_t sVar3;
  undefined *out;
  uint uVar4;
  byte local_38;
  undefined uStack_37;
  undefined uStack_36;
  undefined uStack_35;
  undefined uStack_34;
  undefined uStack_33;
  undefined uStack_32;
  undefined uStack_31;
  undefined uStack_30;
  undefined uStack_2f;
  undefined uStack_2e;
  undefined uStack_2d;
  undefined uStack_2c;
  u8 uStack_2b;
  undefined local_2a[8];
  undefined auStack_22[2];

  local_38 = pReq->fc;
  uVar4 = (uint)local_38;
  uStack_37 = (undefined)pReq->manuCode;
  uStack_36 = (undefined)(pReq->manuCode >> 8);
  uStack_35 = (undefined)pReq->imageType;
  uStack_34 = (undefined)(pReq->imageType >> 8);
  uVar1 = pReq->fileVer;
  uStack_33 = (undefined)uVar1;
  uStack_32 = (undefined)(uVar1 >> 8);
  uStack_31 = (undefined)(uVar1 >> 0x10);
  uStack_30 = (undefined)(uVar1 >> 0x18);
  uVar1 = pReq->fileOffset;
  uStack_2f = (undefined)uVar1;
  uStack_2e = (undefined)(uVar1 >> 8);
  uStack_2d = (undefined)(uVar1 >> 0x10);
  uStack_2c = (undefined)(uVar1 >> 0x18);
  uStack_2b = pReq->maxDataSize;
  out = local_2a;
  if ((int)(uVar4 << 0x1f) < 0)
  {
    memcpy(out, pReq->reqNodeAddr, 8);
    out = auStack_22;
  }
  if ((int)(uVar4 << 0x1e) < 0)
  {
    uVar2 = pReq->blockReqDelay;
    *out = (char)uVar2;
    out[1] = (char)(uVar2 >> 8);
    out = out + 2;
  }
  sVar3 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x03', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      (short)out - (short)&local_38 & 0xff, &local_38);
  return sVar3;
}

status_t zcl_ota_imageBlockRspSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_imageBlockRsp_t *pRsp)

{
  status_t sVar1;
  u8 *cmdPld;
  u16 size;

  if (pRsp->st == '\0')
  {
    size = (pRsp->rsp).success.dataSize + 0xe & 0xff;
  }
  else
  {
    size = 1;
    if (pRsp->st == 0x97)
    {
      size = 0xb;
    }
  }
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = pRsp->st;
    if (pRsp->st == '\0')
    {
      cmdPld[1] = *(u8 *)&pRsp->rsp;
      cmdPld[2] = *(u8 *)((int)&pRsp->rsp + 1);
      cmdPld[3] = *(u8 *)((int)&pRsp->rsp + 2);
      cmdPld[4] = *(u8 *)((int)&pRsp->rsp + 3);
      cmdPld[5] = *(u8 *)((int)&pRsp->rsp + 4);
      cmdPld[6] = *(u8 *)((int)&pRsp->rsp + 5);
      cmdPld[7] = *(u8 *)((int)&pRsp->rsp + 6);
      cmdPld[8] = *(u8 *)((int)&pRsp->rsp + 7);
      cmdPld[9] = *(u8 *)((int)&pRsp->rsp + 8);
      cmdPld[10] = *(u8 *)((int)&pRsp->rsp + 9);
      cmdPld[0xb] = *(u8 *)((int)&pRsp->rsp + 10);
      cmdPld[0xc] = *(u8 *)((int)&pRsp->rsp + 0xb);
      cmdPld[0xd] = (pRsp->rsp).success.dataSize;
      memcpy(cmdPld + 0xe, (pRsp->rsp).success.data, (uint)(pRsp->rsp).success.dataSize);
    }
    else if (pRsp->st == 0x97)
    {
      cmdPld[1] = *(u8 *)&pRsp->rsp;
      cmdPld[2] = *(u8 *)((int)&pRsp->rsp + 1);
      cmdPld[3] = *(u8 *)((int)&pRsp->rsp + 2);
      cmdPld[4] = *(u8 *)((int)&pRsp->rsp + 3);
      cmdPld[5] = *(u8 *)((int)&pRsp->rsp + 4);
      cmdPld[6] = *(u8 *)((int)&pRsp->rsp + 5);
      cmdPld[7] = *(u8 *)((int)&pRsp->rsp + 6);
      cmdPld[8] = *(u8 *)((int)&pRsp->rsp + 7);
      cmdPld[9] = *(u8 *)((int)&pRsp->rsp + 8);
      cmdPld[10] = *(u8 *)((int)&pRsp->rsp + 9);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x05', '\x01', '\x01', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}

status_t zcl_ota_upgradeEndReqSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_upgradeEndReq_t *pReq)

{
  u32 uVar1;
  status_t sVar2;
  u8 local_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;
  undefined uStack_19;
  undefined uStack_18;
  undefined auStack_17[7];

  local_20 = pReq->st;
  uStack_1f = (undefined)pReq->manuCode;
  uStack_1e = (undefined)(pReq->manuCode >> 8);
  uStack_1d = (undefined)pReq->imageType;
  uStack_1c = (undefined)(pReq->imageType >> 8);
  uVar1 = pReq->fileVer;
  uStack_1b = (undefined)uVar1;
  uStack_1a = (undefined)(uVar1 >> 8);
  uStack_19 = (undefined)(uVar1 >> 0x10);
  uStack_18 = (undefined)(uVar1 >> 0x18);
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\x06', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      (short)auStack_17 - (short)&local_20 & 0xff, &local_20);
  return sVar2;
}

status_t zcl_ota_upgradeEndRspSend(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                   ota_upgradeEndRsp_t *pRsp)

{
  u32 uVar1;
  status_t sVar2;
  u8 local_24;
  undefined uStack_23;
  undefined uStack_22;
  undefined uStack_21;
  undefined uStack_20;
  undefined uStack_1f;
  undefined uStack_1e;
  undefined uStack_1d;
  undefined uStack_1c;
  undefined uStack_1b;
  undefined uStack_1a;
  undefined uStack_19;
  undefined uStack_18;
  undefined uStack_17;
  undefined uStack_16;
  undefined uStack_15;
  undefined auStack_14[4];

  local_24 = (u8)pRsp->manuCode;
  uStack_23 = (undefined)(pRsp->manuCode >> 8);
  uStack_22 = (undefined)pRsp->imageType;
  uStack_21 = (undefined)(pRsp->imageType >> 8);
  uVar1 = pRsp->fileVer;
  uStack_20 = (undefined)uVar1;
  uStack_1f = (undefined)(uVar1 >> 8);
  uStack_1e = (undefined)(uVar1 >> 0x10);
  uStack_1d = (undefined)(uVar1 >> 0x18);
  uVar1 = pRsp->currentTime;
  uStack_1c = (undefined)uVar1;
  uStack_1b = (undefined)(uVar1 >> 8);
  uStack_1a = (undefined)(uVar1 >> 0x10);
  uStack_19 = (undefined)(uVar1 >> 0x18);
  uVar1 = pRsp->upgradeTime;
  uStack_18 = (undefined)uVar1;
  uStack_17 = (undefined)(uVar1 >> 8);
  uStack_16 = (undefined)(uVar1 >> 0x10);
  uStack_15 = (undefined)(uVar1 >> 0x18);
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 0x19, '\a', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      (short)auStack_14 - (short)&local_24 & 0xff, &local_24);
  return sVar2;
}

status_t zcl_occupancySensing_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x406, manuCode, attrNum, attrTbl, ll_reset, cb);
  return sVar1;
}

status_t zcl_temperature_measurement_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x402, manuCode, attrNum, attrTbl, ll_reset, cb);
  return sVar1;
}

status_t zcl_basic_cmdHandler(zclIncoming_t *pInMsg)

{
  status_t sVar1;

  sVar1 = 0x81;
  if ((-1 < (int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c)) && ((pInMsg->hdr).cmd == '\0'))
  {
    sVar1 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      sVar1 = FUN_0000548a(&pInMsg->addrInfo, 0, 0);
    }
  }
  return sVar1;
}

void FUN_0000548a(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*in_r3)();
  zcl_registerCluster(endpoint, 0, manuCode, attrNum, pAttrTbl, zcl_basic_cmdHandler, in_stack_00000000);
  return;
}

status_t zcl_basic_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl,
                            cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0, manuCode, attrNum, attrTbl, zcl_basic_cmdHandler, cb);
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_gp_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  undefined3 *puVar2;
  uint3 *puVar3;
  u8 *puVar4;
  status_t sVar5;
  ushort uVar6;
  uint uVar7;
  uint extraout_r1;
  uint uVar8;
  uint extraout_r2;
  uint extraout_r3;
  uint extraout_r3_00;
  uint uVar9;
  byte *pbVar10;
  uint uVar11;
  uint extraout_r3_01;
  uint extraout_r3_02;
  byte *pbVar12;
  byte *pbVar13;
  int *piVar14;
  undefined auStack_134[4];
  byte *pbStack_130;
  byte *pbStack_12c;
  byte *pbStack_128;
  byte *pbStack_124;
  int iStack_120;
  int iStack_10c;
  undefined2 uStack_104;
  short sStack_102;
  short sStack_100;
  short sStack_fe;
  byte bStack_fc;
  byte bStack_fb;
  byte bStack_f9;
  byte bStack_f8;
  byte bStack_f6;
  byte bStack_f5;
  byte bStack_f2;
  char cStack_f1;
  int iStack_f0;
  undefined4 uStack_ec;
  undefined4 uStack_e8;
  undefined4 uStack_e4;
  uint uStack_e0;
  int iStack_dc;
  undefined4 uStack_d8;
  undefined4 uStack_d4;
  undefined4 uStack_d0;
  undefined4 uStack_cc;
  uint uStack_c8;
  uint uStack_c4;
  byte local_c0;
  int iStack_bc;
  undefined4 uStack_b8;
  byte *pbStack_b4;
  int iStack_b0;
  int iStack_ac;
  undefined4 uStack_a8;
  undefined4 uStack_a4;
  int iStack_a0;
  undefined4 uStack_9c;
  byte *pbStack_98;
  int iStack_94;
  undefined4 uStack_90;
  int iStack_8c;
  int iStack_88;
  undefined4 uStack_84;
  byte *pbStack_80;
  undefined4 uStack_7c;
  short local_78;
  byte local_76;
  int iStack_74;
  undefined4 uStack_70;
  int *piStack_6c;
  uint uStack_68;
  int local_64;
  undefined4 uStack_60;
  ushort local_5c;
  undefined local_5a;
  int local_58;
  undefined4 uStack_54;
  ushort local_50;
  undefined local_4e;
  int iStack_4c;
  undefined4 uStack_48;
  undefined local_44;
  int iStack_40;
  uint uStack_3c;
  undefined local_38;
  undefined4 local_34;
  undefined2 uStack_30;
  uint local_2c;
  u8 local_28;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    switch ((pInMsg->hdr).cmd)
    {
    default:
      goto switchD_000054fc_caseD_1;
    case '\x01':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      piVar14 = &iStack_f0;
      iStack_f0 = 0;
      uStack_ec = 0;
      uStack_e8 = 0;
      uStack_e4 = 0;
      iStack_dc = 0;
      uStack_d8 = 0;
      uStack_d4 = 0;
      uStack_d0 = 0;
      uStack_cc = 0;
      uStack_c8 = 0;
      uStack_c4 = 0;
      local_c0 = 0;
      pbVar12 = pInMsg->pData;
      uStack_e0 = (uint)pbVar12[2] * 0x10000 + (uint)pbVar12[1] * 0x100 + (uint)*pbVar12;
      uVar7 = uStack_e0 & 0xff;
      if ((uStack_e0 & 7) != 0)
      {
        sVar5 = FUN_000057ee();
        return sVar5;
      }
      iStack_f0 = (uint)pbVar12[6] * 0x1000000 + (uint)pbVar12[5] * 0x10000 + (uint)pbVar12[3] +
                  (uint)pbVar12[4] * 0x100;
      pbVar13 = pbVar12 + 7;
      if (-1 < (int)(uVar7 << 0x1b))
      {
        uVar8 = uStack_e0 & 0x60;
        if (uVar8 == 0x60)
        {
          FUN_00005e5c();
          uVar8 = extraout_r3;
        }
        if (uVar8 == 0)
        {
          FUN_00005e5c();
          uVar8 = extraout_r3_00;
        }
        if ((uVar8 == 0x40) || (uVar8 == 0x20))
        {
          uStack_c8 = uStack_c8 & 0xffff |
                      (uint)(ushort)((ushort)pbVar12[8] * 0x100 + (ushort)*pbVar13) << 0x10;
          pbVar13 = pbVar12 + 9;
        }
        if ((int)(uVar7 << 0x1c) < 0)
        {
          uStack_c4 = uStack_c4 & 0xffffff | (uint)*pbVar13 << 0x18;
          pbVar12 = pbVar13 + 1;
          if ((int)((uStack_e0 >> 8) << 0x19) < 0)
          {
            iStack_dc = (uint)pbVar13[4] * 0x1000000 + (uint)pbVar13[3] * 0x10000 + (uint)pbVar13[1] + (uint)pbVar13[2] * 0x100;
            pbVar12 = pbVar13 + 5;
          }
          if ((uStack_e0 & 0x8000) != 0)
          {
            FUN_00005ee4();
          }
          uVar7 = uStack_e0 >> 0x10 & 0xff;
          if ((int)(uVar7 << 0x1f) < 0)
          {
            uStack_c4 = uStack_c4 & 0xffff0000 |
                        (uint)(ushort)((ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12);
            pbVar12 = pbVar12 + 2;
          }
          if ((int)(uVar7 << 0x1e) < 0)
          {
            local_c0 = *pbVar12;
          }
        }
      }
      uVar8 = (uint) * (uint3 *)&pInMsg->clusterAppCb;
      uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
      break;
    case '\x02':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      pbVar12 = pInMsg->pData;
      local_2c = (uint)*pbVar12;
      uVar7 = local_2c;
      if ((*pbVar12 & 1) != 0)
      {
        pbVar13 = pbVar12 + 1;
        if ((int)(local_2c << 0x1e) < 0)
        {
          local_2c = local_2c |
                     (uint)(ushort)((ushort)pbVar12[2] * 0x100 + (ushort)pbVar12[1]) << 0x10;
          pbVar13 = pbVar12 + 3;
        }
        if ((int)(uVar7 << 0x1b) < 0)
        {
          local_2c._0_2_ = CONCAT11(*pbVar13, (undefined)local_2c);
          local_2c = local_2c & 0xffff0000 | (uint)(ushort)local_2c;
        }
      }
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 2);
      return sVar5;
    case '\x06':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      iStack_88 = 0;
      uStack_84 = 0;
      pbStack_80 = (byte *)0x0;
      local_78 = 0;
      local_76 = 0;
      pbVar12 = pInMsg->pData;
      bVar1 = *pbVar12;
      uStack_7c = CONCAT13(pbVar12[3],
                           CONCAT12(bVar1, (ushort)pbVar12[2] * 0x100 + (ushort)pbVar12[1]));
      if ((bVar1 & 7) != 0)
      {
        if ((bVar1 & 7) != 2)
        {
          local_78 = (ushort)pbVar12[4] << 8;
          local_76 = pbVar12[5];
          pbStack_80 = pbVar12 + 6;
          sVar5 = FUN_00005f1e(&pInMsg->addrInfo, 6, &iStack_88);
          return sVar5;
        }
        sVar5 = FUN_00005ebe();
        return sVar5;
      }
      iStack_88 = (uint)pbVar12[7] * 0x1000000 + (uint)pbVar12[6] * 0x10000 + (uint)pbVar12[4] +
                  (uint)pbVar12[5] * 0x100;
      sVar5 = FUN_0000575c(1, pbVar12 + 8);
      return sVar5;
    case '\n':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      puVar2 = (undefined3 *)pInMsg->pData;
      local_44 = *(undefined *)(puVar2 + 1);
      iStack_4c = (int)puVar2 + 4;
      uStack_48 = CONCAT31(*puVar2, *(char *)&pInMsg->dataLen + -4);
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 10);
      return sVar5;
    case '\v':
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      piVar14 = &local_64;
      local_64 = 0;
      uStack_60 = 0;
      local_5a = 0;
      pbVar12 = pInMsg->pData;
      bVar1 = *pbVar12;
      local_5c = (ushort)bVar1;
      pbVar13 = pbVar12 + 1;
      if ((bVar1 & 0x18) != 0)
      {
        sVar5 = FUN_000057da();
        return sVar5;
      }
      uVar7 = bVar1 & 7;
      if ((bVar1 & 7) == 0)
      {
        local_64 = (uint)pbVar12[4] * 0x1000000 + (uint)pbVar12[3] * 0x10000 + (uint)pbVar12[1] +
                   (uint)pbVar12[2] * 0x100;
        sVar5 = FUN_000057e0();
        return sVar5;
      }
      goto LAB_00005da6;
    }
    goto LAB_00005612;
  }
  switch ((pInMsg->hdr).cmd)
  {
  case '\0':
    uVar9 = (uint) * (byte *)&pInMsg->clusterAppCb;
    uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
    uVar11 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
    uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\x01';
    }
    piVar14 = &iStack_a0;
    iStack_a0 = 0;
    uStack_9c = 0;
    pbStack_98 = (byte *)0x0;
    iStack_94 = 0;
    iStack_8c = 0;
    pbVar12 = pInMsg->pData;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    uStack_90 = (uint)uVar6;
    if ((uVar6 & 7) != 0)
    {
      sVar5 = FUN_00005e00();
      return sVar5;
    }
    iStack_a0 = (uint)pbVar12[3] * 0x100 +
                (uint)pbVar12[5] * 0x1000000 + (uint)pbVar12[4] * 0x10000 + (uint)pbVar12[2];
    iStack_94 = (uint)pbVar12[9] * 0x1000000 + (uint)pbVar12[8] * 0x10000 + (uint)pbVar12[6] +
                (uint)pbVar12[7] * 0x100;
    iStack_8c = (uint) * (ushort *)(pbVar12 + 10) << 8;
    pbStack_98 = pbVar12 + 0xc;
    uStack_90._1_1_ = (byte)(uVar6 >> 8);
    if ((int)((uint)uStack_90._1_1_ << 0x19) < 0)
    {
      pbVar13 = pbStack_98 + pbVar12[0xb];
      uStack_90 = CONCAT22((ushort)pbVar13[1] * 0x100 + (ushort)*pbVar13, uVar6);
      iStack_8c = (uint)CONCAT12(pbVar13[2], *(ushort *)(pbVar12 + 10)) << 8;
    }
    goto LAB_00005956;
  default:
  switchD_000054fc_caseD_1:
    sVar5 = 0x81;
    break;
  case '\x04':
    uVar9 = (uint) * (byte *)&pInMsg->clusterAppCb;
    uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
    uVar11 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
    uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\x01';
    }
    piVar14 = &iStack_bc;
    iStack_bc = 0;
    uStack_b8 = 0;
    pbStack_b4 = (byte *)0x0;
    iStack_b0 = 0;
    iStack_ac = 0;
    uStack_a4 = 0;
    pbVar12 = pInMsg->pData;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    uStack_a8 = (uint)uVar6;
    if ((uVar6 & 7) != 0)
    {
      sVar5 = FUN_00005dd6();
      return sVar5;
    }
    iStack_bc = (uint)pbVar12[3] * 0x100 +
                (uint)pbVar12[5] * 0x1000000 + (uint)pbVar12[4] * 0x10000 + (uint)pbVar12[2];
    iStack_b0 = (uint)pbVar12[9] * 0x1000000 + (uint)pbVar12[8] * 0x10000 + (uint)pbVar12[6] +
                (uint)pbVar12[7] * 0x100;
    uStack_a4._3_1_ = 0;
    pbStack_b4 = pbVar12 + 0xc;
    pbVar13 = pbStack_b4 + pbVar12[0xb];
    uStack_a8._1_1_ = (byte)(uVar6 >> 8);
    if ((int)((uint)uStack_a8._1_1_ << 0x1c) < 0)
    {
      uStack_a8 = CONCAT22((ushort)*pbVar13 + (ushort)pbVar13[1] * 0x100, uVar6);
      uStack_a4._3_1_ = pbVar13[2];
      pbVar13 = pbVar13 + 3;
    }
    uStack_a4 = (uint)CONCAT12(uStack_a4._3_1_, *(undefined2 *)(pbVar12 + 10)) << 8;
    if ((int)((uint)uStack_a8._1_1_ << 0x1e) < 0)
    {
      iStack_ac = (uint)pbVar13[3] * 0x1000000 + (uint)pbVar13[2] * 0x10000 + (uint)*pbVar13 +
                  (uint)pbVar13[1] * 0x100;
    }
  LAB_00005956:
    uVar8 = uVar9 | uVar8 << 8 | uVar11 << 0x10;
  LAB_00005612:
    sVar5 = FUN_00005f1a(&pInMsg->addrInfo, (pInMsg->hdr).cmd, piVar14, uVar8 | uVar7 << 0x18);
    break;
  case '\x05':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      puVar4 = pInMsg->pData;
      local_34 = CONCAT22((ushort)puVar4[4] * 0x100 + (ushort)puVar4[3],
                          (ushort)puVar4[2] * 0x100 + (ushort)puVar4[1]);
      uStack_30 = CONCAT11(puVar4[5], *puVar4);
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 5);
    }
    break;
  case '\b':
    if (pInMsg->clusterAppCb == ll_reset)
    {
      FUN_000054d8(1);
    }
    local_28 = *pInMsg->pData;
    FUN_00005f1a(&pInMsg->addrInfo, 8);
    FUN_000054d8();
  case '\a':
    uVar11 = (uint) * (byte *)&pInMsg->clusterAppCb;
    pbVar13 = (byte *)(uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
    uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
    uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    if (pInMsg->clusterAppCb == ll_reset)
    {
      FUN_000054d8(1);
      uVar7 = extraout_r1;
      uVar8 = extraout_r2;
      uVar11 = extraout_r3_01;
    }
    iStack_74 = 0;
    uStack_70 = 0;
    piStack_6c = (int *)0x0;
    pbVar12 = pInMsg->pData;
    bVar1 = *(byte *)&pInMsg->dataLen;
    uVar6 = (ushort)*pbVar12 + (ushort)pbVar12[1] * 0x100;
    uStack_68 = (uint)uVar6;
    piVar14 = (int *)(pbVar12 + 2);
    if ((uVar6 & 7) == 0)
    {
      iStack_74 = (uint)pbVar12[3] * 0x100 +
                  (uint)pbVar12[5] * 0x1000000 + (uint)pbVar12[4] * 0x10000 + (uint)pbVar12[2];
      piVar14 = (int *)(pbVar12 + 6);
    }
    else if ((uVar6 & 7) == 2)
    {
      memcpy(&iStack_74, piVar14, 8);
      uStack_68 = (uint)CONCAT12(pbVar12[10], (undefined2)uStack_68);
      piVar14 = (int *)(pbVar12 + 0xb);
      uVar11 = (uint) * (byte *)&pInMsg->clusterAppCb;
      pbVar13 = (byte *)(uint) * (byte *)((int)&pInMsg->clusterAppCb + 1);
      uVar7 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 2);
      uVar8 = (uint) * (byte *)((int)&pInMsg->clusterAppCb + 3);
    }
    uStack_68 = (int)(pbVar12 + ((uint)bVar1 - (int)piVar14)) * 0x1000000 | uStack_68;
    if (((uint)(pbVar12 + ((uint)bVar1 - (int)piVar14)) & 0xff) != 0)
    {
      piStack_6c = piVar14;
    }
    FUN_00005f1a(&pInMsg->addrInfo, (pInMsg->hdr).cmd, &iStack_74,
                 uVar11 | (int)pbVar13 << 8 | uVar7 << 0x10 | uVar8 << 0x18);
    FUN_000054d8();
    uVar7 = extraout_r3_02;
  LAB_00005da6:
    if (uVar7 == 2)
    {
      memcpy(piVar14, pbVar13, 8);
      *(byte *)((int)piVar14 + 9) = pbVar13[8];
      sVar5 = FUN_000057e0();
      return sVar5;
    }
    sVar5 = FUN_000057e0();
    return sVar5;
  case '\t':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      memset(auStack_134, 0, 0x44);
      pbVar12 = pInMsg->pData;
      bStack_fc = *pbVar12;
      uStack_104 = (ushort)pbVar12[2] * 0x100 + (ushort)pbVar12[1];
      if ((uStack_104 & 7) != 0)
      {
        sVar5 = FUN_00005dbc();
        return sVar5;
      }
      iStack_10c = (uint)pbVar12[6] * 0x1000000 + (uint)pbVar12[5] * 0x10000 + (uint)pbVar12[3] +
                   (uint)pbVar12[4] * 0x100;
      bStack_f9 = pbVar12[7];
      pbVar13 = pbVar12 + 8;
      if (((byte)uStack_104 & 0x18) == 0x10)
      {
        sVar5 = FUN_00005ed0();
        return sVar5;
      }
      uStack_104._1_1_ = (byte)(uStack_104 >> 8);
      if ((int)((uint)uStack_104._1_1_ << 0x1f) < 0)
      {
        sStack_102 = (ushort)pbVar12[9] * 0x100 + (ushort)*pbVar13;
        pbVar13 = pbVar12 + 10;
      }
      bStack_f8 = *pbVar13;
      pbVar10 = pbVar13 + 1;
      if ((int)((uint)uStack_104._1_1_ << 0x1e) < 0)
      {
        sVar5 = FUN_00005e90();
        return sVar5;
      }
      if ((int)((uint)(byte)uStack_104 << 0x1a) < 0)
      {
        iStack_120 = (uint)pbVar13[4] * 0x1000000 + (uint)pbVar13[3] * 0x10000 + (uint)*pbVar10 +
                     (uint)pbVar13[2] * 0x100;
        pbVar10 = pbVar13 + 5;
      }
      bStack_f6 = *pbVar10;
      uVar7 = (uint)bStack_f6;
      pbVar10 = pbVar10 + 1;
      pbStack_124 = pbVar10;
      if ((((uVar7 != 0xfe) && (uVar7 != 0)) && (uVar7 != 0xfd)) && (uVar7 != 0xff))
      {
        pbStack_124 = pbVar10 + uVar7;
        pbStack_130 = pbVar10;
      }
      if ((int)((uint)uStack_104._1_1_ << 0x1d) < 0)
      {
        bStack_fb = *pbStack_124;
        pbVar13 = pbStack_124 + 1;
        uVar7 = (uint)bStack_fb;
        if ((int)(uVar7 << 0x1f) < 0)
        {
          sStack_100 = (ushort)pbStack_124[2] * 0x100 + (ushort)*pbVar13;
          pbVar13 = pbStack_124 + 3;
        }
        if ((int)(uVar7 << 0x1e) < 0)
        {
          sStack_fe = (ushort)pbVar13[1] * 0x100 + (ushort)*pbVar13;
          pbVar13 = pbVar13 + 2;
        }
        if ((int)(uVar7 << 0x1d) < 0)
        {
          bStack_f2 = *pbVar13;
          pbVar10 = pbVar13 + 1;
          pbVar13 = pbVar10;
          if (bStack_f2 != 0)
          {
            pbVar13 = pbVar10 + bStack_f2;
            pbStack_12c = pbVar10;
          }
        }
        pbStack_124 = pbVar13;
        if ((int)(uVar7 << 0x1c) < 0)
        {
          pbStack_124 = pbVar13 + 1;
          pbStack_128 = pbVar13;
          if (*pbVar13 != 0)
          {
            pbStack_124 = pbStack_124 + (((uint)*pbVar13 << 0x19) >> 0x18);
          }
        }
        if ((int)(uVar7 << 0x1b) < 0)
        {
          bStack_f5 = *pbStack_124;
          if (bStack_f5 == 2)
          {
            sVar5 = FUN_00005f0a();
            return sVar5;
          }
          pbStack_124 = pbStack_124 + bStack_f5 + 1;
        }
      }
      if ((bStack_fc & 7) == 5)
      {
        if ((int)pbStack_124 - (int)pbVar12 < (int)(uint)pInMsg->dataLen)
        {
          cStack_f1 = ((char)pbVar12 + (char)pInMsg->dataLen) - (char)pbStack_124;
          sVar5 = FUN_00005c82();
          return sVar5;
        }
        sVar5 = FUN_00005c82();
        return sVar5;
      }
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, (pInMsg->hdr).cmd, auStack_134, pInMsg->clusterAppCb);
    }
    break;
  case '\n':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      local_58 = 0;
      uStack_54 = 0;
      local_4e = 0;
      pbVar12 = pInMsg->pData;
      bVar1 = *pbVar12;
      local_50 = (ushort)bVar1;
      if ((bVar1 & 0x18) != 0)
      {
        sVar5 = FUN_00005e50();
        return sVar5;
      }
      if ((bVar1 & 7) == 0)
      {
        local_58 = (uint)pbVar12[4] * 0x1000000 + (uint)pbVar12[3] * 0x10000 + (uint)pbVar12[1] +
                   (uint)pbVar12[2] * 0x100;
      }
      else if ((bVar1 & 7) == 2)
      {
        memcpy(&local_58, pbVar12 + 1, 8);
        local_50 = local_50 & 0xff | (ushort)pbVar12[9] << 8;
      }
      sVar5 = FUN_00005f1c(&pInMsg->addrInfo, 10, &local_58);
    }
    break;
  case '\v':
    sVar5 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      iStack_40 = 0;
      puVar3 = (uint3 *)pInMsg->pData;
      uStack_3c = (uint)*puVar3 << 8;
      local_38 = *(undefined *)(puVar3 + 1);
      uVar7 = (int)puVar3 + ((uint) * (byte *)&pInMsg->dataLen - ((int)puVar3 + 4));
      uStack_3c = uStack_3c | uVar7 & 0xff;
      if ((uVar7 & 0xff) != 0)
      {
        iStack_40 = (int)puVar3 + 4;
      }
      sVar5 = FUN_00005f1a(&pInMsg->addrInfo, 0xb);
    }
  }
  return sVar5;
}

void FUN_000054d8(void)

{
  return;
}

void FUN_000055b0(void)

{
  undefined4 *unaff_r4;
  int unaff_r5;
  byte *pbVar1;
  undefined *unaff_r7;
  int unaff_r8;

  if (unaff_r8 << 0x1c < 0)
  {
    *(undefined *)(unaff_r5 + 0x2f) = *unaff_r7;
    pbVar1 = unaff_r7 + 1;
    if ((int)((uint) * (byte *)(unaff_r5 + 0x11) << 0x19) < 0)
    {
      *(uint *)(unaff_r5 + 0x14) =
          (uint)(byte)unaff_r7[4] * 0x1000000 + (uint)(byte)unaff_r7[3] * 0x10000 +
          (uint)(byte)unaff_r7[1] + (uint)(byte)unaff_r7[2] * 0x100;
      pbVar1 = unaff_r7 + 5;
    }
    if ((*(byte *)(unaff_r5 + 0x11) & 0x80) != 0)
    {
      FUN_00005ee4();
    }
    if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1f) < 0)
    {
      *(ushort *)(unaff_r5 + 0x2c) = (ushort)pbVar1[1] * 0x100 + (ushort)*pbVar1;
      pbVar1 = pbVar1 + 2;
    }
    if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1e) < 0)
    {
      *(byte *)(unaff_r5 + 0x30) = *pbVar1;
    }
  }
  FUN_00005f1a((int)unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 8), unaff_r5, *unaff_r4);
  return;
}

void FUN_000055e6(void)

{
  undefined4 *unaff_r4;
  int unaff_r5;
  byte *unaff_r6;

  if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1f) < 0)
  {
    *(ushort *)(unaff_r5 + 0x2c) = (ushort)unaff_r6[1] * 0x100 + (ushort)*unaff_r6;
    unaff_r6 = unaff_r6 + 2;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x12) << 0x1e) < 0)
  {
    *(byte *)(unaff_r5 + 0x30) = *unaff_r6;
  }
  FUN_00005f1a((int)unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 8), unaff_r5, *unaff_r4);
  return;
}

void FUN_0000575c(undefined4 param_1, undefined *param_2)

{
  int unaff_r4;
  int unaff_r5;

  *(undefined *)(unaff_r5 + 0x11) = *param_2;
  *(undefined *)(unaff_r5 + 0x12) = param_2[1];
  *(undefined **)(unaff_r5 + 8) = param_2 + 2;
  FUN_00005f1e(unaff_r4 + 0x12, 6, unaff_r5);
  return;
}

void FUN_000057da(undefined4 param_1, int param_2)

{
  int unaff_r4;
  undefined4 unaff_r5;

  if (param_2 == 8)
  {
    FUN_00005e8a();
    return;
  }
  FUN_00005f1c(unaff_r4 + 0x12, 0xb, unaff_r5);
  return;
}

void FUN_000057e0(void)

{
  int unaff_r4;
  undefined4 unaff_r5;

  FUN_00005f1c(unaff_r4 + 0x12, 0xb, unaff_r5);
  return;
}

void FUN_000057ee(void)

{
  uint uVar1;
  uint extraout_r3;
  uint extraout_r3_00;
  int in_r3;
  undefined4 *unaff_r4;
  void *unaff_r5;
  byte *pbVar2;
  int unaff_r6;
  byte *unaff_r7;
  uint unaff_r8;

  if (in_r3 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 0x2e) = *(undefined *)(unaff_r6 + 0xb);
    unaff_r7 = (byte *)(unaff_r6 + 0xc);
  }
  if (-1 < (int)(unaff_r8 << 0x1b))
  {
    uVar1 = unaff_r8 & 0x60;
    if (uVar1 == 0x60)
    {
      FUN_00005e5c();
      uVar1 = extraout_r3;
    }
    if (uVar1 == 0)
    {
      FUN_00005e5c();
      uVar1 = extraout_r3_00;
    }
    if ((uVar1 == 0x40) || (uVar1 == 0x20))
    {
      *(ushort *)((int)unaff_r5 + 0x2a) = (ushort)unaff_r7[1] * 0x100 + (ushort)*unaff_r7;
      unaff_r7 = unaff_r7 + 2;
    }
    if ((int)(unaff_r8 << 0x1c) < 0)
    {
      *(byte *)((int)unaff_r5 + 0x2f) = *unaff_r7;
      pbVar2 = unaff_r7 + 1;
      if ((int)((uint) * (byte *)((int)unaff_r5 + 0x11) << 0x19) < 0)
      {
        *(uint *)((int)unaff_r5 + 0x14) =
            (uint)unaff_r7[4] * 0x1000000 + (uint)unaff_r7[3] * 0x10000 + (uint)unaff_r7[1] +
            (uint)unaff_r7[2] * 0x100;
        pbVar2 = unaff_r7 + 5;
      }
      if ((*(byte *)((int)unaff_r5 + 0x11) & 0x80) != 0)
      {
        FUN_00005ee4();
      }
      if ((int)((uint) * (byte *)((int)unaff_r5 + 0x12) << 0x1f) < 0)
      {
        *(ushort *)((int)unaff_r5 + 0x2c) = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
        pbVar2 = pbVar2 + 2;
      }
      if ((int)((uint) * (byte *)((int)unaff_r5 + 0x12) << 0x1e) < 0)
      {
        *(byte *)((int)unaff_r5 + 0x30) = *pbVar2;
      }
    }
  }
  FUN_00005f1a((int)unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 8), unaff_r5, *unaff_r4);
  return;
}

undefined4 switchD_000054fc::caseD_0(void)

{
  byte *pbVar1;
  ushort uVar2;
  undefined4 uVar3;
  int *unaff_r4;
  byte *pbVar4;
  int param_11;
  undefined4 param_12;
  byte *param_13;
  int param_14;
  uint param_15;
  int param_16;

  uVar3 = 1;
  if (*unaff_r4 != 0)
  {
    param_11 = 0;
    param_12 = 0;
    param_13 = (byte *)0x0;
    param_14 = 0;
    param_16 = 0;
    pbVar1 = (byte *)unaff_r4[2];
    uVar2 = (ushort)pbVar1[1] * 0x100 + (ushort)*pbVar1;
    param_15 = (uint)uVar2;
    if ((uVar2 & 7) != 0)
    {
      uVar3 = FUN_00005e00();
      return uVar3;
    }
    param_11 = (uint)pbVar1[3] * 0x100 +
               (uint)pbVar1[5] * 0x1000000 + (uint)pbVar1[4] * 0x10000 + (uint)pbVar1[2];
    param_14 = (uint)pbVar1[9] * 0x1000000 + (uint)pbVar1[8] * 0x10000 + (uint)pbVar1[6] +
               (uint)pbVar1[7] * 0x100;
    param_16._3_1_ = 0;
    param_13 = pbVar1 + 0xc;
    param_15._1_1_ = (byte)(uVar2 >> 8);
    if ((int)((uint)param_15._1_1_ << 0x19) < 0)
    {
      pbVar4 = param_13 + pbVar1[0xb];
      param_15 = CONCAT22((ushort)pbVar4[1] * 0x100 + (ushort)*pbVar4, uVar2);
      param_16._3_1_ = pbVar4[2];
    }
    param_16 = (uint)CONCAT12(param_16._3_1_, *(undefined2 *)(pbVar1 + 10)) << 8;
    uVar3 = FUN_00005f1a((int)unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 8), &stack0x00000094,
                         *unaff_r4);
  }
  return uVar3;
}

void FUN_00005ba8(void)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  byte *pbVar4;
  int unaff_r4;
  int unaff_r5;
  byte *unaff_r6;
  int unaff_r7;
  int unaff_sl;

  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1f) < 0)
  {
    *(ushort *)(unaff_r5 + 0x32) = (ushort)unaff_r6[1] * 0x100 + (ushort)*unaff_r6;
    unaff_r6 = unaff_r6 + 2;
  }
  *(byte *)(unaff_r5 + 0x3c) = *unaff_r6;
  pbVar4 = unaff_r6 + 1;
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1e) < 0)
  {
    FUN_00005e90();
    return;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x30) << 0x1a) < 0)
  {
    *(uint *)(unaff_r5 + 0x14) =
        (uint)unaff_r6[4] * 0x1000000 + (uint)unaff_r6[3] * 0x10000 + (uint)*pbVar4 +
        (uint)unaff_r6[2] * 0x100;
    pbVar4 = unaff_r6 + 5;
  }
  uVar3 = (uint)*pbVar4;
  *(byte *)(unaff_r5 + 0x3e) = *pbVar4;
  pbVar4 = pbVar4 + 1;
  if ((((uVar3 != 0xfe) && (uVar3 != 0)) && (uVar3 != 0xfd)) && (uVar3 != 0xff))
  {
    *(byte **)(unaff_r5 + 4) = pbVar4;
    pbVar4 = pbVar4 + uVar3;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1d) < 0)
  {
    *(byte *)(unaff_r5 + 0x39) = *pbVar4;
    uVar3 = (uint) * (byte *)(unaff_r5 + 0x39);
    pbVar2 = pbVar4 + 1;
    if ((int)(uVar3 << 0x1f) < 0)
    {
      *(ushort *)(unaff_r5 + 0x34) = (ushort)pbVar4[2] * 0x100 + (ushort)pbVar4[1];
      pbVar2 = pbVar4 + 3;
    }
    pbVar4 = pbVar2;
    if ((int)(uVar3 << 0x1e) < 0)
    {
      *(ushort *)(unaff_r5 + 0x36) = (ushort)pbVar4[1] * 0x100 + (ushort)*pbVar4;
      pbVar4 = pbVar4 + 2;
    }
    if ((int)(uVar3 << 0x1d) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x42) = bVar1;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        *(byte **)(unaff_r5 + 8) = pbVar4;
        pbVar4 = pbVar4 + bVar1;
      }
    }
    if ((int)(uVar3 << 0x1c) < 0)
    {
      *(byte **)(unaff_r5 + 0xc) = pbVar4;
      bVar1 = *pbVar4;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        pbVar4 = pbVar4 + (((uint)bVar1 << 0x19) >> 0x18);
      }
    }
    if ((int)(uVar3 << 0x1b) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x3f) = bVar1;
      if (bVar1 == 2)
      {
        FUN_00005f0a();
        return;
      }
      pbVar4 = pbVar4 + bVar1 + 1;
    }
  }
  if ((*(byte *)(unaff_r5 + 0x38) & 7) == 5)
  {
    if (unaff_sl <= (int)pbVar4 - unaff_r7)
    {
      FUN_00005c82();
      return;
    }
    *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)pbVar4;
    *(byte **)(unaff_r5 + 0x10) = pbVar4;
    FUN_00005c82();
    return;
  }
  FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
  return;
}

void FUN_00005c82(void)

{
  int unaff_r4;

  FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
  return;
}

void FUN_00005dbc(undefined4 param_1, undefined *param_2, undefined4 param_3, int param_4)

{
  byte bVar1;
  uint uVar2;
  byte *pbVar3;
  int unaff_r4;
  int unaff_r5;
  byte *pbVar4;
  int unaff_r7;
  uint unaff_r8;
  int unaff_sl;

  if (param_4 == 2)
  {
    memcpy(&stack0x00000028, param_2, 8);
    *(undefined *)(unaff_r5 + 0x3a) = *(undefined *)(unaff_r7 + 0xb);
    param_2 = (undefined *)(unaff_r7 + 0xc);
  }
  *(undefined *)(unaff_r5 + 0x3b) = *param_2;
  pbVar4 = param_2 + 1;
  if ((unaff_r8 & 0x18) == 0x10)
  {
    FUN_00005ed0();
    return;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1f) < 0)
  {
    *(ushort *)(unaff_r5 + 0x32) = (ushort)(byte)param_2[2] * 0x100 + (ushort)*pbVar4;
    pbVar4 = param_2 + 3;
  }
  *(byte *)(unaff_r5 + 0x3c) = *pbVar4;
  pbVar3 = pbVar4 + 1;
  if (-1 < (int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1e))
  {
    if ((int)((uint) * (byte *)(unaff_r5 + 0x30) << 0x1a) < 0)
    {
      *(uint *)(unaff_r5 + 0x14) =
          (uint)pbVar4[4] * 0x1000000 + (uint)pbVar4[3] * 0x10000 + (uint)*pbVar3 +
          (uint)pbVar4[2] * 0x100;
      pbVar3 = pbVar4 + 5;
    }
    uVar2 = (uint)*pbVar3;
    *(byte *)(unaff_r5 + 0x3e) = *pbVar3;
    pbVar3 = pbVar3 + 1;
    if ((((uVar2 != 0xfe) && (uVar2 != 0)) && (uVar2 != 0xfd)) && (uVar2 != 0xff))
    {
      *(byte **)(unaff_r5 + 4) = pbVar3;
      pbVar3 = pbVar3 + uVar2;
    }
    if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1d) < 0)
    {
      *(byte *)(unaff_r5 + 0x39) = *pbVar3;
      uVar2 = (uint) * (byte *)(unaff_r5 + 0x39);
      pbVar4 = pbVar3 + 1;
      if ((int)(uVar2 << 0x1f) < 0)
      {
        *(ushort *)(unaff_r5 + 0x34) = (ushort)pbVar3[2] * 0x100 + (ushort)pbVar3[1];
        pbVar4 = pbVar3 + 3;
      }
      pbVar3 = pbVar4;
      if ((int)(uVar2 << 0x1e) < 0)
      {
        *(ushort *)(unaff_r5 + 0x36) = (ushort)pbVar3[1] * 0x100 + (ushort)*pbVar3;
        pbVar3 = pbVar3 + 2;
      }
      if ((int)(uVar2 << 0x1d) < 0)
      {
        bVar1 = *pbVar3;
        *(byte *)(unaff_r5 + 0x42) = bVar1;
        pbVar3 = pbVar3 + 1;
        if (bVar1 != 0)
        {
          *(byte **)(unaff_r5 + 8) = pbVar3;
          pbVar3 = pbVar3 + bVar1;
        }
      }
      if ((int)(uVar2 << 0x1c) < 0)
      {
        *(byte **)(unaff_r5 + 0xc) = pbVar3;
        bVar1 = *pbVar3;
        pbVar3 = pbVar3 + 1;
        if (bVar1 != 0)
        {
          pbVar3 = pbVar3 + (((uint)bVar1 << 0x19) >> 0x18);
        }
      }
      if ((int)(uVar2 << 0x1b) < 0)
      {
        bVar1 = *pbVar3;
        *(byte *)(unaff_r5 + 0x3f) = bVar1;
        if (bVar1 == 2)
        {
          FUN_00005f0a();
          return;
        }
        pbVar3 = pbVar3 + bVar1 + 1;
      }
    }
    if ((*(byte *)(unaff_r5 + 0x38) & 7) != 5)
    {
      FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
      return;
    }
    if ((int)pbVar3 - unaff_r7 < unaff_sl)
    {
      *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)pbVar3;
      *(byte **)(unaff_r5 + 0x10) = pbVar3;
      FUN_00005c82();
      return;
    }
    FUN_00005c82();
    return;
  }
  FUN_00005e90();
  return;
}

void FUN_00005dd6(undefined4 param_1, uint param_2, uint param_3, uint param_4)

{
  byte bVar1;
  byte *unaff_r4;
  void *unaff_r5;
  byte *pbVar2;
  byte *unaff_r7;
  int unaff_r8;
  int unaff_r9;
  uint unaff_ip;

  if (unaff_r8 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 0x18) = *(undefined *)(unaff_r9 + 10);
    unaff_r7 = (byte *)(unaff_r9 + 0xb);
    param_4 = (uint)*unaff_r4;
    unaff_ip = (uint)unaff_r4[1];
    param_2 = (uint)unaff_r4[2];
    param_3 = (uint)unaff_r4[3];
  }
  *(uint *)((int)unaff_r5 + 0xc) =
      (uint)unaff_r7[3] * 0x1000000 + (uint)unaff_r7[2] * 0x10000 + (uint)*unaff_r7 +
      (uint)unaff_r7[1] * 0x100;
  *(byte *)((int)unaff_r5 + 0x19) = unaff_r7[4];
  bVar1 = unaff_r7[5];
  *(byte *)((int)unaff_r5 + 0x1a) = bVar1;
  *(byte **)((int)unaff_r5 + 8) = unaff_r7 + 6;
  pbVar2 = unaff_r7 + 6 + bVar1;
  if ((int)((uint) * (byte *)((int)unaff_r5 + 0x15) << 0x1c) < 0)
  {
    *(ushort *)((int)unaff_r5 + 0x16) = (ushort)*pbVar2 + (ushort)pbVar2[1] * 0x100;
    *(byte *)((int)unaff_r5 + 0x1b) = pbVar2[2];
    pbVar2 = pbVar2 + 3;
  }
  if ((int)((uint) * (byte *)((int)unaff_r5 + 0x15) << 0x1e) < 0)
  {
    *(uint *)((int)unaff_r5 + 0x10) =
        (uint)pbVar2[3] * 0x1000000 + (uint)pbVar2[2] * 0x10000 + (uint)*pbVar2 +
        (uint)pbVar2[1] * 0x100;
  }
  FUN_00005f1a(unaff_r4 + 0x12, unaff_r4[0x20], unaff_r5,
               param_4 | unaff_ip << 8 | param_2 << 0x10 | param_3 << 0x18);
  return;
}

void FUN_00005e00(undefined4 param_1, uint param_2, uint param_3, uint param_4)

{
  byte bVar1;
  byte *unaff_r4;
  void *unaff_r5;
  byte *pbVar2;
  byte *unaff_r7;
  int unaff_r8;
  int unaff_r9;
  uint unaff_ip;

  if (unaff_r8 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 0x14) = *(undefined *)(unaff_r9 + 10);
    unaff_r7 = (byte *)(unaff_r9 + 0xb);
    param_4 = (uint)*unaff_r4;
    unaff_ip = (uint)unaff_r4[1];
    param_2 = (uint)unaff_r4[2];
    param_3 = (uint)unaff_r4[3];
  }
  *(uint *)((int)unaff_r5 + 0xc) =
      (uint)unaff_r7[3] * 0x1000000 + (uint)unaff_r7[2] * 0x10000 + (uint)*unaff_r7 +
      (uint)unaff_r7[1] * 0x100;
  *(byte *)((int)unaff_r5 + 0x15) = unaff_r7[4];
  bVar1 = unaff_r7[5];
  *(byte *)((int)unaff_r5 + 0x16) = bVar1;
  *(byte **)((int)unaff_r5 + 8) = unaff_r7 + 6;
  if ((int)((uint) * (byte *)((int)unaff_r5 + 0x11) << 0x19) < 0)
  {
    pbVar2 = unaff_r7 + 6 + bVar1;
    *(ushort *)((int)unaff_r5 + 0x12) = (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2;
    *(byte *)((int)unaff_r5 + 0x17) = pbVar2[2];
  }
  FUN_00005f1a(unaff_r4 + 0x12, unaff_r4[0x20], unaff_r5,
               param_4 | unaff_ip << 8 | param_2 << 0x10 | param_3 << 0x18);
  return;
}

void FUN_00005e50(undefined4 param_1, int param_2, int param_3)

{
  int unaff_r4;
  int unaff_r5;

  if (param_2 == 8)
  {
    *(undefined *)(unaff_r5 + 10) = *(undefined *)(param_3 + 1);
  }
  FUN_00005f1c(unaff_r4 + 0x12, 10, unaff_r5);
  return;
}

void FUN_00005e5c(void)

{
  int extraout_r3;
  int unaff_r5;
  void *unaff_r7;
  int unaff_sl;

  memcpy(&stack0x0000004c, unaff_r7, 8);
  *(ushort *)(unaff_r5 + 0x28) =
      (ushort) * (byte *)((int)unaff_r7 + 9) * 0x100 + (ushort) * (byte *)((int)unaff_r7 + 8);
  FUN_000055b0();
  if (unaff_sl <= extraout_r3 - ((int)unaff_r7 + 10))
  {
    FUN_00005c82();
    return;
  }
  *(char *)(unaff_r5 + 0x43) = ((char)((int)unaff_r7 + 10) + (char)unaff_sl) - (char)extraout_r3;
  *(int *)(unaff_r5 + 0x10) = extraout_r3;
  FUN_00005c82();
  return;
}

void FUN_00005e8a(undefined4 param_1, undefined4 param_2, int param_3)

{
  int unaff_r5;

  *(undefined *)(unaff_r5 + 10) = *(undefined *)(param_3 + 1);
  FUN_000057e0();
  return;
}

void FUN_00005e90(void)

{
  byte bVar1;
  byte *pbVar2;
  uint uVar3;
  byte *pbVar4;
  int in_r3;
  int unaff_r4;
  int unaff_r5;
  int unaff_r6;
  int unaff_r7;
  int unaff_sl;

  *(undefined *)(unaff_r5 + 0x3d) = *(undefined *)(unaff_r6 + 1);
  *(uint *)(unaff_r5 + 0x14) =
      (uint) * (byte *)(in_r3 + 4) * 0x1000000 + (uint) * (byte *)(in_r3 + 3) * 0x10000 +
      (uint) * (byte *)(in_r3 + 1) + (uint) * (byte *)(in_r3 + 2) * 0x100;
  memcpy(&stack0x00000018, (void *)(unaff_r6 + 6), 0x10);
  uVar3 = (uint) * (byte *)(unaff_r6 + 0x16);
  *(byte *)(unaff_r5 + 0x3e) = *(byte *)(unaff_r6 + 0x16);
  pbVar4 = (byte *)(unaff_r6 + 0x17);
  if ((((uVar3 != 0xfe) && (uVar3 != 0)) && (uVar3 != 0xfd)) && (uVar3 != 0xff))
  {
    *(byte **)(unaff_r5 + 4) = pbVar4;
    pbVar4 = pbVar4 + uVar3;
  }
  if ((int)((uint) * (byte *)(unaff_r5 + 0x31) << 0x1d) < 0)
  {
    *(byte *)(unaff_r5 + 0x39) = *pbVar4;
    uVar3 = (uint) * (byte *)(unaff_r5 + 0x39);
    pbVar2 = pbVar4 + 1;
    if ((int)(uVar3 << 0x1f) < 0)
    {
      *(ushort *)(unaff_r5 + 0x34) = (ushort)pbVar4[2] * 0x100 + (ushort)pbVar4[1];
      pbVar2 = pbVar4 + 3;
    }
    pbVar4 = pbVar2;
    if ((int)(uVar3 << 0x1e) < 0)
    {
      *(ushort *)(unaff_r5 + 0x36) = (ushort)pbVar4[1] * 0x100 + (ushort)*pbVar4;
      pbVar4 = pbVar4 + 2;
    }
    if ((int)(uVar3 << 0x1d) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x42) = bVar1;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        *(byte **)(unaff_r5 + 8) = pbVar4;
        pbVar4 = pbVar4 + bVar1;
      }
    }
    if ((int)(uVar3 << 0x1c) < 0)
    {
      *(byte **)(unaff_r5 + 0xc) = pbVar4;
      bVar1 = *pbVar4;
      pbVar4 = pbVar4 + 1;
      if (bVar1 != 0)
      {
        pbVar4 = pbVar4 + (((uint)bVar1 << 0x19) >> 0x18);
      }
    }
    if ((int)(uVar3 << 0x1b) < 0)
    {
      bVar1 = *pbVar4;
      *(byte *)(unaff_r5 + 0x3f) = bVar1;
      if (bVar1 == 2)
      {
        FUN_00005f0a();
        return;
      }
      pbVar4 = pbVar4 + bVar1 + 1;
    }
  }
  if ((*(byte *)(unaff_r5 + 0x38) & 7) == 5)
  {
    if (unaff_sl <= (int)pbVar4 - unaff_r7)
    {
      FUN_00005c82();
      return;
    }
    *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)pbVar4;
    *(byte **)(unaff_r5 + 0x10) = pbVar4;
    FUN_00005c82();
    return;
  }
  FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
  return;
}

void FUN_00005ebe(undefined4 param_1, void *param_2)

{
  void *pvVar1;
  void *unaff_r5;
  int unaff_r6;

  pvVar1 = memcpy(unaff_r5, param_2, 8);
  *(undefined *)((int)unaff_r5 + 0x10) = *(undefined *)(unaff_r6 + 0xc);
  FUN_0000575c(pvVar1, unaff_r6 + 0xd);
  return;
}

void FUN_00005ed0(undefined4 param_1, int param_2)

{
  if (*(char *)(param_2 + 1) == '\0')
  {
    FUN_00005ba8();
    return;
  }
  FUN_00005ba8();
  return;
}

void FUN_00005ee4(void)

{
  int extraout_r3;
  int unaff_r4;
  void *unaff_r5;
  void *unaff_r6;
  void *unaff_r7;

  memcpy(&stack0x0000005c, unaff_r6, 0x10);
  FUN_000055e6();
  if (extraout_r3 == 2)
  {
    memcpy(unaff_r5, unaff_r7, 8);
    *(undefined *)((int)unaff_r5 + 9) = *(undefined *)((int)unaff_r7 + 8);
  }
  FUN_00005f1c(unaff_r4 + 0x12, 10, unaff_r5);
  return;
}

void FUN_00005f0a(undefined4 param_1, int param_2, undefined4 param_3, int param_4)

{
  int unaff_r4;
  int unaff_r5;
  int unaff_r7;
  int unaff_sl;

  *(undefined *)(unaff_r5 + 0x40) = *(undefined *)(param_4 + 1);
  *(undefined *)(unaff_r5 + 0x41) = *(undefined *)(param_2 + 1);
  param_2 = param_2 + 2;
  if ((*(byte *)(unaff_r5 + 0x38) & 7) != 5)
  {
    FUN_00005f1a(unaff_r4 + 0x12, *(undefined *)(unaff_r4 + 0x20));
    return;
  }
  if (unaff_sl <= param_2 - unaff_r7)
  {
    FUN_00005c82();
    return;
  }
  *(char *)(unaff_r5 + 0x43) = ((char)unaff_r7 + (char)unaff_sl) - (char)param_2;
  *(int *)(unaff_r5 + 0x10) = param_2;
  FUN_00005c82();
  return;
}

void FUN_00005f1a(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r6;
  code *unaff_r7;
  cluster_forAppCb_t in_stack_00000000;

  (*in_r3)();
  (*unaff_r6)();
  endpoint = (*unaff_r7)();
  zcl_registerCluster(endpoint, 0x21, manuCode, attrNum, pAttrTbl, zcl_gp_cmdHandler, in_stack_00000000);
  return;
}

void FUN_00005f1c(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r6;
  code *unaff_r7;
  cluster_forAppCb_t in_stack_00000000;

  (*unaff_r6)();
  endpoint = (*unaff_r7)();
  zcl_registerCluster(endpoint, 0x21, manuCode, attrNum, pAttrTbl, zcl_gp_cmdHandler, in_stack_00000000);
  return;
}

void FUN_00005f1e(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  zclAttrInfo_t *pAttrTbl;
  code *unaff_r7;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*unaff_r7)();
  zcl_registerCluster(endpoint, 0x21, manuCode, attrNum, pAttrTbl, zcl_gp_cmdHandler, in_stack_00000000);
  return;
}

status_t zcl_gp_register(u8 endpoint, u16 manuCode, u8 arrtNum, zclAttrInfo_t *attrTbl,
                         cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x21, manuCode, arrtNum, attrTbl, zcl_gp_cmdHandler, cb);
  return sVar1;
}

status_t zcl_gp_notificationCmd(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                zcl_gp_notificationCmd_t *pCmd)

{
  ushort size;
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  short sVar3;

  sVar3 = 0xf;
  if (((*(byte *)&pCmd->options & 7) != 0) && (sVar3 = 0x14, (*(byte *)&pCmd->options & 7) != 2))
  {
    sVar3 = 0xb;
  }
  size = sVar3 + (ushort)pCmd->payloadLen & 0xff;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = *(u8 *)&pCmd->options;
    cmdPld[1] = *(u8 *)((int)&pCmd->options + 1);
    puVar2 = cmdPld + 2;
    if ((*(byte *)&pCmd->options & 7) == 0)
    {
      cmdPld[2] = (pCmd->gpdId).gpdIeeeAddr[0];
      cmdPld[3] = (pCmd->gpdId).gpdIeeeAddr[1];
      cmdPld[4] = (pCmd->gpdId).gpdIeeeAddr[2];
      cmdPld[5] = (pCmd->gpdId).gpdIeeeAddr[3];
      puVar2 = cmdPld + 6;
    }
    else if ((*(byte *)&pCmd->options & 7) == 2)
    {
      memcpy(puVar2, pCmd, 8);
      cmdPld[10] = pCmd->endpoint;
      puVar2 = cmdPld + 0xb;
    }
    *puVar2 = *(u8 *)&pCmd->gpdSecFrameCnt;
    puVar2[1] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 1);
    puVar2[2] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 2);
    puVar2[3] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 3);
    puVar2[4] = pCmd->gpdCmdID;
    puVar2[5] = pCmd->payloadLen;
    puVar2 = puVar2 + 6;
    if (pCmd->payloadLen != 0)
    {
      memcpy(puVar2, pCmd->pGpdCmdPayload, (uint)pCmd->payloadLen);
      puVar2 = puVar2 + pCmd->payloadLen;
    }
    if ((int)((uint) * (byte *)((int)&pCmd->options + 1) << 0x19) < 0)
    {
      *puVar2 = *(u8 *)&pCmd->gppShortAddr;
      puVar2[1] = *(u8 *)((int)&pCmd->gppShortAddr + 1);
      *(gpGppGpdLink_t *)(puVar2 + 2) = pCmd->gppGpdLink;
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x21, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}

status_t zcl_gp_commissioningNotificationCmd(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                             zcl_gp_commissioningNotificationCmd_t *pCmd)

{
  ushort size;
  status_t sVar1;
  u8 *cmdPld;
  u8 *puVar2;
  short sVar3;

  sVar3 = 0xf;
  if (((*(byte *)&pCmd->options & 7) != 0) && (sVar3 = 0x14, (*(byte *)&pCmd->options & 7) != 2))
  {
    sVar3 = 0xb;
  }
  if ((int)((uint) * (byte *)((int)&pCmd->options + 1) << 0x1e) < 0)
  {
    sVar3 = sVar3 + 4;
  }
  size = sVar3 + (ushort)pCmd->payloadLen & 0xff;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = *(u8 *)&pCmd->options;
    cmdPld[1] = *(u8 *)((int)&pCmd->options + 1);
    puVar2 = cmdPld + 2;
    if ((*(byte *)&pCmd->options & 7) == 0)
    {
      cmdPld[2] = (pCmd->gpdId).gpdIeeeAddr[0];
      cmdPld[3] = (pCmd->gpdId).gpdIeeeAddr[1];
      cmdPld[4] = (pCmd->gpdId).gpdIeeeAddr[2];
      cmdPld[5] = (pCmd->gpdId).gpdIeeeAddr[3];
      puVar2 = cmdPld + 6;
    }
    else if ((*(byte *)&pCmd->options & 7) == 2)
    {
      memcpy(puVar2, pCmd, 8);
      cmdPld[10] = pCmd->endpoint;
      puVar2 = cmdPld + 0xb;
    }
    *puVar2 = *(u8 *)&pCmd->gpdSecFrameCnt;
    puVar2[1] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 1);
    puVar2[2] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 2);
    puVar2[3] = *(u8 *)((int)&pCmd->gpdSecFrameCnt + 3);
    puVar2[4] = pCmd->gpdCmdID;
    puVar2[5] = pCmd->payloadLen;
    puVar2 = puVar2 + 6;
    if (pCmd->payloadLen != 0)
    {
      memcpy(puVar2, pCmd->pGpdCmdPayload, (uint)pCmd->payloadLen);
      puVar2 = puVar2 + pCmd->payloadLen;
    }
    *puVar2 = *(u8 *)&pCmd->gppShortAddr;
    puVar2[1] = *(u8 *)((int)&pCmd->gppShortAddr + 1);
    *(gpGppGpdLink_t *)(puVar2 + 2) = pCmd->gppGpdLink;
    if ((int)((uint) * (byte *)((int)&pCmd->options + 1) << 0x1e) < 0)
    {
      puVar2[3] = *(u8 *)&pCmd->mic;
      puVar2[4] = *(u8 *)((int)&pCmd->mic + 1);
      puVar2[5] = *(u8 *)((int)&pCmd->mic + 2);
      puVar2[6] = *(u8 *)((int)&pCmd->mic + 3);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x21, '\x04', '\x01', '\0', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}

status_t zcl_gp_proxyTableRspCmd(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                 zcl_gp_proxyTabRspCmd_t *pCmd)

{
  ushort size;
  status_t sVar1;
  u8 *cmdPld;

  size = pCmd->entriesLen + 4 & 0xff;
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = pCmd->status;
    cmdPld[1] = pCmd->totalTabEntries;
    cmdPld[2] = pCmd->startIdx;
    cmdPld[3] = pCmd->entriesCnt;
    if (pCmd->entriesLen != 0)
    {
      memcpy(cmdPld + 4, pCmd->proxyTabEntry, (uint)pCmd->entriesLen);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 0x21, '\v', '\x01', '\0', disableDefaultRsp, 0, seqNo, size, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}

status_t zcl_group_register(u8 endpoint, u16 manuCode, u8 arrtNum, zclAttrInfo_t *attrTbl,
                            cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 4, manuCode, arrtNum, attrTbl, zcl_group_cmdHandler, cb);
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_group_add(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 groupId,
                       u8 *groupName)

{
  status_t sVar1;
  byte bVar2;
  short sVar3;
  undefined2 local_34;
  byte bStack_32;
  undefined auStack_31[17];

  local_34 = groupId;
  if (groupName == (u8 *)0x0)
  {
    bStack_32 = 0;
    sVar3 = (short)auStack_31;
  }
  else
  {
    bVar2 = *groupName;
    if (0xf < bVar2)
    {
      bVar2 = 0xf;
    }
    bStack_32 = bVar2;
    memcpy(auStack_31, groupName + 1, (uint)bVar2);
    sVar3 = (short)auStack_31 + (ushort)bVar2;
  }
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo,
                      sVar3 - (short)&local_34, (u8 *)&local_34);
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_group_addGroupRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 groupId,
                               u8 stauts)

{
  status_t sVar1;
  u8 local_14;
  undefined2 uStack_13;

  local_14 = stauts;
  uStack_13 = groupId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\0', '\x01', '\x01', disableDefaultRsp, 0, seqNo, 3, &local_14);
  return sVar1;
}

status_t zcl_group_viewGroupRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                zcl_viewGroupRsp_t *pViewGroupRsp)

{
  byte *pbVar1;
  status_t sVar2;
  byte bVar3;
  short sVar4;
  u8 local_34;
  undefined uStack_33;
  undefined uStack_32;
  byte bStack_31;
  undefined auStack_30[16];

  local_34 = pViewGroupRsp->status;
  uStack_33 = (undefined)pViewGroupRsp->groupId;
  uStack_32 = (undefined)(pViewGroupRsp->groupId >> 8);
  pbVar1 = pViewGroupRsp->pGroupName;
  if (pbVar1 == (byte *)0x0)
  {
    bStack_31 = 0;
    sVar4 = (short)auStack_30;
  }
  else
  {
    bVar3 = *pbVar1;
    if (0xf < bVar3)
    {
      bVar3 = 0xf;
    }
    bStack_31 = bVar3;
    memcpy(auStack_30, pbVar1 + 1, (uint)bVar3);
    sVar4 = (short)auStack_30 + (ushort)bVar3;
  }
  sVar2 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\x01', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      sVar4 - (short)&local_34, &local_34);
  return sVar2;
}

status_t zcl_group_getGroupMembershipRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 capacity,
                                         u8 groupCnt, u16 *groupList)

{
  status_t sVar1;

  *(u8 *)groupList = capacity;
  *(u8 *)((int)groupList + 1) = groupCnt;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\x02', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      (groupCnt + 1) * 2, (u8 *)groupList);
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_group_removeGroupRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 groupId,
                                  u8 stauts)

{
  status_t sVar1;
  u8 local_14;
  undefined2 uStack_13;

  local_14 = stauts;
  uStack_13 = groupId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 4, '\x03', '\x01', '\x01', disableDefaultRsp, 0, seqNo, 3, &local_14);
  return sVar1;
}

u8 zcl_group_serverCmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  u8 uVar2;

  uVar1 = (pInMsg->hdr).cmd;
  if (uVar1 == '\x01')
  {
    uVar2 = '\0';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAE();
      uVar2 = '\0';
    }
  }
  else if (uVar1 == '\0')
  {
    uVar2 = '\0';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAE();
    }
  }
  else if (uVar1 == '\x02')
  {
    uVar2 = '\0';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      FUNAAAAE();
    }
  }
  else
  {
    uVar2 = 0x81;
    if ((uVar1 == '\x03') && (uVar2 = '\0', pInMsg->clusterAppCb != ll_reset))
    {
      FUNAAAAE();
    }
  }
  return uVar2;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 FUNAAAAE(void)

{
  u8 uVar1;
  apsdeDataInd_t *paVar2;
  u8 uVar3;
  u8 uVar4;
  u8 uVar5;
  status_t sVar6;
  aps_status_t aVar7;
  zclIncoming_t *pInMsg;
  aps_group_tbl_ent_t *paVar8;
  u16 groupAddr;
  code *in_r3;
  uint uVar9;
  uint uVar10;
  byte *pbVar11;
  char cVar12;
  uint uStack_98;
  undefined4 uStack_94;
  uint uStack_90;
  undefined4 uStack_8c;
  undefined2 uStack_88;
  undefined4 uStack_84;
  undefined4 uStack_80;
  undefined4 uStack_7c;
  undefined4 uStack_78;
  uint uStack_70;
  undefined4 uStack_6c;
  uint uStack_68;
  undefined4 uStack_64;
  undefined2 uStack_60;
  uint uStack_5c;
  undefined4 uStack_58;
  uint uStack_54;
  undefined4 uStack_50;
  undefined2 uStack_4c;
  uint uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  undefined4 uStack_3c;
  undefined2 uStack_38;
  undefined8 uStack_34;
  aps_delete_group_req_t aStack_2c;
  u16 uStack_28;
  undefined2 uStack_26;

  pInMsg = (zclIncoming_t *)(*in_r3)();
  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    uVar4 = zcl_group_serverCmdHandler(pInMsg);
  }
  else
  {
    uVar4 = 0x81;
    switch ((pInMsg->hdr).cmd)
    {
    case '\0':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      aStack_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
      aStack_2c.ep = uVar1;
      aVar7 = aps_me_group_add_req(&aStack_2c);
      uVar4 = 0x8a;
      if ((aVar7 != APS_STATUS_DUPLICATE_ENTRY) && (uVar4 = '\0', aVar7 == APS_STATUS_TABLE_FULL))
      {
        uVar4 = 0x89;
      }
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uStack_6c = 0;
        uStack_60 = 0;
        uStack_70 = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_64 = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_68 = (uint)(paVar2->indInfo).profile_id;
        zcl_group_addGroupRsp(uVar1, (epInfo_t *)&uStack_70, '\x01', (pInMsg->hdr).seqNum, aStack_2c.group_addr,
                              uVar4);
        uVar4 = 0xff;
      }
      break;
    case '\x01':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      uVar4 = '\0';
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uVar9 = (uint)pInMsg->pData[1] * 0x100 + (uint)*pInMsg->pData & 0xffff;
        uStack_34._0_4_ = (uint)uStack_34 & 0xff0000ff | uVar9 << 8;
        cVar12 = '\0';
        paVar8 = aps_group_search((u16)uVar9, uVar1);
        uStack_34._4_4_ = (uint)uStack_34._7_1_ << 0x18;
        uStack_34._0_4_ =
            ((uint)uStack_34 & 0xffffff00 | (uint)(byte) ~(~(byte)paVar8 + (byte)paVar8 + cVar12)) &
            0xffff8b;
        uStack_58 = 0;
        uStack_4c = 0;
        uStack_5c = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_50 = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_54 = (uint)(paVar2->indInfo).profile_id;
        zcl_group_viewGroupRsp(uVar1, (epInfo_t *)&uStack_5c, '\x01', (pInMsg->hdr).seqNum,
                               (zcl_viewGroupRsp_t *)&uStack_34);
        uVar4 = 0xff;
      }
      break;
    case '\x02':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      uVar4 = '\0';
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uVar4 = *pInMsg->pData;
        uStack_26 = (ushort)uStack_26._1_1_ << 8;
        if (uVar4 != '\0')
        {
          pbVar11 = pInMsg->pData + 1;
          cVar12 = uVar4 + 0xff;
          do
          {
            groupAddr = (ushort)pbVar11[1] * 0x100 + (ushort)*pbVar11;
            paVar8 = aps_group_search(groupAddr, uVar1);
            if (paVar8 != (aps_group_tbl_ent_t *)0x0)
            {
              *(u16 *)((int)&uStack_84 + (uint)(byte)uStack_26 * 2 + 2) = groupAddr;
              uVar9 = (byte)uStack_26 + 1;
              uStack_26 = uStack_26 & 0xff00 | (ushort)(byte)(uVar9 * 0x1000000 >> 0x18);
              if ((uint)APS_GROUP_TABLE_SIZE <= (uVar9 & 0xff))
                goto LAB_00006810;
            }
            if (cVar12 == '\0')
              goto LAB_00006810;
            pbVar11 = pbVar11 + 2;
            cVar12 = cVar12 + -2;
          } while (true);
        }
        aps_group_list_get((u8 *)&uStack_26, (u16 *)((int)&uStack_84 + 2));
      LAB_00006810:
        uVar3 = APS_GROUP_TABLE_SIZE;
        uStack_94 = 0;
        uStack_88 = 0;
        uStack_98 = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_8c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_90 = (uint)(paVar2->indInfo).profile_id;
        uVar4 = (pInMsg->hdr).seqNum;
        uVar5 = aps_group_entry_num_get();
        zcl_group_getGroupMembershipRsp(uVar1, (epInfo_t *)&uStack_98, '\x01', uVar4, uVar3 - uVar5, (byte)uStack_26,
                                        (u16 *)&uStack_84);
        uVar4 = 0xff;
      }
      break;
    case '\x03':
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      aStack_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
      aStack_2c.ep = uVar1;
      zcl_scene_removeAllSceneEntry(uVar1, aStack_2c.group_addr, '\x01');
      aVar7 = aps_me_group_delete_req(&aStack_2c);
      uVar4 = '\0';
      if (aVar7 == APS_STATUS_INVALID_GROUP)
      {
        uVar4 = 0x8b;
      }
      if (((paVar2->indInfo).dst_addr < 0xfffc) && ((paVar2->indInfo).dst_addr_mode != '\x01'))
      {
        uStack_44 = 0;
        uStack_38 = 0;
        uStack_48 = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_3c = CONCAT13((paVar2->indInfo).src_ep, 0x20000);
        uStack_40 = (uint)(paVar2->indInfo).profile_id;
        zcl_group_removeGroupRsp(uVar1, (epInfo_t *)&uStack_48, '\x01', (pInMsg->hdr).seqNum, aStack_2c.group_addr,
                                 uVar4);
        uVar4 = 0xff;
      }
      break;
    case '\x04':
      uVar4 = (pInMsg->msg->indInfo).dst_ep;
      uStack_26 = (ushort)uStack_26._1_1_ << 8;
      uStack_84 = 0;
      uStack_80 = 0;
      uStack_7c = 0;
      uStack_78 = 0;
      aps_group_list_get((u8 *)&uStack_26, (u16 *)&uStack_84);
      uVar9 = (uint)(byte)uStack_26;
      if (uVar9 != 0)
      {
        uVar10 = 0;
        do
        {
          zcl_scene_removeAllSceneEntry(uVar4, *(u16 *)((int)&uStack_84 + uVar10 * 2), uVar9 <= uVar10);
          uVar10 = uVar10 + 1 & 0xff;
          uVar9 = (uint)(byte)uStack_26;
        } while (uVar10 < uVar9);
      }
      aps_me_group_delete_all_req(uVar4);
      uVar4 = '\0';
      break;
    case '\x05':
      paVar2 = pInMsg->msg;
      uStack_26 = 0;
      uStack_28 = 0;
      sVar6 = zcl_getAttrVal((paVar2->indInfo).dst_ep, 3, 0, &uStack_28, (u8 *)&uStack_26);
      uVar4 = '\0';
      if ((sVar6 == '\0') && (uStack_26 != 0))
      {
        aStack_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
        aStack_2c.ep = (paVar2->indInfo).dst_ep;
        aVar7 = aps_me_group_add_req(&aStack_2c);
        uVar4 = 0x8a;
        if ((aVar7 != APS_STATUS_DUPLICATE_ENTRY) && (uVar4 = '\0', aVar7 == APS_STATUS_TABLE_FULL))
        {
          uVar4 = 0x89;
        }
      }
    }
  }
  return uVar4;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_group_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  u8 uVar2;
  apsdeDataInd_t *paVar3;
  u8 uVar4;
  u8 uVar5;
  u8 uVar6;
  status_t sVar7;
  aps_status_t aVar8;
  aps_group_tbl_ent_t *paVar9;
  u16 groupAddr;
  uint uVar10;
  uint uVar11;
  byte *pbVar12;
  char cVar13;
  uint local_98;
  undefined4 uStack_94;
  uint uStack_90;
  undefined4 uStack_8c;
  undefined2 local_88;
  undefined4 local_84;
  undefined4 uStack_80;
  undefined4 uStack_7c;
  undefined4 uStack_78;
  uint local_70;
  undefined4 uStack_6c;
  uint uStack_68;
  undefined4 uStack_64;
  undefined2 local_60;
  uint local_5c;
  undefined4 uStack_58;
  uint uStack_54;
  undefined4 uStack_50;
  undefined2 local_4c;
  uint local_48;
  undefined4 uStack_44;
  uint uStack_40;
  undefined4 uStack_3c;
  undefined2 local_38;
  undefined8 local_34;
  aps_delete_group_req_t local_2c;
  u16 local_28;
  undefined2 local_26;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    uVar5 = zcl_group_serverCmdHandler(pInMsg);
  }
  else
  {
    bVar1 = (pInMsg->hdr).cmd;
    uVar5 = 0x81;
    if (bVar1 < 6)
    {
      switch (bVar1)
      {
      case 0:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        local_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
        local_2c.ep = uVar2;
        aVar8 = aps_me_group_add_req(&local_2c);
        uVar5 = 0x8a;
        if ((aVar8 != APS_STATUS_DUPLICATE_ENTRY) && (uVar5 = '\0', aVar8 == APS_STATUS_TABLE_FULL))
        {
          uVar5 = 0x89;
        }
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uStack_6c = 0;
          local_60 = 0;
          local_70 = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_64 = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_68 = (uint)(paVar3->indInfo).profile_id;
          zcl_group_addGroupRsp(uVar2, (epInfo_t *)&local_70, '\x01', (pInMsg->hdr).seqNum, local_2c.group_addr,
                                uVar5);
          uVar5 = 0xff;
        }
        break;
      case 1:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        uVar5 = '\0';
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uVar10 = (uint)pInMsg->pData[1] * 0x100 + (uint)*pInMsg->pData & 0xffff;
          local_34._0_4_ = (uint)local_34 & 0xff0000ff | uVar10 << 8;
          cVar13 = '\0';
          paVar9 = aps_group_search((u16)uVar10, uVar2);
          local_34._4_4_ = (uint)local_34._7_1_ << 0x18;
          local_34._0_4_ =
              ((uint)local_34 & 0xffffff00 | (uint)(byte) ~(~(byte)paVar9 + (byte)paVar9 + cVar13)) & 0xffff8b;
          uStack_58 = 0;
          local_4c = 0;
          local_5c = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_50 = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_54 = (uint)(paVar3->indInfo).profile_id;
          zcl_group_viewGroupRsp(uVar2, (epInfo_t *)&local_5c, '\x01', (pInMsg->hdr).seqNum,
                                 (zcl_viewGroupRsp_t *)&local_34);
          uVar5 = 0xff;
        }
        break;
      case 2:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        uVar5 = '\0';
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uVar5 = *pInMsg->pData;
          local_26 = (ushort)local_26._1_1_ << 8;
          if (uVar5 != '\0')
          {
            pbVar12 = pInMsg->pData + 1;
            cVar13 = uVar5 + 0xff;
            do
            {
              groupAddr = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
              paVar9 = aps_group_search(groupAddr, uVar2);
              if (paVar9 != (aps_group_tbl_ent_t *)0x0)
              {
                *(u16 *)((int)&local_84 + (uint)(byte)local_26 * 2 + 2) = groupAddr;
                uVar10 = (byte)local_26 + 1;
                local_26 = local_26 & 0xff00 | (ushort)(byte)(uVar10 * 0x1000000 >> 0x18);
                if ((uint)APS_GROUP_TABLE_SIZE <= (uVar10 & 0xff))
                  goto LAB_00006810;
              }
              if (cVar13 == '\0')
                goto LAB_00006810;
              pbVar12 = pbVar12 + 2;
              cVar13 = cVar13 + -2;
            } while (true);
          }
          aps_group_list_get((u8 *)&local_26, (u16 *)((int)&local_84 + 2));
        LAB_00006810:
          uVar4 = APS_GROUP_TABLE_SIZE;
          uStack_94 = 0;
          local_88 = 0;
          local_98 = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_8c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_90 = (uint)(paVar3->indInfo).profile_id;
          uVar5 = (pInMsg->hdr).seqNum;
          uVar6 = aps_group_entry_num_get();
          zcl_group_getGroupMembershipRsp(uVar2, (epInfo_t *)&local_98, '\x01', uVar5, uVar4 - uVar6, (byte)local_26,
                                          (u16 *)&local_84);
          uVar5 = 0xff;
        }
        break;
      case 3:
        paVar3 = pInMsg->msg;
        uVar2 = (paVar3->indInfo).dst_ep;
        local_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
        local_2c.ep = uVar2;
        zcl_scene_removeAllSceneEntry(uVar2, local_2c.group_addr, '\x01');
        aVar8 = aps_me_group_delete_req(&local_2c);
        uVar5 = '\0';
        if (aVar8 == APS_STATUS_INVALID_GROUP)
        {
          uVar5 = 0x8b;
        }
        if (((paVar3->indInfo).dst_addr < 0xfffc) && ((paVar3->indInfo).dst_addr_mode != '\x01'))
        {
          uStack_44 = 0;
          local_38 = 0;
          local_48 = (uint)(paVar3->indInfo).field_10.src_short_addr;
          uStack_3c = CONCAT13((paVar3->indInfo).src_ep, 0x20000);
          uStack_40 = (uint)(paVar3->indInfo).profile_id;
          zcl_group_removeGroupRsp(uVar2, (epInfo_t *)&local_48, '\x01', (pInMsg->hdr).seqNum, local_2c.group_addr,
                                   uVar5);
          uVar5 = 0xff;
        }
        break;
      case 4:
        uVar5 = (pInMsg->msg->indInfo).dst_ep;
        local_26 = (ushort)local_26._1_1_ << 8;
        local_84 = 0;
        uStack_80 = 0;
        uStack_7c = 0;
        uStack_78 = 0;
        aps_group_list_get((u8 *)&local_26, (u16 *)&local_84);
        uVar10 = (uint)(byte)local_26;
        if (uVar10 != 0)
        {
          uVar11 = 0;
          do
          {
            zcl_scene_removeAllSceneEntry(uVar5, *(u16 *)((int)&local_84 + uVar11 * 2), uVar10 <= uVar11);
            uVar11 = uVar11 + 1 & 0xff;
            uVar10 = (uint)(byte)local_26;
          } while (uVar11 < uVar10);
        }
        aps_me_group_delete_all_req(uVar5);
        uVar5 = '\0';
        break;
      case 5:
        paVar3 = pInMsg->msg;
        local_26 = 0;
        local_28 = 0;
        sVar7 = zcl_getAttrVal((paVar3->indInfo).dst_ep, 3, 0, &local_28, (u8 *)&local_26);
        uVar5 = '\0';
        if ((sVar7 == '\0') && (local_26 != 0))
        {
          local_2c.group_addr = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
          local_2c.ep = (paVar3->indInfo).dst_ep;
          aVar8 = aps_me_group_add_req(&local_2c);
          uVar5 = 0x8a;
          if ((aVar8 != APS_STATUS_DUPLICATE_ENTRY) &&
              (uVar5 = '\0', aVar8 == APS_STATUS_TABLE_FULL))
          {
            uVar5 = 0x89;
          }
        }
      }
    }
  }
  return uVar5;
}

status_t zcl_identify_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 3, manuCode, attrNum, attrTbl, zcl_identify_cmdHandler, cb);
  return sVar1;
}

status_t zcl_identify_identifyQuery(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo)

{
  status_t sVar1;

  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 3, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}

status_t zcl_identify_identifyQueryRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u16 timeout)

{
  status_t sVar1;
  u16 local_10[4];

  local_10[0] = timeout;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 3, '\0', '\x01', '\x01', disableDefaultRsp, 0, seqNo, 2,
                      (u8 *)local_10);
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_identify_cmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  byte bVar4;
  uint local_3c;
  uint uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  undefined2 local_2c;
  ushort local_28;
  ushort local_26;
  ushort local_24[2];
  short local_20;

  bVar4 = (pInMsg->hdr).frmCtrl.byte;
  local_24[0] = bVar4 & 8;
  if ((bVar4 & 8) == 0)
  {
    uVar1 = (pInMsg->hdr).cmd;
    if (uVar1 == '\x01')
    {
      paVar2 = pInMsg->msg;
      uVar1 = (paVar2->indInfo).dst_ep;
      local_28 = local_24[0];
      local_26 = local_24[0];
      bVar4 = zcl_getAttrVal(uVar1, (paVar2->indInfo).cluster_id, 0, &local_28, (u8 *)&local_26);
      if ((bVar4 == 0) && (local_26 != 0))
      {
        local_3c = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_30 = CONCAT13((paVar2->indInfo).src_ep, CONCAT12(2, (ushort)bVar4));
        uStack_34 = (uint)(paVar2->indInfo).profile_id;
        local_2c = 4;
        if (((pInMsg->msg->indInfo).security_status & SECURITY_IN_APSLAYER) != 0)
        {
          local_2c = 5;
        }
        uStack_38 = (uint)bVar4;
        zcl_identify_identifyQueryRsp(uVar1, (epInfo_t *)&local_3c, '\x01', (pInMsg->hdr).seqNum, local_26);
        return 0xff;
      }
    }
    else if (uVar1 == '\0')
    {
      local_24[0] = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
    }
    else
    {
      if (uVar1 != '@')
        goto LAB_00006b70;
      local_24[0] = *(ushort *)pInMsg->pData;
    }
    sVar3 = '\x01';
    if (pInMsg->clusterAppCb != ll_reset)
    {
      sVar3 = FUN_00006c80(&pInMsg->addrInfo, (pInMsg->hdr).cmd, local_24);
    }
  }
  else
  {
    if ((pInMsg->hdr).cmd == '\0')
    {
      local_20 = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar3 = FUN_00006c80(&pInMsg->addrInfo, 0);
      return sVar3;
    }
  LAB_00006b70:
    sVar3 = 0x81;
  }
  return sVar3;
}

status_t FUN_00006c80(void)

{
  u8 srcEp;
  status_t sVar1;
  epInfo_t *pDstEpInfo;
  u8 disableDefaultRsp;
  u8 seqNo;
  code *in_r3;

  srcEp = (*in_r3)();
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 6, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}

status_t zcl_onOff_on(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo)

{
  status_t sVar1;

  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 6, '\x01', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}

status_t zcl_onOff_off(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo)

{
  status_t sVar1;

  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 6, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, 0, (u8 *)0x0);
  return sVar1;
}

status_t zcl_pollCtrl_cmdHandler(zclIncoming_t *pInMsg)

{
  u8 uVar1;
  status_t sVar2;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    if ((pInMsg->hdr).cmd == '\0')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
  }
  else
  {
    uVar1 = (pInMsg->hdr).cmd;
    if (uVar1 == '\x01')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
    if (uVar1 == '\0')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
    if (uVar1 == '\x02')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
    if (uVar1 == '\x03')
    {
      if (pInMsg->clusterAppCb == ll_reset)
      {
        return '\x01';
      }
      sVar2 = FUNAAAAF();
      return sVar2;
    }
  }
  return 0x81;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAF(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*in_r3)();
  zcl_registerCluster(endpoint, 0x20, manuCode, attrNum, pAttrTbl, zcl_pollCtrl_cmdHandler,
                      in_stack_00000000);
  return;
}

status_t zcl_pollCtrl_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x20, manuCode, attrNum, attrTbl, zcl_pollCtrl_cmdHandler, cb);
  return sVar1;
}

status_t zcl_pollCtrl_chkInRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                               zcl_chkInRsp_t *pCheckInRsp)

{
  status_t sVar1;
  u8 local_14;
  undefined uStack_13;
  undefined uStack_12;

  local_14 = pCheckInRsp->startFastPolling;
  uStack_13 = (undefined)pCheckInRsp->fastPollTimeout;
  uStack_12 = (undefined)(pCheckInRsp->fastPollTimeout >> 8);
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 0x20, '\0', '\x01', '\0', disableDefaultRsp, 0, seqNo, 3, &local_14);
  return sVar1;
}

void zcl_scene_clearEntry(zcl_sceneTable_t *pSceneTab)

{
  if (pSceneTab != (zcl_sceneTable_t *)0x0)
  {
    pSceneTab->used = '\0';
    pSceneTab->endpoint = 0xfe;
    memset(&pSceneTab->scene, 0, 0x2c);
  }
  return;
}

void zcl_scene_sceneTabClear(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    zcl_scene_clearEntry(g_zcl_sceneTab + iVar1);
    iVar1 = iVar1 + 1;
  } while (iVar1 != 8);
  return;
}

zcl_sceneTable_t *zcl_scene_findEntry(u8 endpoint, u16 groupId, u8 sceneId)

{
  int iVar1;
  zcl_sceneTable_t *pzVar2;

  pzVar2 = g_zcl_sceneTab;
  iVar1 = 0;
  while (true)
  {
    if ((((pzVar2->used != '\0') && (pzVar2->endpoint == endpoint)) &&
         (g_zcl_sceneTab[iVar1].scene.groupId == groupId)) &&
        ((pzVar2->scene).sceneId == sceneId))
      break;
    iVar1 = iVar1 + 1;
    pzVar2 = pzVar2 + 1;
    if (iVar1 == 8)
    {
      return (zcl_sceneTable_t *)0x0;
    }
  }
  return g_zcl_sceneTab + iVar1;
}

void zcl_scene_updateSceneCntAttr(u8 endpoint)

{
  status_t sVar1;
  zcl_sceneTable_t *pzVar2;
  u16 local_10;
  u8 local_d[5];

  local_10 = 0;
  local_d[0] = '\0';
  sVar1 = zcl_getAttrVal(endpoint, 5, 0, &local_10, local_d);
  if (sVar1 == '\0')
  {
    pzVar2 = g_zcl_sceneTab;
    local_d[0] = '\0';
    do
    {
      if (pzVar2->used != '\0')
      {
        local_d[0] = local_d[0] + '\x01';
      }
      pzVar2 = pzVar2 + 1;
    } while (pzVar2 != (zcl_sceneTable_t *)&g_otaCtx);
    zcl_setAttrVal(endpoint, 5, 0, local_d);
  }
  return;
}

nv_sts_t zcl_scenesSave(u8 endpoint)

{
  nv_sts_t nVar1;

  zcl_scene_updateSceneCntAttr(endpoint);
  nVar1 = zcl_sceneTable_save();
  return nVar1;
}

status_t zcl_scene_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl,
                            cluster_forAppCb_t cb)

{
  nv_sts_t nVar1;
  status_t sVar2;

  nVar1 = zcl_sceneTable_restore();
  if (nVar1 != NV_SUCC)
  {
    zcl_scene_sceneTabClear();
  }
  sVar2 = zcl_registerCluster(endpoint, 5, manuCode, attrNum, attrTbl, zcl_scene_cmdHandler, cb);
  if (sVar2 == '\0')
  {
    zcl_scene_updateSceneCntAttr(endpoint);
  }
  return sVar2;
}

u8 zcl_scene_findAllSceneByGroup(u8 endpoint, u16 groupId, u8 *sceneList)

{
  uint uVar1;
  int iVar2;
  zcl_sceneTable_t *pzVar3;

  pzVar3 = g_zcl_sceneTab;
  iVar2 = 0;
  uVar1 = 0;
  do
  {
    while (((pzVar3->used != '\0' && (pzVar3->endpoint == endpoint)) &&
            (g_zcl_sceneTab[iVar2].scene.groupId == groupId)))
    {
      sceneList[uVar1] = (pzVar3->scene).sceneId;
      uVar1 = uVar1 + 1 & 0xff;
      iVar2 = iVar2 + 1;
      pzVar3 = pzVar3 + 1;
      if (iVar2 == 8)
        goto LAB_00007046;
    }
    iVar2 = iVar2 + 1;
    pzVar3 = pzVar3 + 1;
  } while (iVar2 != 8);
LAB_00007046:
  return (u8)uVar1;
}

status_t zcl_scene_addSceneEntry(u8 endpoint, zcl_sceneEntry_t *pScene)

{
  status_t sVar1;
  zcl_sceneTable_t *pzVar2;
  int iVar3;
  zcl_sceneTable_t *pzVar4;

  pzVar2 = zcl_scene_findEntry(endpoint, pScene->groupId, pScene->sceneId);
  if (pzVar2 == (zcl_sceneTable_t *)0x0)
  {
    pzVar4 = g_zcl_sceneTab;
    iVar3 = 0;
    do
    {
      pzVar2 = g_zcl_sceneTab + iVar3;
      if (pzVar4->used == '\0')
        goto LAB_00007068;
      iVar3 = iVar3 + 1;
      pzVar4 = pzVar4 + 1;
    } while (iVar3 != 8);
    sVar1 = 0x89;
  }
  else
  {
  LAB_00007068:
    pzVar2->used = '\x01';
    pzVar2->endpoint = endpoint;
    memcpy(&pzVar2->scene, pScene, 0x2c);
    zcl_scenesSave(endpoint);
    sVar1 = '\0';
  }
  return sVar1;
}

status_t zcl_scene_removeSceneEntry(u8 endpoint, u16 groupId, u8 sceneId)

{
  zcl_sceneTable_t *pSceneTab;
  status_t sVar1;

  pSceneTab = zcl_scene_findEntry(endpoint, groupId, sceneId);
  sVar1 = 0x8b;
  if (pSceneTab != (zcl_sceneTable_t *)0x0)
  {
    zcl_scene_clearEntry(pSceneTab);
    zcl_scenesSave(endpoint);
    sVar1 = '\0';
  }
  return sVar1;
}

void zcl_scene_removeAllSceneEntry(u8 endpoint, u16 groupId, u8 updateNV)

{
  bool bVar1;
  int iVar2;
  zcl_sceneTable_t *pzVar3;

  pzVar3 = g_zcl_sceneTab;
  iVar2 = 0;
  bVar1 = false;
  do
  {
    while (((pzVar3->used != '\0' && (pzVar3->endpoint == endpoint)) &&
            (g_zcl_sceneTab[iVar2].scene.groupId == groupId)))
    {
      zcl_scene_clearEntry(g_zcl_sceneTab + iVar2);
      bVar1 = true;
      iVar2 = iVar2 + 1;
      pzVar3 = pzVar3 + 1;
      if (iVar2 == 8)
        goto LAB_0000712a;
    }
    iVar2 = iVar2 + 1;
    pzVar3 = pzVar3 + 1;
  } while (iVar2 != 8);
LAB_0000712a:
  if ((bVar1) && (updateNV != '\0'))
  {
    zcl_scenesSave(endpoint);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_scene_copySceneEntry(u8 endpoint, copyScene_t *pCopyScene)

{
  byte sceneId;
  u16 uVar1;
  status_t sVar2;
  byte bVar3;
  zcl_sceneTable_t *pzVar4;
  zcl_sceneTable_t *pzVar5;
  uint uVar6;
  zcl_sceneTable_t *pzVar7;
  int iVar8;
  uint uVar9;
  uint local_30;
  undefined4 local_2c;
  undefined4 uStack_28;

  local_2c = 0;
  uStack_28 = 0;
  if ((int)((uint)pCopyScene->mode << 0x1f) < 0)
  {
    bVar3 = zcl_scene_findAllSceneByGroup(endpoint, pCopyScene->groupIdFrom, (u8 *)&local_2c);
    if (bVar3 == 0)
    {
      return 0x85;
    }
    sceneId = (byte)local_2c;
    local_30 = (uint)bVar3;
  }
  else
  {
    sceneId = pCopyScene->sceneIdFrom;
    pzVar4 = zcl_scene_findEntry(endpoint, pCopyScene->groupIdFrom, sceneId);
    if (pzVar4 == (zcl_sceneTable_t *)0x0)
    {
      return 0x85;
    }
    local_2c = local_2c & 0xffffff00 | (uint)sceneId;
    local_30 = 1;
  }
  uVar1 = pCopyScene->groupIdTo;
  uVar9 = 0;
  pzVar4 = zcl_scene_findEntry(endpoint, uVar1, (byte)local_2c);
  iVar8 = 0;
  while (true)
  {
    if (pzVar4 == (zcl_sceneTable_t *)0x0)
    {
      uVar9 = uVar9 + 1 & 0xff;
    }
    if (local_30 <= (iVar8 + 1U & 0xff))
      break;
    pzVar4 = zcl_scene_findEntry(endpoint, uVar1, *(u8 *)((int)&local_2c + iVar8 + 1));
    iVar8 = iVar8 + 1;
  }
  pzVar4 = g_zcl_sceneTab;
  uVar6 = 0;
  do
  {
    if (pzVar4->used != '\0')
    {
      uVar6 = uVar6 + 1 & 0xff;
    }
    pzVar4 = pzVar4 + 1;
  } while (pzVar4 != (zcl_sceneTable_t *)&g_otaCtx);
  sVar2 = 0x89;
  if ((int)uVar9 <= (int)(8 - uVar6))
  {
    uVar9 = 0;
    while (true)
    {
      pzVar4 = zcl_scene_findEntry(endpoint, pCopyScene->groupIdFrom, sceneId);
      if (pzVar4 != (zcl_sceneTable_t *)0x0)
      {
        if ((pCopyScene->mode & 1) == 0)
        {
          sceneId = pCopyScene->sceneIdTo;
        }
        pzVar5 = zcl_scene_findEntry(endpoint, pCopyScene->groupIdTo, sceneId);
        if (pzVar5 == (zcl_sceneTable_t *)0x0)
        {
          pzVar7 = g_zcl_sceneTab;
          iVar8 = 0;
          while (pzVar5 = g_zcl_sceneTab + iVar8, pzVar7->used != '\0')
          {
            iVar8 = iVar8 + 1;
            pzVar7 = pzVar7 + 1;
            if (iVar8 == 8)
            {
              return 0x89;
            }
          }
        }
        pzVar5->used = '\x01';
        pzVar5->endpoint = endpoint;
        memcpy(&pzVar5->scene, &pzVar4->scene, 0x2c);
        (pzVar5->scene).sceneId = sceneId;
        uVar1 = pCopyScene->groupIdTo;
        *(char *)&(pzVar5->scene).groupId = (char)uVar1;
        *(char *)((int)&(pzVar5->scene).groupId + 1) = (char)(uVar1 >> 8);
      }
      if (local_30 <= (uVar9 + 1 & 0xff))
        break;
      sceneId = *(byte *)((int)&local_2c + uVar9 + 1);
      uVar9 = uVar9 + 1;
    }
    zcl_scenesSave(endpoint);
    sVar2 = '\0';
  }
  return sVar2;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_scene_sceneRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 cmdId,
                            u8 status, u16 groupId, u8 sceneId)

{
  status_t sVar1;
  short sVar2;
  u8 local_18;
  undefined2 uStack_17;
  u8 uStack_15;
  undefined auStack_14[4];

  local_18 = status;
  sVar2 = (short)&uStack_15;
  if (cmdId != '\x03')
  {
    uStack_15 = sceneId;
    sVar2 = (short)auStack_14;
  }
  uStack_17 = groupId;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 5, cmdId, '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                      sVar2 - (short)&local_18, &local_18);
  return sVar1;
}

status_t zcl_scene_viewSceneRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 cmdId, u8 status,
                                u16 groupId, u8 sceneId, zcl_sceneEntry_t *pEntry)

{
  byte bVar1;
  status_t sVar2;
  u16 uVar3;
  u8 *cmdPld;
  short sVar4;
  u8 *out;

  if (status == '\0')
  {
    if (pEntry == (zcl_sceneEntry_t *)0x0)
    {
      return '\x01';
    }
    uVar3 = (u16)(byte)(((uint)pEntry->sceneName[0] + (uint)pEntry->extFieldLen) * 0x1000000 +
                            0x7000000 >>
                        0x18);
  }
  else
  {
    uVar3 = 4;
  }
  cmdPld = ev_buf_allocate(uVar3);
  sVar2 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = status;
    *(u16 *)(cmdPld + 1) = groupId;
    cmdPld[3] = sceneId;
    sVar4 = (short)cmdPld + 4;
    if (status == '\0')
    {
      uVar3 = pEntry->transTime;
      if (cmdId == 'A')
      {
        uVar3 = uVar3 * 10 + pEntry->transTime100ms;
      }
      cmdPld[4] = (u8)uVar3;
      cmdPld[5] = (u8)(uVar3 >> 8);
      cmdPld[6] = pEntry->sceneName[0];
      out = cmdPld + 7;
      memcpy(out, pEntry->sceneName + 1, (uint)pEntry->sceneName[0]);
      bVar1 = pEntry->sceneName[0];
      memcpy(out + bVar1, pEntry->extField, (uint)pEntry->extFieldLen);
      sVar4 = (short)(out + bVar1) + (ushort)pEntry->extFieldLen;
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 5, cmdId, '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                sVar4 - (short)cmdPld, cmdPld);
    ev_buf_free(cmdPld);
    sVar2 = '\0';
  }
  return sVar2;
}

status_t zcl_scene_getSceneMembershipRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo,
                                         getSceneMemRsp_t *pGetSceneMembershipRsp)

{
  status_t sVar1;
  u16 size;
  u8 *cmdPld;
  short sVar2;

  size = 4;
  if (pGetSceneMembershipRsp->status == '\0')
  {
    size = pGetSceneMembershipRsp->sceneCnt + 5 & 0xff;
  }
  cmdPld = ev_buf_allocate(size);
  sVar1 = 0x89;
  if (cmdPld != (u8 *)0x0)
  {
    *cmdPld = pGetSceneMembershipRsp->status;
    cmdPld[1] = pGetSceneMembershipRsp->capacity;
    cmdPld[2] = *(u8 *)&pGetSceneMembershipRsp->groupId;
    cmdPld[3] = *(u8 *)((int)&pGetSceneMembershipRsp->groupId + 1);
    sVar2 = (short)cmdPld + 4;
    if (pGetSceneMembershipRsp->status == '\0')
    {
      cmdPld[4] = pGetSceneMembershipRsp->sceneCnt;
      memcpy(cmdPld + 5, pGetSceneMembershipRsp->sceneList, (uint)pGetSceneMembershipRsp->sceneCnt);
      sVar2 = (ushort)pGetSceneMembershipRsp->sceneCnt + (short)(cmdPld + 5);
    }
    zcl_sendCmd(srcEp, pDstEpInfo, 5, '\x06', '\x01', '\x01', disableDefaultRsp, 0, seqNo,
                sVar2 - (short)cmdPld, cmdPld);
    ev_buf_free(cmdPld);
    sVar1 = '\0';
  }
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Restarted to delay deadcode elimination for space: stack

status_t zcl_scene_cmdHandler(zclIncoming_t *pInMsg)

{
  apsdeDataInd_t *paVar1;
  u8 *puVar2;
  ushort uVar3;
  byte bVar4;
  status_t sVar5;
  u16 uVar6;
  undefined2 uVar7;
  aps_group_tbl_ent_t *paVar8;
  zcl_sceneTable_t *pzVar9;
  zcl_sceneTable_t *pzVar10;
  char cVar11;
  u16 groupAddr;
  epInfo_t *pDstEpInfo;
  byte *pbVar12;
  byte *extraout_r1;
  zcl_sceneEntry_t *pEntry;
  int iVar13;
  uint uVar14;
  u8 uVar15;
  byte *pbVar16;
  uint extraout_r3;
  int iVar17;
  ushort *val;
  uint uVar18;
  u8 uVar19;
  ushort unaff_r8;
  u8 cmdId;
  uint local_128;
  undefined4 uStack_124;
  uint uStack_120;
  undefined4 uStack_11c;
  undefined4 uStack_118;
  uint uStack_114;
  undefined4 uStack_110;
  undefined4 uStack_10c;
  undefined4 uStack_108;
  undefined4 uStack_104;
  undefined4 uStack_100;
  undefined local_fc;
  undefined auStack_f8[20];
  undefined uStack_e4;
  u16 uStack_e3;
  u8 uStack_e1;
  undefined4 uStack_e0;
  undefined4 uStack_dc;
  undefined4 uStack_d8;
  undefined4 uStack_d4;
  undefined4 uStack_d0;
  uint local_cc;
  undefined4 uStack_c8;
  uint uStack_c4;
  undefined4 uStack_c0;
  undefined2 local_bc;
  uint local_b8;
  undefined4 uStack_b4;
  uint uStack_b0;
  undefined4 uStack_ac;
  undefined2 local_a8;
  uint local_a4;
  undefined4 uStack_a0;
  uint uStack_9c;
  undefined4 uStack_98;
  undefined2 local_94;
  uint local_90;
  undefined4 uStack_8c;
  uint uStack_88;
  undefined4 uStack_84;
  undefined2 local_80;
  uint local_7c;
  undefined4 uStack_78;
  uint uStack_74;
  undefined4 uStack_70;
  undefined2 local_6c;
  uint local_68;
  undefined4 uStack_64;
  uint uStack_60;
  undefined4 uStack_5c;
  undefined2 local_58;
  uint uStack_54;
  undefined4 uStack_50;
  uint uStack_4c;
  undefined4 uStack_48;
  undefined2 uStack_44;
  undefined local_40[12];
  undefined8 local_34;
  ushort local_2c;
  u16 local_2a;
  undefined2 local_28;
  byte local_25;

  if ((int)((uint)(pInMsg->hdr).frmCtrl.byte << 0x1c) < 0)
  {
    val = (ushort *)pInMsg->pData;
    local_128 = 0;
    uStack_124 = 0;
    uStack_120 = 0;
    uStack_11c = 0;
    uStack_118 = 0;
    uStack_114 = 0;
    uStack_110 = 0;
    uStack_10c = 0;
    uStack_108 = 0;
    uStack_104 = 0;
    uStack_100 = 0;
    local_fc = 0;
    switch ((pInMsg->hdr).cmd)
    {
    case '\0':
    case '\x02':
    case '\x04':
    case '@':
    case 'B':
      local_128 = (uint) * (byte *)val;
      local_128 = local_128 |
                  ((uint) * (byte *)(val + 1) * 0x100 + (uint) * (byte *)((int)val + 1)) * 0x10000 >> 8 | (uint) * (byte *)((int)val + 3) << 0x18;
      break;
    case '\x01':
    case 'A':
      unaff_r8 = pInMsg->dataLen;
      local_128 = (uint) * (byte *)val |
                  ((uint) * (byte *)(val + 1) * 0x100 + (uint) * (byte *)((int)val + 1)) * 0x10000 >> 8 | (uint) * (byte *)((int)val + 3) << 0x18;
      if (*(byte *)val != 0)
      {
        FUN_000075b2();
      }
      uStack_114 = uStack_114 & 0xffff0000 |
                   (uint)(ushort)((ushort) * (byte *)((int)val + 5) * 0x100 +
                                  (ushort) * (byte *)(val + 2));
      uVar18 = (uint) * (byte *)(val + 3);
      uVar14 = uVar18;
      if (0xf < uVar18)
      {
        uVar14 = 0xf;
      }
      uStack_124 = uStack_124 & 0xffffff00 | uVar14;
      memcpy((void *)((int)&uStack_124 + 1), (byte *)((int)val + 7), uVar14);
      pbVar12 = (byte *)((int)val + 7) + uVar18;
      pbVar16 = (byte *)((int)val + ((uint)unaff_r8 - (int)pbVar12));
      uVar14 = (uint)pbVar16 & 0xff;
      uStack_110 = uStack_110 & 0xffffff00 | (uint)pbVar16 & 0xff;
      if (uVar14 == 0)
      {
        FUN_000075b2();
        pbVar12 = extraout_r1;
        uVar14 = extraout_r3;
      }
      if (0x14 < uVar14)
      {
        uVar14 = 0x14;
      }
      uStack_110 = uStack_110 & 0xffffff00 | uVar14 & 0xff;
      memcpy((void *)((int)&uStack_110 + 1), pbVar12, uVar14 & 0xff);
      FUN_000075b2();
    case '\x03':
      uVar19 = (u8)&local_128;
      local_128 = local_128 & 0xff000000 | (uint) * (byte *)val |
                  ((uint) * (byte *)(val + 1) * 0x100 + (uint) * (byte *)((int)val + 1)) * 0x10000 >> 8;
      FUN_000075b2();
    LAB_00007e28:
      *val = unaff_r8;
      zcl_setAttrVal(uVar19, 5, 2, (u8 *)val);
      goto LAB_00007aea;
    default:
      goto switchD_0000758e_caseD_5;
    case '\x06':
      local_128 = CONCAT22((ushort) * (byte *)((int)val + 3) * 0x100 + (ushort) * (byte *)(val + 1), *val);
      if (*(byte *)val == 0)
      {
        uStack_124 = (uint) * (byte *)(val + 2);
        uStack_124 = (int)(byte *)((int)val + 5) * 0x100 | uStack_124;
        uStack_120 = (uint)(byte *)((int)val + 5) >> 0x18;
      }
    }
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\0';
    }
    FUNAAAAG();
    return '\0';
  }
  uVar19 = (pInMsg->hdr).cmd;
  switch (uVar19)
  {
  case '\0':
  case '@':
    paVar1 = pInMsg->msg;
    uVar15 = (paVar1->indInfo).dst_ep;
    auStack_f8._4_4_ = 0;
    auStack_f8._8_4_ = 0;
    auStack_f8._12_4_ = 0;
    uStack_e3 = 0;
    uStack_e1 = '\0';
    uStack_e0 = 0;
    uStack_dc = 0;
    uStack_d8 = 0;
    uStack_d4 = 0;
    uStack_d0 = 0;
    pbVar12 = pInMsg->pData;
    uVar3 = pInMsg->dataLen;
    auStack_f8._0_4_ = (uint)CONCAT12(pbVar12[2], (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12);
    auStack_f8._16_4_ = (uint)pbVar12[3] << 0x18;
    uStack_e4 = (undefined)((uint)pbVar12[4] * 0x100 + (uint)pbVar12[3] >> 8);
    uVar14 = (uint)pbVar12[5];
    pbVar16 = pbVar12 + 6;
    local_25 = 0;
    local_28 = 0;
    zcl_getAttrVal(uVar15, 5, 4, &local_28, &local_25);
    if (local_25 != 0)
    {
      uVar18 = uVar14;
      if (0xf < uVar14)
      {
        uVar18 = 0xf;
      }
      auStack_f8._0_4_ = auStack_f8._0_4_ & 0xffffff | uVar18 << 0x18;
      memcpy(auStack_f8 + 4, pbVar16, uVar18);
    }
    uVar18 = (uint)(pbVar12 + ((uint)uVar3 - (int)(pbVar16 + uVar14))) & 0xff;
    uStack_e1 = (u8)((uint)((int)(pbVar12 + ((uint)uVar3 - (int)(pbVar16 + uVar14))) * 0x1000000) >>
                     0x18);
    if (uVar18 != 0)
    {
      if (0x14 < uVar18)
      {
        uVar18 = 0x14;
      }
      uStack_e1 = (u8)uVar18;
      memcpy(&uStack_e0, pbVar16 + uVar14, uVar18);
    }
    if (uVar19 == '@')
    {
      uVar7 = CONCAT11(uStack_e4, auStack_f8[19]);
      uVar6 = FUN_00001628(uVar7, 10);
      uVar14 = CONCAT13(uStack_e1, CONCAT21(uStack_e3, uStack_e4)) & 0xff0000ff;
      uStack_e4 = (undefined)uVar14;
      uStack_e1 = (u8)(uVar14 >> 0x18);
      uStack_e3 = uVar6;
      uVar7 = FUN_0000162c(uVar7, 10);
      auStack_f8._16_4_ = auStack_f8._16_4_ & 0xffffff | (uint)(byte)uVar7 << 0x18;
      uStack_e4 = (undefined)((ushort)uVar7 >> 8);
    }
    if (auStack_f8._0_2_ == 0)
    {
    LAB_0000777e:
      local_40[0] = zcl_scene_addSceneEntry(uVar15, (zcl_sceneEntry_t *)auStack_f8);
    }
    else
    {
      paVar8 = aps_group_search(auStack_f8._0_2_, uVar15);
      local_40[0] = 0x85;
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
        goto LAB_0000777e;
    }
    if (((paVar1->indInfo).dst_addr < 0xfffc) && ((paVar1->indInfo).dst_addr_mode != '\x01'))
    {
      uStack_50 = 0;
      uStack_44 = 0;
      uStack_54 = (uint)(paVar1->indInfo).field_10.src_short_addr;
      uStack_48 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
      uStack_4c = (uint)(paVar1->indInfo).profile_id;
      zcl_scene_sceneRsp(uVar15, (epInfo_t *)&uStack_54, '\x01', (pInMsg->hdr).seqNum, uVar19,
                         local_40[0], (u16)auStack_f8._0_4_, auStack_f8[2]);
      local_40[0] = 0xff;
    }
    break;
  case '\x01':
  case 'A':
    paVar1 = pInMsg->msg;
    pbVar12 = pInMsg->pData;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    uVar15 = (paVar1->indInfo).dst_ep;
    bVar4 = pbVar12[2];
    pzVar9 = zcl_scene_findEntry(uVar15, uVar6, bVar4);
    local_40[0] = '\0';
    if (((pzVar9 == (zcl_sceneTable_t *)0x0) && (local_40[0] = 0x8b, uVar6 != 0)) &&
        (paVar8 = aps_group_search(uVar6, uVar15), paVar8 == (aps_group_tbl_ent_t *)0x0))
    {
      local_40[0] = 0x85;
    }
    if (((paVar1->indInfo).dst_addr < 0xfffc) && ((paVar1->indInfo).dst_addr_mode != '\x01'))
    {
      uStack_64 = 0;
      local_58 = 0;
      local_68 = (uint)(paVar1->indInfo).field_10.src_short_addr;
      uStack_5c = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
      uStack_60 = (uint)(paVar1->indInfo).profile_id;
      pEntry = (zcl_sceneEntry_t *)0x0;
      if (local_40[0] == '\0')
      {
        pEntry = &pzVar9->scene;
      }
      zcl_scene_viewSceneRsp(uVar15, (epInfo_t *)&local_68, '\x01', (pInMsg->hdr).seqNum, uVar19, local_40[0], uVar6,
                             bVar4, pEntry);
      local_40[0] = 0xff;
    }
    break;
  case '\x02':
    paVar1 = pInMsg->msg;
    pbVar12 = pInMsg->pData;
    uVar19 = (paVar1->indInfo).dst_ep;
    uVar6 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    bVar4 = pbVar12[2];
    sVar5 = zcl_scene_removeSceneEntry(uVar19, uVar6, bVar4);
    if ((sVar5 == 0x8b) &&
        (paVar8 = aps_group_search(uVar6, uVar19), paVar8 == (aps_group_tbl_ent_t *)0x0))
    {
      sVar5 = 0x85;
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_7c;
    uStack_78 = 0;
    local_6c = 0;
    local_7c = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_70 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_74 = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = '\x02';
    goto LAB_000076b2;
  case '\x03':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    uVar6 = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
    if (uVar6 == 0)
    {
    LAB_00007ca4:
      zcl_scene_removeAllSceneEntry(uVar19, uVar6, '\x01');
      sVar5 = '\0';
    }
    else
    {
      paVar8 = aps_group_search(uVar6, uVar19);
      sVar5 = 0x85;
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
        goto LAB_00007ca4;
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_90;
    bVar4 = 0;
    uStack_8c = 0;
    local_80 = 0;
    local_90 = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_84 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_88 = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = '\x03';
    goto LAB_000076b2;
  case '\x04':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    pbVar12 = pInMsg->pData;
    uVar14 = (uint)pbVar12[1] * 0x100 + (uint)*pbVar12;
    iVar13 = uVar14 * 0x10000;
    uVar14 = uVar14 & 0xffff;
    uVar6 = (u16)uVar14;
    bVar4 = pbVar12[2];
    groupAddr = (u16)((uint)iVar13 >> 0x10);
    if (uVar14 == 0)
    {
    LAB_00007b62:
      pzVar9 = zcl_scene_findEntry(uVar19, groupAddr, bVar4);
      if (pzVar9 == (zcl_sceneTable_t *)0x0)
      {
        pzVar10 = g_zcl_sceneTab;
        iVar17 = 0;
        do
        {
          pzVar9 = g_zcl_sceneTab + iVar17;
          if (pzVar10->used == '\0')
            goto LAB_00007b72;
          iVar17 = iVar17 + 1;
          pzVar10 = pzVar10 + 1;
        } while (iVar17 != 8);
        sVar5 = 0x89;
      }
      else
      {
      LAB_00007b72:
        sVar5 = '\x01';
        if (pInMsg->clusterAppCb != ll_reset)
        {
          FUNAAAAG();
          pzVar9->used = '\x01';
          pzVar9->endpoint = uVar19;
          *(char *)&(pzVar9->scene).groupId = (char)((uint)iVar13 >> 0x10);
          *(char *)((int)&(pzVar9->scene).groupId + 1) = (char)(uVar14 >> 8);
          (pzVar9->scene).sceneId = bVar4;
          local_2c = 0;
          local_25 = 0;
          sVar5 = zcl_getAttrVal(uVar19, 5, 1, &local_2c, &local_25);
          if (sVar5 == '\0')
          {
            local_25 = bVar4;
            zcl_setAttrVal(uVar19, 5, 1, &local_25);
          }
          local_2a = 0;
          sVar5 = zcl_getAttrVal(uVar19, 5, 2, &local_2c, (u8 *)&local_2a);
          if (sVar5 == '\0')
          {
            local_2a = groupAddr;
            zcl_setAttrVal(uVar19, 5, 2, (u8 *)&local_2a);
          }
          local_28 = local_28 & 0xff00;
          sVar5 = zcl_getAttrVal(uVar19, 5, 3, &local_2c, (u8 *)&local_28);
          if (sVar5 == '\0')
          {
            local_28 = CONCAT11(local_28._1_1_, 1);
            zcl_setAttrVal(uVar19, 5, 3, (u8 *)&local_28);
          }
          zcl_scenesSave(uVar19);
          sVar5 = '\0';
        }
      }
    }
    else
    {
      paVar8 = aps_group_search(groupAddr, uVar19);
      sVar5 = 0x85;
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
        goto LAB_00007b62;
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_a4;
    uStack_a0 = 0;
    local_94 = 0;
    local_a4 = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_98 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_9c = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = '\x04';
    goto LAB_000076b2;
  case '\x05':
    pbVar12 = pInMsg->pData;
    unaff_r8 = (ushort)pbVar12[1] * 0x100 + (ushort)*pbVar12;
    bVar4 = pbVar12[2];
    uVar19 = (pInMsg->msg->indInfo).dst_ep;
    pzVar9 = zcl_scene_findEntry(uVar19, unaff_r8, bVar4);
    if (pzVar9 == (zcl_sceneTable_t *)0x0)
    {
      return '\0';
    }
    if (pInMsg->clusterAppCb == ll_reset)
    {
      return '\0';
    }
    FUNAAAAG();
    pInMsg = (zclIncoming_t *)&local_2a;
    local_2a = 0;
    local_28 = local_28 & 0xff00;
    sVar5 = zcl_getAttrVal(uVar19, 5, 1, (u16 *)pInMsg, (u8 *)&local_28);
    if (sVar5 == '\0')
    {
      local_28 = local_28 & 0xff00 | (ushort)bVar4;
      zcl_setAttrVal(uVar19, 5, 1, (u8 *)&local_28);
    }
    val = &local_2c;
    local_2c = 0;
    sVar5 = zcl_getAttrVal(uVar19, 5, 2, (u16 *)pInMsg, (u8 *)val);
    if (sVar5 == '\0')
      goto LAB_00007e28;
  LAB_00007aea:
    local_25 = 0;
    sVar5 = zcl_getAttrVal(uVar19, 5, 3, (u16 *)pInMsg, &local_25);
    local_40[0] = '\0';
    if (sVar5 == '\0')
    {
      local_25 = 1;
      zcl_setAttrVal(uVar19, 5, 3, &local_25);
    }
    break;
  case '\x06':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    local_40._2_2_ = (ushort)pInMsg->pData[1] * 0x100 + (ushort)*pInMsg->pData;
    local_34._0_4_ = 0;
    local_34._4_4_ = 0;
    if ((local_40._2_2_ == 0) ||
        (paVar8 = aps_group_search(local_40._2_2_, uVar19), paVar8 != (aps_group_tbl_ent_t *)0x0))
    {
      bVar4 = zcl_scene_findAllSceneByGroup(uVar19, local_40._2_2_, (u8 *)&local_34);
      local_40[0] = '\0';
    }
    else
    {
      bVar4 = 0;
      local_40[0] = 0x85;
    }
    if (((paVar1->indInfo).dst_addr < 0xfffc) && ((paVar1->indInfo).dst_addr_mode != '\x01'))
    {
      uStack_b4 = 0;
      local_a8 = 0;
      pzVar9 = g_zcl_sceneTab;
      cVar11 = '\0';
      do
      {
        if (pzVar9->used != '\0')
        {
          cVar11 = cVar11 + '\x01';
        }
        pzVar9 = pzVar9 + 1;
      } while (pzVar9 != (zcl_sceneTable_t *)&g_otaCtx);
      local_40[1] = '\b' - cVar11;
      local_40._4_4_ = (int)&local_34 * 0x100 | (uint)bVar4;
      local_40[8] = (undefined)((uint)&local_34 >> 0x18);
      local_b8 = (uint)(paVar1->indInfo).field_10.src_short_addr;
      uStack_ac = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
      uStack_b0 = (uint)(paVar1->indInfo).profile_id;
      zcl_scene_getSceneMembershipRsp(uVar19, (epInfo_t *)&local_b8, '\x01', (pInMsg->hdr).seqNum,
                                      (getSceneMemRsp_t *)local_40);
      local_40[0] = 0xff;
    }
    break;
  default:
  switchD_0000758e_caseD_5:
    local_40[0] = 0x81;
    break;
  case 'B':
    paVar1 = pInMsg->msg;
    uVar19 = (paVar1->indInfo).dst_ep;
    puVar2 = pInMsg->pData;
    uVar6 = (ushort)puVar2[2] * 0x100 + (ushort)puVar2[1];
    local_34._0_4_ = CONCAT13(puVar2[3], CONCAT21(uVar6, *puVar2));
    local_34._4_3_ = CONCAT12(puVar2[6], (ushort)puVar2[5] * 0x100 + (ushort)puVar2[4]);
    local_34._4_4_ = local_34._4_4_ & 0xff000000 | (uint)local_34._4_3_;
    paVar8 = aps_group_search(uVar6, uVar19);
    sVar5 = 0x85;
    if (paVar8 != (aps_group_tbl_ent_t *)0x0)
    {
      paVar8 = aps_group_search(local_34._4_2_, uVar19);
      if (paVar8 != (aps_group_tbl_ent_t *)0x0)
      {
        sVar5 = zcl_scene_copySceneEntry(uVar19, (copyScene_t *)&local_34);
      }
    }
    if (0xfffb < (paVar1->indInfo).dst_addr)
    {
      return sVar5;
    }
    if ((paVar1->indInfo).dst_addr_mode == '\x01')
    {
      return sVar5;
    }
    pDstEpInfo = (epInfo_t *)&local_cc;
    uStack_c8 = 0;
    local_bc = 0;
    local_cc = (uint)(paVar1->indInfo).field_10.src_short_addr;
    uStack_c0 = CONCAT13((paVar1->indInfo).src_ep, 0x20000);
    uStack_c4 = (uint)(paVar1->indInfo).profile_id;
    uVar15 = (pInMsg->hdr).seqNum;
    cmdId = 'B';
    uVar6 = (u16)((uint)(undefined4)local_34 >> 8);
    bVar4 = (byte)((uint)(undefined4)local_34 >> 0x18);
  LAB_000076b2:
    zcl_scene_sceneRsp(uVar19, pDstEpInfo, '\x01', uVar15, cmdId, sVar5, uVar6, bVar4);
    local_40[0] = 0xff;
  }
  return local_40[0];
}

undefined4 FUN_000075b2(void)

{
  int *unaff_r4;

  if (*unaff_r4 != 0)
  {
    FUNAAAAG();
  }
  return 0;
}

u8 switchD_0000754e::caseD_0(void)

{
  u8 endpoint;
  char *pcVar1;
  byte *pbVar2;
  status_t status;
  u16 uVar3;
  undefined2 uVar4;
  aps_group_tbl_ent_t *paVar5;
  uint uVar6;
  uint uVar7;
  int unaff_r4;
  int unaff_r6;
  byte *param_10;
  uint param_11;
  u16 param_12;
  u8 uStack0000004e;
  undefined4 param_13;
  undefined4 param_14;
  undefined4 param_15;
  uint param_16;
  undefined param_17;
  u16 uStack00000061;
  u8 uStack00000063;
  undefined4 param_18;
  undefined4 param_19;
  undefined4 param_20;
  undefined4 param_21;
  undefined4 param_22;
  uint param_23;
  undefined4 param_24;
  uint param_25;
  undefined4 param_26;
  undefined2 param_27;
  u16 param_28;
  u8 param_29;

  pcVar1 = *(char **)(unaff_r4 + 4);
  endpoint = pcVar1[1];
  param_13 = 0;
  param_14 = 0;
  param_15 = 0;
  uStack00000061 = 0;
  uStack00000063 = '\0';
  param_18 = 0;
  param_19 = 0;
  param_20 = 0;
  param_21 = 0;
  param_22 = 0;
  pbVar2 = *(byte **)(unaff_r4 + 8);
  param_11 = (uint) * (ushort *)(unaff_r4 + 0x10);
  _param_12 = (uint)CONCAT12(pbVar2[2], (ushort)pbVar2[1] * 0x100 + (ushort)*pbVar2);
  param_16 = (uint)pbVar2[3] << 0x18;
  param_17 = (undefined)((uint)pbVar2[4] * 0x100 + (uint)pbVar2[3] >> 8);
  uVar7 = (uint)pbVar2[5];
  param_10 = pbVar2 + 6;
  param_29 = '\0';
  param_28 = 0;
  zcl_getAttrVal(endpoint, 5, 4, &stack0x0000011c, &stack0x0000011f);
  if (param_29 != '\0')
  {
    uVar6 = uVar7;
    if (0xf < uVar7)
    {
      uVar6 = 0xf;
    }
    _param_12 = _param_12 & 0xffffff | uVar6 << 0x18;
    memcpy(&stack0x00000050, param_10, uVar6);
  }
  uVar6 = (uint)(pbVar2 + (param_11 - (int)(param_10 + uVar7))) & 0xff;
  uStack00000063 =
      (u8)((uint)((int)(pbVar2 + (param_11 - (int)(param_10 + uVar7))) * 0x1000000) >> 0x18);
  if (uVar6 != 0)
  {
    if (0x14 < uVar6)
    {
      uVar6 = 0x14;
    }
    uStack00000063 = (u8)uVar6;
    memcpy(&stack0x00000064, param_10 + uVar7, uVar6);
  }
  if (unaff_r6 == 0x40)
  {
    uVar4 = CONCAT11(param_17, param_16._3_1_);
    uVar3 = FUN_00001628(uVar4, 10);
    uVar7 = CONCAT13(uStack00000063, CONCAT21(uStack00000061, param_17)) & 0xff0000ff;
    param_17 = (undefined)uVar7;
    uStack00000063 = (u8)(uVar7 >> 0x18);
    uStack00000061 = uVar3;
    uVar4 = FUN_0000162c(uVar4, 10);
    param_16 = param_16 & 0xffffff | (uint)(byte)uVar4 << 0x18;
    param_17 = (undefined)((ushort)uVar4 >> 8);
  }
  if (param_12 != 0)
  {
    paVar5 = aps_group_search(param_12, endpoint);
    status = 0x85;
    if (paVar5 == (aps_group_tbl_ent_t *)0x0)
      goto LAB_00007788;
  }
  status = zcl_scene_addSceneEntry(endpoint, (zcl_sceneEntry_t *)&stack0x0000004c);
LAB_00007788:
  if ((*(ushort *)(pcVar1 + 2) < 0xfffc) && (*pcVar1 != '\x01'))
  {
    param_24 = 0;
    param_27 = 0;
    param_23 = (uint) * (ushort *)(pcVar1 + 0x14);
    param_26 = CONCAT13(pcVar1[5], 0x20000);
    param_25 = (uint) * (ushort *)(pcVar1 + 6);
    zcl_scene_sceneRsp(endpoint, (epInfo_t *)&stack0x000000f0, '\x01', *(u8 *)(unaff_r4 + 0x1f),
                       (u8)unaff_r6, status, (u16)_param_12, uStack0000004e);
    status = 0xff;
  }
  return status;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAG(void)

{
  u8 endpoint;
  u16 manuCode;
  u8 attrNum;
  code *in_r3;
  zclAttrInfo_t *pAttrTbl;
  cluster_forAppCb_t in_stack_00000000;

  endpoint = (*in_r3)();
  zcl_registerCluster(endpoint, 0x101, manuCode, attrNum, pAttrTbl, zcl_doorLock_cmdHandler,
                      in_stack_00000000);
  return;
}

status_t zcl_doorLock_register(u8 endpoint, u16 manuCode, u8 attrNum, zclAttrInfo_t *attrTbl, cluster_forAppCb_t cb)

{
  status_t sVar1;

  sVar1 = zcl_registerCluster(endpoint, 0x101, manuCode, attrNum, attrTbl, zcl_doorLock_cmdHandler, cb);
  return sVar1;
}

status_t zcl_doorLock_doorLockRsp(u8 srcEp, epInfo_t *pDstEpInfo, u8 disableDefaultRsp, u8 seqNo, u8 cmdId,
                                  status_t rspStatus)

{
  status_t sVar1;
  status_t local_14[8];

  local_14[0] = rspStatus;
  sVar1 = zcl_sendCmd(srcEp, pDstEpInfo, 0x101, cmdId, '\x01', '\x01', disableDefaultRsp, 0, seqNo, 1,
                      local_14);
  return sVar1;
}

// WARNING: Could not reconcile some variable overlaps

status_t zcl_doorLock_cmdHandler(zclIncoming_t *pInMsg)

{
  byte bVar1;
  apsdeDataInd_t *paVar2;
  status_t sVar3;
  uint local_3c;
  uint uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  undefined2 local_2c;
  u8 *puStack_28;
  undefined uStack_24;
  u8 local_20;

  bVar1 = (pInMsg->hdr).frmCtrl.byte;
  uStack_38 = bVar1 & 8;
  if ((bVar1 & 8) == 0)
  {
    sVar3 = 0x81;
    if ((pInMsg->hdr).cmd < 3)
    {
      paVar2 = pInMsg->msg;
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        uStack_24 = *(undefined *)&pInMsg->dataLen;
        puStack_28 = pInMsg->pData;
        sVar3 = FUN_000080ae(&pInMsg->addrInfo);
        local_2c = (undefined2)uStack_38;
        local_3c = (uint)(paVar2->indInfo).field_10.src_short_addr;
        uStack_30 = CONCAT13((paVar2->indInfo).src_ep, CONCAT12(2, local_2c));
        uStack_34 = (uint)(paVar2->indInfo).profile_id;
        zcl_doorLock_doorLockRsp((paVar2->indInfo).dst_ep, (epInfo_t *)&local_3c, '\x01', (pInMsg->hdr).seqNum,
                                 (pInMsg->hdr).cmd, sVar3);
        sVar3 = 0xff;
      }
    }
  }
  else
  {
    sVar3 = 0x81;
    if ((pInMsg->hdr).cmd < 3)
    {
      sVar3 = '\x01';
      if (pInMsg->clusterAppCb != ll_reset)
      {
        local_20 = *pInMsg->pData;
        FUN_000080ac(&pInMsg->addrInfo);
        sVar3 = '\0';
      }
    }
  }
  return sVar3;
}

void FUN_000080ac(void)

{
  code *in_r3;
  code *unaff_sl;

  (*in_r3)();
  (*unaff_sl)();
  nv_flashWriteNew('\x01', 2, '\x04', 0x55, (u8 *)&ss_ib);
  return;
}

void FUN_000080ae(void)

{
  code *unaff_sl;

  (*unaff_sl)();
  nv_flashWriteNew('\x01', 2, '\x04', 0x55, (u8 *)&ss_ib);
  return;
}

void zdo_ssInfoSaveToFlash(void)

{
  nv_flashWriteNew('\x01', 2, '\x04', 0x55, (u8 *)&ss_ib);
  return;
}

u8 zdo_ssInfoInit(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashReadNew('\x01', '\x02', '\x04', 0x55, (u8 *)&ss_ib);
  ss_ib.keyPairSetNew._0_1_ = 0;
  ss_ib.keyPairSetNew._1_1_ = 0x80;
  ss_ib.keyPairSetNew._2_1_ = 0x84;
  ss_ib.keyPairSetNew._3_1_ = 0;
  return nVar1;
}

u8 zdo_ssInfoKeyGet(void)

{
  nv_sts_t nVar1;
  ss_info_base_t ss;

  nVar1 = nv_flashReadNew('\x01', '\x02', '\x04', 0x55, (u8 *)&ss);
  if (nVar1 == NV_SUCC)
  {
    nVar1 = (nv_sts_t)(((uint)ss._62_1_ << 0x1a) >> 0x1e);
  }
  return nVar1;
}

s32 ota_imageBlockWaitCb(void *arg)

{
  if (zcl_attr_imageUpgradeStatus == '\x01')
  {
    tl_zbTaskPost(sendImageBlockReq, (void *)0x0);
  }
  return -2;
}

s32 ota_sendImageBlockReqDelay(void *arg)

{
  tl_zbTaskPost(sendImageBlockReq, (void *)0x0);
  return -2;
}

void ota_ieeeAddrReq(u16 dstAddr)

{
  zdo_ieee_addr_req_t local_c;
  u8 local_5[5];

  local_5[0] = '\0';
  local_c.req_type = ZDO_ADDR_REQ_SINGLE_REQ;
  local_c.start_index = '\0';
  local_c.nwk_addr_interest = dstAddr;
  zb_zdoIeeeAddrReq(dstAddr, &local_c, local_5, ota_ieeeAddrRspCb);
  return;
}

void ota_ieeeAddrReqSend(void *arg)

{
  ota_ieeeAddrReq(g_otaCtx.otaServerEpInfo.dstAddr.shortAddr);
  otaTimer.cb = ota_ieeeAddrRspWait;
  otaTimer.data = (void *)0x0;
  ev_on_timer(&otaTimer, 2000);
  return;
}

void ota_saveUpdateInfo2NV(void *arg)

{
  int iVar1;
  uint uVar2;

  ota_saveUpdateInfo2NV::cnt = ota_saveUpdateInfo2NV::cnt + 1;
  uVar2 = (uint)ota_saveUpdateInfo2NV::cnt;
  iVar1 = FUN_0000162c(g_otaCtx.downloadImageSize, &DAT_000014a0);
  if ((iVar1 + 1U <= uVar2) || (zcl_attr_imageUpgradeStatus == '\x02'))
  {
    ota_saveUpdateInfo2NV::cnt = '\0';
    nv_flashWriteNew('\x01', 5, '\n', 0x15, (u8 *)&otaClientInfo);
  }
  return;
}

u8 mcuBootAddrGet(void)

{
  u8 local_9[5];

  local_9[0] = '\0';
  flash_read(8, 1, local_9);
  return '\x01' - (local_9[0] == 'K');
}

u8 ota_loadImageInfo(ota_hdrFields_t *oh)

{
  bool bVar1;
  ota_hdrFields_t local_50;

  if (oh == (ota_hdrFields_t *)0x0)
  {
    flash_read(((uint)mcuBootAddr + ~(uint)mcuBootAddr + 1) * 0x40000, 0x45, (u8 *)&local_50);
    oh = &local_50;
  }
  bVar1 = oh->otaUpgradeFileID != 0xbeef11e;
  if (!bVar1)
  {
    otaServerBinInfo.fileVer = oh->fileVer;
    otaServerBinInfo.imageType = oh->imageType;
    otaServerBinInfo.manufacturerCode = oh->manufacturerCode;
    otaServerBinInfo.totalImageSize = oh->totalImageSize;
  }
  return bVar1;
}

void ota_clientInfoRecover(void)

{
  nv_sts_t nVar1;
  int *buf;
  int iVar2;

  buf = (int *)ev_buf_allocate(0x51);
  if (buf == (int *)0x0)
  {
    return;
  }
  nVar1 = nv_flashReadNew('\x01', '\x05', '\t', 0x51, (u8 *)buf);
  if (nVar1 == NV_SUCC)
  {
    if (*buf == 0xbeef11e)
    {
      nVar1 = nv_flashReadNew('\x01', '\x05', '\n', 0x15, (u8 *)&otaClientInfo);
      if (nVar1 != NV_SUCC)
        goto LAB_00008304;
      zcl_attr_fileOffset = otaClientInfo.offset;
      zcl_attr_downloadFileVer = *(u32 *)((int)buf + 0xe);
      zcl_attr_downloadZigbeeStackVer = *(u16 *)((int)buf + 0x12);
      zcl_attr_manufacturerID = *(u16 *)((int)buf + 10);
      zcl_attr_imageTypeID = *(u16 *)(buf + 3);
      g_otaCtx.downloadImageSize = buf[0xd];
    }
    iVar2 = memcmp((void *)((int)buf + 0x45), &g_invalid_addr, 8);
    if (iVar2 != 0)
    {
      memcpy(zcl_attr_upgradeServerID, (void *)((int)buf + 0x45), 8);
      g_otaCtx.otaServerEpInfo.profileId = *(u16 *)((int)buf + 0x4d);
      g_otaCtx.otaServerEpInfo.dstEp = *(u8 *)((int)buf + 0x4f);
      g_otaCtx.otaServerEpInfo.txOptions = *(aps_tx_options *)(buf + 0x14);
    }
  }
LAB_00008304:
  ev_buf_free((u8 *)buf);
  return;
}

void ota_init(ota_type_e type, af_simple_descriptor_t *simpleDesc, ota_preamble_t *otaPreamble,
              ota_callBack_t *cb)

{
  otaCb = cb;
  mcuBootAddr = mcuBootAddrGet();
  g_otaCtx.pOtaPreamble = (ota_preamble_t *)0x0;
  g_otaCtx.downloadImageSize = 0;
  g_otaCtx.otaServerEpInfo.dstAddr._0_4_ = 0;
  g_otaCtx.otaServerEpInfo.dstAddr._4_4_ = 0;
  g_otaCtx.otaServerEpInfo._8_4_ = 0;
  g_otaCtx.otaServerEpInfo._12_4_ = 0;
  g_otaCtx._28_4_ = 0;
  otaClientInfo.offset = 0;
  otaClientInfo.crcValue = 0;
  otaClientInfo.otaElementPos = 0;
  otaClientInfo.otaElementLen = 0;
  otaClientInfo._16_4_ = 0;
  otaClientInfo.clientOtaFlg = '\0';
  otaServerBinInfo.fileVer = 0;
  otaServerBinInfo.totalImageSize = 0;
  otaServerBinInfo._8_4_ = 0;
  g_otaCtx.isOtaServer = type + ~OTA_TYPE_SERVER + ~(type + ~OTA_TYPE_SERVER);
  zcl_attr_currZigbeeStackVer = 2;
  zcl_attr_imageUpgradeStatus = '\0';
  g_otaCtx.simpleDesc = simpleDesc;
  zcl_register(simpleDesc->endpoint, OTA_CB_CLUSTER_NUM, g_otaClusterList);
  if (g_otaCtx.isOtaServer == '\0')
  {
    zcl_attr_currFileVer = otaPreamble->fileVer;
    zcl_attr_manufacturerID = otaPreamble->manufacturerCode;
    otaClientInfo.clientOtaFlg = '\0';
    otaClientInfo.crcValue = 0xfffffffe;
    g_otaCtx.pOtaPreamble = otaPreamble;
    ota_clientInfoRecover();
  }
  else
  {
    ota_loadImageInfo((ota_hdrFields_t *)0x0);
  }
  return;
}

void ota_upgradeComplete(u8 status)

{
  if (pOtaUpdateInfo != (ota_updateInfo_t *)0x0)
  {
    ev_buf_free((u8 *)pOtaUpdateInfo);
    pOtaUpdateInfo = (ota_updateInfo_t *)0x0;
  }
  zcl_attr_imageUpgradeStatus = '\0';
  if (status == '\0')
  {
    nv_resetModule('\x05');
    if (otaCb != (ota_callBack_t *)0x0)
    {
      FUNAAAAH();
    }
  }
  else
  {
    if (status == 0x96)
    {
      nv_resetModule('\x05');
      otaClientInfo.offset = 0;
      otaClientInfo.otaElementPos = 0;
      otaClientInfo.otaElementLen = 0;
      otaClientInfo._16_4_ = 0;
      otaClientInfo.clientOtaFlg = '\0';
      otaClientInfo.crcValue = 0xfffffffe;
      zcl_attr_imageTypeID = 0xfffe;
      zcl_attr_fileOffset = 0xfffffffe;
      zcl_attr_downloadFileVer = 0xfffffffe;
    }
    if (otaCb != (ota_callBack_t *)0x0)
    {
      FUNAAAAH();
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 FUNAAAAH(void)

{
  undefined4 uVar1;
  code *in_r3;

  (*in_r3)();
  ota_ieeeAddrRspWait::cnt = ota_ieeeAddrRspWait::cnt + 1;
  if (ota_ieeeAddrRspWait::cnt < 3)
  {
    ota_ieeeAddrReq(g_otaCtx.otaServerEpInfo.dstAddr.shortAddr);
    uVar1 = 0;
  }
  else
  {
    ota_ieeeAddrRspWait::cnt = '\0';
    ota_upgradeComplete(0x95);
    uVar1 = 0xfffffffe;
  }
  return uVar1;
}

s32 ota_ieeeAddrRspWait(void *arg)

{
  s32 sVar1;

  ota_ieeeAddrRspWait::cnt = ota_ieeeAddrRspWait::cnt + 1;
  if (ota_ieeeAddrRspWait::cnt < 3)
  {
    ota_ieeeAddrReq(g_otaCtx.otaServerEpInfo.dstAddr.shortAddr);
    sVar1 = 0;
  }
  else
  {
    ota_ieeeAddrRspWait::cnt = '\0';
    ota_upgradeComplete(0x95);
    sVar1 = -2;
  }
  return sVar1;
}

void ota_imageBlockRspTimeout(void *arg)

{
  ota_upgradeComplete(0x95);
  return;
}

void ota_upgrade(void)

{
  if (zcl_attr_imageUpgradeStatus == '\x02')
  {
    g_otaCtx.upgradeEndRetry = g_otaCtx.upgradeEndRetry + 1;
    if (g_otaCtx.upgradeEndRetry < 2)
    {
      tl_zbTaskPost(ota_upgradeWithWait, &DAT_00000005);
      return;
    }
  }
  else if (zcl_attr_imageUpgradeStatus != '\x04')
  {
    if (zcl_attr_imageUpgradeStatus != '\x03')
    {
      return;
    }
    g_otaCtx.upgradeEndRetry = g_otaCtx.upgradeEndRetry + 1;
    if (g_otaCtx.upgradeEndRetry < 2)
    {
      tl_zbTaskPost(ota_upgradeWithWait, (void *)0xe10);
      return;
    }
  }
  ota_upgradeComplete('\0');
  return;
}

s32 ota_upgradeWaitCb(void *arg)

{
  ota_upgrade();
  return -2;
}

void ota_upgradeWait(u32 seconds)

{
  if (seconds == 0)
  {
    ota_upgrade();
  }
  else
  {
    otaTimer.cb = ota_upgradeWaitCb;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, seconds * 1000);
  }
  return;
}

u8 ota_fileIdCmp(u16 currManuCode, u16 newManuCode, u16 currImageType, u16 newImageType, u32 currFileVer, u32 newFileVer)

{
  byte bVar1;
  u8 uVar2;

  if ((((newManuCode == 0xffff) || (currManuCode == 0xffff)) ||
       (uVar2 = '\0', currManuCode == newManuCode)) &&
      (((newImageType == 0xffff || (currImageType == 0xffff)) ||
        (uVar2 = '\0', currImageType == newImageType))))
  {
    if ((newFileVer == 0xffffffff) || (currFileVer == 0xffffffff))
    {
      uVar2 = '\x01';
    }
    else
    {
      bVar1 = (char)currFileVer - (char)newFileVer;
      uVar2 = bVar1 + ~bVar1 + (newFileVer <= currFileVer);
    }
  }
  return uVar2;
}

// WARNING: Type propagation algorithm not settling

u8 ota_imageDataProcess(u8 len, u8 *pData)

{
  byte bVar1;
  ushort uVar2;
  u32 uVar3;
  bool bVar4;
  ota_updateInfo_t *poVar5;
  u8 uVar6;
  nv_sts_t nVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  int iVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  bool bVar15;
  uint uStack_50;
  uchar auStack_3c[16];
  u32 uStack_2c;
  ushort uStack_26;

  uVar8 = (uint)len;
  uVar6 = 0x95;
  if (((zcl_attr_imageUpgradeStatus != '\x01') || (uVar6 = 0x96, pData == (u8 *)0x0)) ||
      (uVar6 = '\0', uVar8 == 0))
  {
    return uVar6;
  }
  bVar4 = false;
  uVar14 = 0;
  do
  {
    poVar5 = pOtaUpdateInfo;
    switch (otaClientInfo.clientOtaFlg + 0xfd)
    {
    case '\0':
      if (otaHdrMagic[uVar14] != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = otaHdrMagic[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = 0;
      otaClientInfo.clientOtaFlg = '\x04';
      break;
    case '\x01':
      bVar1 = otaHdrMagic[uVar14];
      if (bVar1 != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar3 = (pOtaUpdateInfo->hdrInfo).otaUpgradeFileID;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = (char)uVar3;
      *(byte *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = (byte)(uVar3 >> 8) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = (char)(uVar3 >> 0x10);
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x05';
      break;
    case '\x02':
      bVar1 = otaHdrMagic[uVar14];
      if (bVar1 != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar3 = (pOtaUpdateInfo->hdrInfo).otaUpgradeFileID;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = (char)(uVar3 >> 8);
      *(byte *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = (byte)(uVar3 >> 0x10) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x06';
      break;
    case '\x03':
      bVar1 = otaHdrMagic[uVar14];
      if (bVar1 != pData[uVar14])
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar3 = (pOtaUpdateInfo->hdrInfo).otaUpgradeFileID;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaUpgradeFileID = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 1) = (char)(uVar3 >> 8);
      *(char *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 2) = (char)(uVar3 >> 0x10);
      *(byte *)((int)&(poVar5->hdrInfo).otaUpgradeFileID + 3) = (byte)(uVar3 >> 0x18) | bVar1;
      otaClientInfo.clientOtaFlg = '\a';
      break;
    case '\x04':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaHdrVer = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).otaHdrVer + 1) = 0;
      otaClientInfo.clientOtaFlg = '\b';
      break;
    case '\x05':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).otaHdrVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaHdrVer = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).otaHdrVer + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\t';
      break;
    case '\x06':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      if (zcl_attr_fileOffset == 6)
      {
        *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaHdrLen = pData[uVar14];
        *(undefined *)((int)&(poVar5->hdrInfo).otaHdrLen + 1) = 0;
        otaClientInfo.clientOtaFlg = '\n';
      }
    default:
    switchD_00008744_caseD_1e:
      zcl_attr_fileOffset = zcl_attr_fileOffset + 1;
      if (g_otaCtx.downloadImageSize <= zcl_attr_fileOffset)
        goto LAB_00008760;
      goto LAB_00008726;
    case '\a':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).otaHdrLen;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaHdrLen = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).otaHdrLen + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\v';
      break;
    case '\b':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).otaHdrFC = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).otaHdrFC + 1) = 0;
      otaClientInfo.clientOtaFlg = '\f';
      break;
    case '\t':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).otaHdrFC;
      *(char *)&(pOtaUpdateInfo->hdrInfo).otaHdrFC = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).otaHdrFC + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\r';
      break;
    case '\n':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).manufacturerCode = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).manufacturerCode + 1) = 0;
      otaClientInfo.clientOtaFlg = '\x0e';
      break;
    case '\v':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).manufacturerCode;
      *(char *)&(pOtaUpdateInfo->hdrInfo).manufacturerCode = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).manufacturerCode + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\x0f';
      break;
    case '\f':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).imageType = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).imageType + 1) = 0;
      otaClientInfo.clientOtaFlg = '\x10';
      break;
    case '\r':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar2 = (pOtaUpdateInfo->hdrInfo).imageType;
      *(char *)&(pOtaUpdateInfo->hdrInfo).imageType = (char)uVar2;
      *(byte *)((int)&(poVar5->hdrInfo).imageType + 1) = (byte)((uint)uVar2 >> 8) | bVar1;
      otaClientInfo.clientOtaFlg = '\x11';
      break;
    case '\x0e':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      *(u8 *)&(pOtaUpdateInfo->hdrInfo).fileVer = pData[uVar14];
      *(undefined *)((int)&(poVar5->hdrInfo).fileVer + 1) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).fileVer + 2) = 0;
      *(undefined *)((int)&(poVar5->hdrInfo).fileVer + 3) = 0;
      otaClientInfo.clientOtaFlg = '\x12';
      break;
    case '\x0f':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar3 = (pOtaUpdateInfo->hdrInfo).fileVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).fileVer = (char)uVar3;
      *(byte *)((int)&(poVar5->hdrInfo).fileVer + 1) = (byte)(uVar3 >> 8) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 2) = (char)(uVar3 >> 0x10);
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x13';
      break;
    case '\x10':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar3 = (pOtaUpdateInfo->hdrInfo).fileVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).fileVer = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 1) = (char)(uVar3 >> 8);
      *(byte *)((int)&(poVar5->hdrInfo).fileVer + 2) = (byte)(uVar3 >> 0x10) | bVar1;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 3) = (char)(uVar3 >> 0x18);
      otaClientInfo.clientOtaFlg = '\x14';
      break;
    case '\x11':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      bVar1 = pData[uVar14];
      uVar3 = (pOtaUpdateInfo->hdrInfo).fileVer;
      *(char *)&(pOtaUpdateInfo->hdrInfo).fileVer = (char)uVar3;
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 1) = (char)(uVar3 >> 8);
      *(char *)((int)&(poVar5->hdrInfo).fileVer + 2) = (char)(uVar3 >> 0x10);
      *(byte *)((int)&(poVar5->hdrInfo).fileVer + 3) = (byte)(uVar3 >> 0x18) | bVar1;
      otaClientInfo.clientOtaFlg = '\x15';
      break;
    case '\x12':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      if (zcl_attr_fileOffset == 0x12)
      {
        *(u8 *)&(pOtaUpdateInfo->hdrInfo).zbStackVer = pData[uVar14];
        *(undefined *)((int)&(poVar5->hdrInfo).zbStackVer + 1) = 0;
        otaClientInfo.clientOtaFlg = '\x16';
      }
      goto switchD_00008744_caseD_1e;
    case '\x13':
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      uVar2 = (pOtaUpdateInfo->hdrInfo).zbStackVer;
      uVar10 = (uint)uVar2 | (uint)pData[uVar14] << 8;
      *(char *)&(pOtaUpdateInfo->hdrInfo).zbStackVer = (char)uVar2;
      *(char *)((int)&(poVar5->hdrInfo).zbStackVer + 1) = (char)(uVar10 >> 8);
      if (uVar10 != 2)
      {
        return 0x96;
      }
      zcl_attr_downloadZigbeeStackVer = 2;
      otaClientInfo.clientOtaFlg = '\x17';
      break;
    case '\x14':
      if (0x44 < zcl_attr_fileOffset)
      {
        return 0x96;
      }
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x96;
      }
      (pOtaUpdateInfo->hdrInfo).otaHdrString[zcl_attr_fileOffset - 0x14] = pData[uVar14];
      poVar5 = pOtaUpdateInfo;
      if ((pOtaUpdateInfo->hdrInfo).otaHdrLen - 1 == zcl_attr_fileOffset)
      {
        memcpy(&pOtaUpdateInfo->otaServerAddrInfo, zcl_attr_upgradeServerID, 8);
        *(undefined *)&(poVar5->otaServerAddrInfo).profileId =
            (undefined)g_otaCtx.otaServerEpInfo.profileId;
        *(undefined *)((int)&(poVar5->otaServerAddrInfo).profileId + 1) =
            g_otaCtx.otaServerEpInfo.profileId._1_1_;
        (poVar5->otaServerAddrInfo).endpoint = g_otaCtx.otaServerEpInfo.dstEp;
        (poVar5->otaServerAddrInfo).txOptions = g_otaCtx.otaServerEpInfo.txOptions;
        nVar7 = nv_flashWriteNew('\x01', 5, '\t', 0x51, (u8 *)poVar5);
        if ((ota_updateInfo_t *)(uint)nVar7 != (ota_updateInfo_t *)0x0)
        {
          return 0x96;
        }
        ev_buf_free((u8 *)pOtaUpdateInfo);
        otaClientInfo.clientOtaFlg = '\x18';
        pOtaUpdateInfo = (ota_updateInfo_t *)(uint)nVar7;
      }
      goto switchD_00008744_caseD_1e;
    case '\x15':
      otaClientInfo.otaElementTag = (u16)pData[uVar14];
      otaClientInfo.clientOtaFlg = '\x19';
      break;
    case '\x16':
      otaClientInfo.otaElementTag = otaClientInfo.otaElementTag | (ushort)pData[uVar14] << 8;
      otaClientInfo.otaElementPos = 0;
      otaClientInfo.clientOtaFlg = '\x1a';
      break;
    case '\x17':
      otaClientInfo.otaElementLen = (u32)pData[uVar14];
      otaClientInfo.clientOtaFlg = '\x1b';
      break;
    case '\x18':
      otaClientInfo.otaElementLen = otaClientInfo.otaElementLen | (uint)pData[uVar14] << 8;
      otaClientInfo.clientOtaFlg = '\x1c';
      break;
    case '\x19':
      otaClientInfo.otaElementLen = otaClientInfo.otaElementLen | (uint)pData[uVar14] << 0x10;
      otaClientInfo.clientOtaFlg = '\x1d';
      break;
    case '\x1a':
      otaClientInfo.otaElementLen = (uint)pData[uVar14] << 0x18 | otaClientInfo.otaElementLen;
      otaClientInfo.clientOtaFlg = ' ';
      if (otaClientInfo.otaElementTag == 0xf000)
      {
        otaClientInfo.clientOtaFlg = '\x1e';
      }
      if (g_otaCtx.downloadImageSize - zcl_attr_fileOffset < otaClientInfo.otaElementLen)
      {
        return 0x96;
      }
      if (otaClientInfo.otaElementLen == 0)
      {
        return 0x96;
      }
      goto switchD_00008744_caseD_1e;
    case '\x1b':
      otaClientInfo.otaElementInfo1 = pData[uVar14];
      otaClientInfo.clientOtaFlg = '\x1f';
      break;
    case '\x1c':
      otaClientInfo.otaElementInfo2 = pData[uVar14];
      otaClientInfo.clientOtaFlg = ' ';
      break;
    case '\x1d':
      if (otaClientInfo.otaElementLen == 0)
      {
        return 0x96;
      }
      if (otaClientInfo.otaElementPos > otaClientInfo.otaElementLen)
      {
        return 0x96;
      }
      uVar10 = (uint)otaClientInfo.otaElementTag;
      iVar9 = ~uVar10 + uVar10 + (uint)(otaClientInfo.otaElementPos <= otaClientInfo.otaElementLen);
      iVar11 = (uVar10 - 0xf000) + ~(uVar10 - 0xf000) + (uint)(0xefff < uVar10);
      if (iVar11 == 0)
      {
        if (iVar9 == 0)
        {
          return 0x96;
        }
      LAB_00008bb2:
        if (g_otaEncryptionNeeded != '\0')
        {
          return 0x96;
        }
      }
      else if (iVar9 != 0)
        goto LAB_00008bb2;
      uVar10 = uVar8 - uVar14 & 0xff;
      uStack_50 = uVar10;
      if (otaClientInfo.otaElementLen - otaClientInfo.otaElementPos < uVar10)
      {
        uStack_50 = otaClientInfo.otaElementLen - otaClientInfo.otaElementPos & 0xff;
      }
      if ((iVar11 != 0) && (uStack_50 != 0))
      {
        uVar12 = 0;
        do
        {
          memset(auStack_3c, 0xff, 0x10);
          memcpy(auStack_3c, pData + uVar12 + uVar14, 0x10);
          aes_decrypt("", auStack_3c, pData + uVar12 + uVar14);
          uVar12 = uVar12 + 0x10 & 0xff;
        } while (uVar12 < uStack_50);
      }
      iVar9 = otaClientInfo.otaElementLen - otaClientInfo.otaElementInfo2;
      uVar13 = iVar9 - otaClientInfo.otaElementPos;
      uVar12 = 0;
      if ((4 < uVar13) && (uVar13 = uVar13 - 4, uVar12 = uVar10, uVar13 < uVar10))
      {
        uVar12 = uVar13 & 0xff;
      }
      otaClientInfo.crcValue = xcrc32(pData + uVar14, uVar12, otaClientInfo.crcValue);
      bVar15 = 7 < otaClientInfo.otaElementPos;
      if ((otaClientInfo.otaElementPos < 9) &&
          (bVar15 = 7 < uVar10 + otaClientInfo.otaElementPos,
           8 < uVar10 + otaClientInfo.otaElementPos))
      {
        bVar1 = pData[(uVar14 - otaClientInfo.otaElementPos) + 8];
        bVar15 = 0x4a < bVar1;
        if (bVar1 != 0x4b)
        {
          return 0x96;
        }
        pData[(uVar14 - otaClientInfo.otaElementPos) + 8] = 0xff;
      }
      iVar11 = ((uint)mcuBootAddr + ~(uint)mcuBootAddr + (uint)bVar15) * 0x40000;
      uVar6 = flash_writeWithCheck(otaClientInfo.otaElementPos + iVar11, uStack_50, pData + uVar14);
      if (uVar6 != '\x01')
      {
        return 0x96;
      }
      otaClientInfo.otaElementPos = otaClientInfo.otaElementPos + uStack_50;
      zcl_attr_fileOffset = zcl_attr_fileOffset + uStack_50;
      otaClientInfo.offset = zcl_attr_fileOffset;
      if (otaClientInfo.otaElementPos == otaClientInfo.otaElementLen)
      {
        uStack_26 = 0;
        flash_read(iVar11 + 6, 2, (u8 *)&uStack_26);
        if ((uStack_26 & 0xff) != 0x5d)
        {
          return 0x96;
        }
        if (uStack_26 >> 8 != 2)
        {
          return 0x96;
        }
        flash_read(iVar9 + -4 + iVar11, 4, (u8 *)&uStack_2c);
        if (otaClientInfo.crcValue != uStack_2c)
        {
          return 0x96;
        }
        otaClientInfo.clientOtaFlg = '\x18';
        bVar4 = true;
      }
      uVar12 = uVar8 - 1;
      if (uStack_50 != uVar10)
      {
        uVar12 = (uVar14 - 1 & 0xff) + uStack_50;
      }
      uVar14 = uVar12 & 0xff;
      zcl_attr_fileOffset = zcl_attr_fileOffset - 1;
      goto switchD_00008744_caseD_1e;
    }
    zcl_attr_fileOffset = zcl_attr_fileOffset + 1;
    if (g_otaCtx.downloadImageSize <= zcl_attr_fileOffset)
    {
    LAB_00008760:
      if (!bVar4)
      {
        return 0x96;
      }
      zcl_attr_imageUpgradeStatus = '\x02';
      return '\0';
    }
  LAB_00008726:
    uVar14 = uVar14 + 1 & 0xff;
    if (uVar8 <= uVar14)
    {
      return '\0';
    }
  } while (true);
}

void ota_queryNextImageReq(u8 dstEp, u16 dstAddr, u16 profileId)

{
  u8 seqNo;
  uint local_3c;
  undefined4 uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  ushort local_2c;
  undefined auStack_28[8];
  ushort local_20;
  undefined local_1e;

  seqNo = zcl_seqNum;
  local_1e = 0;
  auStack_28._0_4_ =
      (uint)(g_otaCtx.pOtaPreamble)->manufacturerCode << 8 |
      (uint)(byte)(g_otaCtx.pOtaPreamble)->imageType << 0x18;
  auStack_28._4_4_ =
      zcl_attr_currFileVer << 8 | (uint)(byte)((g_otaCtx.pOtaPreamble)->imageType >> 8);
  local_20 = (ushort)zcl_attr_currFileVer._3_1_;
  uStack_38 = 0;
  local_3c = (uint)dstAddr;
  uStack_30 = CONCAT13(dstEp, 0x20000);
  uStack_34 = (uint)profileId;
  local_2c = g_otaCtx.otaServerEpInfo.txOptions | 4;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_ota_queryNextImageReqSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_3c, '\0', seqNo,
                                (ota_queryNextImageReq_t *)auStack_28);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void ota_imageBlockReq(u8 dstEp, u16 dstAddr, u16 profileId)

{
  u8 seqNo;
  uint uVar1;
  undefined local_44[8];
  uint uStack_3c;
  uint uStack_38;
  undefined4 uStack_34;
  int iStack_30;
  uint local_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  ushort local_1c;

  seqNo = zcl_seqNum;
  uStack_34 = 0;
  local_44._0_4_ =
      (uint)(g_otaCtx.pOtaPreamble)->manufacturerCode << 8 | 2 |
      (uint)(byte)(g_otaCtx.pOtaPreamble)->imageType << 0x18;
  local_44._4_4_ =
      zcl_attr_downloadFileVer << 8 | (uint)(byte)((g_otaCtx.pOtaPreamble)->imageType >> 8);
  uStack_3c = zcl_attr_fileOffset << 8 | zcl_attr_downloadFileVer >> 0x18;
  uVar1 = g_otaCtx.downloadImageSize - zcl_attr_fileOffset;
  if (0x2f < uVar1)
  {
    uVar1 = 0x30;
  }
  uStack_38 = (uint)CONCAT11((char)uVar1, (char)(zcl_attr_fileOffset >> 0x18));
  iStack_30 = (uint)zcl_attr_minBlockPeriod << 0x10;
  uStack_28 = 0;
  local_2c = (uint)dstAddr;
  uStack_20 = CONCAT13(dstEp, 0x20000);
  uStack_24 = (uint)profileId;
  local_1c = g_otaCtx.otaServerEpInfo.txOptions | 4;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_ota_imageBlockReqSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_2c, '\0', seqNo,
                            (ota_imageBlockReq_t *)local_44);
  return;
}

void sendImageBlockReq(void *arg)

{
  ota_imageBlockReq(g_otaCtx.otaServerEpInfo.dstEp, g_otaCtx.otaServerEpInfo.dstAddr.shortAddr,
                    g_otaCtx.otaServerEpInfo.profileId);
  otaTimer.cb = ota_imageBlockRspWait;
  otaTimer.data = (void *)0x0;
  ev_on_timer(&otaTimer, (u32)&DAT_00001388);
  return;
}

void ota_sendImageBlockReq(void *arg)

{
  if (zcl_attr_minBlockPeriod == 0)
  {
    sendImageBlockReq((void *)0x0);
  }
  else
  {
    otaTimer.cb = ota_sendImageBlockReqDelay;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, (uint)zcl_attr_minBlockPeriod);
  }
  return;
}

void ota_ieeeAddrRspCb(void *arg)

{
  int iVar1;

  // WARNING: Load size is inaccurate
  iVar1 = *arg;
  if (*(char *)(iVar1 + 1) == '\0')
  {
    memcpy(zcl_attr_upgradeServerID, (void *)(iVar1 + 2), 8);
  }
  if ((zcl_attr_imageUpgradeStatus == '\x01') && (otaClientInfo.clientOtaFlg < 3))
  {
    ev_unon_timer(&otaTimer);
    if (*(char *)(iVar1 + 1) == '\0')
    {
      ota_sendImageBlockReq((void *)0x0);
      otaClientInfo.clientOtaFlg = '\x03';
      if (otaCb != (ota_callBack_t *)0x0)
      {
        FUNAAAAJ();
      }
    }
    else
    {
      ota_upgradeComplete(0x95);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAJ(void)

{
  int iVar1;
  code *in_r3;

  iVar1 = (*in_r3)();
  if (iVar1 == 0)
  {
    ota_sendImageBlockReq((void *)0x0);
  }
  else
  {
    otaTimer.cb = ota_imageBlockWaitCb;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, iVar1 * 1000);
  }
  return;
}

void ota_imageBlockWait(u32 seconds)

{
  if (seconds == 0)
  {
    ota_sendImageBlockReq((void *)0x0);
  }
  else
  {
    otaTimer.cb = ota_imageBlockWaitCb;
    otaTimer.data = (void *)0x0;
    ev_on_timer(&otaTimer, seconds * 1000);
  }
  return;
}

void ota_upgradeEndReqSend(ota_upgradeEndReq_t *req)

{
  u8 seqNo;
  uint local_20;
  undefined4 uStack_1c;
  uint uStack_18;
  undefined4 uStack_14;
  ushort local_10;

  seqNo = zcl_seqNum;
  uStack_1c = 0;
  local_20 = (uint)g_otaCtx.otaServerEpInfo.dstAddr.shortAddr;
  uStack_14 = CONCAT13(g_otaCtx.otaServerEpInfo.dstEp, 0x20000);
  uStack_18 = (uint)g_otaCtx.otaServerEpInfo.profileId;
  local_10 = g_otaCtx.otaServerEpInfo.txOptions | 4;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_ota_upgradeEndReqSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_20, '\0', seqNo, req);
  return;
}

void ota_upgradeWithWait(void *arg)

{
  undefined local_14[5];
  undefined3 uStack_f;
  undefined uStack_c;

  uStack_c = zcl_attr_downloadFileVer._3_1_;
  stack0xfffffff0 = CONCAT31((int3)zcl_attr_downloadFileVer, zcl_attr_imageTypeID._1_1_);
  local_14._0_4_ = (uint)(byte)zcl_attr_imageTypeID << 0x18 | (uint)zcl_attr_manufacturerID << 8;
  ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_14);
  ota_upgradeWait((u32)arg);
  return;
}

s32 ota_imageBlockRspWait(void *arg)

{
  undefined local_10[5];
  undefined3 uStack_b;
  undefined uStack_8;

  g_otaCtx.imageBlockRetry = g_otaCtx.imageBlockRetry + 1;
  if (g_otaCtx.imageBlockRetry < 10)
  {
    tl_zbTaskPost(ota_sendImageBlockReq, (void *)0x0);
  }
  else
  {
    uStack_8 = zcl_attr_downloadFileVer._3_1_;
    local_10._0_4_ = (uint)(byte)zcl_attr_imageTypeID << 0x18 | 0x95;
    stack0xfffffff4 = CONCAT31((int3)zcl_attr_downloadFileVer, zcl_attr_imageTypeID._1_1_);
    local_10._0_4_ = local_10._0_4_ | (uint)zcl_attr_manufacturerID << 8;
    ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_10);
    tl_zbTaskPost(ota_imageBlockRspTimeout, (void *)0x0);
  }
  return -2;
}

// WARNING: Type propagation algorithm not settling

status_t zcl_otaCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  char cVar1;
  uint uVar2;
  u16 uVar3;
  u8 uVar4;
  byte status;
  status_t sVar5;
  ushort uVar6;
  int iVar7;
  addrExt_t *m2;
  u8 *buf;
  undefined2 *puVar8;
  undefined2 *extraout_r2;
  u8 *puVar9;
  u32 *puVar10;
  undefined uVar11;
  u32 uVar12;
  u32 *puVar13;
  ota_ctx_t *poVar14;
  u8 *unaff_sl;
  byte bVar15;
  uint local_a4;
  undefined4 uStack_a0;
  uint uStack_9c;
  undefined4 uStack_98;
  undefined2 local_94;
  undefined local_90[8];
  uint uStack_88;
  undefined uStack_84;
  byte bStack_83;
  undefined2 uStack_82;
  undefined2 uStack_80;
  uint local_7c;
  undefined4 uStack_78;
  uint uStack_74;
  undefined4 uStack_70;
  undefined2 local_6c;
  uint local_68;
  undefined4 uStack_64;
  uint uStack_60;
  undefined4 uStack_5c;
  undefined2 local_58;
  ota_upgradeEndRsp_t local_54;
  undefined local_44[8];
  uint uStack_3c;
  undefined uStack_38;
  undefined local_34[8];
  undefined uStack_2c;
  u32 uStack_28;
  ushort local_22;

  poVar14 = &g_otaCtx;
  if (pAddrInfo->dstEp != (g_otaCtx.simpleDesc)->endpoint)
  {
    return '\0';
  }
  bVar15 = pAddrInfo->field_0x9;
  if ((bVar15 & 1) == 0)
  {
    if (cmdId != '\x03')
    {
      if (cmdId == '\x06')
      {
        // WARNING: Load size is inaccurate
        if (*cmdPayload != '\0')
        {
          return '\0';
        }
        local_54.fileVer = *(u32 *)((int)cmdPayload + 5);
        local_54.imageType = *(u16 *)((int)cmdPayload + 3);
        local_54.manuCode = *(u16 *)((int)cmdPayload + 1);
        local_54.currentTime = 0;
        local_54.upgradeTime = 0x3c;
        uStack_78 = 0;
        local_6c = 0;
        local_7c = (uint)pAddrInfo->srcAddr;
        uStack_70 = CONCAT13(pAddrInfo->srcEp, 0x20000);
        uStack_74 = (uint)pAddrInfo->profileId;
        zcl_ota_upgradeEndRspSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_7c, '\x01', pAddrInfo->seqNum,
                                  &local_54);
        return 0xff;
      }
      if (cmdId != '\x01')
      {
        return 0x81;
      }
      uVar3 = *(u16 *)((int)cmdPayload + 3);
      uVar11 = 0x98;
      if (((otaServerBinInfo.manufacturerCode == *(u16 *)((int)cmdPayload + 1)) &&
           (otaServerBinInfo.imageType == uVar3)) &&
          (uVar11 = 0, otaServerBinInfo.fileVer == *(u32 *)((int)cmdPayload + 5)))
      {
        uVar11 = 0x98;
      }
      local_44._0_4_ = CONCAT13((char)uVar3, CONCAT21(*(u16 *)((int)cmdPayload + 1), uVar11));
      local_44._4_4_ = otaServerBinInfo.fileVer << 8 | (uint)(byte)(uVar3 >> 8);
      uStack_3c = otaServerBinInfo.totalImageSize << 8 | otaServerBinInfo.fileVer >> 0x18;
      uStack_38 = otaServerBinInfo.totalImageSize._3_1_;
      uStack_64 = 0;
      local_68 = (uint)pAddrInfo->srcAddr;
      uStack_5c = CONCAT13(pAddrInfo->srcEp, 0x20000);
      uStack_60 = (uint)pAddrInfo->profileId;
      local_58 = 4;
      zcl_ota_queryNextImageRspSend((g_otaCtx.simpleDesc)->endpoint, (epInfo_t *)&local_68, '\x01', pAddrInfo->seqNum,
                                    (ota_queryNextImageRsp_t *)local_44);
      return 0xff;
    }
    if (otaServerBinInfo.manufacturerCode != *(u16 *)((int)cmdPayload + 1))
    {
      return 0x98;
    }
    if (otaServerBinInfo.fileVer != *(u32 *)((int)cmdPayload + 5))
    {
      return 0x98;
    }
    if (otaServerBinInfo.imageType != *(u16 *)((int)cmdPayload + 3))
    {
      return 0x98;
    }
    // WARNING: Load size is inaccurate
    if (((int)((uint)*cmdPayload << 0x1e) < 0) &&
        ((uint) * (ushort *)((int)cmdPayload + 0x16) != (uint)zcl_attr_minBlockPeriod))
    {
      local_90._0_4_ = 0x97;
      local_90._4_4_ = (uint)(bVar15 & 1);
      uStack_88 = (uint)zcl_attr_minBlockPeriod << 8 |
                  (uStack_88 & 0xffffff00 | (uint)bVar15) & 0xff000001;
      unaff_sl = (u8 *)0x0;
      goto LAB_0000953e;
    }
    bVar15 = *(byte *)((int)cmdPayload + 0xd);
    if (0x30 < bVar15)
    {
      bVar15 = 0x30;
    }
    buf = ev_buf_allocate((ushort)bVar15);
    unaff_sl = buf;
    if (buf != (u8 *)0x0)
    {
      flash_read(((uint)mcuBootAddr + ~(uint)mcuBootAddr + 1) * 0x40000 +
                     *(int *)((int)cmdPayload + 9),
                 (uint)bVar15, buf);
      local_90._0_4_ =
          (uint) * (ushort *)((int)cmdPayload + 1) << 8 |
          (uint)(byte) * (undefined2 *)((int)cmdPayload + 3) << 0x18;
      local_90._4_4_ =
          otaServerBinInfo.fileVer << 8 |
          (uint)(byte)((ushort) * (undefined2 *)((int)cmdPayload + 3) >> 8);
      uStack_84 = *(undefined *)((int)cmdPayload + 0xc);
      uStack_88 = CONCAT31(*(undefined3 *)((int)cmdPayload + 9), otaServerBinInfo.fileVer._3_1_);
      uStack_82 = SUB42(buf, 0);
      uStack_80 = (undefined2)((uint)buf >> 0x10);
      bStack_83 = bVar15;
      goto LAB_0000953e;
    }
  }
  else
  {
    if (cmdId == '\x02')
    {
      if (zcl_attr_imageUpgradeStatus == '\x01')
      {
        return '\0';
      }
      g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
      g_otaCtx.otaServerEpInfo.dstAddr.shortAddr = pAddrInfo->srcAddr;
      g_otaCtx.otaServerEpInfo.dstEp = pAddrInfo->srcEp;
      g_otaCtx.otaServerEpInfo.profileId = pAddrInfo->profileId;
      g_otaCtx.otaServerEpInfo.radius = '\0';
      g_otaCtx.imageBlockRetry = '\0';
      // WARNING: Load size is inaccurate
      if (*cmdPayload != '\0')
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (*(u16 *)((int)cmdPayload + 3) != (g_otaCtx.pOtaPreamble)->imageType)
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (*(u16 *)((int)cmdPayload + 1) != (g_otaCtx.pOtaPreamble)->manufacturerCode)
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (*(u32 *)((int)cmdPayload + 5) == (g_otaCtx.pOtaPreamble)->fileVer)
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return '\0';
      }
      if (0x34000 < *(uint *)((int)cmdPayload + 9))
      {
        g_otaCtx.otaServerEpInfo.dstAddrMode = '\x02';
        g_otaCtx.otaServerEpInfo.radius = '\0';
        g_otaCtx.imageBlockRetry = '\0';
        return 0x89;
      }
      zcl_attr_imageUpgradeStatus = '\x01';
      ev_unon_timer(&otaTimer);
      if (g_otaCtx.downloadImageSize == *(u32 *)((int)cmdPayload + 9))
      {
        if (zcl_attr_imageTypeID == *(u16 *)((int)cmdPayload + 3))
        {
          puVar13 = &zcl_attr_downloadFileVer;
          if ((*(u32 *)((int)cmdPayload + 5) == zcl_attr_downloadFileVer) &&
              (0x1000 < zcl_attr_fileOffset))
          {
            if (g_otaCtx.downloadImageSize == otaClientInfo.offset)
            {
              bVar15 = otaClientInfo.otaElementLen <= otaClientInfo.otaElementPos;
              if (otaClientInfo.otaElementPos != otaClientInfo.otaElementLen)
                goto LAB_00009696;
            }
            else
            {
              ota_sendImageBlockReq((void *)0x0);
              puVar13 = (u32 *)0x0;
              bVar15 = 1;
              if (otaCb != (ota_callBack_t *)0x0)
                goto LAB_0000974a;
              FUN_0000918e();
            }
            iVar7 = ((uint)mcuBootAddr + ~(uint)mcuBootAddr + (uint)bVar15) * 0x40000;
            local_22 = 0;
            flash_read(iVar7 + 6, 2, (u8 *)&local_22);
            if ((((local_22 & 0xff) == 0x5d) && (local_22 >> 8 == 2)) &&
                (flash_read(((otaClientInfo.otaElementLen - 4) - (uint)otaClientInfo.otaElementInfo2) + iVar7, 4, (u8 *)&uStack_28), otaClientInfo.crcValue == uStack_28))
            {
              ota_upgradeComplete('\0');
              puVar8 = (undefined2 *)FUN_0000918e();
              *puVar8 = 0x2010;
              *extraout_r2 = (short)puVar8;
              sVar5 = FUN_00009f52();
              return sVar5;
            }
          }
        }
        else
        {
          puVar13 = &zcl_attr_downloadFileVer;
        }
      }
      else
      {
        puVar13 = &zcl_attr_downloadFileVer;
      }
    LAB_00009696:
      unaff_sl = &mcuBootAddr;
      puVar10 = &zcl_attr_fileOffset;
      zcl_attr_fileOffset = 0;
      otaClientInfo.crcValue = 0xfffffffe;
      zcl_attr_imageTypeID = *(u16 *)((int)cmdPayload + 3);
      *puVar13 = *(u32 *)((int)cmdPayload + 5);
      g_otaCtx.downloadImageSize = *(uint *)((int)cmdPayload + 9);
      poVar14 = (ota_ctx_t *)((g_otaCtx.downloadImageSize >> 0xc) + 1 & 0xffff);
      uVar12 = ((uint)mcuBootAddr + ~(uint)mcuBootAddr) * 0x40000;
      if (poVar14 != (ota_ctx_t *)0x0)
      {
        puVar10 = (u32 *)0x0;
        do
        {
          flash_erase(uVar12);
          puVar10 = (u32 *)((uint)((int)(af_simple_descriptor_t **)puVar10 + 1) & 0xffff);
          uVar12 = uVar12 + 0x1000;
        } while (puVar10 < poVar14);
      }
      pOtaUpdateInfo = (ota_updateInfo_t *)ev_buf_allocate(0x51);
      if (pOtaUpdateInfo == (ota_updateInfo_t *)0x0)
      {
        return 0x89;
      }
      memset(pOtaUpdateInfo, 0, 0x51);
      iVar7 = memcmp(zcl_attr_upgradeServerID, &g_invalid_addr, 8);
      puVar9 = (u8 *)puVar10;
      if (iVar7 != 0)
      {
        ota_sendImageBlockReq((void *)0x0);
        otaClientInfo.clientOtaFlg = '\x03';
        if (otaCb == (ota_callBack_t *)0x0)
        {
          otaClientInfo.clientOtaFlg = '\x03';
          return '\0';
        }
      LAB_0000974a:
        FUNAAAAK();
        return '\0';
      }
    }
    else
    {
      if (cmdId < 3)
      {
        if (cmdId != '\0')
        {
          return 0x81;
        }
        iVar7 = memcmp(zcl_attr_upgradeServerID, &g_invalid_addr, 8);
        if (((iVar7 != 0) &&
             (m2 = tl_zbExtAddrPtrByShortAddr(pAddrInfo->srcAddr), m2 != (addrExt_t *)0x0)) &&
            (iVar7 = memcmp(zcl_attr_upgradeServerID, m2, 8), iVar7 != 0))
        {
          return 0xff;
        }
        if (zcl_attr_imageUpgradeStatus != '\0')
        {
          return '\x01';
        }
        if ((pAddrInfo->dstAddr & 0xfff8) == 0xfff8)
        {
          // WARNING: Load size is inaccurate
          bVar15 = *cmdPayload;
          if (bVar15 != 0)
          {
            if (*(u16 *)((int)cmdPayload + 2) != (g_otaCtx.pOtaPreamble)->manufacturerCode)
            {
              return '\0';
            }
            if (1 < bVar15)
            {
              if (*(u16 *)((int)cmdPayload + 4) != (g_otaCtx.pOtaPreamble)->imageType)
              {
                return '\0';
              }
              if ((bVar15 != 2) && (*(u32 *)((int)cmdPayload + 6) == zcl_attr_currFileVer))
              {
                return '\0';
              }
            }
          }
          uVar12 = drv_u32Rand();
          uVar6 = FUN_00001628(uVar12 & 0xffff, 100);
          if (*(byte *)((int)cmdPayload + 1) < uVar6)
          {
            return '\0';
          }
        }
        if ((int)((uint)(byte)pAddrInfo->field_0x9 << 0x1e) < 0)
        {
          g_otaCtx.otaServerEpInfo.txOptions =
              g_otaCtx.otaServerEpInfo.txOptions | APS_TX_OPT_SECURITY_ENABLED;
        }
        else
        {
          g_otaCtx.otaServerEpInfo.txOptions =
              g_otaCtx.otaServerEpInfo.txOptions & ~APS_TX_OPT_SECURITY_ENABLED;
        }
        ota_queryNextImageReq(pAddrInfo->srcEp, pAddrInfo->srcAddr, pAddrInfo->profileId);
        return 0xff;
      }
      if (cmdId != '\x05')
      {
        if (cmdId != '\a')
        {
          return 0x81;
        }
        if (zcl_attr_imageUpgradeStatus != '\x02')
        {
          if (zcl_attr_imageUpgradeStatus != '\x03')
          {
            return '\0';
          }
          if (*(int *)((int)cmdPayload + 0xc) == -1)
          {
            return '\0';
          }
        }
        // WARNING: Load size is inaccurate
        uVar4 = ota_fileIdCmp((g_otaCtx.pOtaPreamble)->manufacturerCode, *cmdPayload,
                              (g_otaCtx.pOtaPreamble)->imageType, *(u16 *)((int)cmdPayload + 2),
                              zcl_attr_downloadFileVer, *(u32 *)((int)cmdPayload + 4));
        if (uVar4 == '\0')
        {
          return '\0';
        }
        uVar2 = *(uint *)((int)cmdPayload + 0xc);
        if (uVar2 == 0xffffffff)
        {
          zcl_attr_imageUpgradeStatus = '\x03';
          ota_upgradeWait(0xe10);
          g_otaCtx.upgradeEndRetry = '\0';
        }
        else
        {
          uVar12 = 0;
          if (*(uint *)((int)cmdPayload + 8) < uVar2)
          {
            uVar12 = uVar2 - *(uint *)((int)cmdPayload + 8);
          }
          zcl_attr_imageUpgradeStatus = '\x04';
          ota_upgradeWait(uVar12);
        }
        if (otaCb == (ota_callBack_t *)0x0)
        {
          return '\0';
        }
        FUNAAAAK();
        return '\0';
      }
      puVar9 = &zcl_attr_imageUpgradeStatus;
      if (zcl_attr_imageUpgradeStatus != '\x01')
      {
        return '\0';
      }
      // WARNING: Load size is inaccurate
      cVar1 = *cmdPayload;
      if (cVar1 == '\0')
      {
        bVar15 = 0x96;
        if (((*(u16 *)((int)cmdPayload + 3) == (g_otaCtx.pOtaPreamble)->imageType) &&
             (*(u16 *)((int)cmdPayload + 1) == (g_otaCtx.pOtaPreamble)->manufacturerCode)) &&
            (*(u32 *)((int)cmdPayload + 5) == zcl_attr_downloadFileVer))
        {
          if (*(u32 *)((int)cmdPayload + 9) != zcl_attr_fileOffset)
          {
            return '\0';
          }
          ev_unon_timer(&otaTimer);
          g_otaCtx.imageBlockRetry = '\0';
          bVar15 = ota_imageDataProcess(*(u8 *)((int)cmdPayload + 0xd), *(u8 **)((int)cmdPayload + 0xe));
          status = bVar15;
          if (bVar15 == 0)
          {
            tl_zbTaskPost(ota_saveUpdateInfo2NV, (void *)0x0);
            if (zcl_attr_imageUpgradeStatus != '\x02')
              goto LAB_000098ce;
            uStack_2c = *(undefined *)((int)cmdPayload + 8);
            local_34._4_4_ =
                CONCAT31(*(undefined3 *)((int)cmdPayload + 5),
                         (char)((ushort) * (undefined2 *)((int)cmdPayload + 3) >> 8));
            local_34._0_4_ =
                (uint)(byte) * (undefined2 *)((int)cmdPayload + 3) << 0x18 |
                (uint) * (ushort *)((int)cmdPayload + 1) << 8;
            ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_34);
            g_otaCtx.upgradeEndRetry = '\0';
            ota_upgradeWait(5);
            status = FUN_0000918e();
          }
          ota_upgradeComplete(status);
        }
        zcl_attr_imageUpgradeStatus = '\0';
        uStack_2c = *(undefined *)((int)cmdPayload + 8);
        local_34._0_4_ = CONCAT13((char)*(undefined2 *)((int)cmdPayload + 3), (uint3)bVar15);
        local_34._4_4_ =
            CONCAT31(*(undefined3 *)((int)cmdPayload + 5),
                     (char)((ushort) * (undefined2 *)((int)cmdPayload + 3) >> 8));
        local_34._0_4_ = local_34._0_4_ | (uint) * (ushort *)((int)cmdPayload + 1) << 8;
        ota_upgradeEndReqSend((ota_upgradeEndReq_t *)local_34);
        return '\0';
      }
      if (cVar1 != -0x69)
      {
        if (cVar1 != -0x6b)
        {
          return 0x80;
        }
        zcl_attr_imageUpgradeStatus = '\0';
        ev_unon_timer(&otaTimer);
        g_otaCtx.imageBlockRetry = '\0';
        ota_upgradeComplete(0x95);
        return '\0';
      }
      ev_unon_timer(&otaTimer);
      if (*(int *)((int)cmdPayload + 5) == *(int *)((int)cmdPayload + 1))
      {
        zcl_attr_minBlockPeriod = *(u16 *)((int)cmdPayload + 9);
      LAB_000098ce:
        ota_sendImageBlockReq((void *)0x0);
        return '\0';
      }
      g_otaCtx.imageBlockRetry = '\0';
      ota_imageBlockWait(*(int *)((int)cmdPayload + 5) - *(int *)((int)cmdPayload + 1));
      FUN_0000918e();
    }
    tl_zbTaskPost(ota_ieeeAddrReqSend, (void *)0x0);
    buf = (u8 *)FUN_0000918e();
    pAddrInfo = (zclIncomingAddrInfo_t *)puVar9;
  }
  local_90._0_4_ = 0x97;
  local_90._4_4_ = (uint)buf & 0xff;
  uStack_88 = uStack_88 & 0xff000000 | (uint)buf & 0xff | (uint)zcl_attr_minBlockPeriod << 8;
LAB_0000953e:
  uStack_a0 = 0;
  local_94 = 0;
  local_a4 = (uint) * (ushort *)&((ota_ctx_t *)pAddrInfo)->simpleDesc;
  uStack_98 = CONCAT13(((ota_ctx_t *)pAddrInfo)->pOtaPreamble, 0x20000);
  uStack_9c = (uint) * (ushort *)&((ota_ctx_t *)pAddrInfo)->simpleDesc;
  zcl_ota_imageBlockRspSend(poVar14->simpleDesc->endpoint, (epInfo_t *)&local_a4, '\x01',
                            *(u8 *)&((ota_ctx_t *)pAddrInfo)->downloadImageSize, (ota_imageBlockRsp_t *)local_90);
  if (unaff_sl != (u8 *)0x0)
  {
    ev_buf_free(unaff_sl);
  }
  return 0xff;
}

undefined4 FUN_0000918e(void)

{
  undefined4 unaff_r5;

  return unaff_r5;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAK(void)

{
  code *in_r3;
  undefined4 in_lr;

  (*in_r3)();
  sum_rssi = ((int)((DAT_00800441 - 0x6e) * 0x1000000) >> 0x18) + sum_rssi;
  cnt_rssi = cnt_rssi + 1;
  if (0xfffffd < cnt_rssi)
  {
    sum_rssi = FUN_00001624(sum_rssi, cnt_rssi, cnt_rssi, 0xfffffd, in_lr);
    cnt_rssi = 1;
  }
  return;
}

void rf_edDetect(void)

{
  sum_rssi = ((int)((DAT_00800441 - 0x6e) * 0x1000000) >> 0x18) + sum_rssi;
  cnt_rssi = cnt_rssi + 1;
  if (0xfffffd < cnt_rssi)
  {
    sum_rssi = FUN_00001624(sum_rssi, cnt_rssi);
    cnt_rssi = 1;
  }
  return;
}

u8 rf_TrxStateGet(void)

{
  return rfMode;
}

void rf_setChannel(u8 chn)

{
  int iVar1;
  u32 en;

  iVar1 = (uint)chn * 0x1000000;
  if (iVar1 + 0xf5000000U >> 0x18 < 0x10)
  {
    g_zbInfo.macPib.phyChannelCur = (u8)((uint)iVar1 >> 0x18);
    en = drv_disable_irq();
    iVar1 = rf_trx_state_get();
    rf_trx_state_set((RF_StatusTypeDef)iVar1, (char)(((uint)chn * 5 + -0x32) * 0x1000000 >> 0x18));
    if ((iVar1 - 1U & 0xff) < 2)
    {
      rfMode = '\x01';
    }
    else if ((iVar1 == 0) || (iVar1 == 3))
    {
      rfMode = (RF_StatusTypeDef)iVar1;
    }
    drv_restore_irq(en);
  }
  return;
}

u8 rf_getChannel(void)

{
  return g_zbInfo.macPib.phyChannelCur;
}

void rf_setTxPower(u8 power)

{
  rf_set_power_level_index();
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void rf_reset(void)

{
  rf_setTrxState('\0');
  rf_setTxPower(g_zb_txPowerSet);
  rf_setChannel(g_zbInfo.macPib.phyChannelCur);
  if (rf_rxBuf == (u8 *)0x0)
  {
    rf_rxBuf = tl_getRxBuf();
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  else
  {
    *rf_rxBuf = '\0';
    rf_rxBuf[4] = '\0';
  }
  _DAT_00800c08 = rf_rxBuf._0_2_;
  DAT_00800f03 = DAT_00800f03 & 0xfb;
  rf_rx_cf();
  DAT_00800c21 = DAT_00800c21 & 0xf3;
  _DAT_00800f1c = _DAT_00800f1c & 0xe000 | 3;
  _DAT_00800640 = _DAT_00800640 | 0x2000;
  DAT_00800c20 = DAT_00800c20 | 0xc;
  DAT_00800430 = DAT_00800430 | 2;
  return;
}

void rf_init(void)

{
  rf_reset();
  rf_ack_buf._8_4_ = 0;
  rf_ack_buf._0_4_ = 4;
  rf_ack_buf._4_4_ = 0x205;
  ev_on_poll(EV_POLL_ED_DETECT, rf_edDetect);
  ev_disable_poll(EV_POLL_ED_DETECT);
  return;
}

u8 rf_getLqi(s8 rssi)

{
  u8 uVar1;
  int iVar2;

  iVar2 = (int)rssi;
  if (iVar2 + 0xe < 0 == SCARRY4(iVar2, 0xe))
  {
    iVar2 = -0x10;
  }
  else if (iVar2 + 99 < 0 != SCARRY4(iVar2, 99))
  {
    return '\0';
  }
  uVar1 = FUN_00001624((iVar2 + 99) * 0xff, 0x54);
  return uVar1;
}

u8 rf_lqi2cost(u8 lqi)

{
  u8 uVar1;

  uVar1 = '\x01';
  if ((((lqi < 0x77) && (uVar1 = '\x02', lqi < 0x5f)) && (uVar1 = '\x03', lqi < 0x46)) &&
      (uVar1 = '\a', 0x2d < lqi))
  {
    uVar1 = '\x05';
  }
  return uVar1;
}

void rf_startED(void)

{
  soft_rssi = -0x6e;
  sum_rssi = 0;
  cnt_rssi = 0;
  ev_enable_poll(EV_POLL_ED_DETECT);
  rf_setTrxState('\x02');
  return;
}

u8 rf_stopED(void)

{
  u8 uVar1;
  int iVar2;
  int iVar3;

  if (cnt_rssi == 0)
  {
    cnt_rssi = 1;
  }
  soft_rssi = FUN_00001624(sum_rssi, cnt_rssi);
  ev_disable_poll(EV_POLL_ED_DETECT);
  iVar3 = (uint)(byte)soft_rssi << 0x18;
  iVar2 = iVar3 >> 0x18;
  if (iVar2 + 0xe < 0 == SCARRY4(iVar2, 0xe))
  {
    iVar3 = -0xf000000;
  }
  else if (iVar2 + 99 < 0 != SCARRY4(iVar2, 99))
  {
    return '\0';
  }
  uVar1 = FUN_00001624(((iVar3 >> 0x18) + 99) * 0xff, 0x54);
  return uVar1;
}

void rf802154_tx_ready(u8 *buf, u8 len)

{
  rf_tx_buf[0] = len + '\x01';
  rf_tx_buf[1] = '\0';
  rf_tx_buf[2] = '\0';
  rf_tx_buf[3] = '\0';
  rf_tx_buf[4] = len + '\x02';
  memcpy(rf_tx_buf + 5, buf, (uint)len);
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u8 tl_zbMacAttrGet(u8 attribute, u8 *value, u8 *len)

{
  byte bVar1;
  uint uVar2;

  if (attribute == 0)
  {
    *value = *(u8 *)(FUN_00009f52 + 0x46);
  }
  else
  {
    uVar2 = attribute - 0x40;
    attribute = 0xe8;
    if ((uVar2 & 0xff) < 0x20)
    {
      bVar1 = g_zbMacPibTbl[uVar2].len;
      *len = bVar1;
      memcpy(value, (void *)((uint)g_zbMacPibTbl[uVar2].offset + FUN_00009f52), (uint)bVar1);
      attribute = '\0';
    }
  }
  return attribute;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_00009f52(int param_1)

{
  int iVar1;
  u32 uVar2;
  int iVar3;
  int unaff_r4;
  u8 auStack_24[8];
  u8 auStack_1c[2];
  u8 uStack_1a;
  char cStack_19;
  char cStack_18;
  char acStack_17[7];
  int iStack_10;

  iStack_10 = unaff_r4 << param_1;
  flash_read(g_u32MacFlashAddr, 8, auStack_1c);
  iVar1 = memcmp(auStack_1c, &g_invalid_addr, 8);
  iVar3 = _DAT_00800740;
  if (iVar1 == 0)
  {
    do
    {
      uVar2 = drv_u32Rand();
      iVar1 = FUN_00001628(uVar2, 0xfff);
    } while (iVar1 == 0);
    do
    {
    } while ((uint)(_DAT_00800740 - iVar3) <= (uint)(iVar1 << 4));
    drv_generateRandomData(auStack_1c, '\x05');
    memcpy(acStack_17, startIEEEAddr, 3);
    flash_write(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_write(g_u32MacFlashAddr + 6, 2, auStack_1c);
    flash_read(g_u32MacFlashAddr, 8, auStack_24);
    iVar3 = memcmp(auStack_24, &g_invalid_addr, 8);
    if (iVar3 == 0)
    {
      sys_exceptionPost(0xa2, '\x04');
    }
  }
  else
  {
    if (cStack_19 == '8')
    {
      if ((cStack_18 != -0x3f) || (acStack_17[0] != -0x5c))
        goto LAB_00009fdc;
    }
    else if (cStack_19 == -0x2f)
    {
      if ((cStack_18 != '\x19') || (acStack_17[0] != -0x3c))
        goto LAB_00009fdc;
    }
    else
    {
      if (cStack_19 == -0x35)
      {
        if (cStack_18 != '\v')
          goto LAB_00009fdc;
      }
      else if ((cStack_19 != 'w') || (cStack_18 != '_'))
        goto LAB_00009fdc;
      if (acStack_17[0] != -0x28)
        goto LAB_00009fdc;
    }
    flash_read(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_read(g_u32MacFlashAddr + 6, 2, auStack_1c);
  }
LAB_00009fdc:
  memcpy(g_zbInfo.macPib.extAddress, auStack_1c, 8);
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void generateIEEEAddr(void)

{
  int iVar1;
  u32 uVar2;
  int iVar3;
  u8 auStack_24[8];
  u8 auStack_1c[2];
  u8 uStack_1a;
  char cStack_19;
  char cStack_18;
  char acStack_17[7];

  flash_read(g_u32MacFlashAddr, 8, auStack_1c);
  iVar1 = memcmp(auStack_1c, &g_invalid_addr, 8);
  iVar3 = _DAT_00800740;
  if (iVar1 == 0)
  {
    do
    {
      uVar2 = drv_u32Rand();
      iVar1 = FUN_00001628(uVar2, 0xfff);
    } while (iVar1 == 0);
    do
    {
    } while ((uint)(_DAT_00800740 - iVar3) <= (uint)(iVar1 << 4));
    drv_generateRandomData(auStack_1c, '\x05');
    memcpy(acStack_17, startIEEEAddr, 3);
    flash_write(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_write(g_u32MacFlashAddr + 6, 2, auStack_1c);
    flash_read(g_u32MacFlashAddr, 8, auStack_24);
    iVar3 = memcmp(auStack_24, &g_invalid_addr, 8);
    if (iVar3 == 0)
    {
      sys_exceptionPost(0xa2, '\x04');
    }
  }
  else
  {
    if (cStack_19 == '8')
    {
      if ((cStack_18 != -0x3f) || (acStack_17[0] != -0x5c))
        goto LAB_00009fdc;
    }
    else if (cStack_19 == -0x2f)
    {
      if ((cStack_18 != '\x19') || (acStack_17[0] != -0x3c))
        goto LAB_00009fdc;
    }
    else
    {
      if (cStack_19 == -0x35)
      {
        if (cStack_18 != '\v')
          goto LAB_00009fdc;
      }
      else if ((cStack_19 != 'w') || (cStack_18 != '_'))
        goto LAB_00009fdc;
      if (acStack_17[0] != -0x28)
        goto LAB_00009fdc;
    }
    flash_read(g_u32MacFlashAddr, 6, &uStack_1a);
    flash_read(g_u32MacFlashAddr + 6, 2, auStack_1c);
  }
LAB_00009fdc:
  memcpy(g_zbInfo.macPib.extAddress, auStack_1c, 8);
  return;
}

u8 gpChangleChannelReqCb(void)

{
  return '\x01';
}

void gpDataCnfPrc(gp_data_cnf_t *pGpDataCnf)

{
  return;
}

void gpSecReqPrc(void *arg)

{
  u8 appId;
  u8 gpdfSecurityLevel;
  undefined uVar1;
  u8 gpdfKeyType;
  undefined uVar2;
  undefined4 uVar3;
  gpSecRsp_status_t gVar4;
  u8 local_38[4];
  u32 uStack_34;

  memcpy(local_38, arg, 0x11);
  uVar3 = *(undefined4 *)((int)arg + 8);
  appId = *(u8 *)((int)arg + 0xc);
  gpdfSecurityLevel = *(u8 *)((int)arg + 0xd);
  uVar1 = *(undefined *)((int)arg + 0xe);
  gpdfKeyType = *(u8 *)((int)arg + 0xf);
  uVar2 = *(undefined *)((int)arg + 0x10);
  memset(arg, 0, 0x22);
  *(u8 *)((int)arg + 0xe) = appId;
  *(undefined *)((int)arg + 0xd) = uVar2;
  *(u8 *)((int)arg + 0xf) = gpdfSecurityLevel;
  memcpy(arg, local_38, 8);
  *(undefined *)((int)arg + 0x20) = uVar1;
  *(char *)((int)arg + 8) = (char)uVar3;
  *(char *)((int)arg + 9) = (char)((uint)uVar3 >> 8);
  *(char *)((int)arg + 10) = (char)((uint)uVar3 >> 0x10);
  *(char *)((int)arg + 0xb) = (char)((uint)uVar3 >> 0x18);
  gVar4 = gpProxySecOperation(appId, (gpdId_t)(ulonglong)CONCAT14(uVar1, uVar3), local_38[0], uStack_34,
                              gpdfSecurityLevel, gpdfKeyType, (u8 *)((int)arg + 0x21),
                              (u8 *)((int)arg + 0x10));
  *(gpSecRsp_status_t *)((int)arg + 0xc) = gVar4;
  tl_zbTaskPost(gpSecRsp, arg);
  return;
}

void gpDataIndPrc(void *arg)

{
  gppGpDataIndProcess((gp_data_ind_t *)arg);
  return;
}

u8 gpDevAnnceCheckCb(u16 aliasNwkAddr, u8 *aliasIeeeAddr)

{
  ev_timer_event_t *peVar1;
  u8 uVar2;
  uint uVar3;
  int iVar4;
  u32 uVar5;
  byte bVar6;
  uint uVar7;
  ev_timer_event_t *peVar8;
  uint uVar9;

  uVar3 = (uint)aliasNwkAddr;
  iVar4 = memcmp(aliasIeeeAddr, &g_invalid_addr, 8);
  peVar1 = g_gppCtx.aliasConflictTimeoutEvt;
  if (iVar4 == 0)
  {
    peVar8 = (ev_timer_event_t *)(ll_reset + 1);
    if ((g_gppCtx.aliasConflictTimeoutEvt != (ev_timer_event_t *)0x0) &&
        (g_gppCtx.gpAliasConflictAddr == uVar3))
    {
      ev_timer_taskCancel(&g_gppCtx.aliasConflictTimeoutEvt);
    }
  }
  else
  {
    peVar8 = (ev_timer_event_t *)(ll_reset + 1);
    if (g_gppCtx.aliasConflictTimeoutEvt == (ev_timer_event_t *)0x0)
    {
      uVar2 = gp_getProxyTabEntryTotalNum();
      peVar8 = (ev_timer_event_t *)0x0;
      if ((uVar2 != '\0') && (peVar8 = peVar1, zclGpAttr_gppMaxProxyTabEntries != '\0'))
      {
        uVar9 = 0;
        do
        {
          uVar7 = (uint)(byte)g_gpProxyTab.gpProxyTab[uVar9].field_0x40;
          if (((int)(uVar7 << 0x1f) >> 0x1f) * -0x1000000 != 0)
          {
            bVar6 = (byte)(uVar3 >> 8);
            if ((uVar7 << 0x1d) >> 0x1e != 0)
            {
              uVar7 = 0;
              do
              {
                iVar4 = memcmp(g_gpProxyTab.gpProxyTab[uVar9].lightweightSinkAddrList + uVar7,
                               aliasIeeeAddr, 8);
                if (iVar4 == 0)
                {
                  *(char *)&g_gpProxyTab.gpProxyTab[uVar9].lightweightSinkAddrList[uVar7].sinkNwkAddr = (char)aliasNwkAddr;
                  *(byte *)((int)&g_gpProxyTab.gpProxyTab[uVar9].lightweightSinkAddrList[uVar7].sinkNwkAddr + 1) = bVar6;
                }
                uVar7 = uVar7 + 1 & 0xff;
              } while (uVar7 < ((uint)(byte)g_gpProxyTab.gpProxyTab[uVar9].field_0x40 << 0x1d) >>
                       0x1e);
            }
            uVar7 = gpAliasSrcAddrDerived();
            if ((uVar7 == uVar3) || (g_gpProxyTab.gpProxyTab[uVar9].gpdAssignedAlias == uVar3))
            {
              tl_zbNwkAddrConflictStatusSend(0xfffd, aliasNwkAddr, '\x01');
              g_gppCtx.gpAliasConflictAddr = aliasNwkAddr & 0xff | (ushort)bVar6 << 8;
              uVar5 = drv_u32Rand();
              iVar4 = FUN_0000162c(uVar5 & 0xffff, 0x28a);
              g_gppCtx.aliasConflictTimeoutEvt =
                  ev_timer_taskPost(gpAliasConflictTimeoutCb, (void *)0x0, iVar4 + 5U & 0xffff);
              peVar8 = (ev_timer_event_t *)(ll_reset + 1);
              goto LAB_0000a17a;
            }
          }
          uVar9 = uVar9 + 1 & 0xff;
        } while (uVar9 < zclGpAttr_gppMaxProxyTabEntries);
        peVar8 = (ev_timer_event_t *)0x0;
      }
    }
  }
LAB_0000a17a:
  return (u8)peVar8;
}

s32 gpAliasConflictTimeoutCb(void *arg)

{
  gpDevAnnceAliasSend(g_gppCtx.gpAliasConflictAddr);
  g_gppCtx.gpAliasConflictAddr = 0xfefd;
  g_gppCtx.aliasConflictTimeoutEvt._0_1_ = 0;
  g_gppCtx.aliasConflictTimeoutEvt._1_1_ = 0;
  g_gppCtx.aliasConflictTimeoutEvt._2_1_ = 0;
  g_gppCtx.aliasConflictTimeoutEvt._3_1_ = 0;
  return -2;
}

void gpCommissioningModeCb(u8 isInCommMode)

{
  if (isInCommMode == '\0')
  {
    zb_nlmePermitJoiningRequest('\0');
  }
  return;
}

void gp_init(u8 endpoint)

{
  gpStubCbInit();
  af_endpointRegister(0xf2, &gp_simpleDesc, zcl_rx_handler, ll_reset);
  zcl_register(0xf2, GP_CB_CLUSTER_NUM, g_gpClusterList);
  gpAppCb = &gpAppCbList;
  gp_proxyInit();
  return;
}

void gpsCommissionModeInvork(void)

{
  return;
}

void gpCommissioningNotificationCmdFromLocalCb(zcl_gp_commissioningNotificationCmd_t *pCmd)

{
  return;
}

status_t zcl_gpCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  status_t sVar1;

  sVar1 = '\0';
  if ((pAddrInfo->dstEp == 0xf2) &&
      (sVar1 = 0x81, (int)((uint)(byte)pAddrInfo->field_0x9 << 0x1f) < 0))
  {
    sVar1 = zcl_gpServerCmdHandler(pAddrInfo, cmdId, cmdPayload);
  }
  return sVar1;
}

s32 gpCommissioningNotificationCmdSend(void *arg)

{
  u8 seqNo;
  int iVar1;

  seqNo = zcl_seqNum;
  zcl_seqNum = zcl_seqNum + '\x01';
  zcl_gp_commissioningNotificationCmd(0xf2, (epInfo_t *)arg, '\x01', seqNo,
                                      (zcl_gp_commissioningNotificationCmd_t *)((int)arg + 0x12));
  iVar1 = aps_duplicate_check();
  if (iVar1 == 0)
  {
    gpCommissioningNotificationCmdFromLocalCb((zcl_gp_commissioningNotificationCmd_t *)((int)arg + 0x12));
  }
  ev_buf_free((u8 *)arg);
  return -2;
}

void gpCommissioningWindowTimeoutStop(void)

{
  if (g_gppCtx.commissioningWindowTimeoutEvt != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_gppCtx.commissioningWindowTimeoutEvt);
  }
  return;
}

void gpExitCommissioningMode(void)

{
  g_gppCtx.gpCommissioningModeOpt.opts = '\0';
  g_gppCtx.gppInCommMode = '\0';
  g_gppCtx.gpCommissionerAddr = 0xfffd;
  g_gppCtx.gpCommissioningWindow = 0xb4;
  gpTxQueueFree();
  return;
}

s32 gpCommissioningWindowTimeoutCb(void *arg)

{
  gpExitCommissioningMode();
  if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpCommissioningModeCb != ll_reset))
  {
    FUNAAAAM();
  }
  g_gppCtx.commissioningWindowTimeoutEvt = (ev_timer_event_t *)0x0;
  return -2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAM(void)

{
  code *in_r3;

  (*in_r3)();
  gpProxyTabInit();
  zclGpAttr_gppFunc[0] = '/';
  zclGpAttr_gppFunc[1] = 0xac;
  zclGpAttr_gppFunc[2] = '\t';
  zclGpAttr_gppActiveFunc[0] = 0xff;
  zclGpAttr_gppActiveFunc[1] = 0xff;
  zclGpAttr_gppActiveFunc[2] = 0xff;
  return;
}

void gp_proxyInit(void)

{
  gpProxyTabInit();
  zclGpAttr_gppFunc[0] = '/';
  zclGpAttr_gppFunc[1] = 0xac;
  zclGpAttr_gppFunc[2] = '\t';
  zclGpAttr_gppActiveFunc[0] = 0xff;
  zclGpAttr_gppActiveFunc[1] = 0xff;
  zclGpAttr_gppActiveFunc[2] = 0xff;
  return;
}

gpSecRsp_status_t
gpProxySecOperation(u8 appId, gpdId_t gpdId, u8 endpoint, u32 gpdSecFrameCnt, u8 gpdfSecurityLevel,
                    u8 gpdfKeyType, u8 *pKeyType, u8 *pKey)

{
  gpSecRsp_status_t gVar1;
  gpProxyTabEntry_t *pgVar2;
  int iVar3;
  u8 uVar4;
  undefined4 in_stack_ffffffd8;
  undefined4 in_stack_ffffffdc;

  pgVar2 = gp_getProxyTabByGpdId(appId, (gpdId_t)CONCAT44(in_stack_ffffffdc, in_stack_ffffffd8));
  if (pgVar2 != (gpProxyTabEntry_t *)0x0)
  {
    if ((int)((uint) * (byte *)&pgVar2->options << 0x1c) < 0)
    {
      if ((int)((uint) * (byte *)((int)&pgVar2->options + 1) << 0x19) < 0)
      {
        if (((((pgVar2->secOptions).opts & 3) == (gpdId._4_4_ & 0xff)) &&
             (pgVar2->gpdSecFrameCnt < gpdId.srcId)) &&
            (iVar3 = gpSecKeyTypeMappingChk(), iVar3 == 0))
        {
        LAB_0000a530:
          if (((appId != '\x02') || (gpdfSecurityLevel == '\0')) ||
              ((pgVar2->endpoint == gpdfSecurityLevel ||
                (gVar1 = GP_SEC_RSP_STATUS_TX_THEN_DROP, gpdfSecurityLevel == 0xff))))
          {
            gVar1 = GP_SEC_RSP_STATUS_MATCH;
          }
          if (((ulonglong)gpdId & 0xff00000000) == 0)
          {
            return gVar1;
          }
          gVar1 = gpKeyRecovery();
          return gVar1;
        }
      }
      else if (((ulonglong)gpdId & 0xff00000000) == 0)
        goto LAB_0000a530;
      if (g_gppCtx.gppInCommMode == '\0')
      {
        return GP_SEC_RSP_STATUS_DROP_FRAME;
      }
      return GP_SEC_RSP_STATUS_PASS_UNPROCESSED - (((ulonglong)gpdId & 0xff00000000) == 0);
    }
    if (g_gppCtx.gppInCommMode == '\0')
    {
      return GP_SEC_RSP_STATUS_DROP_FRAME;
    }
  }
  if (gpdfKeyType == '\0')
  {
    if (((ulonglong)gpdId & 0xff00000000) == 0)
    {
      memcpy(pKey, zclGpAttr_gpSharedSecKey, 0x10);
      uVar4 = '\0';
    }
    else
    {
      iVar3 = memcmp(zclGpAttr_gpSharedSecKey, g_null_securityKey, 0x10);
      if (iVar3 == 0)
      {
        return GP_SEC_RSP_STATUS_PASS_UNPROCESSED;
      }
      memcpy(pKey, zclGpAttr_gpSharedSecKey, 0x10);
      uVar4 = zclGpAttr_gpSharedSecKeyType;
    }
    *pKeyType = uVar4;
    gVar1 = GP_SEC_RSP_STATUS_MATCH;
  }
  else
  {
    *pKeyType = '\x04';
    gVar1 = GP_SEC_RSP_STATUS_PASS_UNPROCESSED;
  }
  return gVar1;
}

void gpProxyCommissioningModeCmdProcess(u16 srcAddr, zcl_gp_proxyCommissioningModeCmd_t *pCmd)

{
  gpProxyCommModeOpt_t gVar1;

  if ((g_gppCtx.gppInCommMode == '\0') || (g_gppCtx.gpCommissionerAddr == srcAddr))
  {
    gVar1.bits = *(anon_struct_1_6_28c719c2_for_bits *)&pCmd->options;
    if ((gVar1.opts & 1) == 0)
    {
      gpCommissioningWindowTimeoutStop();
      gpExitCommissioningMode();
    }
    else
    {
      g_gppCtx.gppInCommMode = '\x01';
      g_gppCtx.gpCommissionerAddr = srcAddr;
      g_gppCtx.gpCommissioningModeOpt.bits = gVar1.bits;
      if ((int)((uint)(pCmd->options).opts << 0x1e) < 0)
      {
        g_gppCtx.gpCommissioningWindow = pCmd->commissioningWindow;
        gpCommissioningWindowTimeoutStop();
        if (g_gppCtx.gpCommissioningWindow != 0)
        {
          g_gppCtx.commissioningWindowTimeoutEvt =
              ev_timer_taskPost(gpCommissioningWindowTimeoutCb, (void *)0x0,
                                (uint)g_gppCtx.gpCommissioningWindow * 1000);
        }
      }
    }
    if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpCommissioningModeCb != ll_reset))
    {
      FUNAAAAN();
    }
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAN(void)

{
  void *in;
  code *in_r3;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined2 uStack_1c;
  undefined uStack_1a;
  byte bStack_18;

  in = (void *)(*in_r3)();
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20._0_2_ = 0;
  uStack_1c = 0;
  uStack_1a = 0;
  g_gppCtx.firstToForward = *(u16 *)((int)in + 0xc) == g_zbInfo.nwkNib.nwkAddr;
  if ((bool)g_gppCtx.firstToForward)
  {
    uStack_20._0_2_ = 0x100;
  }
  uStack_20._0_2_ =
      (ushort)uStack_20 |
      (byte)((byte)((((uint) * (byte *)((int)in + 0xe) << 0x1c) >> 0x1f) << 5) | 1);
  uStack_20._0_3_ =
      CONCAT12((byte)(((uint) * (byte *)((int)in + 0xe) << 0x1d) >> 0x1d), (ushort)uStack_20);
  uStack_20 = (uint)(uint3)uStack_20;
  memcpy(&uStack_28, in, 8);
  uStack_20 = uStack_20 & 0xffffff | (uint) * (byte *)((int)in + 0x10) << 0x18;
  uStack_1c = *(undefined2 *)((int)in + 0x11);
  gpTranimitGPDF();
  if ((uStack_20._1_1_ != '\0') && (*(char *)((int)in + 0x11) == -0xd))
  {
    bStack_18 = **(byte **)((int)in + 8);
    gpSwitchToTransmitChannel(bStack_18 & 0xf, *(u8 *)((int)in + 0xf));
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

void gpResponseCmdProcess(zcl_gp_responseCmd_t *pCmd)

{
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined2 local_1c;
  undefined local_1a;
  byte local_18;

  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20._0_2_ = 0;
  local_1c = 0;
  local_1a = 0;
  g_gppCtx.firstToForward = pCmd->tempMasterShortAddr == g_zbInfo.nwkNib.nwkAddr;
  if ((bool)g_gppCtx.firstToForward)
  {
    uStack_20._0_2_ = 0x100;
  }
  uStack_20._0_2_ =
      (ushort)uStack_20 | (byte)((byte)((((uint)(pCmd->options).opts << 0x1c) >> 0x1f) << 5) | 1);
  uStack_20._0_3_ = CONCAT12((byte)(((uint)(pCmd->options).opts << 0x1d) >> 0x1d), (ushort)uStack_20);
  uStack_20 = (uint)(uint3)uStack_20;
  memcpy(&uStack_28, pCmd, 8);
  uStack_20 = uStack_20 & 0xffffff | (uint)pCmd->endpoint << 0x18;
  local_1c = *(undefined2 *)&pCmd->gpdCmdID;
  gpTranimitGPDF();
  if ((uStack_20._1_1_ != '\0') && (pCmd->gpdCmdID == 0xf3))
  {
    local_18 = *pCmd->pGpdCmdPayload;
    gpSwitchToTransmitChannel(local_18 & 0xf, pCmd->tempMasterTxChannel);
  }
  return;
}

status_t zcl_gpServerCmdHandler(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  undefined uVar1;
  undefined4 uVar2;
  u8 uVar3;
  byte bVar4;
  byte bVar5;
  u16 uVar6;
  gpProxyTabEntry_t *pgVar7;
  u8 *puVar8;
  u8 *pBuf;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  undefined4 in_stack_ffffffac;
  undefined4 in_stack_ffffffb0;
  uint local_44;
  undefined4 uStack_40;
  uint uStack_3c;
  undefined4 uStack_38;
  undefined2 local_34;
  zcl_gp_proxyTabRspCmd_t local_30;
  undefined2 local_26;

  if (cmdId == '\x02')
  {
    gpProxyCommissioningModeCmdProcess(pAddrInfo->srcAddr, (zcl_gp_proxyCommissioningModeCmd_t *)cmdPayload);
    uVar11 = 0;
    goto LAB_0000a784;
  }
  if (cmdId < 3)
  {
    if (cmdId == '\x01')
    {
      pgVar7 = gp_getProxyTabByGpdId(*(byte *)((int)cmdPayload + 0x10) & 7,
                                     (gpdId_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac));
      uVar9 = (uint) * (byte *)((int)cmdPayload + 0x10);
      if ((int)(uVar9 << 0x1b) < 0)
      {
        uVar11 = 0x8b;
        if (pgVar7 != (gpProxyTabEntry_t *)0x0)
        {
        LAB_0000a7dc:
          gp_proxyTabEntryClear(pgVar7);
          goto LAB_0000a7e2;
        }
      }
      else
      {
        uVar11 = 0x85;
        if (((*(byte *)((int)cmdPayload + 0x10) & 0x60) == 0) ||
            ((*(byte *)((int)cmdPayload + 0x11) & 6) == 2))
          goto LAB_0000aacc;
        if (pgVar7 == (gpProxyTabEntry_t *)0x0)
        {
          uVar11 = 0x8b;
          if (-1 < (int)(uVar9 << 0x1c))
            goto LAB_0000aacc;
          pgVar7 = gp_proxyTabEntryFreeGet();
          if (pgVar7 != (gpProxyTabEntry_t *)0x0)
          {
            uVar9 = (uint) * (byte *)((int)cmdPayload + 0x10);
            goto LAB_0000a8f8;
          }
        LAB_0000adac:
          uVar11 = 0x89;
          goto LAB_0000aacc;
        }
      LAB_0000a8f8:
        uVar11 = uVar9 & 0x60;
        if ((int)(uVar9 << 0x1c) < 0)
        {
          if (uVar11 == 0x60)
          {
            uVar3 = lwSinkAddrListAdd(pgVar7, (u8 *)((int)cmdPayload + 8),
                                      *(u16 *)((int)cmdPayload + 0x28));
          joined_r0x0000ada8:
            if (uVar3 == '\x01')
              goto LAB_0000adac;
          }
          else
          {
            if (uVar11 == 0x40)
            {
              if ((int)((uint) * (byte *)((int)cmdPayload + 0x12) << 0x1f) < 0)
              {
                uVar6 = *(u16 *)((int)cmdPayload + 0x2c);
              }
              else
              {
                uVar6 = 0xffff;
              }
              uVar3 = sinkGroupListAdd(pgVar7, *(u16 *)((int)cmdPayload + 0x2a), uVar6);
              goto joined_r0x0000ada8;
            }
            if (uVar11 == 0x20)
            {
              *(byte *)((int)&pgVar7->options + 1) =
                  *(byte *)((int)&pgVar7->options + 1) & 0xdf |
                  (byte)((*(byte *)((int)cmdPayload + 0x12) & 1) << 5);
              uVar1 = *(undefined *)((int)cmdPayload + 0x2d);
              *(undefined *)&pgVar7->gpdAssignedAlias = *(undefined *)((int)cmdPayload + 0x2c);
              *(undefined *)((int)&pgVar7->gpdAssignedAlias + 1) = uVar1;
            }
          }
          if (-1 < (int)((uint)(byte)pgVar7->field_0x40 << 0x1f))
          {
            pgVar7->field_0x40 = pgVar7->field_0x40 | 1;
            g_gpProxyTab.gpProxyTabNum = g_gpProxyTab.gpProxyTabNum + '\x01';
          }
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0xf8 | *(byte *)((int)cmdPayload + 0x10) & 7;
          *(byte *)&pgVar7->options = *(byte *)&pgVar7->options | 8;
          *(byte *)&pgVar7->options = *(byte *)&pgVar7->options | 0x10;
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0xdf |
              (byte)((((uint) * (byte *)&pgVar7->options << 0x1a |
                       (uint) * (byte *)((int)cmdPayload + 0x11) << 0x1f) >>
                      0x1f)
                     << 5);
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0xbf |
              (byte)((((uint) * (byte *)&pgVar7->options << 0x19) >> 0x1f |
                      (0x5f < (*(byte *)((int)cmdPayload + 0x10) & 0x60)) - 1 & 1)
                     << 6);
          *(byte *)&pgVar7->options =
              *(byte *)&pgVar7->options & 0x7f |
              (byte)(((uint)(*(byte *)&pgVar7->options >> 7) |
                      (0x1f < (*(byte *)((int)cmdPayload + 0x10) & 0x60)) - 1)
                     << 7);
          bVar4 = *(byte *)((int)&pgVar7->options + 1);
          *(byte *)((int)&pgVar7->options + 1) =
              bVar4 & 0xfe |
              (byte)(((uint)bVar4 << 0x1f) >> 0x1f) |
              (0x3f < (*(byte *)((int)cmdPayload + 0x10) & 0x60)) - 1U & 1;
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0xfd;
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0xfb;
          bVar4 = *(byte *)((int)&pgVar7->options + 1);
          *(byte *)((int)&pgVar7->options + 1) =
              bVar4 & 0xf7 |
              (byte)((((uint)bVar4 << 0x1c) >> 0x1f |
                      (uint)(*(byte *)((int)cmdPayload + 0x10) >> 7))
                     << 3);
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0xef | 0x10;
          *(byte *)((int)&pgVar7->options + 1) =
              *(byte *)((int)&pgVar7->options + 1) & 0xbf |
              (1 < ((uint) * (byte *)((int)cmdPayload + 0x11) << 0x1d) >> 0x1e) << 6;
          *(byte *)((int)&pgVar7->options + 1) = *(byte *)((int)&pgVar7->options + 1) & 0x7f;
          if ((*(byte *)&pgVar7->options & 7) == 0)
          {
            // WARNING: Load size is inaccurate
            uVar2 = *cmdPayload;
            (pgVar7->gpdId).gpdIeeeAddr[0] = (u8)uVar2;
            (pgVar7->gpdId).gpdIeeeAddr[1] = (u8)((uint)uVar2 >> 8);
            (pgVar7->gpdId).gpdIeeeAddr[2] = (u8)((uint)uVar2 >> 0x10);
            (pgVar7->gpdId).gpdIeeeAddr[3] = (u8)((uint)uVar2 >> 0x18);
          }
          else if ((*(byte *)&pgVar7->options & 7) == 2)
          {
            memcpy(pgVar7, cmdPayload, 8);
          }
          pgVar7->endpoint = *(u8 *)((int)cmdPayload + 0x2e);
          (pgVar7->secOptions).opts =
              (pgVar7->secOptions).opts & 0xfc | *(byte *)((int)cmdPayload + 0x11) >> 1 & 3;
          (pgVar7->secOptions).opts =
              (pgVar7->secOptions).opts & 0xe3 |
              (byte)((((uint) * (byte *)((int)cmdPayload + 0x11) << 0x1a) >> 0x1d) << 2);
          uVar2 = *(undefined4 *)((int)cmdPayload + 0x14);
          *(char *)&pgVar7->gpdSecFrameCnt = (char)uVar2;
          *(char *)((int)&pgVar7->gpdSecFrameCnt + 1) = (char)((uint)uVar2 >> 8);
          *(char *)((int)&pgVar7->gpdSecFrameCnt + 2) = (char)((uint)uVar2 >> 0x10);
          *(char *)((int)&pgVar7->gpdSecFrameCnt + 3) = (char)((uint)uVar2 >> 0x18);
          memcpy(pgVar7->gpdKey, (void *)((int)cmdPayload + 0x18), 0x10);
          if ((int)((uint) * (byte *)((int)cmdPayload + 0x12) << 0x1e) < 0)
          {
            uVar3 = *(u8 *)((int)cmdPayload + 0x30);
          }
          else
          {
            uVar3 = pgVar7->groupcastRadius;
          }
          pgVar7->groupcastRadius = uVar3;
          pgVar7->searchCnt = '\0';
        }
        else
        {
          if (uVar11 == 0x60)
          {
            uVar3 = lwSinkAddrListRemove(pgVar7, (u8 *)((int)cmdPayload + 8), *(u16 *)((int)cmdPayload + 0x28));
          joined_r0x0000ade8:
            if (uVar3 == '\x01')
            {
              uVar11 = 0x8b;
              goto LAB_0000aacc;
            }
          }
          else if (uVar11 == 0x40)
          {
            uVar3 = sinkGroupListRemove(pgVar7, *(u16 *)((int)cmdPayload + 0x2a));
            goto joined_r0x0000ade8;
          }
          if (((pgVar7->field_0x40 & 0x1e) == 0) && ((*(byte *)&pgVar7->options & 0x80) == 0))
            goto LAB_0000a7dc;
        }
      LAB_0000a7e2:
        gpProxyTabUpdate();
        if ((g_gppCtx.gppInCommMode != '\0') &&
            ((int)((uint)g_gppCtx.gpCommissioningModeOpt.opts << 0x1d) < 0))
        {
          gpCommissioningWindowTimeoutStop();
          gpExitCommissioningMode();
          if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpCommissioningModeCb != ll_reset))
          {
            FUNAAAAP();
            uVar11 = 0;
            goto LAB_0000aacc;
          }
        }
        uVar11 = 0;
      }
    LAB_0000aacc:
      uVar10 = (uint)g_zbInfo.nwkNib.nwkAddr;
      uVar9 = gpAliasSrcAddrDerived();
      if ((uVar10 == uVar9) || (g_zbInfo.nwkNib.nwkAddr == *(u16 *)((int)cmdPayload + 0x2c)))
      {
        tl_zbNwkAddrConflictStatusSend(0xfffd, g_zbInfo.nwkNib.nwkAddr, '\x01');
        uVar6 = tl_zbNwkStochasticAddrCal();
        g_zbInfo.macPib.shortAddress._0_1_ = (undefined)uVar6;
        g_zbInfo.macPib.shortAddress._1_1_ = (byte)((uint)uVar6 >> 8);
        g_zbInfo.nwkNib.nwkAddr = uVar6 & 0xff | (ushort)g_zbInfo.macPib.shortAddress._1_1_ << 8;
        local_26 = 0;
        tl_zbNwkAddrMapAdd(uVar6, (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac),
                           (u16 *)g_zbInfo.macPib.extAddress);
        zb_info_save((void *)0x0);
        zb_zdoSendDevAnnance();
      }
      goto LAB_0000a784;
    }
  }
  else
  {
    if (cmdId == '\x06')
    {
      gpResponseCmdProcess((zcl_gp_responseCmd_t *)cmdPayload);
      uVar11 = 0;
      goto LAB_0000a784;
    }
    if (cmdId == '\v')
    {
      uStack_40 = 0;
      local_34 = 0;
      local_44 = (uint)pAddrInfo->srcAddr;
      uStack_38 = CONCAT13(pAddrInfo->srcEp, 0x20000);
      uStack_3c = (uint)pAddrInfo->profileId;
      local_30.proxyTabEntry = (u8 *)0x0;
      local_30._4_4_ = 0;
      local_30.entriesCnt = '\0';
      uVar3 = gp_getProxyTabEntryTotalNum();
      uVar11 = local_30._4_4_;
      local_30._4_3_ = CONCAT12(uVar3, local_30._4_2_);
      local_30._4_4_ = local_30._4_4_ & 0xff000000 | (uint)local_30._4_3_;
      if (uVar3 == '\0')
      {
        bVar4 = 0xff;
        if ((*(byte *)((int)cmdPayload + 8) & 0x18) != 0)
        {
          bVar4 = *(byte *)((int)cmdPayload + 10);
        }
        local_30._4_4_ = local_30._4_3_ & 0xffff0000 | (uint)bVar4 << 0x18 | 0x8b00;
        local_30.entriesCnt = '\0';
      }
      else
      {
        bVar4 = *(byte *)((int)cmdPayload + 8);
        if ((bVar4 & 0x18) == 0)
        {
          pgVar7 = gp_getProxyTabByGpdId(bVar4 & 7, (gpdId_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac));
          if (pgVar7 != (gpProxyTabEntry_t *)0x0)
          {
            bVar4 = gp_getProxyTabEntryLen(pgVar7);
            puVar8 = ev_buf_allocate((ushort)bVar4);
            uVar11 = 0;
            if (puVar8 == (u8 *)0x0)
              goto LAB_0000a784;
            memset(puVar8, 0, (uint)bVar4);
            gp_buildProxyTabEntryFormat(pgVar7, puVar8);
            local_30._4_4_ = CONCAT13(0xff, (uint3)local_30._4_4_ & 0xff0000);
            local_30.entriesCnt = '\x01';
            local_30._4_4_ = local_30._4_4_ | bVar4;
          LAB_0000abf0:
            local_30.proxyTabEntry = puVar8;
            puVar8 = local_30.proxyTabEntry;
            zcl_gp_proxyTableRspCmd(0xf2, (epInfo_t *)&local_44, '\x01', pAddrInfo->seqNum, &local_30);
            ev_buf_free(puVar8);
            uVar11 = 0;
            goto LAB_0000a784;
          }
          local_30._4_3_ = (uint3)local_30._4_4_ & 0xff0000 | 0x8b00;
          local_30._4_4_ = CONCAT13(0xff, local_30._4_3_);
          local_30.entriesCnt = '\0';
        }
        else if ((bVar4 & 0x18) == 8)
        {
          local_30._4_2_ = CONCAT11(0x8b, (u8)uVar11);
          local_30._4_3_ = CONCAT12(uVar3, local_30._4_2_);
          local_30._4_4_ = CONCAT13(*(undefined *)((int)cmdPayload + 10), local_30._4_3_);
          if (zclGpAttr_gppMaxProxyTabEntries == '\0')
          {
            local_30._4_4_ = local_30._4_4_ & 0xffffff00;
          }
          else
          {
            bVar4 = 0;
            uVar11 = 0;
            uVar9 = 0;
            do
            {
              uVar10 = uVar9;
              if ((((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar11].field_0x40 << 0x1f) >> 0x1f) *
                       -0x1000000 !=
                   0) &&
                  (bVar4 = bVar4 + 1, *(byte *)((int)cmdPayload + 10) < bVar4))
              {
                bVar5 = gp_getProxyTabEntryLen(g_gpProxyTab.gpProxyTab + uVar11);
                uVar10 = bVar5 + uVar9 & 0xff;
                if (0x4a < uVar10)
                  break;
                local_30.entriesCnt = local_30.entriesCnt + '\x01';
              }
              uVar11 = uVar11 + 1 & 0xff;
              uVar9 = uVar10;
            } while (uVar11 < zclGpAttr_gppMaxProxyTabEntries);
            uVar3 = local_30.entriesCnt;
            uVar11 = local_30._4_4_;
            local_30._4_4_ = local_30._4_4_ & 0xffffff00 | uVar9 & 0xff;
            if (uVar9 != 0)
            {
              local_30._4_4_ = uVar11 & 0xffff0000 | uVar9 & 0xff;
              puVar8 = ev_buf_allocate((u16)uVar9);
              uVar11 = 0;
              if (puVar8 == (u8 *)0x0)
                goto LAB_0000a784;
              memset(puVar8, 0, uVar9);
              if (zclGpAttr_gppMaxProxyTabEntries != '\0')
              {
                bVar4 = 0;
                pBuf = puVar8;
                do
                {
                  if ((((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar11].field_0x40 << 0x1f) >>
                        0x1f) *
                           -0x1000000 !=
                       0) &&
                      (bVar4 = bVar4 + 1, *(byte *)((int)cmdPayload + 10) < bVar4))
                  {
                    if (uVar3 == '\0')
                      break;
                    bVar5 = gp_buildProxyTabEntryFormat(g_gpProxyTab.gpProxyTab + uVar11, pBuf);
                    pBuf = pBuf + bVar5;
                    uVar3 = uVar3 + 0xff;
                  }
                  uVar11 = uVar11 + 1 & 0xff;
                } while (uVar11 < zclGpAttr_gppMaxProxyTabEntries);
              }
              goto LAB_0000abf0;
            }
          }
        }
      }
      zcl_gp_proxyTableRspCmd(0xf2, (epInfo_t *)&local_44, '\x01', pAddrInfo->seqNum, &local_30);
      uVar11 = 0;
      goto LAB_0000a784;
    }
  }
  uVar11 = 0x81;
LAB_0000a784:
  return (status_t)uVar11;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAP(void)

{
  char cVar1;
  u8 appId;
  u16 uVar2;
  undefined4 uVar3;
  byte bVar4;
  undefined2 uVar5;
  ushort uVar6;
  int *piVar7;
  gpProxyTabEntry_t *pgVar8;
  u8 *dest;
  uint uVar9;
  u8 uVar10;
  code *in_r3;
  int iVar11;
  uint uVar12;
  bool bVar13;
  undefined4 in_stack_ffffffa8;
  uint uStack_3c;
  undefined4 uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  ushort uStack_2c;
  int iStack_28;
  undefined4 uStack_24;

  piVar7 = (int *)(*in_r3)();
  if (piVar7 == (int *)0x0)
  {
    return;
  }
  if (g_gppCtx.gppInCommMode == '\0')
  {
    if (*(char *)(piVar7 + 7) == '\x03')
    {
      return;
    }
    uVar10 = *(u8 *)((int)piVar7 + 0x21);
    if (uVar10 == '\0')
    {
      iVar11 = piVar7[1];
    }
    else
    {
      if (uVar10 != '\x02')
        goto LAB_0000ae92;
      iVar11 = memcmp(piVar7 + 4, &g_zero_addr, 8);
    }
    if (iVar11 == 0)
    {
      return;
    }
  LAB_0000ae92:
    if ((byte)(*(char *)((int)piVar7 + 0x25) + 0x1eU) < 2)
    {
      return;
    }
    iVar11 = 0;
    appId = '\0';
    iStack_28 = 0;
    uStack_24 = 0;
    if (uVar10 == '\0')
    {
      iStack_28 = piVar7[1];
    }
    else if (uVar10 == '\x02')
    {
      memcpy(&iStack_28, piVar7 + 4, 8);
    }
    pgVar8 = gp_getProxyTabByGpdId(uVar10, (gpdId_t)CONCAT44(iVar11, in_stack_ffffffa8));
    if (pgVar8 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    bVar4 = *(byte *)((int)&pgVar8->options + 1);
    if (-1 < (int)((uint)bVar4 << 0x1d))
    {
      *(byte *)((int)&pgVar8->options + 1) = bVar4 | 4;
    }
    if ((byte)(*(char *)(piVar7 + 7) - 3U) < 2)
    {
      return;
    }
    if (*(char *)((int)piVar7 + 0x22) == '\0')
    {
      uVar12 = (uint) * (byte *)((int)piVar7 + 0x1f);
    }
    else
    {
      uVar12 = piVar7[2];
    }
    *(char *)&pgVar8->gpdSecFrameCnt = (char)uVar12;
    *(char *)((int)&pgVar8->gpdSecFrameCnt + 1) = (char)(uVar12 >> 8);
    *(char *)((int)&pgVar8->gpdSecFrameCnt + 2) = (char)(uVar12 >> 0x10);
    *(char *)((int)&pgVar8->gpdSecFrameCnt + 3) = (char)(uVar12 >> 0x18);
    if (*(char *)((int)piVar7 + 0x21) == '\0')
    {
      appId = '\0';
      iVar11 = piVar7[1];
    }
    else if (*(char *)((int)piVar7 + 0x21) == '\x02')
    {
      appId = '\x02';
      memcpy(&stack0xffffffac, piVar7 + 4, 8);
    }
    gpProxyTabUpdate();
    uStack_3c = 0;
    uStack_38 = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    uStack_2c = 0;
    pgVar8 = gp_getProxyTabByGpdId(appId, (gpdId_t)CONCAT44(iVar11, in_stack_ffffffa8));
    uVar3 = uStack_30;
    if (pgVar8 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
    uStack_34 = uStack_34 & 0xffff0000 | 0xa1e0;
    uStack_2c = uStack_2c & 0xff |
                (ushort)(pgVar8->groupcastRadius & ~(1U - (pgVar8->groupcastRadius == 0xff))) << 8;
    bVar4 = *(byte *)&pgVar8->options;
    if ((bVar4 & 0x40) != 0)
    {
      uStack_30._0_2_ = (ushort)uVar3;
      uStack_30._0_3_ = CONCAT12(2, (ushort)uStack_30);
      uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
      uStack_30 = uStack_30 & 0xffffff00;
      if (((uint)(byte)pgVar8->field_0x40 << 0x1d) >> 0x1e != 0)
      {
        uVar12 = 0;
        do
        {
          uVar10 = zcl_seqNum;
          uStack_3c = uStack_3c & 0xffff0000 |
                      (uint)pgVar8->lightweightSinkAddrList[uVar12].sinkNwkAddr;
          zcl_seqNum = zcl_seqNum + '\x01';
          zcl_gp_notificationCmd(0xf2, (epInfo_t *)&uStack_3c, '\x01', uVar10,
                                 (zcl_gp_notificationCmd_t *)&stack0xffffffac);
          uVar12 = uVar12 + 1 & 0xff;
        } while (uVar12 < ((uint)(byte)pgVar8->field_0x40 << 0x1d) >> 0x1e);
      }
      bVar4 = *(byte *)&pgVar8->options;
    }
    if ((bVar4 & 0x80) != 0)
    {
      uStack_30._0_3_ = CONCAT12(1, (ushort)uStack_30);
      uStack_30 = uStack_30 & 0xff000000 | (uint)(uint3)uStack_30;
      uVar6 = gpAliasSrcAddrDerived();
      uStack_3c = uStack_3c & 0xffff0000 | (uint)uVar6;
      uStack_30 = CONCAT31(uStack_30._1_3_, 1);
      if ((int)((uint) * (byte *)((int)&pgVar8->options + 1) << 0x1a) < 0)
      {
        uVar6 = pgVar8->gpdAssignedAlias;
      }
      else
      {
        uVar6 = gpAliasSrcAddrDerived();
      }
      uVar10 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar6 << 0x10;
      uStack_30._0_2_ = CONCAT11(*(undefined *)((int)piVar7 + 0x1f), (u8)uStack_30);
      uStack_30 = uStack_30 & 0xffff0000 | (uint)(ushort)uStack_30;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&uStack_3c, '\x01', uVar10,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
    }
    if ((*(byte *)((int)&pgVar8->options + 1) & 1) == 0)
    {
      return;
    }
    uStack_30._0_2_ = CONCAT11(*(char *)((int)piVar7 + 0x1f) + -9, 1);
    uStack_30 = uStack_30 & 0xff000000 | (uint)(ushort)uStack_30 | 0x10000;
    if (((uint)(byte)pgVar8->field_0x40 << 0x1b) >> 0x1e == 0)
    {
      return;
    }
    uVar12 = 0;
    do
    {
      uStack_3c = uStack_3c & 0xffff0000 |
                  (uint)CONCAT11(*(undefined *)((int)&pgVar8->sinkGroupList[uVar12].groupId + 1),
                                 *(undefined *)&pgVar8->sinkGroupList[uVar12].groupId);
      uVar6 = pgVar8->sinkGroupList[uVar12].alias;
      if (uVar6 == 0xffff)
      {
        uVar6 = gpAliasSrcAddrDerived();
      }
      uVar10 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar6 << 0x10;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&uStack_3c, '\x01', uVar10,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
      uVar12 = uVar12 + 1 & 0xff;
    } while (uVar12 < ((uint)(byte)pgVar8->field_0x40 << 0x1b) >> 0x1e);
    return;
  }
  cVar1 = *(char *)((int)piVar7 + 0x25);
  if (cVar1 == -0x1d)
  {
    if (*(char *)((int)piVar7 + 0x27) == '\0')
    {
      return;
    }
    if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpChangleChannelReqCb != ll_reset))
    {
      iVar11 = FUNAAAAR();
      if (iVar11 == 0)
      {
        return;
      }
      goto LAB_0000b240;
    }
  }
  else
  {
    if (cVar1 == -0x10)
    {
      return;
    }
    if (cVar1 == -0xd)
    {
      return;
    }
    if (((cVar1 == -0x1e) || (cVar1 == -0x20)) && (*(char *)((int)piVar7 + 0x1a) != '\0'))
    {
      return;
    }
  LAB_0000b240:
    if (*(char *)((int)piVar7 + 0x27) == '\0')
    {
      if (*(char *)((int)piVar7 + 0x21) == '\0')
      {
        iVar11 = piVar7[1];
      }
      else
      {
        if (*(char *)((int)piVar7 + 0x21) != '\x02')
          goto LAB_0000b268;
        iVar11 = memcmp(piVar7 + 4, &g_zero_addr, 8);
      }
      if (iVar11 == 0)
      {
        return;
      }
    }
  }
LAB_0000b268:
  dest = ev_buf_allocate(0x2e);
  if (dest == (u8 *)0x0)
  {
    return;
  }
  memset(dest, 0, 0x2e);
  if (*(char *)((int)piVar7 + 0x25) == -0x1d)
  {
  LAB_0000b650:
    dest[0x26] = dest[0x26] | 8;
  }
  else
  {
    if (*(char *)((int)piVar7 + 0x21) == '\0')
    {
      dest[0x26] = dest[0x26] & 0xf8;
      iVar11 = piVar7[1];
      dest[0x12] = (u8)iVar11;
      dest[0x13] = (u8)((uint)iVar11 >> 8);
      dest[0x14] = (u8)((uint)iVar11 >> 0x10);
      dest[0x15] = (u8)((uint)iVar11 >> 0x18);
    LAB_0000b2be:
      if (*(char *)((int)piVar7 + 0x25) == -0x1d)
        goto LAB_0000b650;
    }
    else if (*(char *)((int)piVar7 + 0x21) == '\x02')
    {
      dest[0x26] = dest[0x26] & 0xf8 | 2;
      memcpy(dest + 0x12, piVar7 + 4, 8);
      dest[0x2a] = *(u8 *)(piVar7 + 9);
      goto LAB_0000b2be;
    }
    dest[0x26] = dest[0x26] & 0xf7 | (byte)((*(byte *)((int)piVar7 + 0x1b) & 1) << 3);
  }
  dest[0x26] = dest[0x26] & 0xcf | (byte)((*(byte *)((int)piVar7 + 0x22) & 3) << 4);
  dest[0x26] = dest[0x26] & 0x3f | (byte)((*(byte *)((int)piVar7 + 0x23) & 3) << 6);
  dest[0x27] = dest[0x27] & 0xfe | *(byte *)((int)piVar7 + 0x23) >> 2 & 1;
  if ((byte)(*(char *)(piVar7 + 7) - 3U) < 2)
  {
    dest[0x27] = dest[0x27] | 2;
    iVar11 = piVar7[3];
    dest[0x22] = (u8)iVar11;
    dest[0x23] = (u8)((uint)iVar11 >> 8);
    dest[0x24] = (u8)((uint)iVar11 >> 0x10);
    dest[0x25] = (u8)((uint)iVar11 >> 0x18);
  }
  else
  {
    dest[0x27] = dest[0x27] & 0xfd;
    dest[0x22] = 0xfe;
    dest[0x23] = 0xfe;
    dest[0x24] = 0xfe;
    dest[0x25] = 0xfe;
  }
  dest[0x27] = dest[0x27] & 0xfb;
  dest[0x27] = dest[0x27] | 8;
  iVar11 = piVar7[2];
  dest[0x1e] = (u8)iVar11;
  dest[0x1f] = (u8)((uint)iVar11 >> 8);
  dest[0x20] = (u8)((uint)iVar11 >> 0x10);
  dest[0x21] = (u8)((uint)iVar11 >> 0x18);
  dest[0x2b] = *(u8 *)((int)piVar7 + 0x25);
  uVar10 = *(char *)((int)piVar7 + 0x26) + 0xff;
  dest[0x2c] = uVar10;
  if (uVar10 != '\0')
  {
    iVar11 = *piVar7 + 1;
    dest[0x1a] = (u8)iVar11;
    dest[0x1b] = (u8)((uint)iVar11 >> 8);
    dest[0x1c] = (u8)((uint)iVar11 >> 0x10);
    dest[0x1d] = (u8)((uint)iVar11 >> 0x18);
  }
  uVar2 = g_zbInfo.nwkNib.nwkAddr;
  dest[0x28] = (u8)g_zbInfo.nwkNib.nwkAddr;
  dest[0x29] = (u8)(uVar2 >> 8);
  bVar4 = *(byte *)((int)piVar7 + 0x1d);
  uVar12 = (uint)bVar4;
  if ((char)bVar4 + 0x6d < 0 != SCARRY4((int)(char)bVar4, 0x6d))
  {
    uVar12 = 0xffffff92;
  }
  uVar9 = uVar12 & 0xff;
  if ('\b' < (char)uVar12)
  {
    uVar9 = 8;
  }
  iVar11 = (uVar9 + 0x6e) * 0x1000000;
  dest[0x2d] = dest[0x2d] & 0xc0 | (byte)((iVar11 >> 0x18) - (iVar11 >> 0x1f) >> 1) & 0x3f;
  bVar13 = *(char *)((int)piVar7 + 0x1e) != '\0';
  bVar4 = bVar13 * '\x02';
  dest[0x2d] = dest[0x2d] & 0x3f | bVar13 * -0x80;
  dest[0xe] = '\x02';
  uVar2 = g_gppCtx.gpCommissionerAddr;
  if ((int)((uint)g_gppCtx.gpCommissioningModeOpt.opts << 0x1a) < 0)
  {
    *dest = (u8)g_gppCtx.gpCommissionerAddr;
    dest[1] = (u8)(uVar2 >> 8);
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
    if ((uVar2 & 0xfff8) != 0xfff8)
    {
      dest[0xc] = '\0';
      goto LAB_0000b458;
    }
  }
  else
  {
    *dest = 0xfc;
    dest[1] = 0xfe;
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
  }
  dest[0xc] = '\x01';
  uVar5 = gpAliasSrcAddrDerived();
  dest[10] = (u8)uVar5;
  dest[0xb] = (u8)((ushort)uVar5 >> 8);
  dest[0xd] = *(char *)((int)piVar7 + 0x1f) + 0xf4;
  bVar4 = dest[0x2d] >> 6;
LAB_0000b458:
  bVar4 = gppTunnelingDelayGet(SUB41(((uint)dest[0x26] << 0x1c) >> 0x1f, 0), bVar4, (bool)g_gppCtx.firstToForward, false);
  ev_timer_taskPost(gpCommissioningNotificationCmdSend, dest, (uint)bVar4);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void gppGpDataIndProcess(gp_data_ind_t *pGpDataInd)

{
  u8 appId;
  u16 uVar1;
  undefined4 uVar2;
  byte bVar3;
  undefined2 uVar4;
  ushort uVar5;
  gpProxyTabEntry_t *pgVar6;
  u32 uVar7;
  u8 *dest;
  uint uVar8;
  u8 uVar9;
  u8 *puVar10;
  uint uVar11;
  int iVar12;
  u32 uVar13;
  bool bVar14;
  undefined4 in_stack_ffffffa8;
  uint local_3c;
  undefined4 uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  ushort local_2c;
  u32 uStack_28;
  undefined4 uStack_24;

  if (pGpDataInd == (gp_data_ind_t *)0x0)
  {
    return;
  }
  if (g_gppCtx.gppInCommMode == '\0')
  {
    if (pGpDataInd->status == '\x03')
    {
      return;
    }
    uVar9 = pGpDataInd->appId;
    if (uVar9 == '\0')
    {
      uVar7 = pGpDataInd->srcId;
    }
    else
    {
      if (uVar9 != '\x02')
        goto LAB_0000ae92;
      uVar7 = memcmp(&pGpDataInd->srcAddr, &g_zero_addr, 8);
    }
    if (uVar7 == 0)
    {
      return;
    }
  LAB_0000ae92:
    if ((byte)(pGpDataInd->gpdCmdId + 0x1e) < 2)
    {
      return;
    }
    uVar7 = 0;
    appId = '\0';
    uStack_28 = 0;
    uStack_24 = 0;
    if (uVar9 == '\0')
    {
      uStack_28 = pGpDataInd->srcId;
    }
    else if (uVar9 == '\x02')
    {
      memcpy(&uStack_28, &pGpDataInd->srcAddr, 8);
    }
    pgVar6 = gp_getProxyTabByGpdId(uVar9, (gpdId_t)CONCAT44(uVar7, in_stack_ffffffa8));
    if (pgVar6 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    bVar3 = *(byte *)((int)&pgVar6->options + 1);
    if (-1 < (int)((uint)bVar3 << 0x1d))
    {
      *(byte *)((int)&pgVar6->options + 1) = bVar3 | 4;
    }
    if ((byte)(pGpDataInd->status - 3) < 2)
    {
      return;
    }
    if (pGpDataInd->gpdfSecurityLevel == '\0')
    {
      uVar13 = (u32)pGpDataInd->seqNum;
    }
    else
    {
      uVar13 = pGpDataInd->gpdSecFrameCnt;
    }
    *(char *)&pgVar6->gpdSecFrameCnt = (char)uVar13;
    *(char *)((int)&pgVar6->gpdSecFrameCnt + 1) = (char)(uVar13 >> 8);
    *(char *)((int)&pgVar6->gpdSecFrameCnt + 2) = (char)(uVar13 >> 0x10);
    *(char *)((int)&pgVar6->gpdSecFrameCnt + 3) = (char)(uVar13 >> 0x18);
    if (pGpDataInd->appId == '\0')
    {
      appId = '\0';
      uVar7 = pGpDataInd->srcId;
    }
    else if (pGpDataInd->appId == '\x02')
    {
      appId = '\x02';
      memcpy(&stack0xffffffac, &pGpDataInd->srcAddr, 8);
    }
    gpProxyTabUpdate();
    local_3c = 0;
    uStack_38 = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    local_2c = 0;
    pgVar6 = gp_getProxyTabByGpdId(appId, (gpdId_t)CONCAT44(uVar7, in_stack_ffffffa8));
    uVar2 = uStack_30;
    if (pgVar6 == (gpProxyTabEntry_t *)0x0)
    {
      return;
    }
    uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
    uStack_34 = uStack_34 & 0xffff0000 | 0xa1e0;
    local_2c = local_2c & 0xff |
               (ushort)(pgVar6->groupcastRadius & ~(1U - (pgVar6->groupcastRadius == 0xff))) << 8;
    bVar3 = *(byte *)&pgVar6->options;
    if ((bVar3 & 0x40) != 0)
    {
      uStack_30._0_2_ = (ushort)uVar2;
      uStack_30._0_3_ = CONCAT12(2, (ushort)uStack_30);
      uStack_30 = CONCAT13(0xf2, (uint3)uStack_30);
      uStack_30 = uStack_30 & 0xffffff00;
      if (((uint)(byte)pgVar6->field_0x40 << 0x1d) >> 0x1e != 0)
      {
        uVar11 = 0;
        do
        {
          uVar9 = zcl_seqNum;
          local_3c = local_3c & 0xffff0000 |
                     (uint)pgVar6->lightweightSinkAddrList[uVar11].sinkNwkAddr;
          zcl_seqNum = zcl_seqNum + '\x01';
          zcl_gp_notificationCmd(0xf2, (epInfo_t *)&local_3c, '\x01', uVar9,
                                 (zcl_gp_notificationCmd_t *)&stack0xffffffac);
          uVar11 = uVar11 + 1 & 0xff;
        } while (uVar11 < ((uint)(byte)pgVar6->field_0x40 << 0x1d) >> 0x1e);
      }
      bVar3 = *(byte *)&pgVar6->options;
    }
    if ((bVar3 & 0x80) != 0)
    {
      uStack_30._0_3_ = CONCAT12(1, (ushort)uStack_30);
      uStack_30 = uStack_30 & 0xff000000 | (uint)(uint3)uStack_30;
      uVar5 = gpAliasSrcAddrDerived();
      local_3c = local_3c & 0xffff0000 | (uint)uVar5;
      uStack_30 = CONCAT31(uStack_30._1_3_, 1);
      if ((int)((uint) * (byte *)((int)&pgVar6->options + 1) << 0x1a) < 0)
      {
        uVar5 = pgVar6->gpdAssignedAlias;
      }
      else
      {
        uVar5 = gpAliasSrcAddrDerived();
      }
      uVar9 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar5 << 0x10;
      uStack_30._0_2_ = CONCAT11(pGpDataInd->seqNum, (u8)uStack_30);
      uStack_30 = uStack_30 & 0xffff0000 | (uint)(ushort)uStack_30;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&local_3c, '\x01', uVar9,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
    }
    if ((*(byte *)((int)&pgVar6->options + 1) & 1) == 0)
    {
      return;
    }
    uStack_30._0_2_ = CONCAT11(pGpDataInd->seqNum + 0xf7, 1);
    uStack_30 = uStack_30 & 0xff000000 | (uint)(ushort)uStack_30 | 0x10000;
    if (((uint)(byte)pgVar6->field_0x40 << 0x1b) >> 0x1e == 0)
    {
      return;
    }
    uVar11 = 0;
    do
    {
      local_3c = local_3c & 0xffff0000 |
                 (uint)CONCAT11(*(undefined *)((int)&pgVar6->sinkGroupList[uVar11].groupId + 1),
                                *(undefined *)&pgVar6->sinkGroupList[uVar11].groupId);
      uVar5 = pgVar6->sinkGroupList[uVar11].alias;
      if (uVar5 == 0xffff)
      {
        uVar5 = gpAliasSrcAddrDerived();
      }
      uVar9 = zcl_seqNum;
      uStack_34 = uStack_34 & 0xffff | (uint)uVar5 << 0x10;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_gp_notificationCmd(0xf2, (epInfo_t *)&local_3c, '\x01', uVar9,
                             (zcl_gp_notificationCmd_t *)&stack0xffffffac);
      uVar11 = uVar11 + 1 & 0xff;
    } while (uVar11 < ((uint)(byte)pgVar6->field_0x40 << 0x1b) >> 0x1e);
    return;
  }
  uVar9 = pGpDataInd->gpdCmdId;
  if (uVar9 == 0xe3)
  {
    if (pGpDataInd->frameType == '\0')
    {
      return;
    }
    if ((gpAppCb != (gp_appCb_t *)0x0) && (gpAppCb->gpChangleChannelReqCb != ll_reset))
    {
      iVar12 = FUNAAAAR();
      if (iVar12 == 0)
      {
        return;
      }
      goto LAB_0000b240;
    }
  }
  else
  {
    if (uVar9 == 0xf0)
    {
      return;
    }
    if (uVar9 == 0xf3)
    {
      return;
    }
    if (((uVar9 == 0xe2) || (uVar9 == 0xe0)) && (pGpDataInd->autoCommissioning != '\0'))
    {
      return;
    }
  LAB_0000b240:
    if (pGpDataInd->frameType == '\0')
    {
      if (pGpDataInd->appId == '\0')
      {
        uVar7 = pGpDataInd->srcId;
      }
      else
      {
        if (pGpDataInd->appId != '\x02')
          goto LAB_0000b268;
        uVar7 = memcmp(&pGpDataInd->srcAddr, &g_zero_addr, 8);
      }
      if (uVar7 == 0)
      {
        return;
      }
    }
  }
LAB_0000b268:
  dest = ev_buf_allocate(0x2e);
  if (dest == (u8 *)0x0)
  {
    return;
  }
  memset(dest, 0, 0x2e);
  if (pGpDataInd->gpdCmdId == 0xe3)
  {
  LAB_0000b650:
    dest[0x26] = dest[0x26] | 8;
  }
  else
  {
    if (pGpDataInd->appId == '\0')
    {
      dest[0x26] = dest[0x26] & 0xf8;
      uVar7 = pGpDataInd->srcId;
      dest[0x12] = (u8)uVar7;
      dest[0x13] = (u8)(uVar7 >> 8);
      dest[0x14] = (u8)(uVar7 >> 0x10);
      dest[0x15] = (u8)(uVar7 >> 0x18);
    LAB_0000b2be:
      if (pGpDataInd->gpdCmdId == 0xe3)
        goto LAB_0000b650;
    }
    else if (pGpDataInd->appId == '\x02')
    {
      dest[0x26] = dest[0x26] & 0xf8 | 2;
      memcpy(dest + 0x12, &pGpDataInd->srcAddr, 8);
      dest[0x2a] = pGpDataInd->endpoint;
      goto LAB_0000b2be;
    }
    dest[0x26] = dest[0x26] & 0xf7 | (byte)((pGpDataInd->rxAfterTx & 1) << 3);
  }
  dest[0x26] = dest[0x26] & 0xcf | (byte)((pGpDataInd->gpdfSecurityLevel & 3) << 4);
  dest[0x26] = dest[0x26] & 0x3f | (byte)((pGpDataInd->gpdfKeyType & 3) << 6);
  dest[0x27] = dest[0x27] & 0xfe | pGpDataInd->gpdfKeyType >> 2 & 1;
  if ((byte)(pGpDataInd->status - 3) < 2)
  {
    dest[0x27] = dest[0x27] | 2;
    uVar7 = pGpDataInd->mic;
    dest[0x22] = (u8)uVar7;
    dest[0x23] = (u8)(uVar7 >> 8);
    dest[0x24] = (u8)(uVar7 >> 0x10);
    dest[0x25] = (u8)(uVar7 >> 0x18);
  }
  else
  {
    dest[0x27] = dest[0x27] & 0xfd;
    dest[0x22] = 0xfe;
    dest[0x23] = 0xfe;
    dest[0x24] = 0xfe;
    dest[0x25] = 0xfe;
  }
  dest[0x27] = dest[0x27] & 0xfb;
  dest[0x27] = dest[0x27] | 8;
  uVar7 = pGpDataInd->gpdSecFrameCnt;
  dest[0x1e] = (u8)uVar7;
  dest[0x1f] = (u8)(uVar7 >> 8);
  dest[0x20] = (u8)(uVar7 >> 0x10);
  dest[0x21] = (u8)(uVar7 >> 0x18);
  dest[0x2b] = pGpDataInd->gpdCmdId;
  uVar9 = pGpDataInd->gpdAsduLen + 0xff;
  dest[0x2c] = uVar9;
  if (uVar9 != '\0')
  {
    puVar10 = pGpDataInd->gpdAsdu + 1;
    dest[0x1a] = (u8)puVar10;
    dest[0x1b] = (u8)((uint)puVar10 >> 8);
    dest[0x1c] = (u8)((uint)puVar10 >> 0x10);
    dest[0x1d] = (u8)((uint)puVar10 >> 0x18);
  }
  uVar1 = g_zbInfo.nwkNib.nwkAddr;
  dest[0x28] = (u8)g_zbInfo.nwkNib.nwkAddr;
  dest[0x29] = (u8)(uVar1 >> 8);
  bVar3 = pGpDataInd->rssi;
  uVar11 = (uint)bVar3;
  if ((char)bVar3 + 0x6d < 0 != SCARRY4((int)(char)bVar3, 0x6d))
  {
    uVar11 = 0xffffff92;
  }
  uVar8 = uVar11 & 0xff;
  if ('\b' < (char)uVar11)
  {
    uVar8 = 8;
  }
  iVar12 = (uVar8 + 0x6e) * 0x1000000;
  dest[0x2d] = dest[0x2d] & 0xc0 | (byte)((iVar12 >> 0x18) - (iVar12 >> 0x1f) >> 1) & 0x3f;
  bVar14 = pGpDataInd->lqi != '\0';
  bVar3 = bVar14 * '\x02';
  dest[0x2d] = dest[0x2d] & 0x3f | bVar14 * -0x80;
  dest[0xe] = '\x02';
  uVar1 = g_gppCtx.gpCommissionerAddr;
  if ((int)((uint)g_gppCtx.gpCommissioningModeOpt.opts << 0x1a) < 0)
  {
    *dest = (u8)g_gppCtx.gpCommissionerAddr;
    dest[1] = (u8)(uVar1 >> 8);
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
    if ((uVar1 & 0xfff8) != 0xfff8)
    {
      dest[0xc] = '\0';
      goto LAB_0000b458;
    }
  }
  else
  {
    *dest = 0xfc;
    dest[1] = 0xfe;
    dest[0xf] = 0xf2;
    dest[8] = 0xdf;
    dest[9] = 0xa0;
  }
  dest[0xc] = '\x01';
  uVar4 = gpAliasSrcAddrDerived();
  dest[10] = (u8)uVar4;
  dest[0xb] = (u8)((ushort)uVar4 >> 8);
  dest[0xd] = pGpDataInd->seqNum + 0xf4;
  bVar3 = dest[0x2d] >> 6;
LAB_0000b458:
  bVar3 = gppTunnelingDelayGet(SUB41(((uint)dest[0x26] << 0x1c) >> 0x1f, 0), bVar3, (bool)g_gppCtx.firstToForward, false);
  ev_timer_taskPost(gpCommissioningNotificationCmdSend, dest, (uint)bVar3);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAR(void)

{
  code *in_r2;

  (*in_r2)();
  nv_flashWriteNew('\x01', 3, '%', 0x146, (u8 *)&g_gpProxyTab);
  return;
}

void gp_proxyTabSave2Flash(void *arg)

{
  nv_flashWriteNew('\x01', 3, '%', 0x146, (u8 *)&g_gpProxyTab);
  return;
}

nv_sts_t gp_proxyTabRestoreFromFlash(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashReadNew('\x01', '\x03', '%', 0x146, (u8 *)&g_gpProxyTab);
  return nVar1;
}

void gp_proxyTabEntryClear(gpProxyTabEntry_t *pEntry)

{
  if ((int)((uint)(byte)pEntry->field_0x40 << 0x1f) < 0)
  {
    memset(pEntry, 0, 0x41);
    g_gpProxyTab.gpProxyTabNum = g_gpProxyTab.gpProxyTabNum + 0xff;
  }
  return;
}

u8 gp_getProxyTabEntryTotalNum(void)

{
  return g_gpProxyTab.gpProxyTabNum;
}

u8 gp_getProxyTabEntryLen(gpProxyTabEntry_t *pEntry)

{
  byte bVar1;
  u8 uVar2;
  uint uVar3;
  uint uVar4;
  char cVar5;
  uint uVar6;
  uint uVar7;

  bVar1 = *(byte *)&pEntry->options;
  uVar6 = (uint)bVar1;
  cVar5 = '\x06';
  if ((bVar1 & 7) != 0)
  {
    cVar5 = '\v';
    if ((uVar6 & 7) != 2)
    {
      cVar5 = '\x02';
    }
  }
  uVar7 = (uint) * (byte *)((int)&pEntry->options + 1);
  if ((int)(uVar7 << 0x1a) < 0)
  {
    cVar5 = cVar5 + '\x02';
  }
  if ((int)(uVar7 << 0x19) < 0)
  {
    cVar5 = cVar5 + '\x15';
  }
  else if ((int)(uVar6 << 0x1a) < 0)
  {
    cVar5 = cVar5 + '\x04';
  }
  if ((bVar1 & 0x40) != 0)
  {
    cVar5 = cVar5 + ((pEntry->field_0x40 & 6) != 0);
    uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
    if (uVar3 != 0)
    {
      uVar4 = 0;
      do
      {
        cVar5 = cVar5 + '\n';
        uVar4 = uVar4 + 1 & 0xff;
      } while (uVar4 < uVar3);
    }
  }
  if ((int)(uVar7 << 0x1f) < 0)
  {
    cVar5 = cVar5 + ((pEntry->field_0x40 & 0x18) != 0);
    uVar7 = ((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e;
    if (uVar7 != 0)
    {
      uVar3 = 0;
      do
      {
        cVar5 = cVar5 + '\x04';
        uVar3 = uVar3 + 1 & 0xff;
      } while (uVar3 < uVar7);
    }
  }
  uVar2 = cVar5 + '\x01';
  if ((uVar6 & 0x18) != 0x18)
  {
    uVar2 = cVar5 + '\x02';
  }
  return uVar2;
}

u8 gp_buildProxyTabEntryFormat(gpProxyTabEntry_t *pEntry, u8 *pBuf)

{
  uint uVar1;
  gpSecOpt_t *pgVar2;
  gpSecOpt_t *out;

  *pBuf = *(u8 *)&pEntry->options;
  pBuf[1] = *(u8 *)((int)&pEntry->options + 1);
  out = (gpSecOpt_t *)(pBuf + 2);
  if ((*(byte *)&pEntry->options & 7) == 0)
  {
    pBuf[2] = (pEntry->gpdId).gpdIeeeAddr[0];
    pBuf[3] = (pEntry->gpdId).gpdIeeeAddr[1];
    pBuf[4] = (pEntry->gpdId).gpdIeeeAddr[2];
    pBuf[5] = (pEntry->gpdId).gpdIeeeAddr[3];
    out = (gpSecOpt_t *)(pBuf + 6);
  }
  else if ((*(byte *)&pEntry->options & 7) == 2)
  {
    memcpy(out, pEntry, 8);
    pBuf[10] = pEntry->endpoint;
    out = (gpSecOpt_t *)(pBuf + 0xb);
  }
  uVar1 = (uint) * (byte *)((int)&pEntry->options + 1);
  if ((int)(uVar1 << 0x1a) < 0)
  {
    *out = *(gpSecOpt_t *)&pEntry->gpdAssignedAlias;
    out[1] = *(gpSecOpt_t *)((int)&pEntry->gpdAssignedAlias + 1);
    out = out + 2;
    uVar1 = (uint) * (byte *)((int)&pEntry->options + 1);
  }
  if ((uVar1 & 0x40) == 0)
  {
  LAB_0000b944:
    uVar1 = (uint) * (byte *)&pEntry->options;
    pgVar2 = out;
    if (-1 < (int)(uVar1 << 0x1a))
      goto LAB_0000b87a;
  }
  else
  {
    *out = pEntry->secOptions;
    out = out + 1;
    pgVar2 = out;
    if ((*(byte *)((int)&pEntry->options + 1) & 0x40) == 0)
      goto LAB_0000b944;
  }
  *pgVar2 = *(gpSecOpt_t *)&pEntry->gpdSecFrameCnt;
  pgVar2[1] = *(gpSecOpt_t *)((int)&pEntry->gpdSecFrameCnt + 1);
  pgVar2[2] = *(gpSecOpt_t *)((int)&pEntry->gpdSecFrameCnt + 2);
  pgVar2[3] = *(gpSecOpt_t *)((int)&pEntry->gpdSecFrameCnt + 3);
  out = pgVar2 + 4;
  if ((int)((uint) * (byte *)((int)&pEntry->options + 1) << 0x19) < 0)
  {
    memcpy(out, pEntry->gpdKey, 0x10);
    out = pgVar2 + 0x14;
  }
  uVar1 = (uint) * (byte *)&pEntry->options;
LAB_0000b87a:
  if ((uVar1 & 0x40) != 0)
  {
    out->opts = (byte)(((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e);
    out = out + 1;
    if (((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e != 0)
    {
      uVar1 = 0;
      do
      {
        memcpy(out, pEntry->lightweightSinkAddrList + uVar1, 8);
        out[8] = *(gpSecOpt_t *)&pEntry->lightweightSinkAddrList[uVar1].sinkNwkAddr;
        out[9] = *(gpSecOpt_t *)((int)&pEntry->lightweightSinkAddrList[uVar1].sinkNwkAddr + 1);
        out = out + 10;
        uVar1 = uVar1 + 1 & 0xff;
      } while (uVar1 < ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e);
    }
  }
  if ((int)((uint) * (byte *)((int)&pEntry->options + 1) << 0x1f) < 0)
  {
    out->opts = (byte)(((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e);
    out = out + 1;
    if (((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e != 0)
    {
      uVar1 = 0;
      do
      {
        *out = *(gpSecOpt_t *)(pEntry->sinkGroupList + uVar1);
        out[1] = *(gpSecOpt_t *)((int)&pEntry->sinkGroupList[uVar1].groupId + 1);
        out[2] = *(gpSecOpt_t *)&pEntry->sinkGroupList[uVar1].alias;
        out[3] = *(gpSecOpt_t *)((int)&pEntry->sinkGroupList[uVar1].alias + 1);
        out = out + 4;
        uVar1 = uVar1 + 1 & 0xff;
      } while (uVar1 < ((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e);
    }
  }
  *out = (gpSecOpt_t)pEntry->groupcastRadius;
  pgVar2 = out + 1;
  if ((*(byte *)&pEntry->options & 0x18) != 0x18)
  {
    out[1] = (gpSecOpt_t)pEntry->searchCnt;
    pgVar2 = out + 2;
  }
  return (u8)((uint)(((int)pgVar2 - (int)pBuf) * 0x1000000) >> 0x18);
}

void zclGpProxyTabAttrUpdate(void)

{
  u8 uVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  uint uVar5;
  u8 *pBuf;
  uint uVar6;

  if (g_gpProxyTab.gpProxyTabNum == '\0')
  {
    zclGpAttr_proxyTabEntry[0] = '\0';
    zclGpAttr_proxyTabEntry[1] = '\0';
  }
  else
  {
    uVar5 = (uint)zclGpAttr_gppMaxProxyTabEntries;
    if (uVar5 == 0)
    {
      zclGpAttr_proxyTabEntry[0] = zclGpAttr_gppMaxProxyTabEntries;
      zclGpAttr_proxyTabEntry[1] = zclGpAttr_gppMaxProxyTabEntries;
    }
    else
    {
      uVar4 = 0;
      uVar6 = 0;
      bVar3 = 0;
      do
      {
        while (((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar4].field_0x40 << 0x1f) >> 0x1f) *
                   -0x1000000 ==
               0)
        {
          uVar4 = uVar4 + 1;
          if (uVar5 <= (uVar4 & 0xff))
            goto LAB_0000b9dc;
        }
        uVar1 = gp_getProxyTabEntryLen(g_gpProxyTab.gpProxyTab + uVar4);
        bVar2 = uVar1 + bVar3;
        if (0x4a < bVar2)
          break;
        uVar6 = uVar6 + 1 & 0xff;
        uVar4 = uVar4 + 1;
        bVar3 = bVar2;
      } while ((uVar4 & 0xff) < uVar5);
    LAB_0000b9dc:
      zclGpAttr_proxyTabEntry[0] = bVar3;
      zclGpAttr_proxyTabEntry[1] = '\0';
      if (uVar6 != 0)
      {
        uVar5 = 0;
        pBuf = zclGpAttr_proxyTabEntry + 2;
        do
        {
          while (((int)((uint)(byte)g_gpProxyTab.gpProxyTab[uVar5].field_0x40 << 0x1f) >> 0x1f) *
                     -0x1000000 !=
                 0)
          {
            bVar3 = gp_buildProxyTabEntryFormat(g_gpProxyTab.gpProxyTab + uVar5, pBuf);
            pBuf = pBuf + bVar3;
            uVar5 = uVar5 + 1;
            if (uVar6 <= (uVar5 & 0xff))
            {
              return;
            }
          }
          uVar5 = uVar5 + 1;
        } while ((uVar5 & 0xff) < uVar6);
      }
    }
  }
  return;
}

gpProxyTabEntry_t *gp_getProxyTabByGpdId(u8 appId, gpdId_t gpdId)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  gpProxyTabEntry_t *m2;
  undefined local_28[8];

  if ((g_gpProxyTab.gpProxyTabNum != '\0') &&
      (uVar2 = (uint)zclGpAttr_gppMaxProxyTabEntries, uVar2 != 0))
  {
    uVar3 = 0;
    do
    {
      m2 = g_gpProxyTab.gpProxyTab + uVar3;
      if (((g_gpProxyTab.gpProxyTab[uVar3].field_0x40 & 1) != 0) &&
          ((*(byte *)&g_gpProxyTab.gpProxyTab[uVar3].options & 7) == appId))
      {
        if (appId == '\0')
        {
          iVar1 = memcmp(local_28, m2, 4);
        }
        else
        {
          if (appId != '\x02')
            goto LAB_0000ba98;
          iVar1 = memcmp(local_28, m2, 8);
        }
        if (iVar1 == 0)
        {
          return m2;
        }
      }
    LAB_0000ba98:
      uVar3 = uVar3 + 1;
    } while ((uVar3 & 0xff) < uVar2);
  }
  return (gpProxyTabEntry_t *)0x0;
}

gpProxyTabEntry_t *gp_proxyTabEntryFreeGet(void)

{
  int iVar1;
  gp_proxyTab_t *pgVar2;
  byte bVar3;
  int iVar4;
  int iVar5;
  int iVar6;

  pgVar2 = (gp_proxyTab_t *)0x0;
  if ((g_gpProxyTab.gpProxyTabNum < zclGpAttr_gppMaxProxyTabEntries) &&
      (zclGpAttr_gppMaxProxyTabEntries != '\0'))
  {
    if ((int)((uint)g_gpProxyTab.gpProxyTab[0]._64_1_ << 0x1f) < 0)
    {
      bVar3 = 0;
      iVar5 = 0;
      do
      {
        bVar3 = bVar3 + 1;
        if (zclGpAttr_gppMaxProxyTabEntries <= bVar3)
        {
          return (gpProxyTabEntry_t *)0x0;
        }
        iVar4 = iVar5 + 1;
        iVar6 = iVar4 * 0x40;
        iVar1 = iVar5 + 1;
        pgVar2 = (gp_proxyTab_t *)(g_gpProxyTab.gpProxyTab + iVar5 + 1);
        iVar5 = iVar4;
      } while ((g_gpProxyTab.gpProxyTab[iVar1].field_0x40 & 1) != 0);
    }
    else
    {
      iVar4 = 0;
      iVar6 = 0;
      pgVar2 = &g_gpProxyTab;
    }
    iVar6 = iVar6 + iVar4;
    g_gpProxyTab.gpProxyTab[0].lightweightSinkAddrList[0].sinkIeeeAddr[iVar6 + -4] = 0xfe;
    g_gpProxyTab.gpProxyTab[0].lightweightSinkAddrList[0].sinkIeeeAddr[iVar6 + -3] = 0xfe;
    g_gpProxyTab.gpProxyTab[0].lightweightSinkAddrList[0].sinkIeeeAddr[iVar6 + -2] = 0xfe;
    g_gpProxyTab.gpProxyTab[0].lightweightSinkAddrList[0].sinkIeeeAddr[iVar6 + -1] = 0xfe;
    g_gpProxyTab.gpProxyTab[0].gpdKey[iVar6 + -2] = 0xfe;
  }
  return pgVar2->gpProxyTab;
}

u8 lwSinkAddrListAdd(gpProxyTabEntry_t *pEntry, u8 *sinkIeeeAddr, u16 sinkNwkAddr)

{
  int iVar1;
  uint uVar2;
  uint uVar3;

  if ((pEntry->field_0x40 & 6) == 0)
  {
    memcpy(pEntry->lightweightSinkAddrList, sinkIeeeAddr, 8);
    *(char *)&pEntry->lightweightSinkAddrList[0].sinkNwkAddr = (char)sinkNwkAddr;
    *(char *)((int)&pEntry->lightweightSinkAddrList[0].sinkNwkAddr + 1) =
        (char)((uint)sinkNwkAddr >> 8);
    pEntry->field_0x40 =
        pEntry->field_0x40 & 0xf9 |
        (byte)(((((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e) + 1 & 3) << 1);
  }
  else
  {
    uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
    if (uVar3 != 0)
    {
      uVar2 = 0;
      do
      {
        iVar1 = memcmp(pEntry->lightweightSinkAddrList + uVar2, sinkIeeeAddr, 8);
        if ((iVar1 == 0) &&
            ((uint)pEntry->lightweightSinkAddrList[uVar2].sinkNwkAddr == (uint)sinkNwkAddr))
        {
          return '\0';
        }
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < uVar3);
      if (1 < uVar3)
      {
        return '\x01';
      }
    }
    memcpy(pEntry->lightweightSinkAddrList + uVar3, sinkIeeeAddr, 8);
    uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
    pEntry->lightweightSinkAddrList[uVar3].sinkNwkAddr = sinkNwkAddr;
    pEntry->field_0x40 = pEntry->field_0x40 & 0xf9 | (byte)((uVar3 + 1 & 3) << 1);
  }
  return '\0';
}

u8 lwSinkAddrListRemove(gpProxyTabEntry_t *pEntry, u8 *sinkIeeeAddr, u16 sinkNwkAddr)

{
  u16 uVar1;
  int iVar2;
  uint uVar3;
  u8 *puVar4;
  uint uVar5;
  u16 *puVar6;
  gpLwSinkAddrListItem_t *m1;

  if (((pEntry->field_0x40 & 6) != 0) &&
      (uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e, uVar3 != 0))
  {
    uVar5 = 0;
    do
    {
      m1 = pEntry->lightweightSinkAddrList + uVar5;
      iVar2 = memcmp(m1, sinkIeeeAddr, 8);
      if ((iVar2 == 0) &&
          (puVar6 = &pEntry->lightweightSinkAddrList[uVar5].sinkNwkAddr, *puVar6 == sinkNwkAddr))
      {
        if (uVar5 == uVar3 - 2)
        {
          m1->sinkIeeeAddr[0] = '\0';
          m1->sinkIeeeAddr[1] = '\0';
          m1->sinkIeeeAddr[2] = '\0';
          m1->sinkIeeeAddr[3] = '\0';
          m1->sinkIeeeAddr[4] = '\0';
          m1->sinkIeeeAddr[5] = '\0';
          m1->sinkIeeeAddr[6] = '\0';
          m1->sinkIeeeAddr[7] = '\0';
          *(undefined *)puVar6 = 0;
          *(undefined *)((int)&pEntry->lightweightSinkAddrList[uVar5].sinkNwkAddr + 1) = 0;
          uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
        }
        else
        {
          memcpy(m1, pEntry->gpdKey + uVar3 * 10, 8);
          uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
          uVar1 = pEntry->lightweightSinkAddrList[uVar3 - 1].sinkNwkAddr;
          *(char *)puVar6 = (char)uVar1;
          *(char *)((int)&pEntry->lightweightSinkAddrList[uVar5].sinkNwkAddr + 1) =
              (char)(uVar1 >> 8);
          puVar4 = pEntry->gpdKey + uVar3 * 10 + 10;
          *puVar4 = '\0';
          puVar4[1] = '\0';
          puVar4[2] = '\0';
          puVar4[3] = '\0';
          puVar4[4] = '\0';
          puVar4[5] = '\0';
          puVar4[6] = '\0';
          puVar4[7] = '\0';
          uVar3 = ((uint)(byte)pEntry->field_0x40 << 0x1d) >> 0x1e;
          *(undefined *)&pEntry->lightweightSinkAddrList[uVar3 - 1].sinkNwkAddr = 0;
          *(undefined *)((int)&pEntry->lightweightSinkAddrList[uVar3 - 1].sinkNwkAddr + 1) = 0;
        }
        pEntry->field_0x40 = pEntry->field_0x40 & 0xf9 | (byte)((uVar3 + 3 & 3) << 1);
        return '\0';
      }
      uVar5 = uVar5 + 1 & 0xff;
    } while (uVar5 < uVar3);
  }
  return '\x01';
}

u8 sinkGroupListAdd(gpProxyTabEntry_t *pEntry, u16 sinkGroupID, u16 alias)

{
  byte bVar1;
  undefined uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;

  uVar3 = (uint)sinkGroupID;
  bVar1 = pEntry->field_0x40;
  uVar2 = (undefined)(uVar3 >> 8);
  if ((bVar1 & 0x18) == 0)
  {
    *(char *)&pEntry->sinkGroupList[0].groupId = (char)sinkGroupID;
    *(undefined *)((int)&pEntry->sinkGroupList[0].groupId + 1) = uVar2;
    *(char *)&pEntry->sinkGroupList[0].alias = (char)alias;
    *(char *)((int)&pEntry->sinkGroupList[0].alias + 1) = (char)((uint)alias >> 8);
    pEntry->field_0x40 = bVar1 & 0xe7 | (byte)(((((uint)bVar1 << 0x1b) >> 0x1e) + 1 & 3) << 3);
  }
  else
  {
    uVar5 = ((uint)bVar1 << 0x1b) >> 0x1e;
    if (uVar5 == 0)
    {
    LAB_0000be26:
      *(char *)&pEntry->sinkGroupList[uVar5].groupId = (char)sinkGroupID;
      *(undefined *)((int)&pEntry->sinkGroupList[uVar5].groupId + 1) = uVar2;
      pEntry->sinkGroupList[uVar5].alias = alias;
      pEntry->field_0x40 = pEntry->field_0x40 & 0xe7 | (byte)((uVar5 + 1 & 3) << 3);
    }
    else
    {
      if (pEntry->sinkGroupList[0].groupId == uVar3)
      {
        uVar4 = 0;
      }
      else
      {
        uVar4 = 0;
        do
        {
          uVar4 = uVar4 + 1 & 0xff;
          if (uVar5 <= uVar4)
          {
            if (1 < uVar5)
            {
              return '\x01';
            }
            goto LAB_0000be26;
          }
        } while (CONCAT11(*(undefined *)((int)&pEntry->sinkGroupList[uVar4].groupId + 1),
                          *(undefined *)&pEntry->sinkGroupList[uVar4].groupId) != uVar3);
      }
      pEntry->sinkGroupList[uVar4].alias = alias;
    }
  }
  return '\0';
}

u8 sinkGroupListRemove(gpProxyTabEntry_t *pEntry, u16 sinkGroupID)

{
  undefined2 uVar1;
  int iVar2;
  u8 uVar3;
  uint uVar4;
  uint uVar5;

  uVar3 = '\x01';
  if (((pEntry->field_0x40 & 0x18) != 0) &&
      (uVar5 = ((uint)(byte)pEntry->field_0x40 << 0x1b) >> 0x1e, uVar5 != 0))
  {
    if (pEntry->sinkGroupList[0].groupId == sinkGroupID)
    {
      uVar4 = 0;
    }
    else
    {
      uVar4 = 0;
      do
      {
        uVar4 = uVar4 + 1 & 0xff;
        if (uVar5 <= uVar4)
        {
          return '\x01';
        }
      } while (CONCAT11(*(undefined *)((int)&pEntry->sinkGroupList[uVar4].groupId + 1),
                        *(undefined *)&pEntry->sinkGroupList[uVar4].groupId) != sinkGroupID);
    }
    if (uVar5 - 1 == uVar4)
    {
      iVar2 = uVar5 * 4;
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 6] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 7] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 8] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 9] = '\0';
    }
    else
    {
      iVar2 = uVar5 * 4;
      uVar3 = pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 7];
      *(u8 *)&pEntry->sinkGroupList[uVar4].groupId =
          pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 6];
      *(u8 *)((int)&pEntry->sinkGroupList[uVar4].groupId + 1) = uVar3;
      uVar1 = *(undefined2 *)(pEntry->lightweightSinkAddrList[1].sinkIeeeAddr + iVar2 + 8);
      *(char *)&pEntry->sinkGroupList[uVar4].alias = (char)uVar1;
      *(char *)((int)&pEntry->sinkGroupList[uVar4].alias + 1) = (char)((ushort)uVar1 >> 8);
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 6] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 7] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 8] = '\0';
      pEntry->lightweightSinkAddrList[1].sinkIeeeAddr[iVar2 + 9] = '\0';
    }
    pEntry->field_0x40 = pEntry->field_0x40 & 0xe7 | (byte)((uVar5 + 3 & 3) << 3);
    uVar3 = '\0';
  }
  return uVar3;
}

void gpProxyTabUpdate(void)

{
  zclGpProxyTabAttrUpdate();
  tl_zbTaskPost(gp_proxyTabSave2Flash, (void *)0x0);
  return;
}

void gpProxyTabInit(void)

{
  nv_sts_t nVar1;

  nVar1 = gp_proxyTabRestoreFromFlash();
  if (nVar1 == NV_SUCC)
  {
    zclGpProxyTabAttrUpdate();
  }
  else
  {
    memset(&g_gpProxyTab, 0, 0x146);
  }
  return;
}

nwk_brcTransRecordEntry_t *brcTransRecordEntryGet(u8 idx)

{
  return g_brcTransTab + idx;
}

aps_binding_entry_t *bindTblEntryGet(void)

{
  return g_apsBindingTbl;
}

u32 zbBufferSizeGet(void)

{
  return 0x1d48;
}

u32 neighborTblSizeGet(void)

{
  return 0x45c;
}

u32 addrMapTblSizeGet(void)

{
  return 0xa0c;
}

u8 bdb_topLevelCommissioning(u8 target)

{
  u8 uVar1;

  uVar1 = '\x06';
  if ((g_bdbCtx.state == '\0') && (g_zbInfo.bdbAttr.commissioningStatus != '\x01'))
  {
    g_zbInfo.bdbAttr.commissioningStatus = '\x01';
    g_bdbCtx.role = target;
    tl_zbTaskPost(bdb_task, &_d);
    uVar1 = '\0';
  }
  return uVar1;
}

s32 bdb_findBindIdentifyQueryTimeout(void *arg)

{
  if ((g_bdbCtx.pFindBindQ == (findBindQ_t *)0x0) ||
      ((g_bdbCtx.pFindBindQ)->front == (g_bdbCtx.pFindBindQ)->rear))
  {
    g_bdbCtx.status = '\x06';
    tl_zbTaskPost(bdb_task, &DAT_0000000a);
  }
  else
  {
    tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  }
  g_bdbCtx.field_2.identifyTimer = (ev_timer_event_t *)0x0;
  return -2;
}

s32 bdb_simpleDescReqTimeoutCb(void *arg)

{
  tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  g_bdbCtx.field_2.identifyTimer = (ev_timer_event_t *)0x0;
  return -2;
}

s32 bdb_task_delay(void *arg)

{
  tl_zbTaskPost(bdb_task, arg);
  return -2;
}

// WARNING: Could not reconcile some variable overlaps

u8 bdb_commissioningFindBind(void)

{
  u8 seqNo;
  u8 uVar1;
  epInfo_t dstEpInfo;

  seqNo = zcl_seqNum;
  uVar1 = '\0';
  if (((int)((uint)(byte)g_zbInfo.bdbAttr.commissioningMode << 0x1c) < 0) &&
      (g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0'))
  {
    if (g_bdbCtx.role == '\x02')
    {
      if (g_bdbCtx.field_2.identifyTimer == (ev_timer_event_t *)0x0)
      {
        g_bdbCtx.field_2.identifyTimer =
            ev_timer_taskPost(bdb_findBindIdentifyTimeout, (void *)0x0, (u32)&DAT_00001388);
      }
      uVar1 = '\x05';
      if ((g_bdbCtx.bdbAppCb)->bdbIdentifyCb != ll_reset)
      {
        FUNAAAAS();
      }
    }
    else
    {
      dstEpInfo.dstAddr._4_4_ = 0;
      dstEpInfo._16_2_ = 0;
      dstEpInfo.dstAddr._0_4_ = 0xfffe;
      dstEpInfo._12_4_ = 0xfe020000;
      dstEpInfo._8_4_ = 0x104;
      zcl_seqNum = zcl_seqNum + '\x01';
      zcl_identify_identifyQuery((g_bdbCtx.simpleDesc)->endpoint, &dstEpInfo, '\x01', seqNo);
      uVar1 = '\x05';
      if (g_bdbCtx.field_2.identifyTimer == (ev_timer_event_t *)0x0)
      {
        g_bdbCtx.field_2.identifyTimer =
            ev_timer_taskPost(bdb_findBindIdentifyQueryTimeout, (void *)0x0, (u32)&DAT_00001388);
      }
    }
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 FUNAAAAS(void)

{
  u8 uVar1;
  code *in_r3;

  (*in_r3)();
  if (((int)((uint)(byte)g_zbInfo.bdbAttr.commissioningMode << 0x1d) < 0) &&
      (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0'))
  {
    zb_nwkFormation(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration);
    uVar1 = '\x04';
  }
  else
  {
    uVar1 = bdb_commissioningFindBind();
  }
  return uVar1;
}

u8 bdb_commissioningNetworkFormation(void)

{
  u8 uVar1;

  if (((int)((uint)(byte)g_zbInfo.bdbAttr.commissioningMode << 0x1d) < 0) &&
      (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0'))
  {
    zb_nwkFormation(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration);
    uVar1 = '\x04';
  }
  else
  {
    uVar1 = bdb_commissioningFindBind();
  }
  return uVar1;
}

void bdb_simpleDescReqSend(void *arg)

{
  findBindQ_t *pfVar1;
  byte bVar2;

  pfVar1 = g_bdbCtx.pFindBindQ;
  if ((g_bdbCtx.pFindBindQ == (findBindQ_t *)0x0) ||
      ((g_bdbCtx.pFindBindQ)->rear == (g_bdbCtx.pFindBindQ)->front))
  {
    g_bdbCtx.status = '\0';
    tl_zbTaskPost(bdb_task, &DAT_0000000a);
  }
  else
  {
    bVar2 = FUNAAAAB();
    pfVar1->front = bVar2;
    g_bdbCtx.findDstInfo.addr =
        CONCAT11(*(undefined *)((int)&pfVar1->findBindDstInfo[bVar2].addr + 1),
                 *(undefined *)&pfVar1->findBindDstInfo[bVar2].addr);
    g_bdbCtx.findDstInfo.endpoint = pfVar1->findBindDstInfo[bVar2].endpoint;
    if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
    {
      ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
    }
    tl_zbTaskPost(bdb_task, &DAT_0000000b);
    g_bdbCtx.field_2.identifyTimer =
        ev_timer_taskPost(bdb_simpleDescReqTimeoutCb, (void *)0x0, (u32)&DAT_00001388);
  }
  return;
}

s32 bdb_findBindIdentifyTimeout(void *arg)

{
  status_t sVar1;
  u16 local_14;
  short local_12[3];

  local_12[0] = 0;
  local_14 = 0;
  sVar1 = zcl_getAttrVal((g_bdbCtx.simpleDesc)->endpoint, 3, 0, &local_14, (u8 *)local_12);
  if (sVar1 == '\0')
  {
    if ((local_12[0] != 0) && (bdb_findBindIdentifyTimeout::timerIdentifyCnt < 0x24))
    {
      bdb_findBindIdentifyTimeout::timerIdentifyCnt =
          bdb_findBindIdentifyTimeout::timerIdentifyCnt + 1;
      return 0;
    }
    bdb_findBindIdentifyTimeout::timerIdentifyCnt = 0;
    g_bdbCtx.status = '\0';
    tl_zbTaskPost(bdb_task, &DAT_0000000a);
  }
  g_bdbCtx.field_2 = (anon_union_4_2_85b55d36_for_bdb_ctx_t_2)0x0;
  return -2;
}

void bdb_binding(zdo_bind_dstAddr_t *pDstAddr, u8 clusterNum, u16 *clusterList)

{
  u8 uVar1;
  zdo_status_t zVar2;
  byte bVar3;
  undefined local_3c[12];
  uint uStack_30;
  undefined4 uStack_2c;
  u8 local_28;
  u8 local_25;

  local_3c._0_4_ = 0;
  local_3c._4_4_ = 0;
  local_3c._8_4_ = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  local_28 = '\0';
  memcpy(local_3c, g_zbInfo.macPib.extAddress, 8);
  local_3c._8_3_ = (uint3)local_3c._8_4_ & 0xffff00 | (uint3)(g_bdbCtx.simpleDesc)->endpoint;
  uVar1 = pDstAddr->dstAddrMode;
  local_3c._8_4_ = CONCAT13(uVar1, local_3c._8_3_);
  if (uVar1 == '\x03')
  {
    memcpy(&uStack_30, &pDstAddr->dstAddr, 8);
    local_28 = (pDstAddr->dstAddr).field_0.dstEp;
  }
  else if (uVar1 == '\x01')
  {
    uStack_30 = uStack_30 & 0xffff0000 | (uint)(pDstAddr->dstAddr).dstGroupId;
  }
  if (clusterNum == '\0')
  {
    ev_buf_free((u8 *)g_bdbCtx.matchClusterList);
    g_bdbCtx.matchClusterNum = clusterNum;
  }
  else
  {
    bVar3 = 0;
    do
    {
      local_3c._8_3_ = CONCAT12((char)(*clusterList >> 8), CONCAT11((char)*clusterList, local_3c[8]));
      local_3c._8_4_ = local_3c._8_4_ & 0xff000000 | (uint)local_3c._8_3_;
      local_25 = '\0';
      zVar2 = zb_zdoBindUnbindReq(true, (zdo_bind_req_t *)local_3c, &local_25, ll_reset);
      if (zVar2 == ZDO_TABLE_FULL)
      {
        g_bdbCtx.status = '\a';
        tl_zbTaskPost(bdb_task, &DAT_0000000a);
        ev_buf_free((u8 *)g_bdbCtx.matchClusterList);
        g_bdbCtx.matchClusterList = (u16 *)0x0;
        g_bdbCtx.matchClusterNum = '\0';
        return;
      }
      bVar3 = bVar3 + 1;
      clusterList = clusterList + 1;
    } while (bVar3 < clusterNum);
    ev_buf_free((u8 *)g_bdbCtx.matchClusterList);
    g_bdbCtx.matchClusterNum = '\0';
    g_bdbCtx.matchClusterList = (u16 *)0x0;
    if (zVar2 != ZDO_SUCCESS)
      goto LAB_0000c32a;
  }
  g_bdbCtx.matchClusterList = (u16 *)0x0;
  if ((g_bdbCtx.bdbAppCb != (bdb_appCb_t *)0x0) &&
      ((g_bdbCtx.bdbAppCb)->bdbFindBindSuccessCb != ll_reset))
  {
    FUNAAAAT();
  }
LAB_0000c32a:
  tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAT(void)

{
  byte bVar1;
  int *piVar2;
  code *in_r3;
  undefined auStack_18[4];
  uint uStack_14;
  undefined2 uStack_10;

  piVar2 = (int *)(*in_r3)();
  bVar1 = *(byte *)(*piVar2 + 1);
  uStack_14 = (uint)bVar1;
  if (uStack_14 == 0)
  {
    auStack_18 = (undefined[4])0x3;
    uStack_10 = CONCAT11(g_bdbCtx.bindDstInfo.endpoint, bVar1);
    memcpy(auStack_18 + 1, (void *)(*piVar2 + 2), 8);
    bdb_binding((zdo_bind_dstAddr_t *)auStack_18, g_bdbCtx.matchClusterNum, g_bdbCtx.matchClusterList);
  }
  return;
}

void bdb_ieeeAddrResp(void *arg)

{
  byte bVar1;
  undefined local_18[4];
  uint uStack_14;
  undefined2 local_10;

  // WARNING: Load size is inaccurate
  bVar1 = *(byte *)(*arg + 1);
  uStack_14 = (uint)bVar1;
  if (uStack_14 == 0)
  {
    local_18 = (undefined[4])0x3;
    local_10 = CONCAT11(g_bdbCtx.bindDstInfo.endpoint, bVar1);
    memcpy(local_18 + 1, (void *)(*arg + 2), 8);
    bdb_binding((zdo_bind_dstAddr_t *)local_18, g_bdbCtx.matchClusterNum, g_bdbCtx.matchClusterList);
  }
  return;
}

void bdb_commissioningInfoSave(void *arg)

{
  nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter);
  zdo_ssInfoSaveToFlash();
  zb_info_save((void *)0x0);
  nwk_parentNodeInfoStore();
  g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfd;
  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
  return;
}

u8 bdb_topLevelCommissiongConfirm(void)

{
  u8 uVar1;
  u8 local_11[5];

  g_zbInfo.bdbAttr.commissioningStatus = g_bdbCtx.status;
  if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
  }
  if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
  {
    FUNAAAAU();
  }
  if (g_zbInfo.bdbAttr.commissioningStatus == '\0')
  {
    local_11[0] = g_zbInfo.bdbAttr.commissioningStatus;
    tl_zbMacAttrGet('\0', &g_bdbCtx.channel, local_11);
    if ((g_bdbCtx._43_1_ & 2) != 0)
    {
      bdb_commissioningInfoSave((void *)0x0);
      g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfd;
    }
  }
  else if (((int)((uint)g_zbInfo.bdbAttr.nodeCommissioningCapability << 0x1c) < 0) &&
           (uVar1 = is_device_factory_new(), uVar1 != '\0'))
  {
    tl_zbMacChannelSet(g_bdbCtx.channel);
    rf_setTrxState('\x01');
  }
  return '\0';
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAU(void)

{
  u8 uVar1;
  bool bVar2;
  byte bVar3;
  int iVar4;
  code *in_r3;
  zdo_simple_descriptor_req_t azStack_18[2];
  u8 uStack_12;
  u8 auStack_11[5];

  iVar4 = (*in_r3)();
  auStack_11[0] = '\0';
  uVar1 = g_bdbCtx.state;
  switch (g_bdbCtx.state)
  {
  case '\0':
    if (iVar4 == 2)
    {
      if (((byte)g_zbInfo.bdbAttr.commissioningMode & 1) == 0)
      {
        if (((byte)g_zbInfo.bdbAttr.commissioningMode & 2) != 0)
        {
          if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
          {
            zb_nwkDiscovery(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration, bdb_nwkDiscCnfCb);
          }
          else
          {
            uStack_12 = (u8)(zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1);
            zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', &uStack_12,
                                 (zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1));
            tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
          }
          g_bdbCtx.state = '\x03';
          return;
        }
        uVar1 = bdb_commissioningNetworkFormation();
        if (uVar1 != '\0')
        {
          g_bdbCtx.state = uVar1;
          return;
        }
      }
      else if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
      {
        ss_securityModeSet(1);
      }
      g_zbInfo.bdbAttr.commissioningStatus = '\x03';
      uVar1 = '\0';
      if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
      {
        FUNAAAAV();
      }
    }
    else if (iVar4 == 7)
    {
      bdb_topLevelCommissiongConfirm();
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x01':
    g_bdbCtx.state = '\0';
    uVar1 = g_bdbCtx.state;
    if (iVar4 == 1)
    {
      if ((g_bdbCtx.bdbAppCb)->bdbInitCb != ll_reset)
      {
        FUNAAAAV();
      }
      if ((g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0') &&
          (nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter), g_bdbCtx.initResult == '\0'))
      {
        bVar3 = zdo_ssInfoKeyGet();
        if ((((uint)ss_ib._62_1_ << 0x1a) >> 0x1e != (uint)bVar3) ||
            (((g_zbInfo.macPib.phyChannelCur != g_bdbCtx.channel || ((g_zbNwkCtx._46_1_ & 0x80) != 0)) || ((int)((uint)g_bdbCtx._43_1_ << 0x1c) < 0))))
        {
          g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0x7f;
          tl_zbTaskPost(bdb_commissioningInfoSave, (void *)0x0);
        }
        g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
        zb_zdoSendParentAnnce();
      }
      g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xf6;
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x02':
    if (iVar4 == 3)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xfe);
      g_bdbCtx.state = '\0';
      g_zbInfo.bdbAttr.commissioningStatus = g_bdbCtx.status;
      bdb_topLevelCommissioning('\x02');
      uVar1 = g_bdbCtx.state;
    }
    else if (iVar4 == 4)
    {
      bVar2 = zb_isDeviceFactoryNew();
      if (bVar2 == false)
      {
        bdb_commissioningInfoSave((void *)0x0);
      }
      bdb_topLevelCommissiongConfirm();
      g_bdbCtx.state = '\0';
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x03':
    if (iVar4 == 6)
    {
      ev_timer_taskPost(bdb_retrieveTcLinkKeyStart, (void *)0x0, 1000);
      return;
    }
    if (iVar4 == 5)
    {
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
    LAB_0000c6d6:
      zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', auStack_11, ll_reset);
      tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
      return;
    }
    if (iVar4 != 7)
    {
      return;
    }
    ss_securityModeSet(SS_SEMODE_CENTRALIZED);
    uVar1 = bdb_commissioningNetworkFormation();
    goto joined_r0x0000c518;
  case '\x04':
    if (iVar4 == 8)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
      goto LAB_0000c6d6;
    }
    if (iVar4 != 9)
    {
      return;
    }
    uVar1 = bdb_commissioningFindBind();
  joined_r0x0000c518:
    if (uVar1 == '\0')
    {
    LAB_0000c4fc:
      bdb_topLevelCommissiongConfirm();
    }
    break;
  case '\x05':
    if (iVar4 == 0xb)
    {
      if (g_bdbCtx.role != '\x01')
      {
        return;
      }
      uStack_12 = '\0';
      azStack_18[0].endpoint = g_bdbCtx.findDstInfo.endpoint;
      azStack_18[0].nwk_addr_interest = g_bdbCtx.findDstInfo.addr;
      zb_zdoSimpleDescReq(g_bdbCtx.findDstInfo.addr, azStack_18, &uStack_12, bdb_SimpleDescResp);
      return;
    }
    if (iVar4 != 10)
    {
      return;
    }
    if (g_bdbCtx.pFindBindQ != (findBindQ_t *)0x0)
    {
      ev_buf_free((u8 *)g_bdbCtx.pFindBindQ);
      g_bdbCtx.pFindBindQ = (findBindQ_t *)0x0;
    }
    uVar1 = '\0';
    g_bdbCtx.findDstInfo = (findBindDst_t)0x0;
    g_bdbCtx.bindDstInfo = (findBindDst_t)0x0;
    goto LAB_0000c4fc;
  }
  g_bdbCtx.state = uVar1;
  return;
}

void bdb_task(void *arg)

{
  u8 uVar1;
  bool bVar2;
  byte bVar3;
  zdo_simple_descriptor_req_t local_18[2];
  u8 local_12;
  u8 local_11[5];

  local_11[0] = '\0';
  uVar1 = g_bdbCtx.state;
  switch (g_bdbCtx.state)
  {
  case '\0':
    if ((undefined *)arg == &_d)
    {
      if (((byte)g_zbInfo.bdbAttr.commissioningMode & 1) == 0)
      {
        if (((byte)g_zbInfo.bdbAttr.commissioningMode & 2) != 0)
        {
          if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
          {
            zb_nwkDiscovery(aps_ib.aps_channel_mask, g_zbInfo.bdbAttr.scanDuration, bdb_nwkDiscCnfCb);
          }
          else
          {
            local_12 = (u8)(zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1);
            zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', &local_12,
                                 (zdo_callback)((byte)g_zbInfo.bdbAttr.commissioningMode & 1));
            tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
          }
          g_bdbCtx.state = '\x03';
          return;
        }
        uVar1 = bdb_commissioningNetworkFormation();
        if (uVar1 != '\0')
        {
          g_bdbCtx.state = uVar1;
          return;
        }
      }
      else if (g_zbInfo.bdbAttr.nodeIsOnANetwork == '\0')
      {
        ss_securityModeSet(1);
      }
      g_zbInfo.bdbAttr.commissioningStatus = '\x03';
      uVar1 = '\0';
      if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
      {
        FUNAAAAV();
      }
    }
    else if ((undefined1 *)arg == &DAT_00000007)
    {
      bdb_topLevelCommissiongConfirm();
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x01':
    g_bdbCtx.state = '\0';
    uVar1 = g_bdbCtx.state;
    if ((code *)arg == ll_reset + 1)
    {
      if ((g_bdbCtx.bdbAppCb)->bdbInitCb != ll_reset)
      {
        FUNAAAAV();
      }
      if ((g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0') &&
          (nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter), g_bdbCtx.initResult == '\0'))
      {
        bVar3 = zdo_ssInfoKeyGet();
        if ((((uint)ss_ib._62_1_ << 0x1a) >> 0x1e != (uint)bVar3) ||
            (((g_zbInfo.macPib.phyChannelCur != g_bdbCtx.channel || ((g_zbNwkCtx._46_1_ & 0x80) != 0)) || ((int)((uint)g_bdbCtx._43_1_ << 0x1c) < 0))))
        {
          g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0x7f;
          tl_zbTaskPost(bdb_commissioningInfoSave, (void *)0x0);
        }
        g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
        zb_zdoSendParentAnnce();
      }
      g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xf6;
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x02':
    if ((undefined *)arg == &UNK_00000003)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xfe);
      g_bdbCtx.state = '\0';
      g_zbInfo.bdbAttr.commissioningStatus = g_bdbCtx.status;
      bdb_topLevelCommissioning('\x02');
      uVar1 = g_bdbCtx.state;
    }
    else if ((undefined1 *)arg == &DAT_00000004)
    {
      bVar2 = zb_isDeviceFactoryNew();
      if (bVar2 == false)
      {
        bdb_commissioningInfoSave((void *)0x0);
      }
      bdb_topLevelCommissiongConfirm();
      g_bdbCtx.state = '\0';
      uVar1 = g_bdbCtx.state;
    }
    break;
  case '\x03':
    if ((undefined1 *)arg == &DAT_00000006)
    {
      ev_timer_taskPost(bdb_retrieveTcLinkKeyStart, (void *)0x0, 1000);
      return;
    }
    if ((undefined1 *)arg == &DAT_00000005)
    {
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
    LAB_0000c6d6:
      zb_mgmtPermitJoinReq(0xfffc, 0xb4, '\x01', local_11, ll_reset);
      tl_zbTaskPost(bdb_mgmtPermitJoiningConfirm, (void *)0x0);
      return;
    }
    if ((undefined1 *)arg != &DAT_00000007)
    {
      return;
    }
    ss_securityModeSet(SS_SEMODE_CENTRALIZED);
    uVar1 = bdb_commissioningNetworkFormation();
    goto joined_r0x0000c518;
  case '\x04':
    if ((undefined1 *)arg == &DAT_00000008)
    {
      g_zbInfo.bdbAttr.commissioningMode =
          (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
      goto LAB_0000c6d6;
    }
    if ((undefined1 *)arg != &DAT_00000009)
    {
      return;
    }
    uVar1 = bdb_commissioningFindBind();
  joined_r0x0000c518:
    if (uVar1 == '\0')
    {
    LAB_0000c4fc:
      bdb_topLevelCommissiongConfirm();
    }
    break;
  case '\x05':
    if ((undefined1 *)arg == &DAT_0000000b)
    {
      if (g_bdbCtx.role != '\x01')
      {
        return;
      }
      local_12 = '\0';
      local_18[0].endpoint = g_bdbCtx.findDstInfo.endpoint;
      local_18[0].nwk_addr_interest = g_bdbCtx.findDstInfo.addr;
      zb_zdoSimpleDescReq(g_bdbCtx.findDstInfo.addr, local_18, &local_12, bdb_SimpleDescResp);
      return;
    }
    if ((undefined1 *)arg != &DAT_0000000a)
    {
      return;
    }
    if (g_bdbCtx.pFindBindQ != (findBindQ_t *)0x0)
    {
      ev_buf_free((u8 *)g_bdbCtx.pFindBindQ);
      g_bdbCtx.pFindBindQ = (findBindQ_t *)0x0;
    }
    uVar1 = '\0';
    g_bdbCtx.findDstInfo = (findBindDst_t)0x0;
    g_bdbCtx.bindDstInfo = (findBindDst_t)0x0;
    goto LAB_0000c4fc;
  }
  g_bdbCtx.state = uVar1;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAV(void)

{
  code *in_r3;

  (*in_r3)();
  zb_nlmePermitJoiningRequest(0xb4);
  g_bdbCtx.status = '\0';
  if (g_bdbCtx.state == '\x03')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000007);
  }
  else if (g_bdbCtx.state == '\x04')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000009);
  }
  if (g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0')
  {
    bdb_commissioningInfoSave((void *)0x0);
  }
  return;
}

void bdb_mgmtPermitJoiningConfirm(void *arg)

{
  zb_nlmePermitJoiningRequest(0xb4);
  g_bdbCtx.status = '\0';
  if (g_bdbCtx.state == '\x03')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000007);
  }
  else if (g_bdbCtx.state == '\x04')
  {
    tl_zbTaskPost(bdb_task, &DAT_00000009);
  }
  if (g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0')
  {
    bdb_commissioningInfoSave((void *)0x0);
  }
  return;
}

void bdb_nwkDiscCnfCb(void)

{
  zb_assocJoinReq();
  return;
}

void bdb_SimpleDescResp(void *arg)

{
  byte bVar1;
  u16 *puVar2;
  u8 uVar3;
  u16 *puVar4;
  int iVar5;
  byte *pbVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  undefined in_stack_ffffffa4;
  undefined in_stack_ffffffa5;
  undefined2 in_stack_ffffffa6;
  undefined4 in_stack_ffffffa8;
  uint local_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined2 local_40;
  undefined local_3c;
  undefined3 uStack_3b;
  undefined4 uStack_38;
  ushort local_34;
  zdo_ieee_addr_req_t local_30;
  undefined4 uStack_2c;
  u8 local_25;

  // WARNING: Load size is inaccurate
  iVar5 = *arg;
  if (*(char *)(iVar5 + 1) == '\0')
  {
    if (g_bdbCtx.matchClusterList != (u16 *)0x0)
    {
      return;
    }
    if (g_bdbCtx.matchClusterNum != '\0')
    {
      return;
    }
    if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
    {
      ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
    }
    bVar1 = *(byte *)(iVar5 + 0xb);
    if ((bVar1 != 0) &&
        (puVar4 = (u16 *)ev_buf_allocate((ushort)bVar1 << 1), puVar2 = g_bdbCtx.clusterList,
         g_bdbCtx.matchClusterList = puVar4, puVar4 != (u16 *)0x0))
    {
      if (g_bdbCtx.clusterNum == '\0')
      {
        uVar8 = (uint)g_bdbCtx.matchClusterNum;
      }
      else
      {
        uVar8 = (uint)g_bdbCtx.matchClusterNum;
        uVar9 = 0;
        do
        {
          pbVar6 = (byte *)(iVar5 + 0xc);
          while (true)
          {
            if (puVar2[uVar9] == (u16)((ushort)pbVar6[1] * 0x100 + (ushort)*pbVar6))
            {
              puVar4[uVar8] = puVar2[uVar9];
              uVar7 = uVar8 + 1;
              uVar8 = uVar7 & 0xff;
              g_bdbCtx.matchClusterNum = (u8)(uVar7 * 0x1000000 >> 0x18);
            }
            else
            {
              uVar8 = (uint)g_bdbCtx.matchClusterNum;
            }
            if (pbVar6 == (byte *)(iVar5 + 0xc) + ((bVar1 - 1) * 0x1000000 >> 0x17))
              break;
            pbVar6 = pbVar6 + 2;
          }
          uVar9 = uVar9 + 1 & 0xff;
        } while (uVar9 < g_bdbCtx.clusterNum);
      }
      uVar3 = zcl_seqNum;
      if (uVar8 != 0)
      {
        g_bdbCtx.bindDstInfo.addr = *(u16 *)(iVar5 + 2);
        g_bdbCtx.bindDstInfo.endpoint = *(u8 *)(iVar5 + 5);
        _local_3c = 0;
        uStack_38 = 0;
        local_34 = 0;
        if (g_zbInfo.bdbAttr.commissioningGroupId == 0xffff)
        {
          local_50 = 0;
          uStack_4c = 0;
          uVar3 = zb_address_ieee_by_short(g_bdbCtx.bindDstInfo.addr,
                                           (addrExt_t)
                                               CONCAT44(in_stack_ffffffa8,
                                                        CONCAT22(in_stack_ffffffa6,
                                                                 CONCAT11(in_stack_ffffffa5, in_stack_ffffffa4))));
          if ((uVar3 != '\0') || (iVar5 = memcmp(&local_50, &g_zero_addr, 8), iVar5 == 0))
          {
            local_25 = '\0';
            local_30 = (zdo_ieee_addr_req_t)(uint)g_bdbCtx.bindDstInfo.addr;
            zb_zdoIeeeAddrReq(g_bdbCtx.bindDstInfo.addr, &local_30, &local_25, bdb_ieeeAddrResp);
            return;
          }
          _local_3c = CONCAT31(uStack_3b, 3);
          local_34 = local_34 & 0xff | (ushort)g_bdbCtx.bindDstInfo.endpoint << 8;
          memcpy(&local_3c + 1, &local_50, 8);
        }
        else
        {
          uStack_4c = 0;
          local_40 = 0;
          uStack_44 = CONCAT13(g_bdbCtx.bindDstInfo.endpoint, 0x20000);
          local_50 = (uint)g_bdbCtx.bindDstInfo.addr;
          uStack_48 = 0x104;
          local_30 = (zdo_ieee_addr_req_t)0x0;
          uStack_2c = 0;
          zcl_seqNum = zcl_seqNum + '\x01';
          zcl_group_add((g_bdbCtx.simpleDesc)->endpoint, (epInfo_t *)&local_50, '\0', uVar3,
                        g_zbInfo.bdbAttr.commissioningGroupId & 0xff |
                            (ushort)(byte)((uint)g_zbInfo.bdbAttr.commissioningGroupId >> 8) << 8,
                        (u8 *)&local_30);
          _local_3c = CONCAT31(uStack_3b, 1);
          _local_3c = _local_3c & 0xff0000ff | (uint)g_zbInfo.bdbAttr.commissioningGroupId << 8;
        }
        bdb_binding((zdo_bind_dstAddr_t *)&local_3c, g_bdbCtx.matchClusterNum,
                    g_bdbCtx.matchClusterList);
        return;
      }
    }
  }
  tl_zbTaskPost(bdb_simpleDescReqSend, (void *)0x0);
  return;
}

void bdb_retrieveTcLinkKeyDone(u8 status)

{
  undefined1 *arg;

  if (g_bdbCtx.field_2.identifyTimer != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_bdbCtx.field_2.identifyTimer);
  }
  g_zbInfo.bdbAttr.nodeIsOnANetwork = status == '\0';
  if ((bool)g_zbInfo.bdbAttr.nodeIsOnANetwork)
  {
    arg = &DAT_00000005;
  }
  else
  {
    arg = &DAT_00000007;
  }
  g_bdbCtx.status = status;
  tl_zbTaskPost(bdb_task, arg);
  return;
}

s32 bdb_retrieveTcLinkKeyStart(void *arg)

{
  zdo_node_descriptor_req_t local_10;
  u8 local_d[5];

  local_d[0] = g_zbInfo.bdbAttr.tcLinkKeyExchangeMethod;
  if (g_zbInfo.bdbAttr.tcLinkKeyExchangeMethod == '\0')
  {
    local_10.nwk_addr_interest = 0;
    zb_zdoNodeDescReq(0, &local_10, local_d, bdb_nodeDescRespHandler);
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfb;
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = '\0';
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttemptsMax = '\x03';
    if (g_bdbCtx.field_2.identifyTimer == (ev_timer_event_t *)0x0)
    {
      g_bdbCtx.field_2.identifyTimer =
          ev_timer_taskPost(bdb_retrieveTcLinkKeyTimeout, (void *)0x0, (u32)&DAT_00001388);
    }
  }
  else
  {
    bdb_retrieveTcLinkKeyDone('\0');
  }
  return -2;
}

s32 bdb_retrieveTcLinkKeyTimeout(void *arg)

{
  bool bVar1;
  u8 uVar2;
  s32 sVar3;
  nlme_leave_req_t nStack_20;
  zdo_node_descriptor_req_t local_14;
  u8 local_11[5];

  if (g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts < g_zbInfo.bdbAttr.tcLinkKeyExchangeAttemptsMax)
  {
    local_11[0] = '\0';
    local_14.nwk_addr_interest = 0;
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts + '\x01';
    zb_zdoNodeDescReq(0, &local_14, local_11, bdb_nodeDescRespHandler);
    sVar3 = 0;
  }
  else
  {
    g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts + '\x01';
    bVar1 = zb_isDeviceJoinedNwk();
    if (bVar1 == false)
    {
      g_bdbCtx.field_2.identifyTimer = (ev_timer_event_t *)0x0;
      g_zbInfo.bdbAttr.tcLinkKeyExchangeAttempts = bVar1;
      bdb_retrieveTcLinkKeyDone('\n');
      sVar3 = -2;
    }
    else
    {
      memcpy(&nStack_20, g_zbInfo.macPib.extAddress, 8);
      nStack_20.rejoin = '\0';
      nStack_20.removeChildren = '\0';
      if (((int)((uint)g_bdbCtx._43_1_ << 0x1d) < 0) ||
          (uVar2 = zb_nlmeLeaveReq(&nStack_20), uVar2 != '\0'))
      {
        sVar3 = 3000;
      }
      else
      {
        g_bdbCtx._43_1_ = g_bdbCtx._43_1_ | 4;
        sVar3 = 3000;
      }
    }
  }
  return sVar3;
}

void bdb_nodeDescRespHandler(void *arg)

{
  u8 uVar1;
  uint uVar2;
  uint local_18;
  uint uStack_14;
  uint uStack_10;
  uint uStack_c;
  u8 uStack_8;
  ss_keyReqType_e sStack_7;

  // WARNING: Load size is inaccurate
  uVar2 = (uint) * (byte *)(*arg + 1);
  if (uVar2 == 0)
  {
    if (0x14 < ((uint) * (byte *)(*arg + 0xd) << 0x19) >> 0x1a)
    {
      sStack_7 = SS_KEYREQ_TYPE_TCLK;
      uStack_8 = '\x02';
      local_18 = uVar2;
      uStack_14 = uVar2;
      uStack_10 = uVar2;
      uStack_c = uVar2;
      uVar1 = zb_apsmeRequestKeyReq((ss_apsmeRequestKeyReq_t *)&local_18);
      if (uVar1 == '\0')
      {
        g_zbInfo.bdbAttr.nodeIsOnANetwork = '\0';
        return;
      }
    }
    bdb_retrieveTcLinkKeyDone('\0');
  }
  return;
}

void bdb_zdoStartDevCnf(zdo_start_device_confirm_t *startDevCnf)

{
  byte bVar1;
  int iVar2;
  undefined1 *puVar3;

  if (g_bdbCtx.state == '\x01')
  {
    g_bdbCtx.initResult = '\0';
    if (startDevCnf->status != '\0')
    {
      g_bdbCtx.initResult = g_bdbCtx.state;
    }
    tl_zbTaskPost(bdb_task, ll_reset + 1);
  }
  else if (g_bdbCtx.state == '\0')
  {
    g_bdbCtx.status = startDevCnf->status;
    if (g_bdbCtx.status == '\0')
    {
      g_zbInfo.bdbAttr.nodeIsOnANetwork = '\x01';
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
      bVar1 = zdo_ssInfoKeyGet();
      if ((((((uint)ss_ib._62_1_ << 0x1a) >> 0x1e != (uint)bVar1) ||
            (g_zbInfo.macPib.phyChannelCur != g_bdbCtx.channel)) ||
           ((g_zbNwkCtx._46_1_ & 0x80) != 0)) ||
          ((int)((uint)g_bdbCtx._43_1_ << 0x1c) < 0))
      {
        g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0x7f;
        tl_zbTaskPost(bdb_commissioningInfoSave, (void *)0x0);
      }
    }
    else if (g_bdbCtx.status == '`')
    {
      g_bdbCtx.status = '\v';
    }
    else
    {
      g_bdbCtx.status = '\f';
    }
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xf7;
    tl_zbTaskPost(bdb_task, &DAT_00000007);
  }
  else if (g_bdbCtx.state == '\x03')
  {
    if (startDevCnf->status == '\0')
    {
      g_zbInfo.bdbAttr.nodeIsOnANetwork = '\x01';
      g_bdbCtx.status = '\0';
      iVar2 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8);
      puVar3 = &DAT_00000005;
      if (iVar2 != 0)
      {
        puVar3 = (undefined1 *)(6 - (uint)((ss_ib._62_1_ & 7) == 0));
      }
      ev_timer_taskPost(bdb_task_delay, puVar3, 200);
    }
    else
    {
      g_bdbCtx.status = g_bdbCtx.state;
      tl_zbTaskPost(bdb_task, &DAT_00000007);
    }
  }
  else if (g_bdbCtx.state == '\x04')
  {
    if (startDevCnf->status == '\0')
    {
      g_zbInfo.bdbAttr.nodeIsOnANetwork = '\x01';
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x7f;
      g_bdbCtx.status = '\0';
      puVar3 = &DAT_00000008;
      if ((g_bdbCtx.bdbAppCb)->bdbcommissioningCb != ll_reset)
      {
        FUNAAAAW();
      }
    }
    else
    {
      g_bdbCtx.status = '\x05';
      puVar3 = &DAT_00000009;
    }
    tl_zbTaskPost(bdb_task, puVar3);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAW(void)

{
  code *in_r3;

  (*in_r3)();
  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xf4 | 4);
  ss_securityModeSet(SS_SEMODE_CENTRALIZED);
  bdb_topLevelCommissioning('\x02');
  return;
}

u8 bdb_networkFormationStart(void)

{
  u8 uVar1;

  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode & 0xf4 | 4);
  ss_securityModeSet(SS_SEMODE_CENTRALIZED);
  uVar1 = bdb_topLevelCommissioning('\x02');
  return uVar1;
}

u8 bdb_init(af_simple_descriptor_t *simple_desc, bdb_commissionSetting_t *setting, bdb_appCb_t *cb,
            u8 repower)

{
  bool bVar1;
  u8 uVar2;
  int iVar3;
  byte bVar4;
  u8 local_19;

  uVar2 = '\x01';
  if ((g_bdbCtx._43_1_ & 1) == 0)
  {
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ | 1;
    g_bdbCtx.simpleDesc = simple_desc;
    g_bdbCtx.commissionSettings = setting;
    g_bdbCtx.bdbAppCb = cb;
    bVar1 = zb_isDeviceFactoryNew();
    g_bdbCtx._43_1_ = g_bdbCtx._43_1_ & 0xfd | (byte)((bVar1 & 1) << 1);
    g_bdbCtx.state = '\x01';
    if ((int)((uint)g_bdbCtx._43_1_ << 0x1b) < 0)
    {
      ss_zdoInit(false);
    }
    else
    {
      ss_zdoInit(true);
    }
    bdb_linkKeyCfg(setting, (byte)(((uint)g_bdbCtx._43_1_ << 0x1e) >> 0x1f));
    bVar4 = 0;
    bdb_scanCfg(g_zbInfo.bdbAttr.secondaryChannelSet | g_zbInfo.bdbAttr.primaryChannelSet,
                g_zbInfo.bdbAttr.scanDuration);
    g_zbInfo.bdbAttr.commissioningStatus = '\0';
    iVar3 = (g_bdbCtx._43_1_ & 2) + ~(g_bdbCtx._43_1_ & 2) + (uint)bVar4;
    g_zbInfo.bdbAttr.nodeIsOnANetwork = (u8)iVar3;
    if (iVar3 == 0)
    {
      bdb_factoryNewDevCfg(g_zbInfo.bdbAttr.nodeCommissioningCapability & BDB_NODE_COMMISSION_CAP_TOUCHLINK,
                           setting->touchlinkChannel);
      tl_zbTaskPost(bdb_task, ll_reset + 1);
    }
    else
    {
      bdb_outgoingFrameCountUpdate(repower);
      bdb_coordinatorStart();
    }
    local_19 = '\0';
    tl_zbMacAttrGet('\0', &g_bdbCtx.channel, &local_19);
    uVar2 = '\0';
  }
  return uVar2;
}

void tl_bdbAttrInit(void)

{
  memset(&g_zbInfo.bdbAttr, 0, 0x30);
  g_zbInfo.bdbAttr.primaryChannelSet._1_1_ = 0x87;
  g_zbInfo.bdbAttr.primaryChannelSet._2_1_ = 0x10;
  g_zbInfo.bdbAttr.primaryChannelSet._3_1_ = 2;
  g_zbInfo.bdbAttr.secondaryChannelSet._1_1_ = 0x70;
  g_zbInfo.bdbAttr.secondaryChannelSet._2_1_ = 0xee;
  g_zbInfo.bdbAttr.secondaryChannelSet._3_1_ = 5;
  g_zbInfo.bdbAttr.commissioningGroupId._0_1_ = 0xfe;
  g_zbInfo.bdbAttr.commissioningGroupId._1_1_ = 0xfe;
  g_zbInfo.bdbAttr.commissioningMode =
      (bdb_commissioningMode_t)((byte)g_zbInfo.bdbAttr.commissioningMode | 2);
  g_zbInfo.bdbAttr.tcRequireKeyExchange = '\x01';
  g_zbInfo.bdbAttr.scanDuration = '\x03';
  g_zbInfo.bdbAttr.tcLinkKeyExchangeAttemptsMax = '\x03';
  g_zbInfo.bdbAttr.tcNodeJoinTimeout = '\x0f';
  return;
}

void aps_groupEntryDel(aps_group_tbl_ent_t *p)

{
  uint uVar1;
  int iVar2;

  if (p != (aps_group_tbl_ent_t *)0x0)
  {
    *(undefined *)&p->group_addr = 0xfe;
    *(undefined *)((int)&p->group_addr + 1) = 0xfe;
    iVar2 = aps_group_entry_num - 1;
    aps_group_entry_num = (u8)iVar2;
    uVar1 = ((int)(p[-0x4b877].group_name + 5) >> 2) * -0x49249249 & 0xff;
    if ((int)uVar1 < iVar2)
    {
      memcpy(p, p + 1, (iVar2 - uVar1) * 0x1c);
    }
    *(undefined *)&aps_group_tbl[iVar2].group_addr = 0xfe;
    *(undefined *)((int)&aps_group_tbl[iVar2].group_addr + 1) = 0xfe;
  }
  return;
}

void aps_groupTblSave2Flash(void *arg)

{
  nv_flashWriteNew('\x01', 2, '\x05', (ushort)APS_GROUP_TABLE_SIZE * 0x1c, (u8 *)aps_group_tbl);
  return;
}

u8 aps_groupTblNvInit(void)

{
  nv_sts_t nVar1;

  nv_itemLengthCheckAdd('\x05', (ushort)APS_GROUP_TABLE_SIZE * 0x1c);
  nVar1 = nv_flashReadNew('\x01', '\x02', '\x05', 0x1c, (u8 *)aps_group_tbl);
  return nVar1;
}

aps_group_tbl_ent_t *aps_group_search_by_addr(u16 group_addr)

{
  int iVar1;
  u16 uVar2;
  aps_group_tbl_ent_t *paVar3;
  uint uVar4;
  uint uVar5;
  byte bVar6;

  uVar4 = group_addr - 0xffff;
  iVar1 = ~uVar4 + uVar4;
  uVar4 = 1;
  bVar6 = 0;
  while (uVar5 = uVar4 - 1 & 0xff, bVar6 < aps_group_entry_num)
  {
    if (aps_group_tbl[uVar5].group_addr == 0xffff)
    {
      if (iVar1 != 0)
      {
        return aps_group_tbl + uVar5;
      }
    }
    else
    {
      if ((uint)group_addr == (uint)aps_group_tbl[uVar5].group_addr)
      {
        return aps_group_tbl + uVar5;
      }
      bVar6 = bVar6 + 1;
    }
    uVar4 = uVar4 + 1 & 0xff;
  }
  paVar3 = (aps_group_tbl_ent_t *)0x0;
  if ((iVar1 != 0) && (uVar5 < APS_GROUP_TABLE_SIZE))
  {
    uVar2 = aps_group_tbl[uVar5].group_addr;
    while (uVar2 != 0xffff)
    {
      uVar5 = uVar5 + 1 & 0xff;
      if (APS_GROUP_TABLE_SIZE <= uVar5)
      {
        return (aps_group_tbl_ent_t *)0x0;
      }
      uVar2 = aps_group_tbl[uVar5].group_addr;
    }
    paVar3 = aps_group_tbl + uVar5;
  }
  return paVar3;
}

u8 *aps_group_ep_info_get(u16 group_addr, u8 *epNum)

{
  aps_group_tbl_ent_t *paVar1;
  u8 *puVar2;

  paVar1 = aps_group_search_by_addr(group_addr);
  puVar2 = (u8 *)0x0;
  if (paVar1 != (aps_group_tbl_ent_t *)0x0)
  {
    *epNum = paVar1->n_endpoints;
    puVar2 = paVar1->endpoints;
  }
  return puVar2;
}

u8 *aps_group_ep_find(aps_group_tbl_ent_t *entry, u8 endpoint)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;

  uVar2 = (uint)endpoint;
  iVar5 = (uVar2 - 0xff) + ~(uVar2 - 0xff) + (uint)(0xfe < uVar2);
  uVar4 = 1;
  bVar1 = 0;
  do
  {
    uVar3 = uVar4 - 1 & 0xff;
    if (entry->n_endpoints <= bVar1)
    {
      if (iVar5 != 0)
      {
        for (; uVar3 < 8; uVar3 = uVar3 + 1 & 0xff)
        {
          if (entry->endpoints[uVar3] == 0xff)
          {
            return entry->endpoints + uVar3;
          }
        }
      }
      return (u8 *)0x0;
    }
    if (entry->endpoints[uVar3] == 0xff)
    {
      if (iVar5 != 0)
      {
      LAB_0000d0c2:
        return entry->endpoints + uVar3;
      }
    }
    else
    {
      if (uVar2 == entry->endpoints[uVar3])
        goto LAB_0000d0c2;
      bVar1 = bVar1 + 1;
    }
    uVar4 = uVar4 + 1 & 0xff;
  } while (true);
}

aps_group_tbl_ent_t *aps_group_search(u16 groupAddr, u8 endpoint)

{
  aps_group_tbl_ent_t *entry;
  u8 *puVar1;

  entry = aps_group_search_by_addr(groupAddr);
  if (entry != (aps_group_tbl_ent_t *)0x0)
  {
    puVar1 = aps_group_ep_find(entry, endpoint);
    entry = (aps_group_tbl_ent_t *)((uint)entry & ~(uint)(puVar1 != (u8 *)0x0));
  }
  return entry;
}

aps_status_t aps_me_group_add_req(aps_add_group_req_t *req)

{
  u8 endpoint;
  u16 uVar1;
  aps_group_tbl_ent_t *paVar2;
  u8 *puVar3;

  endpoint = req->ep;
  if (0xfd < (byte)(endpoint - 1))
  {
    return APS_STATUS_INVALID_PARAMETER;
  }
  paVar2 = aps_group_search_by_addr(req->group_addr);
  if (paVar2 == (aps_group_tbl_ent_t *)0x0)
  {
    paVar2 = aps_group_search_by_addr(0xffff);
    if (paVar2 == (aps_group_tbl_ent_t *)0x0)
    {
      return APS_STATUS_TABLE_FULL;
    }
    paVar2->endpoints[0] = 0xff;
    paVar2->endpoints[1] = 0xff;
    paVar2->endpoints[2] = 0xff;
    paVar2->endpoints[3] = 0xff;
    paVar2->endpoints[4] = 0xff;
    paVar2->endpoints[5] = 0xff;
    paVar2->endpoints[6] = 0xff;
    paVar2->endpoints[7] = 0xff;
    memset(paVar2->group_name, 0, 0x10);
    uVar1 = req->group_addr;
    *(char *)&paVar2->group_addr = (char)uVar1;
    *(char *)((int)&paVar2->group_addr + 1) = (char)(uVar1 >> 8);
    paVar2->endpoints[0] = req->ep;
    paVar2->n_endpoints = '\x01';
    aps_group_entry_num = aps_group_entry_num + '\x01';
  }
  else
  {
    puVar3 = aps_group_ep_find(paVar2, endpoint);
    if (puVar3 != (u8 *)0x0)
    {
      return APS_STATUS_DUPLICATE_ENTRY;
    }
    puVar3 = aps_group_ep_find(paVar2, 0xff);
    if (puVar3 == (u8 *)0x0)
    {
      return APS_STATUS_TABLE_FULL;
    }
    *puVar3 = endpoint;
    paVar2->n_endpoints = paVar2->n_endpoints + '\x01';
  }
  tl_zbTaskPost(aps_groupTblSave2Flash, (void *)0x0);
  return APS_STATUS_SUCCESS;
}

aps_status_t aps_me_group_delete_req(aps_delete_group_req_t *req)

{
  aps_group_tbl_ent_t *entry;
  u8 *puVar1;
  uint uVar2;
  u8 uVar3;
  int iVar4;
  aps_status_t aVar5;
  u8 local_18[12];

  uVar3 = req->ep;
  aVar5 = APS_STATUS_INVALID_PARAMETER;
  if ((byte)(uVar3 - 1) < 0xfe)
  {
    entry = aps_group_search_by_addr(req->group_addr);
    aVar5 = APS_STATUS_INVALID_GROUP;
    if ((entry != (aps_group_tbl_ent_t *)0x0) &&
        (puVar1 = aps_group_ep_find(entry, uVar3), puVar1 != (u8 *)0x0))
    {
      *puVar1 = 0xff;
      uVar3 = entry->n_endpoints + 0xff;
      entry->n_endpoints = uVar3;
      if (uVar3 == '\0')
      {
        aps_groupEntryDel(entry);
      }
      else
      {
        memset(local_18, 0xff, 8);
        iVar4 = 0;
        uVar2 = 0;
        do
        {
          if (entry->endpoints[iVar4] != 0xff)
          {
            local_18[uVar2] = entry->endpoints[iVar4];
            uVar2 = uVar2 + 1 & 0xff;
          }
          iVar4 = iVar4 + 1;
        } while (iVar4 != 8);
        memcpy(entry->endpoints, local_18, 8);
      }
      tl_zbTaskPost(aps_groupTblSave2Flash, (void *)0x0);
      aVar5 = APS_STATUS_SUCCESS;
    }
  }
  return aVar5;
}

void aps_groupTblReset(void)

{
  uint uVar1;
  aps_group_tbl_ent_t *paVar2;
  uint uVar3;

  aps_group_entry_num = '\0';
  uVar3 = (uint)APS_GROUP_TABLE_SIZE;
  if (uVar3 != 0)
  {
    paVar2 = aps_group_tbl;
    uVar1 = 0;
    do
    {
      *(undefined *)&aps_group_tbl[uVar1].group_addr = 0xfe;
      *(undefined *)((int)&aps_group_tbl[uVar1].group_addr + 1) = 0xfe;
      paVar2->n_endpoints = '\0';
      paVar2->endpoints[0] = 0xfe;
      paVar2->endpoints[1] = 0xfe;
      paVar2->endpoints[2] = 0xfe;
      paVar2->endpoints[3] = 0xfe;
      paVar2->endpoints[4] = 0xfe;
      paVar2->endpoints[5] = 0xfe;
      paVar2->endpoints[6] = 0xfe;
      paVar2->endpoints[7] = 0xfe;
      uVar1 = uVar1 + 1;
      paVar2 = paVar2 + 1;
    } while ((uVar1 & 0xff) < uVar3);
  }
  return;
}

aps_status_t aps_me_group_delete_all_req(u8 ep)

{
  aps_status_t aVar1;
  u8 *puVar2;
  uint uVar3;
  u8 uVar4;
  char cVar5;
  uint uVar6;
  byte bVar7;
  u8 local_2c[8];

  aVar1 = APS_STATUS_INVALID_PARAMETER;
  if ((uint)ep * 0x1000000 - 0x1000000 >> 0x18 < 0xfe)
  {
    uVar6 = 0;
    bVar7 = 0;
    do
    {
      while (aps_group_tbl[uVar6].group_addr != 0xffff)
      {
        puVar2 = aps_group_ep_find(aps_group_tbl + uVar6, ep);
        if (puVar2 == (u8 *)0x0)
        {
          uVar4 = aps_group_tbl[uVar6].n_endpoints;
        }
        else
        {
          *puVar2 = 0xff;
          uVar4 = aps_group_tbl[uVar6].n_endpoints + 0xff;
          aps_group_tbl[uVar6].n_endpoints = uVar4;
        }
        if (uVar4 == '\0')
        {
          aps_groupEntryDel(aps_group_tbl + uVar6);
        }
        else
        {
          memset(local_2c, 0xff, 8);
          puVar2 = aps_group_tbl[uVar6].endpoints;
          cVar5 = '\b';
          uVar3 = 0;
          do
          {
            if (*puVar2 != 0xff)
            {
              local_2c[uVar3] = *puVar2;
              uVar3 = uVar3 + 1 & 0xff;
            }
            cVar5 = cVar5 + -1;
            puVar2 = puVar2 + 1;
          } while (cVar5 != '\0');
          memcpy(aps_group_tbl[uVar6].endpoints, local_2c, 8);
        }
        uVar6 = uVar6 + 1 & 0xff;
        bVar7 = bVar7 + 1;
        if (aps_group_entry_num < bVar7)
          goto LAB_0000d34e;
      }
      uVar6 = uVar6 + 1 & 0xff;
      if (APS_GROUP_TABLE_SIZE <= uVar6)
      {
        bVar7 = bVar7 + 1;
        uVar6 = 0;
      }
    } while (bVar7 <= aps_group_entry_num);
  LAB_0000d34e:
    aps_groupTblReset();
    tl_zbTaskPost(aps_groupTblSave2Flash, (void *)0x0);
    aVar1 = APS_STATUS_SUCCESS;
  }
  return aVar1;
}

u8 aps_group_entry_num_get(void)

{
  return aps_group_entry_num;
}

void aps_group_list_get(u8 *counter, u16 *group_list)

{
  byte bVar1;
  uint uVar2;

  if ((group_list != (u16 *)0x0) && (counter + ~(uint)counter == (u8 *)0xffffffff))
  {
    *counter = '\0';
    if (APS_GROUP_TABLE_SIZE != '\0')
    {
      uVar2 = 0;
      do
      {
        if (aps_group_tbl[uVar2].group_addr != 0xffff)
        {
          bVar1 = *counter;
          group_list[bVar1] = aps_group_tbl[uVar2].group_addr;
          *counter = bVar1 + 1;
        }
        uVar2 = uVar2 + 1 & 0xff;
      } while (uVar2 < APS_GROUP_TABLE_SIZE);
    }
  }
  return;
}

void aps_init_group_num_set(void)

{
  uint uVar1;

  if (APS_GROUP_TABLE_SIZE != 0)
  {
    uVar1 = 0;
    do
    {
      if (aps_group_tbl[uVar1].group_addr != 0xffff)
      {
        aps_group_entry_num = aps_group_entry_num + '\x01';
      }
      uVar1 = uVar1 + 1;
    } while ((uVar1 & 0xff) < (uint)APS_GROUP_TABLE_SIZE);
  }
  return;
}

void af_init(void)

{
  available_active_ep_num = '\0';
  memset(aed, 0, 0x80);
  zdo_epDesc.cb_rx = ll_reset;
  zdo_epDesc.cb_cnf = ll_reset;
  zdo_epDesc.correspond_simple_desc = (af_simple_descriptor_t *)0x0;
  zdo_epDesc._12_4_ = 0;
  return;
}

void af_nodeDescManuCodeUpdate(u16 manuCode)

{
  ndt._3_2_ = manuCode;
  return;
}

u8 af_nodeDescStackRevisionGet(void)

{
  return (u8)(ndt.server_mask >> 9);
}

u8 af_nodeMacCapabilityGet(void)

{
  return ndt.mac_capability_flag;
}

device_type_t af_nodeDevTypeGet(void)

{
  return (device_type_t)(((uint)ndt._0_1_ << 0x1d) >> 0x1d);
}

u8 af_simpleDescriptorCopy(u8 *dst, af_simple_descriptor_t *sd)

{
  u8 *puVar1;
  uint uVar2;

  *dst = sd->endpoint;
  dst[1] = *(u8 *)&sd->app_profile_id;
  dst[2] = *(u8 *)((int)&sd->app_profile_id + 1);
  dst[3] = *(u8 *)&sd->app_dev_id;
  dst[4] = *(u8 *)((int)&sd->app_dev_id + 1);
  dst[5] = '\0';
  dst[5] = (byte)(((uint)(byte)sd->field_0x5 << 0x1c) >> 0x1c);
  dst[6] = sd->app_in_cluster_count;
  puVar1 = dst + 7;
  uVar2 = ((uint)sd->app_in_cluster_count << 0x19) >> 0x18;
  memcpy(puVar1, sd->app_in_cluster_lst, uVar2);
  puVar1 = puVar1 + uVar2;
  *puVar1 = sd->app_out_cluster_count;
  uVar2 = ((uint)sd->app_out_cluster_count << 0x19) >> 0x18;
  memcpy(puVar1 + 1, sd->app_out_cluster_lst, uVar2);
  return (u8)((uint)((int)(puVar1 + 1 + (uVar2 - (int)dst)) * 0x1000000) >> 0x18);
}

void af_nodeDescriptorCopy(node_descriptor_t *dst)

{
  memcpy(dst, &ndt, 0xd);
  return;
}

void af_powerDescriptorCopy(power_descriptor_t *dst)

{
  memcpy(dst, &pdt, 2);
  return;
}

u8 af_availableEpNumGet(void)

{
  return available_active_ep_num;
}

af_endpoint_descriptor_t *af_epDescriptorGet(void)

{
  return aed;
}

af_endpoint_descriptor_t *af_zdoSimpleDescriptorGet(void)

{
  return &zdo_epDesc;
}

af_simple_descriptor_t *af_simpleDescGet(u8 ep)

{
  u8 uVar1;
  af_simple_descriptor_t *paVar2;
  u8 *puVar3;
  int iVar4;
  byte bVar5;

  paVar2 = (af_simple_descriptor_t *)0x0;
  if (available_active_ep_num != '\0')
  {
    if (aed[0].ep == ep)
    {
      iVar4 = 0;
    }
    else
    {
      puVar3 = &aed[1].ep;
      iVar4 = 0;
      bVar5 = 0;
      do
      {
        bVar5 = bVar5 + 1;
        if (available_active_ep_num <= bVar5)
        {
          return (af_simple_descriptor_t *)0x0;
        }
        iVar4 = iVar4 + 1;
        uVar1 = *puVar3;
        puVar3 = puVar3 + 0x10;
      } while (uVar1 != ep);
    }
    paVar2 = aed[iVar4].correspond_simple_desc;
  }
  return paVar2;
}

u8 af_profileMatchedLocal(u16 profileID, u8 ep)

{
  u8 uVar1;
  uint uVar2;
  uint uVar3;
  u8 *puVar4;
  uint uVar5;

  uVar3 = (uint)ep;
  uVar2 = (uint)profileID;
  if (((uVar3 != 0) || (uVar1 = '\x01', uVar2 != 0)) &&
      ((uVar3 == 0 || (uVar1 = '\x01', uVar2 != 0xc05e))))
  {
    uVar1 = '\0';
    if (available_active_ep_num != 0)
    {
      puVar4 = &aed[0].ep;
      uVar5 = 0;
      do
      {
        if ((((uVar3 - 0xff) + ~(uVar3 - 0xff) + (uint)(0xfe < uVar3) != 0) || (*puVar4 == uVar3)) && ((~(uVar2 - 0xffff) + (uVar2 - 0xffff) + (uint)(0xfffe < uVar2) != 0 ||
                                                                                                        ((aed[uVar5].correspond_simple_desc)->app_profile_id == uVar2))))
        {
          return '\x01';
        }
        uVar5 = uVar5 + 1;
        puVar4 = puVar4 + 0x10;
      } while ((uVar5 & 0xff) < (uint)available_active_ep_num);
      uVar1 = '\0';
    }
  }
  return uVar1;
}

u8 af_clusterMatchedLocal(u16 clusterID, u8 ep)

{
  uint uVar1;
  u16 *puVar2;
  byte bVar3;
  af_simple_descriptor_t *paVar4;
  u8 *puVar5;

  uVar1 = 0;
  if (available_active_ep_num != 0)
  {
    puVar5 = &aed[0].ep;
    do
    {
      if (*puVar5 == ep)
      {
        paVar4 = aed[uVar1].correspond_simple_desc;
        if (paVar4->app_in_cluster_count != 0)
        {
          puVar2 = paVar4->app_in_cluster_lst;
          if (*puVar2 != clusterID)
          {
            bVar3 = 0;
            while (true)
            {
              puVar2 = puVar2 + 1;
              bVar3 = bVar3 + 1;
              if (paVar4->app_in_cluster_count <= bVar3)
                break;
              if (*puVar2 == clusterID)
                goto LAB_0000d75c;
            }
            goto LAB_0000d71e;
          }
        LAB_0000d75c:
          uVar1 = 1;
          goto LAB_0000d75e;
        }
      LAB_0000d71e:
        if (paVar4->app_out_cluster_count != 0)
        {
          puVar2 = paVar4->app_out_cluster_lst;
          if (*puVar2 == clusterID)
            goto LAB_0000d75c;
          bVar3 = 0;
          while (true)
          {
            puVar2 = puVar2 + 1;
            bVar3 = bVar3 + 1;
            if (paVar4->app_out_cluster_count <= bVar3)
              break;
            if (*puVar2 == clusterID)
              goto LAB_0000d75c;
          }
        }
      }
      uVar1 = uVar1 + 1;
      puVar5 = puVar5 + 0x10;
    } while ((uVar1 & 0xff) < (uint)available_active_ep_num);
    uVar1 = 0;
  }
LAB_0000d75e:
  return (u8)uVar1;
}

u8 af_clsuterIdMatched(u16 clusterID, af_simple_descriptor_t *pSimpleDesc)

{
  u16 *puVar1;
  byte bVar2;

  if (pSimpleDesc == (af_simple_descriptor_t *)0x0)
  {
    return '\0';
  }
  if (pSimpleDesc->app_in_cluster_count == 0)
  {
  LAB_0000d7b6:
    if (pSimpleDesc->app_out_cluster_count == 0)
    {
      return '\0';
    }
    puVar1 = pSimpleDesc->app_out_cluster_lst;
    if (*puVar1 == clusterID)
    {
      return '\x01';
    }
    bVar2 = 0;
    do
    {
      puVar1 = puVar1 + 1;
      bVar2 = bVar2 + 1;
      if (pSimpleDesc->app_out_cluster_count <= bVar2)
      {
        return '\0';
      }
    } while (*puVar1 != clusterID);
  }
  else
  {
    puVar1 = pSimpleDesc->app_in_cluster_lst;
    if (*puVar1 == clusterID)
    {
      return '\x01';
    }
    bVar2 = 0;
    do
    {
      puVar1 = puVar1 + 1;
      bVar2 = bVar2 + 1;
      if (pSimpleDesc->app_in_cluster_count <= bVar2)
        goto LAB_0000d7b6;
    } while (*puVar1 != clusterID);
  }
  return '\x01';
}

u8 af_profileIdMatched(u16 profileID, af_simple_descriptor_t *pSimpleDesc)

{
  byte bVar1;
  u8 uVar2;

  uVar2 = '\0';
  if ((pSimpleDesc != (af_simple_descriptor_t *)0x0) && (uVar2 = '\x01', profileID != 0xffff))
  {
    bVar1 = (char)profileID - (char)pSimpleDesc->app_profile_id;
    uVar2 = bVar1 + ~bVar1 + (pSimpleDesc->app_profile_id <= profileID);
  }
  return uVar2;
}

u8 af_endpointRegister(u8 ep, af_simple_descriptor_t *simple_desc, af_endpoint_cb_t rx_cb,
                       af_dataCnf_cb_t cnfCb)

{
  u8 uVar1;
  u8 *puVar2;
  uint uVar3;

  if (ep == '\0')
  {
    uVar1 = '\x01';
    zdo_epDesc.cb_rx = rx_cb;
    zdo_epDesc.cb_cnf = cnfCb;
    zdo_epDesc.correspond_simple_desc = simple_desc;
    zdo_epDesc.ep = ep;
  }
  else
  {
    puVar2 = &aed[0].ep;
    do
    {
      if (*puVar2 == ep)
      {
        return '\0';
      }
      puVar2 = puVar2 + 0x10;
    } while ((u32 *)puVar2 != &prevSysTick);
    uVar3 = (uint)available_active_ep_num;
    uVar1 = '\0';
    if (uVar3 < 8)
    {
      aed[uVar3].ep = ep;
      aed[uVar3].correspond_simple_desc = simple_desc;
      aed[uVar3].cb_cnf = cnfCb;
      aed[uVar3].cb_rx = rx_cb;
      available_active_ep_num = available_active_ep_num + '\x01';
      uVar1 = '\x01';
    }
  }
  return uVar1;
}

u8 sys_exceptionPost(u16 line, u8 evt)

{
  T_evtExcept[1] = (u16)evt;
  T_evtExcept[0] = line;
  if (g_sysExceptCallbak != ll_reset)
  {
    FUNAAAAX();
  }
  return '\0';
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAX(void)

{
  code *in_r3;

  g_sysExceptCallbak = (sys_exception_cb_t)(*in_r3)();
  return;
}

void sys_exceptHandlerRegister(sys_exception_cb_t cb)

{
  g_sysExceptCallbak = cb;
  return;
}

void ev_main(void)

{
  ev_timer_process();
  ev_poll_process();
  return;
}

void ev_buf_reset(void)

{
  byte bVar1;
  ushort uVar2;
  mem_pool_t *pmVar3;
  int iVar4;
  ev_buf_vars_t *peVar5;
  mem_pool_t **ppmVar6;
  u8 **ppuVar7;
  u8 *local_50[4];
  mem_pool_t *local_40[4];
  undefined4 local_30;
  undefined4 uStack_2c;
  undefined4 local_28;

  uStack_2c = 0x3c0018;
  local_30 = 0x4000096;
  ppmVar6 = local_40;
  local_40[2] = &size_0_pool;
  local_40[1] = &size_1_pool;
  local_40[0] = &size_2_pool;
  local_40[3] = &size_3_pool;
  local_50[2] = size_0_mem;
  local_50[1] = size_1_mem;
  local_50[0] = size_2_mem;
  local_50[3] = size_3_mem;
  local_28 = 0x1080808;
  memset(ev_buf_v, 0, 0x20);
  iVar4 = 0;
  peVar5 = ev_buf_v;
  ppuVar7 = local_50;
  do
  {
    bVar1 = *(byte *)((int)&local_28 + iVar4);
    peVar5->bufGroups[iVar4].availBufNum = bVar1;
    pmVar3 = *ppmVar6;
    ppmVar6 = ppmVar6 + 1;
    uVar2 = *(ushort *)((int)&local_30 + iVar4 * 2);
    pmVar3 = mempool_init(pmVar3, *ppuVar7, (uint)uVar2, (uint)bVar1);
    *(char *)&peVar5->bufGroups[iVar4].qHead = (char)pmVar3;
    *(char *)((int)&peVar5->bufGroups[iVar4].qHead + 1) = (char)((uint)pmVar3 >> 8);
    *(char *)((int)&peVar5->bufGroups[iVar4].qHead + 2) = (char)((uint)pmVar3 >> 0x10);
    *(char *)((int)&peVar5->bufGroups[iVar4].qHead + 3) = (char)((uint)pmVar3 >> 0x18);
    peVar5 = ev_buf_v;
    *(char *)&ev_buf_v->bufGroups[iVar4].size = (char)uVar2;
    *(char *)((int)&peVar5->bufGroups[iVar4].size + 1) = (char)(uVar2 >> 8);
    iVar4 = iVar4 + 1;
    ppuVar7 = ppuVar7 + 1;
  } while (iVar4 != 4);
  return;
}

void ev_buf_init(void)

{
  ev_buf_reset();
  return;
}

u8 *ev_buf_allocate(u16 size)

{
  u32 en;
  undefined *puVar1;
  ev_buf_groups_t *peVar2;
  int iVar3;

  if ((uint)size * 0x10000 - 0x10000 >> 0x10 < 0x3f8)
  {
    en = drv_disable_irq();
    iVar3 = 0;
    peVar2 = ev_buf_v->bufGroups;
    do
    {
      if (((uint)size <= ev_buf_v->bufGroups[iVar3].size - 8) && (peVar2->availBufNum != '\0'))
      {
        puVar1 = (undefined *)
            mempool_alloc((mem_pool_t *)
                              CONCAT13(*(undefined *)((int)&ev_buf_v->bufGroups[iVar3].qHead + 3),
                                       CONCAT12(*(undefined *)((int)&ev_buf_v->bufGroups[iVar3].qHead + 2),
                                                CONCAT11(*(undefined *)((int)&ev_buf_v->bufGroups[iVar3].qHead +
                                                                        1),
                                                         *(undefined *)&ev_buf_v->bufGroups[iVar3].qHead))));
        if (puVar1 != (undefined *)0x0)
        {
          ev_buf_v->bufGroups[iVar3].availBufNum = ev_buf_v->bufGroups[iVar3].availBufNum + 0xff;
          *puVar1 = (char)iVar3;
          puVar1[1] = 0;
          puVar1[2] = 0;
          puVar1[3] = 0;
          drv_restore_irq(en);
          return puVar1 + 4;
        }
        break;
      }
      iVar3 = iVar3 + 1;
      peVar2 = peVar2 + 1;
    } while (iVar3 != 4);
    drv_restore_irq(en);
  }
  return (u8 *)0x0;
}

u8 *long_ev_buf_get(void)

{
  u8 *puVar1;

  puVar1 = ev_buf_allocate(0x3f8);
  return puVar1;
}

u8 is_ev_buf(void *arg)

{
  bool bVar1;

  if ((((arg < size_0_mem) || (bVar1 = true, &size_2_pool < arg)) &&
       ((arg < size_1_mem || (bVar1 = true, &size_0_pool < arg)))) &&
      ((arg < size_2_mem || (bVar1 = true, size_3_mem < arg))))
  {
    bVar1 = false;
    if (size_2_mem + 0x4bf < arg)
    {
      bVar1 = arg < (void *)((int)&size_3_pool.free_list + 1);
    }
  }
  return bVar1;
}

buf_sts_t ev_buf_free(u8 *pBuf)

{
  int iVar1;
  undefined4 *puVar2;
  u8 uVar3;
  u32 en;
  uint uVar4;

  en = drv_disable_irq();
  uVar3 = is_ev_buf(pBuf);
  if (uVar3 == '\0')
  {
    sys_exceptionPost(0xd2, 'q');
  }
  iVar1 = *(int *)(pBuf + -4);
  uVar4 = (uint)(iVar1 << 0x18) >> 0x15;
  puVar2 = *(undefined4 **)
               CONCAT13(*(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4 + 3),
                        CONCAT12(*(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4 + 2),
                                 CONCAT11(*(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4 + 1),
                                          *(undefined *)((int)&ev_buf_v->bufGroups[0].qHead + uVar4))));
  while (true)
  {
    if (puVar2 == (undefined4 *)0x0)
    {
      mempool_free((mem_pool_t *)
                       CONCAT13(*(undefined *)((int)&ev_buf_v->bufGroups[iVar1].qHead + 3),
                                CONCAT12(*(undefined *)((int)&ev_buf_v->bufGroups[iVar1].qHead + 2),
                                         CONCAT11(*(undefined *)((int)&ev_buf_v->bufGroups[iVar1].qHead + 1),
                                                  *(undefined *)&ev_buf_v->bufGroups[iVar1].qHead))),
                   pBuf + -4);
      ev_buf_v->bufGroups[*(int *)(pBuf + -4)].availBufNum =
          ev_buf_v->bufGroups[*(int *)(pBuf + -4)].availBufNum + '\x01';
      drv_restore_irq(en);
      return BUFFER_SUCC;
    }
    if ((undefined4 *)(pBuf + -8) == puVar2)
      break;
    puVar2 = (undefined4 *)*puVar2;
  }
  sys_exceptionPost(0xdf, 'r');
  drv_restore_irq(en);
  return BUFFER_DUPLICATE_FREE;
}

void ev_buf_getFreeMaxSize(void)

{
  uint uVar1;
  uint uVar2;
  ev_buf_groups_t *peVar3;
  int iVar4;

  iVar4 = 0;
  uVar1 = 0;
  peVar3 = ev_buf_v->bufGroups;
  do
  {
    if ((peVar3->availBufNum != '\0') &&
        (uVar2 = ev_buf_v->bufGroups[iVar4].size - 8, uVar1 < uVar2))
    {
      uVar1 = uVar2 & 0xffff;
    }
    iVar4 = iVar4 + 1;
    peVar3 = peVar3 + 1;
  } while (iVar4 != 4);
  return;
}

void ev_on_poll(ev_poll_e e, ev_poll_callback_t cb)

{
  uint uVar1;

  uVar1 = ((uint)e << 0x18) >> 0x15;
  *(ev_poll_callback_t *)((int)&ev_poll[0].cb + uVar1) = cb;
  *(undefined4 *)((int)&ev_poll[0].valid + uVar1) = 1;
  return;
}

void ev_enable_poll(ev_poll_e e)

{
  *(undefined4 *)((int)&ev_poll[0].valid + (((uint)e << 0x18) >> 0x15)) = 1;
  return;
}

void ev_disable_poll(ev_poll_e e)

{
  *(undefined4 *)((int)&ev_poll[0].valid + (((uint)e << 0x18) >> 0x15)) = 0;
  return;
}

void ev_poll_process(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    if (ev_poll[iVar1].valid != 0)
    {
      FUNAAAAY();
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 3);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAY(void)

{
  code *in_r3;

  (*in_r3)();
  memset(&ev_timer, 0, 0x2ac);
  return;
}

void ev_timer_init(void)

{
  memset(&ev_timer, 0, 0x2ac);
  return;
}

ev_timer_event_t *ev_timer_freeGet(void)

{
  u8 uVar1;
  ev_timer_event_t *peVar2;
  u8 *puVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;

  uVar4 = (uint)g_ev_timer_maxNum;
  peVar2 = (ev_timer_event_t *)0x0;
  if ((ev_timer.timerEventPool.used_num < uVar4) && (uVar4 != 0))
  {
    if (ev_timer.timerEventPool.evt[0].used == '\0')
    {
      uVar5 = 0;
      iVar6 = 0;
    }
    else
    {
      puVar3 = &ev_timer.timerEventPool.evt[1].used;
      iVar6 = 0;
      uVar5 = 0;
      do
      {
        uVar5 = uVar5 + 1 & 0xff;
        if (uVar4 <= uVar5)
        {
          return (ev_timer_event_t *)0x0;
        }
        iVar6 = iVar6 + 1;
        uVar1 = *puVar3;
        puVar3 = puVar3 + 0x1c;
      } while (uVar1 != '\0');
    }
    ev_timer.timerEventPool.evt[iVar6].used = '\x01';
    ev_timer.timerEventPool.used_num = ev_timer.timerEventPool.used_num + 1;
    peVar2 = ev_timer.timerEventPool.evt + uVar5;
  }
  return peVar2;
}

void ev_timer_poolDelUpdate(ev_timer_event_t *evt)

{
  evt->isRunning = '\0';
  *(undefined *)&evt->curSysTick = 0;
  *(undefined *)((int)&evt->curSysTick + 1) = 0;
  *(undefined *)((int)&evt->curSysTick + 2) = 0;
  *(undefined *)((int)&evt->curSysTick + 3) = 0;
  if ((((ev_timer_event_t *)((int)&ev_timer.timer_nearest + 3) < evt) &&
       (evt <= (ev_timer_event_t *)((int)&ev_timer + (g_ev_timer_maxNum - 1) * 0x1c + 8))) &&
      (evt->used != '\0'))
  {
    evt->used = '\0';
    ev_timer.timerEventPool.used_num = ev_timer.timerEventPool.used_num - 1;
  }
  return;
}

void ev_timer_nearestUpdate(void)

{
  ev_timer_event_t **ppeVar1;
  ev_timer_event_t *peVar2;

  ev_timer.timer_nearest = ev_timer.timer_head;
  peVar2 = ev_timer.timer_head;
  if (ev_timer.timer_head != (ev_timer_event_t *)0x0)
  {
    do
    {
      if (peVar2->timeout < (ev_timer.timer_nearest)->timeout)
      {
        ev_timer.timer_nearest = peVar2;
      }
      ppeVar1 = &peVar2->next;
      peVar2 = *ppeVar1;
    } while (*ppeVar1 != (ev_timer_event_t *)0x0);
  }
  return;
}

u8 ev_timer_enough(void)

{
  return ev_timer.timerEventPool.used_num < 0x14;
}

u8 ev_timer_exist(ev_timer_event_t *evt)

{
  u8 uVar1;
  ev_timer_event_t *peVar2;

  uVar1 = '\0';
  if ((ev_timer.timer_head != (ev_timer_event_t *)0x0) &&
      (uVar1 = '\x01', peVar2 = ev_timer.timer_head, ev_timer.timer_head != evt))
  {
    do
    {
      peVar2 = peVar2->next;
      if (peVar2 == (ev_timer_event_t *)0x0)
      {
        return '\0';
      }
    } while (evt != peVar2);
    uVar1 = '\x01';
  }
  return uVar1;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ev_on_timer(ev_timer_event_t *evt, u32 timeout)

{
  ev_timer_event_t *peVar1;
  u32 uVar2;
  ev_timer_event_t *peVar3;
  undefined4 uVar4;
  u32 en;

  if (evt == (ev_timer_event_t *)0x0)
  {
    sys_exceptionPost(0x7d, '\x01');
  }
  else
  {
    *(char *)&evt->period = (char)timeout;
    *(char *)((int)&evt->period + 1) = (char)(timeout >> 8);
    *(char *)((int)&evt->period + 2) = (char)(timeout >> 0x10);
    *(char *)((int)&evt->period + 3) = (char)(timeout >> 0x18);
    en = drv_disable_irq();
    uVar4 = _DAT_00800740;
    peVar1 = evt;
    peVar3 = ev_timer.timer_head;
    while (peVar3 != (ev_timer_event_t *)0x0)
    {
      if (evt == peVar3)
      {
        uVar2 = evt->period;
        *(char *)&peVar1->timeout = (char)uVar2;
        *(char *)((int)&peVar1->timeout + 1) = (char)(uVar2 >> 8);
        *(char *)((int)&peVar1->timeout + 2) = (char)(uVar2 >> 0x10);
        *(char *)((int)&peVar1->timeout + 3) = (char)(uVar2 >> 0x18);
        goto LAB_0000de70;
      }
      peVar1 = peVar3->next;
      peVar3 = peVar1;
    }
    if (evt->isRunning == '\0')
    {
      *(char *)&evt->curSysTick = (char)_DAT_00800740;
      *(char *)((int)&evt->curSysTick + 1) = (char)((uint)uVar4 >> 8);
      *(char *)((int)&evt->curSysTick + 2) = (char)((uint)uVar4 >> 0x10);
      *(char *)((int)&evt->curSysTick + 3) = (char)((uint)uVar4 >> 0x18);
    }
    uVar2 = evt->period;
    *(char *)&evt->timeout = (char)uVar2;
    *(char *)((int)&evt->timeout + 1) = (char)(uVar2 >> 8);
    *(char *)((int)&evt->timeout + 2) = (char)(uVar2 >> 0x10);
    *(char *)((int)&evt->timeout + 3) = (char)(uVar2 >> 0x18);
    *(char *)&evt->next = (char)ev_timer.timer_head;
    *(char *)((int)&evt->next + 1) = (char)((uint)ev_timer.timer_head >> 8);
    *(char *)((int)&evt->next + 2) = (char)((uint)ev_timer.timer_head >> 0x10);
    *(char *)((int)&evt->next + 3) = (char)((uint)ev_timer.timer_head >> 0x18);
    ev_timer.timer_head = evt;
  LAB_0000de70:
    ev_timer_nearestUpdate();
    drv_restore_irq(en);
  }
  return;
}

void ev_unon_timer(ev_timer_event_t *evt)

{
  u32 en;
  ev_timer_event_t *peVar1;
  ev_timer_event_t *peVar2;

  if (evt == (ev_timer_event_t *)0x0)
  {
    sys_exceptionPost(0x9a, '\x01');
    return;
  }
  peVar1 = ev_timer.timer_head;
  if (ev_timer.timer_head == (ev_timer_event_t *)0x0)
  {
    return;
  }
  do
  {
    if (evt == peVar1)
    {
      en = drv_disable_irq();
      ev_timer_poolDelUpdate(evt);
      peVar1 = ev_timer.timer_head;
      if (ev_timer.timer_head == evt)
      {
        ev_timer.timer_head = evt->next;
        ev_timer_nearestUpdate();
        drv_restore_irq(en);
        return;
      }
      do
      {
        peVar2 = peVar1;
        peVar1 = peVar2->next;
        if (peVar1 == (ev_timer_event_t *)0x0)
        {
          ev_timer_nearestUpdate();
          drv_restore_irq(en);
          return;
        }
      } while (evt != peVar1);
      peVar1 = evt->next;
      *(char *)&peVar2->next = (char)peVar1;
      *(char *)((int)&peVar2->next + 1) = (char)((uint)peVar1 >> 8);
      *(char *)((int)&peVar2->next + 2) = (char)((uint)peVar1 >> 0x10);
      *(char *)((int)&peVar2->next + 3) = (char)((uint)peVar1 >> 0x18);
      ev_timer_nearestUpdate();
      drv_restore_irq(en);
      return;
    }
    peVar1 = peVar1->next;
  } while (peVar1 != (ev_timer_event_t *)0x0);
  return;
}

ev_timer_event_t *ev_timer_add(ev_timer_callback_t func, void *arg, u32 timeout)

{
  ev_timer_event_t *evt;

  evt = ev_timer_freeGet();
  if (evt == (ev_timer_event_t *)0x0)
  {
    sys_exceptionPost(0xb3, '\x01');
  }
  else
  {
    *(char *)&evt->cb = (char)func;
    *(char *)((int)&evt->cb + 1) = (char)((uint)func >> 8);
    *(char *)((int)&evt->cb + 2) = (char)((uint)func >> 0x10);
    *(char *)((int)&evt->cb + 3) = (char)((uint)func >> 0x18);
    *(char *)&evt->data = (char)arg;
    *(char *)((int)&evt->data + 1) = (char)((uint)arg >> 8);
    *(char *)((int)&evt->data + 2) = (char)((uint)arg >> 0x10);
    *(char *)((int)&evt->data + 3) = (char)((uint)arg >> 0x18);
    ev_on_timer(evt, timeout);
  }
  return evt;
}

ev_timer_event_t *ev_timer_taskPost(ev_timer_callback_t func, void *arg, u32 t_ms)

{
  u32 en;
  ev_timer_event_t *peVar1;

  en = drv_disable_irq();
  peVar1 = ev_timer_add(func, arg, t_ms);
  drv_restore_irq(en);
  return peVar1;
}

u8 ev_timer_taskCancel(ev_timer_event_t **evt)

{
  u8 uVar1;
  ev_timer_event_t *evt_00;

  evt_00 = *evt;
  uVar1 = '\b';
  if ((evt_00 != (ev_timer_event_t *)0x0) && (evt_00->used != '\0'))
  {
    ev_unon_timer(evt_00);
    *evt = (ev_timer_event_t *)0x0;
    uVar1 = '\0';
  }
  return uVar1;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ev_timer_update(u32 updateTime)

{
  int iVar1;
  u32 en;
  int iVar2;
  u32 uVar3;
  int iVar4;
  ev_timer_event_t *peVar5;

  iVar1 = _DAT_00800740;
  if (updateTime != 0)
  {
    en = drv_disable_irq();
    if (ev_timer.timer_head != (ev_timer_event_t *)0x0)
    {
      iVar4 = sysTimerPerUs * 1000;
      peVar5 = ev_timer.timer_head;
      do
      {
        uVar3 = updateTime;
        if (peVar5->isRunning == '\0')
        {
          uVar3 = FUN_0000162c(iVar1 - peVar5->curSysTick, iVar4);
          peVar5->isRunning = '\x01';
        }
        if (uVar3 < peVar5->timeout)
        {
          iVar2 = peVar5->timeout - uVar3;
          *(char *)&peVar5->timeout = (char)iVar2;
          *(char *)((int)&peVar5->timeout + 1) = (char)((uint)iVar2 >> 8);
          *(char *)((int)&peVar5->timeout + 2) = (char)((uint)iVar2 >> 0x10);
          *(char *)((int)&peVar5->timeout + 3) = (char)((uint)iVar2 >> 0x18);
        }
        else
        {
          *(undefined *)&peVar5->timeout = 0;
          *(undefined *)((int)&peVar5->timeout + 1) = 0;
          *(undefined *)((int)&peVar5->timeout + 2) = 0;
          *(undefined *)((int)&peVar5->timeout + 3) = 0;
        }
        peVar5 = peVar5->next;
      } while (peVar5 != (ev_timer_event_t *)0x0);
    }
    drv_restore_irq(en);
  }
  return;
}

void ev_timer_executeCB(void)

{
  u32 uVar1;
  undefined uVar2;
  undefined uVar3;
  ev_timer_event_t **ppeVar4;
  undefined uVar5;
  int iVar6;
  ev_timer_event_t *evt;
  ev_timer_event_t *peVar7;

  evt = ev_timer.timer_head;
  peVar7 = ev_timer.timer_head;
  if (ev_timer.timer_head != (ev_timer_event_t *)0x0)
  {
    do
    {
      while (evt->timeout != 0)
      {
      LAB_0000e0b4:
        ppeVar4 = &evt->next;
        evt = *ppeVar4;
        if (*ppeVar4 == (ev_timer_event_t *)0x0)
          goto LAB_0000e146;
      }
      iVar6 = FUNAAAAZ();
      if (iVar6 < 0)
      {
        ev_unon_timer(evt);
      }
      else if (iVar6 == 0)
      {
        uVar1 = evt->period;
        *(char *)&evt->timeout = (char)uVar1;
        *(char *)((int)&evt->timeout + 1) = (char)(uVar1 >> 8);
        *(char *)((int)&evt->timeout + 2) = (char)(uVar1 >> 0x10);
        *(char *)((int)&evt->timeout + 3) = (char)(uVar1 >> 0x18);
      }
      else
      {
        *(char *)&evt->period = (char)iVar6;
        uVar2 = (undefined)((uint)iVar6 >> 8);
        *(undefined *)((int)&evt->period + 1) = uVar2;
        uVar3 = (undefined)((uint)iVar6 >> 0x10);
        *(undefined *)((int)&evt->period + 2) = uVar3;
        uVar5 = (undefined)((uint)iVar6 >> 0x18);
        *(undefined *)((int)&evt->period + 3) = uVar5;
        *(char *)&evt->timeout = (char)iVar6;
        *(undefined *)((int)&evt->timeout + 1) = uVar2;
        *(undefined *)((int)&evt->timeout + 2) = uVar3;
        *(undefined *)((int)&evt->timeout + 3) = uVar5;
      }
      if (ev_timer.timer_head == peVar7)
        goto LAB_0000e0b4;
      evt = ev_timer.timer_head;
      peVar7 = ev_timer.timer_head;
    } while (ev_timer.timer_head != (ev_timer_event_t *)0x0);
  }
LAB_0000e146:
  ev_timer_nearestUpdate();
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNAAAAZ(void)

{
  int iVar1;
  int iVar2;
  code *in_r3;
  int iVar3;
  int iVar4;
  undefined4 in_lr;

  (*in_r3)();
  if (prevSysTick != _DAT_00800740)
  {
    iVar4 = _DAT_00800740 - prevSysTick;
    prevSysTick = _DAT_00800740;
    iVar3 = sysTimerPerUs * 1000;
    iVar1 = FUN_0000162c(iVar4, iVar3, &prevSysTick, sysTimerPerUs, in_lr);
    iVar4 = FUN_00001628(iVar4, iVar3);
    iVar4 = iVar4 + remSysTick;
    iVar2 = FUN_0000162c(iVar4, iVar3);
    remSysTick = FUN_00001628(iVar4, iVar3);
    if (iVar2 + iVar1 != 0)
    {
      ev_timer_update(iVar2 + iVar1);
      ev_timer_executeCB();
    }
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ev_timer_process(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  if (prevSysTick != _DAT_00800740)
  {
    iVar4 = _DAT_00800740 - prevSysTick;
    prevSysTick = _DAT_00800740;
    iVar3 = sysTimerPerUs * 1000;
    iVar1 = FUN_0000162c(iVar4, iVar3);
    iVar4 = FUN_00001628(iVar4, iVar3);
    iVar4 = iVar4 + remSysTick;
    iVar2 = FUN_0000162c(iVar4, iVar3);
    remSysTick = FUN_00001628(iVar4, iVar3);
    if (iVar2 + iVar1 != 0)
    {
      ev_timer_update(iVar2 + iVar1);
      ev_timer_executeCB();
    }
  }
  return;
}

u8 drv_adc_init(void)

{
  adc_init();
  return '\x01';
}

void drv_adc_mode_pin_set(drv_adc_mode_t mode, GPIO_PinTypeDef pin)

{
  if (mode == DRV_ADC_BASE_MODE)
  {
    adc_base_init(pin);
  }
  else if (mode == DRV_ADC_VBAT_MODE)
  {
    adc_vbat_init(pin);
  }
  return;
}

void drv_adc_enable(u8 enable)

{
  byte bVar1;

  bVar1 = analog_read(0xfc);
  analog_write(0xfc, (~enable + enable) * ' ' | bVar1 & 0xdf);
  return;
}

// WARNING: Variable defined which should be unmapped: flash_mid

void drv_calibration(void)

{
  int iVar1;
  u8 flash_uid[16];
  u8 adc_vref_calib_value[7];
  uint auStack_10[2];
  u32 flash_mid;

  auStack_10[0] = 0;
  flash_uid._0_4_ = 0;
  flash_uid._4_4_ = 0;
  flash_uid._8_4_ = 0;
  flash_uid._12_4_ = 0;
  iVar1 = flash_read_mid_uid_with_check(auStack_10, flash_uid);
  if (iVar1 != 0)
  {
    adc_vref_calib_value._0_4_ = 0;
    adc_vref_calib_value._4_2_ = 0;
    adc_vref_calib_value[6] = '\0';
    flash_read(g_u32CfgFlashAddr + 0xc0, 7, adc_vref_calib_value);
    if ((((int)((uint)adc_vref_calib_value[4] * 0x1000000) < 0) || (adc_vref_calib_value[5] == 0xff)) || (adc_vref_calib_value[6] == 0xff))
    {
      iVar1 = (adc_vref_calib_value._0_4_ & 0xff) + (adc_vref_calib_value._0_4_ >> 8 & 0xff);
      if ((iVar1 - 0x7fU & 0xffff) < 0x100)
      {
        adc_set_gpio_calib_vref((short)iVar1 + 0x398);
      }
    }
    else
    {
      adc_set_gpio_calib_vref(adc_vref_calib_value[5] + 1000 + (ushort)adc_vref_calib_value[6] * 0x100);
      adc_set_gpio_two_point_calib_offset((char)((adc_vref_calib_value[4] - 0x14) * 0x1000000 >> 0x18));
    }
  }
  return;
}

void flash_write(u32 addr, u32 len, u8 *buf)

{
  flash_write_page(addr, len, buf);
  return;
}

u8 flash_writeWithCheck(u32 addr, u32 len, u8 *buf)

{
  int iVar1;
  u32 uVar2;
  uint len_00;
  uchar auStack_48[48];

  flash_write_page(addr, len, buf);
  if (0 < (int)len)
  {
    while (true)
    {
      uVar2 = len;
      if (0x30 < (int)len)
      {
        uVar2 = 0x30;
      }
      len_00 = uVar2 & 0xff;
      flash_read_page(addr, len_00, auStack_48);
      iVar1 = memcmp(auStack_48, buf, len_00);
      if (iVar1 != 0)
      {
        return '\0';
      }
      len = len - len_00;
      if ((int)len < 1)
        break;
      addr = addr + len_00;
      buf = buf + len_00;
    }
  }
  return '\x01';
}

void flash_read(u32 addr, u32 len, u8 *buf)

{
  flash_read_page(addr, len, buf);
  return;
}

void flash_erase(u32 addr)

{
  flash_erase_sector(addr);
  return;
}

void drv_gpio_irq_process(drv_gpioIrqMode_t mode)

{
  int iVar1;
  undefined4 *puVar2;

  iVar1 = listLength(&gpioIrqHandlerQ_list);
  if (iVar1 != 0)
  {
    for (puVar2 = (undefined4 *)listHead(&gpioIrqHandlerQ_list); puVar2 != (undefined4 *)0x0;
         puVar2 = (undefined4 *)*puVar2)
    {
      if ((*(drv_gpioIrqMode_t *)(puVar2 + 3) == mode) && (puVar2[1] != 0))
      {
        FUNBBBBA();
        return;
      }
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNBBBBA(void)

{
  code *in_r3;

  (*in_r3)();
  drv_gpio_irq_process(GPIO_IRQ_MODE);
  return;
}

void drv_gpio_irq_handler(void)

{
  drv_gpio_irq_process(GPIO_IRQ_MODE);
  return;
}

void drv_gpio_irq_risc0_handler(void)

{
  drv_gpio_irq_process(GPIO_IRQ_RISC0_MODE);
  return;
}

void drv_gpio_irq_risc1_handler(void)

{
  drv_gpio_irq_process(GPIO_IRQ_RISC1_MODE);
  return;
}

void drv_gpio_write(u32 pin, u8 value)

{
  byte *pbVar1;

  if (value == '\0')
  {
    pbVar1 = (byte *)(((pin << 0x10) >> 0x18) * 8 + 0x800583);
    *pbVar1 = *pbVar1 & ~(byte)pin;
  }
  else
  {
    pbVar1 = (byte *)(((pin << 0x10) >> 0x18) * 8 + 0x800583);
    *pbVar1 = (byte)pin | *pbVar1;
  }
  return;
}

void drv_gpio_read_all(u8 *p)

{
  *p = DAT_00800580;
  p[1] = DAT_00800588;
  p[2] = DAT_00800590;
  p[3] = DAT_00800598;
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

char drv_platform_init(void)

{
  char cVar1;
  byte bVar2;
  uchar uVar3;
  undefined4 local_14;

  cpu_wakeup_init();
  cVar1 = pmParam._2_1_;
  clock_init(0x20);
  sysTimerPerUs = 0x10;
  _DAT_00800580 = 0xf38000;
  _DAT_00800584 = 0x7fff00;
  analog_write(0xbd, '\0');
  DAT_0080058a = 0xff;
  DAT_0080058b = 0;
  analog_write(0xbf, 0xff);
  DAT_0080058e = 0xff;
  analog_write(0xc0, '\0');
  DAT_00800592 = 0xff;
  DAT_00800593 = 0;
  analog_write(0xc2, 0xff);
  DAT_00800596 = 0xff;
  _DAT_00800598 = 0xff6000;
  _DAT_0080059c = 0xffff00;
  DAT_008005a1 = 0xf;
  DAT_008005a2 = 0xf;
  DAT_008005a3 = 0;
  DAT_008005a5 = 0xf;
  DAT_008005a6 = 0;
  analog_write('\x0e', '\0');
  analog_write('\x0f', '@');
  analog_write('\x10', '\0');
  analog_write('\x11', '\0');
  analog_write('\x12', '\0');
  analog_write('\x13', '\0');
  analog_write('\x14', '\0');
  analog_write('\x15', '<');
  if (cVar1 == '\x01')
    goto LAB_0000e52a;
  random_generator_init();
  local_14 = flash_read_mid();
  local_14._2_1_ = (byte)(local_14 >> 0x10);
  if (local_14._2_1_ < 0x13)
  {
  LAB_0000e4fc:
    do
    {
      // WARNING: Do nothing block with infinite loop
    } while (true);
  }
  if (g_u32MacFlashAddr == 0xff000)
  {
    if (local_14._2_1_ == 0x13)
      goto LAB_0000e4fc;
  LAB_0000e516:
    if (local_14._2_1_ == 0x15)
    {
      g_u32MacFlashAddr = 0x1ff000;
      g_u32CfgFlashAddr = 0x1fe000;
      goto LAB_0000e52a;
    }
  }
  else
  {
    if (g_u32MacFlashAddr == 0x1ff000)
    {
      if (local_14._2_1_ < 0x15)
        goto LAB_0000e4fc;
      goto LAB_0000e516;
    }
    if (g_u32MacFlashAddr != 0x3ff000)
      goto LAB_0000e516;
    if (local_14._2_1_ < 0x16)
      goto LAB_0000e4fc;
  }
  if (local_14._2_1_ == 0x16)
  {
    g_u32MacFlashAddr = 0x3ff000;
    g_u32CfgFlashAddr = 0x3fe000;
  }
  else if (local_14._2_1_ == 0x14)
  {
    g_u32MacFlashAddr = 0xff000;
    g_u32CfgFlashAddr = 0xfe000;
  }
LAB_0000e52a:
  rf_drv_init();
  local_14._0_1_ = 0xff;
  flash_read_page(g_u32CfgFlashAddr, 1, (uchar *)&local_14);
  if ((byte)local_14 != 0xff)
  {
    local_14._0_1_ = (byte)local_14 & 0x3f;
    bVar2 = analog_read(0x8a);
    analog_write(0x8a, bVar2 & 0xc0 | (byte)local_14);
  }
  drv_hwTmr_init('\x03', '\0');
  drv_calibration();
  uVar3 = flash_is_zb();
  if (uVar3 != '\0')
  {
    drv_adc_init();
    drv_adc_mode_pin_set(DRV_ADC_VBAT_MODE, GPIO_PC5);
    drv_adc_enable('\x01');
    flash_safe_voltage_set(0x898);
    flash_unlock_mid13325e();
  }
  return cVar1;
}

void drv_enable_irq(void)

{
  DAT_00800643 = 1;
  return;
}

undefined drv_disable_irq(void)

{
  undefined uVar1;

  uVar1 = DAT_00800643;
  DAT_00800643 = 0;
  return uVar1;
}

u32 drv_restore_irq(u32 en)

{
  DAT_00800643 = (char)en;
  return 0;
}

u32 drv_u32Rand(void)

{
  u32 uVar1;

  uVar1 = rand();
  return uVar1;
}

void drv_generateRandomData(u8 *pData, u8 len)

{
  uint uVar1;
  uint uVar2;

  if (len != 0)
  {
    uVar2 = 0;
    uVar1 = 0;
    while (true)
    {
      if ((uVar2 & 3) == 0)
      {
        uVar1 = rand();
        pData[uVar2] = (u8)uVar1;
      }
      else
      {
        pData[uVar2] = (u8)uVar1;
      }
      if ((uint)len <= (uVar2 + 1 & 0xff))
        break;
      uVar2 = uVar2 + 1;
      uVar1 = uVar1 >> 8;
    }
  }
  return;
}

u32 key_debounce_filter(u32 *mtrx_cur, u32 filt_en)

{
  uint uVar1;
  uint uVar2;
  bool bVar3;

  uVar2 = *mtrx_cur;
  uVar1 = uVar2;
  if (filt_en != 0)
  {
    uVar1 = (uVar2 | key_debounce_filter::mtrx_pre[0]) & key_debounce_filter::mtrx_last[0] |
            key_debounce_filter::mtrx_pre[0] & ~key_debounce_filter::mtrx_last[0] & uVar2;
    *mtrx_cur = uVar1;
  }
  bVar3 = uVar1 != key_debounce_filter::mtrx_last[0];
  key_debounce_filter::mtrx_pre[0] = uVar2;
  key_debounce_filter::mtrx_last[0] = uVar1;
  return (uint)bVar3;
}

u32 kb_scan_row(int drv_ind, u8 *gpio)

{
  u32 uVar1;

  uVar1 = 0;
  if ((int)(scan_pin_need << 0x1f) < 0)
  {
    uVar1 = (uint)(gpio[scan_pins[0] >> 8] & (byte)scan_pins[0]) +
            ~(uint)(gpio[scan_pins[0] >> 8] & (byte)scan_pins[0]) +
            (uint)((scan_pins[0] >> 7 & 1) != 0);
  }
  if (((scan_pin_need & 2) != 0) && ((gpio[scan_pins[1] >> 8] & (byte)scan_pins[1]) == 0))
  {
    uVar1 = uVar1 | 2;
  }
  drv_gpio_read_all(gpio);
  return uVar1;
}

/*
Unable to decompile 'kb_scan_key'
Cause:
Low-level Error: Unsupported data-type for ResolveUnion
*/

nv_sts_t nv_index_read_op(u16 id, u8 itemId, u16 *itemLen, u8 opSect, u32 totalItemNum, u16 *idxNo,
                          u8 lenCheck)

{
  u16 uVar1;
  ushort uVar2;
  int iVar3;
  uint uVar4;
  ushort *puVar5;
  int iVar6;
  u8 uVar7;
  bool bVar8;
  u32 local_5c;
  uint uStack_50;
  nv_sts_t nStack_4c;
  u8 auStack_44[4];
  ushort auStack_40[14];

  uVar4 = (uint)id;
  if (uVar4 < 6)
  {
    iVar6 = (uVar4 + 0x1a) * 0x2000;
  }
  else
  {
    iVar6 = (uVar4 + 0x37) * 0x2000;
    if (uVar4 == 7)
    {
      iVar3 = 0x2000;
      uVar1 = *itemLen;
      goto joined_r0x0000e8e8;
    }
  }
  iVar3 = 0x1000;
  uVar1 = *itemLen;
joined_r0x0000e8e8:
  if (itemId == 0xff)
  {
    uVar2 = 0xffff;
    uVar7 = 0xff;
  }
  else
  {
    uVar2 = uVar1 + 8;
    uVar7 = 'Z';
  }
  nStack_4c = NV_ITEM_NOT_FOUND;
  if (totalItemNum != 0)
  {
    local_5c = iVar6 + totalItemNum * 8 + 4 + iVar3 * (uint)opSect;
    uStack_50 = totalItemNum & 0xffff;
    nStack_4c = NV_ITEM_NOT_FOUND;
    do
    {
      uVar4 = totalItemNum;
      if (4 < totalItemNum)
      {
        uVar4 = 4;
      }
      uVar4 = uVar4 & 0xffff;
      local_5c = local_5c + uVar4 * -8;
      uStack_50 = uStack_50 - uVar4 & 0xffff;
      flash_read(local_5c, uVar4 * 8, auStack_44);
      iVar6 = uVar4 - 1;
      if (uVar4 != 0)
      {
        puVar5 = auStack_40 + iVar6 * 4 + 1;
      LAB_0000e964:
        do
        {
          if (itemId == 0xff)
          {
            if (((*(u8 *)((int)puVar5 + 1) != uVar7) || (auStack_40[iVar6 * 4] != uVar2)) ||
                (*(u8 *)puVar5 != 0xff))
              goto LAB_0000e97e;
          }
          else if (((*(u8 *)((int)puVar5 + 1) == 'z') || (*(u8 *)((int)puVar5 + 1) == 'Z')) &&
                   (*(u8 *)puVar5 == itemId))
          {
            if (lenCheck == '\0')
            {
              *itemLen = auStack_40[iVar6 * 4] - 8;
              nStack_4c = NV_SUCC;
              break;
            }
            iVar3 = FUN_00001628(auStack_40[iVar6 * 4] - 8, uVar1);
            if (iVar3 == 0)
            {
            LAB_0000e97e:
              *idxNo = (short)iVar6 + (short)uStack_50;
              return NV_SUCC;
            }
            puVar5 = puVar5 + -4;
            bVar8 = iVar6 == 0;
            iVar6 = iVar6 + -1;
            if (bVar8)
              break;
            goto LAB_0000e964;
          }
          puVar5 = puVar5 + -4;
          bVar8 = iVar6 != 0;
          iVar6 = iVar6 + -1;
        } while (bVar8);
      }
      totalItemNum = totalItemNum - uVar4;
    } while (totalItemNum != 0);
  }
  return nStack_4c;
}

void nv_itemLengthCheckAdd(u8 itemId, u16 len)

{
  uint uVar1;
  int iVar2;
  nv_itemLenChk_t *pnVar3;
  undefined uVar4;

  uVar1 = (uint)g_nvItemLengthCheckNum;
  uVar4 = (undefined)((uint)len >> 8);
  if (uVar1 == 0)
  {
  LAB_0000ea46:
    if (uVar1 < 0x10)
    {
      g_nvItemLenCheckTbl[uVar1].itemId = itemId;
      *(char *)&g_nvItemLenCheckTbl[uVar1].len = (char)len;
      *(undefined *)((int)&g_nvItemLenCheckTbl[uVar1].len + 1) = uVar4;
      g_nvItemLengthCheckNum = g_nvItemLengthCheckNum + '\x01';
    }
    else
    {
      sys_exceptionPost(0x61, 0x80);
    }
  }
  else
  {
    pnVar3 = g_nvItemLenCheckTbl;
    if (g_nvItemLenCheckTbl[0].itemId == itemId)
    {
      iVar2 = 0;
    }
    else
    {
      iVar2 = 0;
      do
      {
        pnVar3 = pnVar3 + 1;
        iVar2 = iVar2 + 1;
        if ((int)uVar1 <= iVar2)
          goto LAB_0000ea46;
      } while (pnVar3->itemId != itemId);
    }
    *(char *)&g_nvItemLenCheckTbl[iVar2].len = (char)len;
    *(undefined *)((int)&g_nvItemLenCheckTbl[iVar2].len + 1) = uVar4;
  }
  return;
}

nv_sts_t nv_index_read(u16 id, u8 itemId, u16 len, u8 opSect, u32 totalItemNum, u16 *idxNo)

{
  nv_sts_t nVar1;
  u16 local_c[4];

  local_c[0] = len;
  nVar1 = nv_index_read_op(id, itemId, local_c, opSect, totalItemNum, idxNo, '\x01');
  return nVar1;
}

// WARNING: Could not reconcile some variable overlaps

nv_sts_t nv_sector_read(u16 id, u8 sectTotalNum, nv_sect_info_t *sectInfo)

{
  byte bVar1;
  u8 uVar2;
  nv_sts_t nVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  u32 addr;
  undefined4 uStack_2c;
  uint local_28;

  uVar5 = (uint)sectTotalNum;
  uVar4 = (uint)id;
  if (uVar4 < 6)
  {
    iVar10 = uVar4 + 0x1a;
  }
  else
  {
    iVar10 = uVar4 + 0x37;
  }
  addr = iVar10 * 0x2000;
  nVar3 = NV_ITEM_NOT_FOUND;
  if (uVar5 != 0)
  {
    uVar9 = 0;
    while (true)
    {
      flash_read(addr, 4, (u8 *)&local_28);
      uVar6 = local_28 >> 0x18 & 3;
      uVar7 = local_28 & 0xffff;
      uStack_2c._3_1_ = (byte)(local_28 >> 0x18);
      if (uVar7 == 0xfafa)
        break;
      iVar10 = (uVar7 - 0x7a7a) + ~(uVar7 - 0x7a7a) + (uint)(0x7a79 < uVar7);
      if (((iVar10 != 0) || (uVar7 == 0x5a5a)) && ((local_28 >> 0x10 & 0xff) == uVar4))
      {
        if (iVar10 == 0)
          goto LAB_0000eb8c;
        uStack_2c = local_28 & 0x3ffffff;
        uVar7 = xcrc32((uchar *)((int)&uStack_2c + 2), 2, 0xfffffffe);
        if ((uVar7 & 0x3f) == (uint)(uStack_2c._3_1_ >> 2))
        {
          local_28 = local_28 & 0xffffff | uVar6 << 0x18;
          memcpy(sectInfo, &local_28, 4);
          goto LAB_0000ebda;
        }
      }
    LAB_0000eb2c:
      if (uVar4 == 7)
      {
        iVar10 = 0x2000;
      }
      else
      {
        iVar10 = 0x1000;
      }
      uVar9 = uVar9 + 1;
      if ((int)uVar5 <= (int)uVar9)
        goto LAB_0000ebda;
      addr = addr + iVar10;
    }
    uStack_2c = local_28 & 0x3ffffff;
    uVar7 = xcrc32((uchar *)((int)&uStack_2c + 2), 2, 0xfffffffe);
    if ((uVar7 & 0x3f) != (uint)(uStack_2c._3_1_ >> 2))
      goto LAB_0000eb2c;
    local_28 = local_28 & 0xffff0000 | 0x5050;
    if (uVar4 < 6)
    {
      iVar10 = (uVar4 + 0x1a) * 0x2000;
    LAB_0000eb78:
      iVar8 = 0x1000;
    }
    else
    {
      iVar10 = (uVar4 + 0x37) * 0x2000;
      if (uVar4 != 7)
        goto LAB_0000eb78;
      iVar8 = 0x2000;
    }
    uVar2 = flash_writeWithCheck(iVar8 * (uVar6 + 1 & 1) + iVar10, 2, (u8 *)&local_28);
    if (uVar2 == '\x01')
    {
      local_28 = local_28 & 0xffff0000 | 0x7a7a;
      flash_writeWithCheck(addr, 2, (u8 *)&local_28);
    }
  LAB_0000eb8c:
    local_28 = local_28 & 0xffffff | uVar6 << 0x18;
    memcpy(sectInfo, &local_28, 4);
  LAB_0000ebda:
    bVar1 = (char)uVar9 - sectTotalNum;
    nVar3 = ~(bVar1 + ~bVar1 + (uVar5 <= uVar9)) & 3;
  }
  return nVar3;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Restarted to delay deadcode elimination for space: stack

nv_sts_t nv_write_item(u8 single, u16 id, u8 itemId, u8 opSect, u16 opItemIdx, u16 len, u8 *buf,
                       u8 isFlashCopy)

{
  u8 uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  u32 addr;
  int iVar7;
  uint uVar8;
  uint uVar9;
  u32 uVar10;
  uint uVar11;
  uint uVar12;
  nv_sts_t nVar13;
  uint uVar14;
  u8 *addr_00;
  uint *local_74;
  uint uStack_70;
  byte local_64[48];
  uint uStack_34;
  u16 uStack_30;
  u8 uStack_2e;
  char cStack_2d;
  uint local_2c;
  undefined4 uStack_28;

  uVar14 = (uint)opSect;
  uVar11 = (uint)id;
  uVar9 = (uint)len;
  local_2c = 0;
  uStack_28 = 0;
  uVar12 = uVar11;
  if (uVar11 < 6)
  {
    iVar4 = (uVar11 + 0x1a) * 0x2000;
  LAB_0000ec86:
    iVar4 = uVar14 * 0x1000 + iVar4 + 4;
    if (opItemIdx == 0)
      goto LAB_0000ec96;
  LAB_0000ee56:
    flash_read((opItemIdx - 2) * 8 + iVar4, 8, (u8 *)&local_2c);
    flash_read(local_2c, 8, (u8 *)&uStack_34);
    if ((cStack_2d == 'z') &&
        (uVar3 = xcrc32((uchar *)&local_2c, 7, 0xfffffffe), (uVar3 & 0xffff) != uStack_34 >> 0x10))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if ((((uStack_28._3_1_ != 'z') && (uStack_28._3_1_ != 'Z')) && (uStack_28._3_1_ != 'P')) &&
        (uStack_28._3_1_ != -6))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if (uVar11 < 6)
    {
      iVar7 = (uVar11 + 0x1a) * 0x2000;
    LAB_0000ee92:
      iVar7 = iVar7 + uVar14 * 0x1000;
      iVar2 = ~(uVar11 - 7) + (uVar11 - 7) + (uint)(6 < uVar11);
      if (((iVar2 != 0) || (uVar11 == 5)) || (uVar11 == 1))
        goto LAB_0000ef24;
      iVar6 = 0x200;
    }
    else
    {
      iVar7 = (uVar11 + 0x37) * 0x2000;
      if (uVar11 != 7)
        goto LAB_0000ee92;
      iVar7 = uVar14 * 0x2000 + iVar7;
      iVar2 = 1;
    LAB_0000ef24:
      iVar6 = 0x400;
    }
    if (local_2c < (uint)(iVar7 + iVar6))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if (uVar11 < 6)
    {
      iVar6 = (uVar11 + 0x1a) * 0x2000;
      iVar7 = 0x1000;
    }
    else
    {
      iVar6 = (uVar11 + 0x37) * 0x2000;
      if (iVar2 == 0)
      {
        iVar7 = 0x1000;
      }
      else
      {
        iVar7 = 0x2000;
      }
    }
    if (iVar7 * (uVar14 + 1) + iVar6 <= local_2c)
    {
      return NV_ITEM_CHECK_ERROR;
    }
    if (uVar11 < 6)
    {
      uStack_70 = (uVar11 + 0x1a) * 0x2000;
      iVar7 = 0x1000;
    }
    else
    {
      uStack_70 = (uVar11 + 0x37) * 0x2000;
      if (iVar2 == 0)
      {
        iVar7 = 0x1000;
      }
      else
      {
        iVar7 = 0x2000;
      }
    }
    if (((uVar14 + 1) * iVar7 + uStack_70) - local_2c < (uStack_28 & 0xffff))
    {
      return NV_ITEM_CHECK_ERROR;
    }
    local_2c = local_2c + 3 + (uStack_28 & 0xffff) & 0xfffffffc;
  }
  else
  {
    iVar4 = (uVar11 + 0x37) * 0x2000;
    if (uVar11 != 7)
      goto LAB_0000ec86;
    iVar4 = uVar14 * 0x2000 + iVar4 + 4;
    if (opItemIdx != 0)
      goto LAB_0000ee56;
  LAB_0000ec96:
    if (uVar11 < 6)
    {
      iVar7 = (uVar11 + 0x1a) * 0x2000;
    LAB_0000eeb4:
      uVar8 = iVar7 + uVar14 * 0x1000;
      uVar3 = uVar11 - 7;
      if ((uVar3 == 0) || (uVar11 == 5))
      {
        uVar5 = 0x400;
      }
      else if (uVar11 == 1)
      {
        uVar5 = 0x400;
        uVar12 = 1;
      }
      else
      {
        uVar5 = 0x200;
      }
    }
    else
    {
      iVar7 = (uVar11 + 0x37) * 0x2000;
      if (uVar11 != 7)
        goto LAB_0000eeb4;
      uVar8 = uVar14 * 0x2000 + iVar7;
      uVar5 = 0x400;
      uVar3 = 0;
    }
    local_2c = uVar8 + uVar5;
    iVar2 = uVar3 + ~uVar3 + (uint)CARRY4(uVar8, uVar5);
  }
  uStack_28 = CONCAT12(itemId, (short)(uVar9 + 8)) | 0xfa000000;
  if (uVar11 < 6)
  {
    iVar7 = (uVar12 + 0x1a) * 0x2000;
  LAB_0000ecde:
    iVar7 = iVar7 + uVar14 * 0x1000;
    if (((iVar2 != 0) || (uVar11 == 5)) || (uVar11 == 1))
      goto LAB_0000eee4;
    iVar6 = 0x200;
  }
  else
  {
    iVar7 = (uVar12 + 0x37) * 0x2000;
    if (uVar11 != 7)
      goto LAB_0000ecde;
    iVar7 = iVar7 + uVar14 * 0x2000;
  LAB_0000eee4:
    iVar6 = 0x400;
  }
  if (local_2c < (uint)(iVar7 + iVar6))
  {
    return NV_ITEM_CHECK_ERROR;
  }
  if (uVar11 < 6)
  {
    iVar7 = (uVar12 + 0x1a) * 0x2000;
    iVar6 = 0x1000;
  }
  else
  {
    iVar7 = (uVar12 + 0x37) * 0x2000;
    if (iVar2 == 0)
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
  }
  if (iVar6 * (uVar14 + 1) + iVar7 <= local_2c)
  {
    return NV_ITEM_CHECK_ERROR;
  }
  if (uVar11 < 6)
  {
    iVar7 = (uVar12 + 0x1a) * 0x2000;
  LAB_0000ef00:
    iVar2 = 0x1000;
  }
  else
  {
    iVar7 = (uVar12 + 0x37) * 0x2000;
    if (iVar2 == 0)
      goto LAB_0000ef00;
    iVar2 = 0x2000;
  }
  if (((uVar14 + 1) * iVar2 + iVar7) - local_2c < (uVar9 + 8 & 0xffff))
  {
    return NV_ITEM_CHECK_ERROR;
  }
  addr = (uint)opItemIdx * 8 + iVar4;
  uVar1 = flash_writeWithCheck(addr, 8, (u8 *)&local_2c);
  uVar12 = local_2c;
  if (uVar1 != '\x01')
  {
    return NV_ITEM_CHECK_ERROR;
  }
  if (isFlashCopy == '\0')
  {
    uVar10 = local_2c + 8;
    uVar12 = xcrc32(buf, uVar9, 0xfffffffe);
    flash_write(uVar10, uVar9, buf);
    if (len == 0)
    {
      uVar11 = 0xfffffffe;
    }
    else
    {
      uVar11 = 0xfffffffe;
      do
      {
        uVar14 = uVar9;
        if (0x10 < (int)uVar9)
        {
          uVar14 = 0x10;
        }
        uVar14 = uVar14 & 0xffff;
        flash_read(uVar10, uVar14, local_64);
        uVar11 = xcrc32(local_64, uVar14, uVar11);
        uVar9 = uVar9 - uVar14;
        uVar10 = uVar10 + uVar14;
      } while (0 < (int)uVar9);
    }
    if (uVar11 != uVar12)
    {
      return NV_CHECK_SUM_ERROR;
    }
    uStack_30 = len;
    uStack_2e = itemId;
  }
  else
  {
    uVar9 = (uStack_28 & 0xffff) - 8;
    flash_read((u32)buf, 8, (u8 *)&uStack_34);
    if ((int)uVar9 < 1)
    {
      uVar11 = 0xfffffffe;
      uVar12 = 0;
      uStack_70 = 0xfffffffe;
    }
    else
    {
      uVar10 = uVar12 + 8;
      addr_00 = buf + 8;
      uVar11 = 0xfffffffe;
      uVar12 = 0;
      uStack_70 = 0xfffffffe;
      while (true)
      {
        uVar14 = uVar9;
        if (0x30 < (int)uVar9)
        {
          uVar14 = 0x30;
        }
        uVar14 = uVar14 & 0xff;
        flash_read((u32)addr_00, uVar14, local_64);
        if (cStack_2d == 'Z')
        {
          if (uVar14 != 0)
          {
            iVar4 = 0;
            do
            {
              uVar12 = uVar12 + local_64[iVar4];
              iVar4 = iVar4 + 1;
            } while (iVar4 < (int)uVar14);
          }
          uVar11 = xcrc32(local_64, uVar14, uVar11);
        }
        else
        {
          uStack_70 = xcrc32(local_64, uVar14, uStack_70);
        }
        uVar1 = flash_writeWithCheck(uVar10, uVar14, local_64);
        if (uVar1 != '\x01')
        {
          return NV_CHECK_SUM_ERROR;
        }
        uVar9 = uVar9 - uVar14;
        if ((int)uVar9 < 1)
          break;
        addr_00 = addr_00 + uVar14;
        uVar10 = uVar10 + uVar14;
      }
    }
    if (cStack_2d != 'Z')
    {
      uVar9 = xcrc32((uchar *)&uStack_30, 4, uStack_70);
      if (((uStack_34 ^ uVar9) & 0xffff) != 0)
      {
        return NV_DATA_CHECK_ERROR;
      }
      goto LAB_0000ede4;
    }
    if (uStack_34 != uVar12)
    {
      return NV_DATA_CHECK_ERROR;
    }
  }
  uVar9 = xcrc32((uchar *)&uStack_30, 4, uVar11);
LAB_0000ede4:
  local_74 = &uStack_34;
  uStack_28 = CONCAT13(0x5a, (undefined3)uStack_28);
  if (single != '\0')
  {
    uStack_28 = CONCAT13(0x7a, (undefined3)uStack_28);
  }
  uVar12 = xcrc32((uchar *)&local_2c, 7, 0xfffffffe);
  uStack_34 = uVar12 << 0x10 | uVar9 & 0xffff;
  uVar1 = flash_writeWithCheck(local_2c, 8, (u8 *)local_74);
  nVar13 = NV_CHECK_SUM_ERROR;
  if (uVar1 == '\x01')
  {
    flash_writeWithCheck(addr + 7, 1, (u8 *)((int)&uStack_28 + 3));
    nVar13 = NV_SUCC;
  }
  return nVar13;
}

nv_sts_t nv_flashReadByIndex(u8 id, u8 itemId, u8 opSect, u16 opIdx, u16 len, u8 *buf)

{
  nv_sts_t nVar1;
  short sVar2;
  int iVar3;
  uint len_00;
  undefined4 *puVar4;
  int iVar5;
  u32 uVar6;
  nv_itemLenChk_t *pnVar7;
  u32 addr;
  uint uVar8;
  u32 uVar9;
  undefined4 local_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  uint uStack_2c;
  ushort uStack_28;
  u8 uStack_26;
  char cStack_25;
  u32 uStack_24;
  char cStack_1d;

  uVar8 = (uint)id;
  if (uVar8 < 6)
  {
    iVar5 = (uVar8 + 0x1a) * 0x2000;
  }
  else
  {
    iVar5 = (uVar8 + 0x37) * 0x2000;
    if (uVar8 == 7)
    {
      iVar3 = 0x2000;
      goto LAB_0000f100;
    }
  }
  iVar3 = 0x1000;
LAB_0000f100:
  flash_read((uint)opIdx * 8 + 4 + iVar3 * (uint)opSect + iVar5, 8, (u8 *)&uStack_24);
  if ((cStack_1d == 'z') || (nVar1 = NV_ITEM_NOT_FOUND, cStack_1d == 'Z'))
  {
    flash_read(uStack_24, 8, (u8 *)&uStack_2c);
    uVar8 = (uint)uStack_28;
    sVar2 = FUN_00001628(uVar8, len);
    pnVar7 = g_nvItemLenCheckTbl;
    iVar5 = 0;
    do
    {
      if (pnVar7->itemId == itemId)
      {
        len_00 = (uint)g_nvItemLenCheckTbl[iVar5].len;
        if (uVar8 < g_nvItemLenCheckTbl[iVar5].len)
        {
          len_00 = uVar8;
        }
        if (sVar2 != 0)
        {
          return NV_ITEM_NOT_FOUND;
        }
        goto LAB_0000f172;
      }
      iVar5 = iVar5 + 1;
      pnVar7 = pnVar7 + 1;
    } while (iVar5 != 0x10);
    nVar1 = NV_ITEM_NOT_FOUND;
    len_00 = uVar8;
    if (sVar2 == 0)
    {
    LAB_0000f172:
      nVar1 = NV_ITEM_NOT_FOUND;
      if (((cStack_25 == 'z') || (cStack_25 == 'Z')) &&
          (nVar1 = NV_ITEM_NOT_FOUND, uStack_26 == itemId))
      {
        flash_read(uStack_24 + 8, len_00, buf);
        addr = uStack_24 + 8 + len_00;
        local_4c = 0;
        uStack_48 = 0;
        uStack_44 = 0;
        uStack_40 = 0;
        uStack_3c = 0;
        uStack_38 = 0;
        uStack_34 = 0;
        uStack_30 = 0;
        if (cStack_25 == 'Z')
        {
          uVar8 = 0;
          if (len_00 != 0)
          {
            iVar5 = 0;
            do
            {
              uVar8 = uVar8 + buf[iVar5];
              iVar5 = iVar5 + 1;
            } while (iVar5 < (int)len_00);
          }
          if ((len_00 < uStack_28) && (uVar9 = uStack_28 - len_00, 0 < (int)uVar9))
          {
            while (true)
            {
              uVar6 = uVar9;
              if (0x20 < (int)uVar9)
              {
                uVar6 = 0x20;
              }
              flash_read(addr, uVar6, (u8 *)&local_4c);
              if (uVar6 != 0)
              {
                puVar4 = &local_4c;
                do
                {
                  uVar8 = uVar8 + *(byte *)puVar4;
                  puVar4 = (undefined4 *)((int)puVar4 + 1);
                } while (puVar4 != (undefined4 *)((int)&local_4c + uVar6));
              }
              uVar9 = uVar9 - uVar6;
              if ((int)uVar9 < 1)
                break;
              addr = addr + uVar6;
            }
          }
          nVar1 = ~(1U - (uStack_2c == uVar8)) & 6;
        }
        else
        {
          uVar8 = xcrc32(buf, len_00, 0xfffffffe);
          if (len_00 < uStack_28)
          {
            for (uVar9 = uStack_28 - len_00; 0 < (int)uVar9; uVar9 = uVar9 - uVar6)
            {
              uVar6 = uVar9;
              if (0x20 < (int)uVar9)
              {
                uVar6 = 0x20;
              }
              flash_read(addr, uVar6, (u8 *)&local_4c);
              uVar8 = xcrc32((uchar *)&local_4c, uVar6, uVar8);
              addr = addr + uVar6;
            }
          }
          uVar8 = xcrc32((uchar *)&uStack_28, 4, uVar8);
          nVar1 = ~(1U - (((uStack_2c ^ uVar8) & 0xffff) == 0)) & 6;
        }
      }
    }
  }
  return nVar1;
}

nv_sts_t nv_itemDeleteByIndex(u8 id, u8 itemId, u8 opSect, u16 opIdx)

{
  uint uVar1;
  int iVar2;
  int iVar3;
  u8 auStack_d[5];

  uVar1 = (uint)id;
  if (uVar1 < 6)
  {
    iVar3 = (uVar1 + 0x1a) * 0x2000;
  }
  else
  {
    iVar3 = (uVar1 + 0x37) * 0x2000;
    if (uVar1 == 7)
    {
      iVar2 = 0x2000;
      goto LAB_0000f2b4;
    }
  }
  iVar2 = 0x1000;
LAB_0000f2b4:
  auStack_d[0] = 'P';
  flash_write((uint)opIdx * 8 + 0xb + iVar2 * (uint)opSect + iVar3, 1, auStack_d);
  return NV_SUCC;
}

// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

nv_sts_t nv_flashWriteNewHandler(u8 forceChgSec, u8 single, u16 id, u8 itemId, u16 len, u8 *buf)

{
  bool bVar1;
  bool bVar2;
  byte bVar3;
  byte bVar4;
  nv_sts_t nVar5;
  u8 *puVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  short sVar13;
  uint uVar14;
  uint uVar15;
  u8 *puVar16;
  int iVar17;
  u8 **ppuVar18;
  int iVar19;
  u32 uVar20;
  int iVar21;
  uint uVar22;
  uint uStack_98;
  int iStack_7c;
  int iStack_6c;
  uint uStack_68;
  u32 uStack_64;
  u8 *puStack_60;
  ushort uStack_5c;
  u8 uStack_5a;
  byte bStack_59;
  u8 auStack_40[6];
  byte bStack_3a;
  char cStack_39;
  u8 auStack_38[7];
  byte bStack_31;
  short asStack_30[2];
  nv_sect_info_t nStack_2c;
  u16 uStack_26;

  uVar10 = (uint)id;
  uVar8 = (uint)single;
  if (uVar10 < 6)
  {
    iVar19 = (uVar10 + 0x1a) * 0x2000;
  }
  else
  {
    iVar19 = (uVar10 + 0x37) * 0x2000;
    if (uVar10 == 7)
    {
      uStack_98 = 1;
      bVar2 = true;
      if (0x2000 < len + 0x408)
      {
        return NV_NOT_ENOUGH_SAPCE;
      }
      goto LAB_0000f378;
    }
  }
  uStack_98 = ~(uVar10 - 7) + (uVar10 - 7) + (uint)(6 < uVar10) |
              (uVar10 - 5) + ~(uVar10 - 5) + (uint)(4 < uVar10);
  if (uStack_98 != 0)
  {
    nVar5 = FUN_0000f718();
    return nVar5;
  }
  if (uVar10 == 1)
  {
    nVar5 = FUN_0000f764();
    return nVar5;
  }
  bVar2 = false;
  if (0x1000 < len + 0x208)
  {
    return NV_NOT_ENOUGH_SAPCE;
  }
LAB_0000f378:
  nVar5 = nv_sector_read(id, '\x02', &nStack_2c);
  if (nVar5 != NV_SUCC)
  {
    nVar5 = FUN_0000f722();
    return nVar5;
  }
  uVar14 = (uint)nStack_2c.opSect;
  if (5 < uVar10)
  {
    nVar5 = FUN_0000f750();
    return nVar5;
  }
  uStack_26 = 0;
  if ((uStack_98 == 0) && (uVar10 == 1))
  {
    nVar5 = FUN_0000fa02();
    return nVar5;
  }
  if (forceChgSec == '\0')
  {
    nVar5 = FUN_0000f7d2();
    return nVar5;
  }
  uStack_26 = 0;
  uVar11 = uVar14 + 1 & 1;
  if (bVar2)
  {
    nVar5 = FUN_0000fa06();
    return nVar5;
  }
  uVar20 = uVar11 * 0x1000 + iVar19;
  iVar19 = 0;
  do
  {
    flash_erase(uVar20);
    uVar20 = uVar20 + 0x1000;
    iVar19 = iVar19 + 1;
  } while (iVar19 < 1);
  if (5 < uVar10)
  {
    nVar5 = FUN_0000f940();
    return nVar5;
  }
  if (uStack_98 != 0)
  {
    nVar5 = FUN_0000f93a();
    return nVar5;
  }
  if (uVar10 == 1)
  {
    nVar5 = FUN_0000f97a();
    return nVar5;
  }
  if (uVar10 < 6)
  {
    iStack_6c = uVar10 + 0x1a;
    iStack_7c = 0x1000;
  }
  else
  {
    iStack_6c = uVar10 + 0x37;
    if (!bVar2)
    {
      nVar5 = FUN_0000fa2a();
      return nVar5;
    }
    iStack_7c = 0x2000;
  }
  iStack_6c = iStack_6c * 0x2000;
  if (uVar10 == 1)
  {
    nVar5 = FUN_0000f952();
    return nVar5;
  }
  uVar22 = 0x3e;
  uStack_68 = 0x3f;
  puVar6 = ev_buf_allocate(0x3f);
  if (uVar10 < 6)
  {
    iVar19 = uVar10 + 0x1a;
    iVar17 = 0x1000;
  }
  else
  {
    iVar19 = uVar10 + 0x37;
    if (!bVar2)
    {
      nVar5 = FUN_0000fa24();
      return nVar5;
    }
    iVar17 = 0x2000;
  }
  if (puVar6 != (u8 *)0x0)
  {
    memset(puVar6, 0, 0x3f);
    iVar9 = 0x3e0000;
    uVar20 = iVar17 * uVar14 + iVar19 * 0x2000 + 500;
    sVar13 = 0;
    do
    {
      flash_read(uVar20, 8, auStack_40);
      if (((cStack_39 == 'z') || (cStack_39 == 'Z')) &&
          ((cStack_39 == 'z' || ((uVar10 == bStack_3a && (uVar8 != 0))))))
      {
        iVar19 = (int)sVar13;
        if (iVar19 != 0)
        {
          bVar1 = true;
          iVar17 = 0;
          while (true)
          {
            if (puVar6[iVar17] == bStack_3a)
            {
              nv_itemDeleteByIndex((u8)id, itemId, nStack_2c.opSect, (u16)((uint)iVar9 >> 0x10));
              bVar1 = false;
            }
            if (iVar19 <= iVar17 + 1)
              break;
            iVar17 = iVar17 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        puVar6[iVar19] = bStack_3a;
        sVar13 = sVar13 + 1;
      }
    LAB_0000f530:
      iVar9 = (uVar22 - 2) * 0x10000;
      uVar22 = uVar22 - 2 & 0xffff;
      uVar20 = uVar20 - 9;
    } while (-1 < iVar9);
    ev_buf_free(puVar6);
  }
  if (5 < uVar10)
  {
    nVar5 = FUN_0000f928();
    return nVar5;
  }
  flash_read(uVar14 * 0x1000 + (uVar10 + 0x1a) * 0x2000, 4, (u8 *)asStack_30);
  if (asStack_30[0] != 0x7a7a)
  {
    nVar5 = FUNBBBBB();
    return nVar5;
  }
  uStack_64 = uVar14 * iStack_7c + iStack_6c + 4;
  iVar19 = (uVar10 + 0x1a) * 0x2000;
  iVar17 = (uVar10 + 0x37) * 0x2000;
  uVar22 = 0;
  puVar6 = (u8 *)0x0;
  bVar1 = true;
  do
  {
    uVar15 = uStack_68;
    if (4 < (int)uStack_68)
    {
      uVar15 = 4;
    }
    uVar15 = uVar15 & 0xff;
    flash_read(uStack_64, uVar15 * 8, (u8 *)&puStack_60);
    if (uVar15 != 0)
    {
      iVar9 = 0;
      ppuVar18 = &puStack_60;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar21 = 0;
      if (uVar10 < 6)
      {
        nVar5 = FUN_0000f778();
        return nVar5;
      }
      if (!bVar2)
      {
        nVar5 = FUN_0000f7c2();
        return nVar5;
      }
      if (uVar10 == 1)
      {
        nVar5 = FUN_0000f772();
        return nVar5;
      }
      if (puStack_60 != (u8 *)(uVar14 * 0x2000 + iVar17 + 0x200))
      {
        nVar5 = FUN_0000fa20();
        return nVar5;
      }
      if (5 < uVar10)
      {
        nVar5 = FUN_0000f780();
        return nVar5;
      }
      uVar22 = (uint)uStack_5c;
      puVar6 = puStack_60;
      bVar4 = bStack_59;
      if (((uVar14 + 1) * 0x1000 + iVar19) - (int)puStack_60 < uVar22)
      {
        nVar5 = FUN_0000fa20();
        return nVar5;
      }
      while (true)
      {
        iVar7 = bVar4 - 0x7b;
        bVar3 = (byte)iVar7;
        if (((iVar7 == 0) || (bVar4 == 0x5a)) &&
            ((*(u8 *)((int)ppuVar18 + 6) != itemId || (~uVar8 + uVar8 != 0))))
        {
          flash_read((u32)puVar6, 8, auStack_38);
          if (bStack_31 == 0x7a)
          {
            nVar5 = FUN_0000f8b0();
            return nVar5;
          }
          nVar5 = nv_write_item(~bVar3 + bVar3 + (0x79 < bStack_31), id, *(u8 *)((int)ppuVar18 + 6),
                                (u8)uVar11, uStack_26, *(short *)(&uStack_5a + iVar21 + -2) - 8,
                                *(u8 **)((int)&puStack_60 + iVar21), '\x01');
          if (nVar5 == NV_SUCC)
          {
            uStack_26 = uStack_26 + 1;
            nVar5 = FUN_0000f6c0();
            return nVar5;
          }
          if (nVar5 == NV_ITEM_CHECK_ERROR)
          {
            nVar5 = FUN_0000fa20();
            return nVar5;
          }
          if (nVar5 == NV_CHECK_SUM_ERROR)
          {
            nVar5 = FUN_0000f992();
            return nVar5;
          }
          if (nVar5 == NV_NOT_ENOUGH_SAPCE)
          {
            nVar5 = FUN_0000f992();
            return nVar5;
          }
        }
        iVar9 = iVar9 + 1;
        ppuVar18 = ppuVar18 + 2;
        if ((int)uVar15 <= iVar9)
          break;
      LAB_0000f6cc:
        iVar21 = iVar9 * 8;
        puVar16 = (&puStack_60)[iVar9 * 2];
        if (puVar16 != (u8 *)((uint)(puVar6 + uVar22 + 3) & 0xfffffffc))
        {
          nVar5 = FUN_0000fa20();
          return nVar5;
        }
        iVar7 = iVar19;
        if ((uVar10 < 6) || (iVar7 = iVar17, !bVar2))
        {
          iVar12 = 0x1000;
        }
        else
        {
          iVar12 = 0x2000;
        }
        uVar22 = (uint) * (ushort *)(&uStack_5a + iVar21 + -2);
        if ((iVar12 * (uVar14 + 1) + iVar7) - (int)puVar16 < uVar22)
        {
          nVar5 = FUN_0000fa20();
          return nVar5;
        }
        puVar6 = puVar16;
        bVar4 = *(byte *)((int)ppuVar18 + 7);
      }
      bVar1 = false;
    }
    uStack_68 = uStack_68 - uVar15;
    if ((int)uStack_68 < 1)
    {
      nVar5 = FUN_0000fa20();
      return nVar5;
    }
    uStack_64 = uStack_64 + uVar15 * 8;
  } while (true);
}

undefined4 FUN_0000f342(void)

{
  undefined4 unaff_r6;

  return unaff_r6;
}

// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000f398(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  uint unaff_r4;
  int iVar8;
  undefined4 *puVar9;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  int unaff_sl;
  uint uVar14;
  int in_stack_00000010;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (in_stack_00000010 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, uStack0000008e,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000f3ba(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  uint unaff_r4;
  int iVar8;
  undefined4 *puVar9;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  int unaff_sl;
  uint uVar14;
  int in_stack_00000010;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (in_stack_00000010 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, uStack0000008e,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000f3c2(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  uint unaff_r4;
  int iVar8;
  undefined4 *puVar9;
  int iVar10;
  u32 uVar11;
  int iVar12;
  u32 uVar13;
  int unaff_sl;
  uint uVar14;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int param_11;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 param_13;

  param_13 = 0;
  uVar4 = param_11 + 1U & 1;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, param_13,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            param_13 = param_13 + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}

void FUN_0000f582(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u32 len;
  int iVar5;
  int iVar6;
  int iVar7;
  u32 uVar8;
  uint unaff_r4;
  undefined4 *puVar9;
  int iVar10;
  int iVar11;
  u32 addr;
  uint uVar12;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint uStack00000028;
  u8 in_stack_0000002c;
  uint param_12;
  int param_13;
  int param_14;
  int param_15;
  int param_16;
  uint in_stack_0000004c;
  u32 param_17;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  param_17 = param_11 * param_14 + param_16 + 4;
  param_13 = (unaff_r4 + 0x1a) * 0x2000;
  iVar7 = (unaff_r4 + 0x37) * 0x2000;
  uVar12 = 0;
  addr = 0;
  param_15 = ~param_12 + param_12 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0);
  bVar1 = true;
  do
  {
    uStack00000028 = in_stack_0000004c;
    if (4 < (int)in_stack_0000004c)
    {
      uStack00000028 = 4;
    }
    uStack00000028 = uStack00000028 & 0xff;
    len = uStack00000028 * 8;
    flash_read(param_17, len, (u8 *)&stack0x00000054);
    if (uStack00000028 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar11 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != param_11 * 0x2000 + iVar7 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar12 = (uint)uStack00000058;
      addr = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((param_11 + 1) * 0x1000 + param_13) - in_stack_00000054 < uVar12)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 || (param_15 != 0))))
        {
          flash_read(addr, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar11) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar11), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        if ((int)uStack00000028 <= iVar10)
          break;
      LAB_0000f6cc:
        iVar11 = iVar10 * 8;
        uVar8 = (&stack0x00000054)[iVar10 * 2];
        if (uVar8 != (uVar12 + addr + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = param_13;
        if ((unaff_r4 < 6) || (iVar5 = iVar7, param_9 == 0))
        {
          iVar6 = 0x1000;
        }
        else
        {
          iVar6 = 0x2000;
        }
        uVar12 = (uint) * (ushort *)((int)&stack0x00000058 + iVar10 * 2 * 4);
        if ((iVar6 * (param_11 + 1) + iVar5) - uVar8 < uVar12)
        {
          FUN_0000fa20();
          return;
        }
        addr = uVar8;
        bVar3 = *(byte *)((int)puVar9 + 7);
      }
      bVar1 = false;
    }
    in_stack_0000004c = in_stack_0000004c - uStack00000028;
    if ((int)in_stack_0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    param_17 = param_17 + len;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)

void FUN_0000f67a(void)

{
  nv_sts_t nVar1;
  int iVar2;
  int iVar3;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  u32 uVar4;
  uint unaff_sl;
  uint unaff_fp;
  char in_tmpCY;
  int param_9;
  int param_10;
  int in_stack_00000018;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 param_11;
  int in_stack_00000034;
  int in_stack_00000038;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  while (true)
  {
    nVar1 = nv_write_item(~(byte)param_10 + (byte)param_10 + in_tmpCY, (u16)unaff_sl, unaff_r4[6],
                          param_11, in_stack_0000008c._2_2_, *(short *)(unaff_r7 + unaff_r8 + 4) - 8,
                          *(u8 **)(unaff_r7 + unaff_r8), '\x01');
    if (nVar1 == NV_SUCC)
    {
      in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
      FUN_0000f6c0();
      return;
    }
    if (nVar1 == NV_ITEM_CHECK_ERROR)
    {
      FUN_0000fa20();
      return;
    }
    if (nVar1 == NV_CHECK_SUM_ERROR)
    {
      FUN_0000f992();
      return;
    }
    uVar4 = unaff_r9;
    if (nVar1 == NV_NOT_ENOUGH_SAPCE)
      break;
    do
    {
      unaff_r6 = unaff_r6 + 1;
      unaff_r4 = unaff_r4 + 8;
      if ((int)in_stack_00000028 <= unaff_r6)
      {
        do
        {
          in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
          if ((int)in_stack_0000004c < 1)
          {
            FUN_0000fa20();
            return;
          }
          in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
          in_stack_00000028 = in_stack_0000004c;
          if (4 < (int)in_stack_0000004c)
          {
            in_stack_00000028 = 4;
          }
          in_stack_00000028 = in_stack_00000028 & 0xff;
          in_stack_00000048 = in_stack_00000028 << 3;
          flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
        } while (in_stack_00000028 == 0);
        unaff_r6 = 0;
        unaff_r4 = unaff_r7;
      }
      unaff_r8 = unaff_r6 * 8;
      unaff_r9 = *(u32 *)(unaff_r7 + unaff_r8);
      if (unaff_r9 != (unaff_fp + uVar4 + 3 & 0xfffffffc))
      {
        FUN_0000fa20();
        return;
      }
      iVar2 = in_stack_00000034;
      if ((unaff_sl < 6) || (iVar2 = in_stack_00000038, param_9 == 0))
      {
        iVar3 = 0x1000;
      }
      else
      {
        iVar3 = 0x2000;
      }
      unaff_fp = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
      if ((iVar3 * (in_stack_00000018 + 1) + iVar2) - unaff_r9 < unaff_fp)
      {
        FUN_0000fa20();
        return;
      }
      param_10 = unaff_r4[7] - 0x7b;
      uVar4 = unaff_r9;
    } while (((param_10 != 0) && (unaff_r4[7] != 0x5a)) ||
             ((unaff_r4[6] == in_stack_00000024 && (in_stack_0000003c == 0))));
    flash_read(unaff_r9, 8, &stack0x0000007c);
    in_tmpCY = 0x79 < in_stack_00000080._3_1_;
    if (in_stack_00000080._3_1_ == 0x7a)
    {
      FUN_0000f8b0();
      return;
    }
  }
  FUN_0000f992();
  return;
}

// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)

void FUN_0000f6c0(void)

{
  byte bVar1;
  nv_sts_t nVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  u32 addr;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  u32 unaff_r9;
  uint unaff_sl;
  uint unaff_fp;
  int param_9;
  int param_11;
  uint param_13;
  uint param_14;
  u8 in_stack_0000002c;
  int param_15;
  int param_16;
  int param_17;
  u32 param_18;
  uint param_19;
  u32 param_20;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  while (true)
  {
    do
    {
      unaff_r6 = unaff_r6 + 1;
      unaff_r4 = unaff_r4 + 8;
      if ((int)param_14 <= unaff_r6)
      {
        do
        {
          param_19 = param_19 - param_14;
          if ((int)param_19 < 1)
          {
            FUN_0000fa20();
            return;
          }
          param_20 = param_20 + param_18;
          param_14 = param_19;
          if (4 < (int)param_19)
          {
            param_14 = 4;
          }
          param_14 = param_14 & 0xff;
          param_18 = param_14 << 3;
          flash_read(param_20, param_18, unaff_r7);
        } while (param_14 == 0);
        unaff_r6 = 0;
        unaff_r4 = unaff_r7;
      }
      iVar4 = unaff_r6 * 8;
      addr = *(u32 *)(unaff_r7 + iVar4);
      if (addr != (unaff_fp + unaff_r9 + 3 & 0xfffffffc))
      {
        FUN_0000fa20();
        return;
      }
      iVar3 = param_15;
      if ((unaff_sl < 6) || (iVar3 = param_16, param_9 == 0))
      {
        iVar5 = 0x1000;
      }
      else
      {
        iVar5 = 0x2000;
      }
      unaff_fp = (uint) * (ushort *)(unaff_r7 + iVar4 + 4);
      if ((iVar5 * (param_11 + 1) + iVar3) - addr < unaff_fp)
      {
        FUN_0000fa20();
        return;
      }
      iVar3 = unaff_r4[7] - 0x7b;
      unaff_r9 = addr;
    } while (((iVar3 != 0) && (unaff_r4[7] != 0x5a)) ||
             ((unaff_r4[6] == param_13 && (param_17 == 0))));
    flash_read(addr, 8, &stack0x0000007c);
    if (in_stack_00000080._3_1_ == 0x7a)
    {
      FUN_0000f8b0();
      return;
    }
    bVar1 = (byte)iVar3;
    nVar2 = nv_write_item(~bVar1 + bVar1 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                          unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                          *(short *)(unaff_r7 + iVar4 + 4) - 8, *(u8 **)(unaff_r7 + iVar4), '\x01');
    if (nVar2 == NV_SUCC)
      break;
    if (nVar2 == NV_ITEM_CHECK_ERROR)
    {
      FUN_0000fa20();
      return;
    }
    if (nVar2 == NV_CHECK_SUM_ERROR)
    {
      FUN_0000f992();
      return;
    }
    if (nVar2 == NV_NOT_ENOUGH_SAPCE)
    {
      FUN_0000f992();
      return;
    }
  }
  in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
  FUN_0000f6c0();
  return;
}

// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

undefined4 FUN_0000f718(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  undefined4 uVar4;
  u8 *pBuf;
  uint uVar5;
  short sVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  int iVar10;
  undefined4 *puVar11;
  uint unaff_r4;
  int iVar12;
  u32 uVar13;
  int iVar14;
  int unaff_r8;
  u32 uVar15;
  uint uVar16;
  int unaff_sl;
  int param_9;
  int in_stack_0000001c;
  int param_12;
  uint in_stack_00000024;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  nv_sect_info_t in_stack_00000088;
  u16 uStack0000008e;

  if (0x1000 < param_12 + 0x408U)
  {
    return 4;
  }
  nVar3 = nv_sector_read((u16)unaff_r4, '\x02', &stack0x00000088);
  if (nVar3 != NV_SUCC)
  {
    uVar4 = FUN_0000f722();
    return uVar4;
  }
  uVar7 = (uint)in_stack_00000088.opSect;
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000f750();
    return uVar4;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar4 = FUN_0000fa02();
    return uVar4;
  }
  if (unaff_r8 == 0)
  {
    uVar4 = FUN_0000f7d2();
    return uVar4;
  }
  uStack0000008e = 0;
  uVar5 = uVar7 + 1 & 1;
  if (param_9 != 0)
  {
    uVar4 = FUN_0000fa06();
    return uVar4;
  }
  uVar13 = uVar5 * 0x1000 + unaff_sl;
  iVar12 = 0;
  do
  {
    flash_erase(uVar13);
    uVar13 = uVar13 + 0x1000;
    iVar12 = iVar12 + 1;
  } while (iVar12 < 1);
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000f940();
    return uVar4;
  }
  if (in_stack_0000001c != 0)
  {
    uVar4 = FUN_0000f93a();
    return uVar4;
  }
  if (unaff_r4 == 1)
  {
    uVar4 = FUN_0000f97a();
    return uVar4;
  }
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000fa2a();
    return uVar4;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    uVar4 = FUN_0000f952();
    return uVar4;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000fa24();
    return uVar4;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar12 = 0x3e0000;
    uVar13 = uVar7 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar6 = 0;
    do
    {
      flash_read(uVar13, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar14 = (int)sVar6;
        if (iVar14 != 0)
        {
          bVar1 = true;
          iVar10 = 0;
          while (true)
          {
            if (pBuf[iVar10] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, in_stack_00000088.opSect,
                                   (u16)((uint)iVar12 >> 0x10));
              bVar1 = false;
            }
            if (iVar14 <= iVar10 + 1)
              break;
            iVar10 = iVar10 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar14] = in_stack_00000078._2_1_;
        sVar6 = sVar6 + 1;
      }
    LAB_0000f530:
      iVar12 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar13 = uVar13 - 9;
    } while (-1 < iVar12);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    uVar4 = FUN_0000f928();
    return uVar4;
  }
  flash_read(uVar7 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    uVar4 = FUNBBBBB();
    return uVar4;
  }
  uStack00000050 = uVar7 * 0x1000 + iStack00000048 + 4;
  uVar16 = 0;
  uVar13 = 0;
  bVar1 = true;
  do
  {
    uVar8 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar8 = 4;
    }
    uVar8 = uVar8 & 0xff;
    flash_read(uStack00000050, uVar8 * 8, (u8 *)&stack0x00000054);
    if (uVar8 != 0)
    {
      iVar12 = 0;
      puVar11 = &stack0x00000054;
      uVar15 = uVar13;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          uVar4 = FUN_0000f778();
          return uVar4;
        }
        uVar4 = FUN_0000f7c2();
        return uVar4;
      }
      do
      {
        uVar13 = (&stack0x00000054)[iVar12 * 2];
        if (uVar13 != (uVar16 + uVar15 + 3 & 0xfffffffc))
        {
          uVar4 = FUN_0000fa20();
          return uVar4;
        }
        uVar9 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar9 = unaff_r4 + 0x1a;
        }
        uVar16 = (uint)(ushort)(&stack0x00000058)[iVar12 * 4];
        if (((uVar7 + 1) * 0x1000 + uVar9 * 0x2000) - uVar13 < uVar16)
        {
          uVar4 = FUN_0000fa20();
          return uVar4;
        }
        iVar14 = *(byte *)((int)puVar11 + 7) - 0x7b;
        if (((iVar14 == 0) || (*(byte *)((int)puVar11 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar11 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar13, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            uVar4 = FUN_0000f8b0();
            return uVar4;
          }
          bVar2 = (byte)iVar14;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar11 + 6), (u8)uVar5, uStack0000008e,
                                (&stack0x00000058)[iVar12 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar12 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            uVar4 = FUN_0000f6c0();
            return uVar4;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            uVar4 = FUN_0000fa20();
            return uVar4;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            uVar4 = FUN_0000f992();
            return uVar4;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            uVar4 = FUN_0000f992();
            return uVar4;
          }
        }
        iVar12 = iVar12 + 1;
        puVar11 = puVar11 + 2;
        uVar15 = uVar13;
      } while (iVar12 < (int)uVar8);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar8;
    if ((int)uStack0000004c < 1)
    {
      uVar4 = FUN_0000fa20();
      return uVar4;
    }
    uStack00000050 = uStack00000050 + uVar8 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000f722(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  short sVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  undefined4 *puVar8;
  uint unaff_r4;
  int iVar9;
  u32 uVar10;
  int iVar11;
  int unaff_r8;
  u32 uVar12;
  uint uVar13;
  u32 unaff_sl;
  byte in_tmpCY;
  uint param_9;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  uVar10 = unaff_sl;
  for (iVar9 = 0; iVar9 < (int)(2 - (~param_9 + param_9 + (uint)in_tmpCY)); iVar9 = iVar9 + 1)
  {
    flash_erase(uVar10);
    uVar10 = uVar10 + 0x1000;
  }
  if (unaff_r4 < 6)
  {
    FUN_0000f398();
    return;
  }
  if (param_9 == 0)
  {
    FUN_0000f996();
    return;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar10 = unaff_sl + 0x1000;
  iVar9 = 0;
  do
  {
    flash_erase(uVar10);
    uVar10 = uVar10 + 0x1000;
    iVar9 = iVar9 + 1;
  } while (iVar9 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar13 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar9 = 0x3e0000;
    uVar10 = (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar4 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar11 = (int)sVar4;
        if (iVar11 != 0)
        {
          bVar1 = true;
          iVar7 = 0;
          while (true)
          {
            if (pBuf[iVar7] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, '\0', (u16)((uint)iVar9 >> 0x10));
              bVar1 = false;
            }
            if (iVar11 <= iVar7 + 1)
              break;
            iVar7 = iVar7 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar11] = in_stack_00000078._2_1_;
        sVar4 = sVar4 + 1;
      }
    LAB_0000f530:
      iVar9 = (uVar13 - 2) * 0x10000;
      uVar13 = uVar13 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar9);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read((unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = iStack00000048 + 4;
  uVar13 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar5 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar5 = 4;
    }
    uVar5 = uVar5 & 0xff;
    flash_read(uStack00000050, uVar5 * 8, (u8 *)&stack0x00000054);
    if (uVar5 != 0)
    {
      iVar9 = 0;
      puVar8 = &stack0x00000054;
      uVar12 = uVar10;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar10 = (&stack0x00000054)[iVar9 * 2];
        if (uVar10 != (uVar13 + uVar12 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar6 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar6 = unaff_r4 + 0x1a;
        }
        uVar13 = (uint)(ushort)(&stack0x00000058)[iVar9 * 4];
        if ((uVar6 * 0x2000 + 0x1000) - uVar10 < uVar13)
        {
          FUN_0000fa20();
          return;
        }
        iVar11 = *(byte *)((int)puVar8 + 7) - 0x7b;
        if (((iVar11 == 0) || (*(byte *)((int)puVar8 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar8 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar11;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar8 + 6), '\x01', uStack0000008e,
                                (&stack0x00000058)[iVar9 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar9 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar9 = iVar9 + 1;
        puVar8 = puVar8 + 2;
        uVar12 = uVar10;
      } while (iVar9 < (int)uVar5);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar5;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar5 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000f750(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined4 *puVar9;
  uint unaff_r4;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  uint uVar14;
  int unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 uStack0000008e;

  if (param_9 == 0)
  {
    FUN_0000f996();
    return;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  uStack0000008e = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, uStack0000008e,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

undefined4 FUN_0000f764(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  undefined4 uVar5;
  u8 *pBuf;
  int iVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  short sVar10;
  uint uVar11;
  uint uVar12;
  u32 uVar13;
  int iVar14;
  undefined4 *puVar15;
  uint unaff_r4;
  int iVar16;
  u32 uVar17;
  int iVar18;
  int unaff_r8;
  uint uVar19;
  int unaff_sl;
  int param_9;
  int in_stack_0000001c;
  int in_stack_00000020;
  uint in_stack_00000024;
  uint in_stack_00000030;
  int iStack00000038;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  nv_sect_info_t in_stack_00000088;
  u16 uStack0000008e;

  param_9 = 0;
  if (0x1000 < in_stack_00000020 + 0x408U)
  {
    return 4;
  }
  nVar4 = nv_sector_read((u16)unaff_r4, '\x02', &stack0x00000088);
  if (nVar4 != NV_SUCC)
  {
    uVar5 = FUN_0000f722();
    return uVar5;
  }
  uVar11 = (uint)in_stack_00000088.opSect;
  if (5 < unaff_r4)
  {
    uVar5 = FUN_0000f750();
    return uVar5;
  }
  uStack0000008e = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar5 = FUN_0000fa02();
    return uVar5;
  }
  if (unaff_r8 == 0)
  {
    uVar5 = FUN_0000f7d2();
    return uVar5;
  }
  uStack0000008e = 0;
  uVar8 = uVar11 + 1 & 1;
  if (param_9 != 0)
  {
    uVar5 = FUN_0000fa06();
    return uVar5;
  }
  uVar17 = uVar8 * 0x1000 + unaff_sl;
  iVar16 = 0;
  do
  {
    flash_erase(uVar17);
    uVar17 = uVar17 + 0x1000;
    iVar16 = iVar16 + 1;
  } while (iVar16 < 1);
  if (5 < unaff_r4)
  {
    uVar5 = FUN_0000f940();
    return uVar5;
  }
  if (in_stack_0000001c != 0)
  {
    uVar5 = FUN_0000f93a();
    return uVar5;
  }
  if (unaff_r4 == 1)
  {
    uVar5 = FUN_0000f97a();
    return uVar5;
  }
  if (unaff_r4 < 6)
  {
    iStack00000048 = unaff_r4 + 0x1a;
    iStack00000038 = 0x1000;
  }
  else
  {
    iStack00000048 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      uVar5 = FUN_0000fa2a();
      return uVar5;
    }
    iStack00000038 = 0x2000;
  }
  iStack00000048 = iStack00000048 * 0x2000;
  if (unaff_r4 == 1)
  {
    uVar5 = FUN_0000f952();
    return uVar5;
  }
  uVar19 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar16 = unaff_r4 + 0x1a;
    iVar14 = 0x1000;
  }
  else
  {
    iVar16 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      uVar5 = FUN_0000fa24();
      return uVar5;
    }
    iVar14 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar7 = 0x3e0000;
    uVar17 = iVar14 * uVar11 + iVar16 * 0x2000 + 500;
    sVar10 = 0;
    do
    {
      flash_read(uVar17, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar16 = (int)sVar10;
        if (iVar16 != 0)
        {
          bVar1 = true;
          iVar14 = 0;
          while (true)
          {
            if (pBuf[iVar14] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, in_stack_00000088.opSect,
                                   (u16)((uint)iVar7 >> 0x10));
              bVar1 = false;
            }
            if (iVar16 <= iVar14 + 1)
              break;
            iVar14 = iVar14 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar16] = in_stack_00000078._2_1_;
        sVar10 = sVar10 + 1;
      }
    LAB_0000f530:
      iVar7 = (uVar19 - 2) * 0x10000;
      uVar19 = uVar19 - 2 & 0xffff;
      uVar17 = uVar17 - 9;
    } while (-1 < iVar7);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    uVar5 = FUN_0000f928();
    return uVar5;
  }
  flash_read(uVar11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    uVar5 = FUNBBBBB();
    return uVar5;
  }
  uStack00000050 = uVar11 * iStack00000038 + iStack00000048 + 4;
  iVar16 = (unaff_r4 + 0x1a) * 0x2000;
  iVar14 = (unaff_r4 + 0x37) * 0x2000;
  uVar19 = 0;
  uVar17 = 0;
  bVar1 = true;
  do
  {
    uVar12 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar12 = 4;
    }
    uVar12 = uVar12 & 0xff;
    flash_read(uStack00000050, uVar12 * 8, (u8 *)&stack0x00000054);
    if (uVar12 != 0)
    {
      iVar7 = 0;
      puVar15 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar18 = 0;
      if (unaff_r4 < 6)
      {
        uVar5 = FUN_0000f778();
        return uVar5;
      }
      if (param_9 == 0)
      {
        uVar5 = FUN_0000f7c2();
        return uVar5;
      }
      if (unaff_r4 == 1)
      {
        uVar5 = FUN_0000f772();
        return uVar5;
      }
      if (in_stack_00000054 != uVar11 * 0x2000 + iVar14 + 0x200)
      {
        uVar5 = FUN_0000fa20();
        return uVar5;
      }
      if (5 < unaff_r4)
      {
        uVar5 = FUN_0000f780();
        return uVar5;
      }
      uVar19 = (uint)uStack00000058;
      uVar17 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((uVar11 + 1) * 0x1000 + iVar16) - in_stack_00000054 < uVar19)
      {
        uVar5 = FUN_0000fa20();
        return uVar5;
      }
      while (true)
      {
        iVar6 = bVar3 - 0x7b;
        bVar2 = (byte)iVar6;
        if (((iVar6 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar15 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar17, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            uVar5 = FUN_0000f8b0();
            return uVar5;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar15 + 6), (u8)uVar8, uStack0000008e,
                                *(short *)((int)&stack0x00000058 + iVar18) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar18), '\x01');
          if (nVar4 == NV_SUCC)
          {
            uStack0000008e = uStack0000008e + 1;
            uVar5 = FUN_0000f6c0();
            return uVar5;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            uVar5 = FUN_0000fa20();
            return uVar5;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            uVar5 = FUN_0000f992();
            return uVar5;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            uVar5 = FUN_0000f992();
            return uVar5;
          }
        }
        iVar7 = iVar7 + 1;
        puVar15 = puVar15 + 2;
        if ((int)uVar12 <= iVar7)
          break;
      LAB_0000f6cc:
        iVar18 = iVar7 * 8;
        uVar13 = (&stack0x00000054)[iVar7 * 2];
        if (uVar13 != (uVar19 + uVar17 + 3 & 0xfffffffc))
        {
          uVar5 = FUN_0000fa20();
          return uVar5;
        }
        iVar6 = iVar16;
        if ((unaff_r4 < 6) || (iVar6 = iVar14, param_9 == 0))
        {
          iVar9 = 0x1000;
        }
        else
        {
          iVar9 = 0x2000;
        }
        uVar19 = (uint) * (ushort *)((int)&stack0x00000058 + iVar7 * 2 * 4);
        if ((iVar9 * (uVar11 + 1) + iVar6) - uVar13 < uVar19)
        {
          uVar5 = FUN_0000fa20();
          return uVar5;
        }
        uVar17 = uVar13;
        bVar3 = *(byte *)((int)puVar15 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar12;
    if ((int)uStack0000004c < 1)
    {
      uVar5 = FUN_0000fa20();
      return uVar5;
    }
    uStack00000050 = uStack00000050 + uVar12 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)

void FUN_0000f772(undefined4 param_1, undefined4 param_2, int param_3)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  u32 uVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int in_stack_00000010;
  int in_stack_00000018;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int in_stack_00000034;
  int in_stack_00000038;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (unaff_r9 != param_3 + 0x400U)
  {
    FUN_0000fa20();
    return;
  }
  if (5 < unaff_sl)
  {
    FUN_0000f780();
    return;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if (((in_stack_00000018 + 1) * 0x1000 + in_stack_00000034) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar5 = bVar1 - 0x7b;
    bVar2 = (byte)iVar5;
    if (((iVar5 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar7 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar7 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar5 = in_stack_00000034;
    if ((unaff_sl < 6) || (iVar5 = in_stack_00000038, in_stack_00000010 == 0))
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar6 * (in_stack_00000018 + 1) + iVar5) - uVar7 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar7;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)

void FUN_0000f778(void)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  u32 uVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int param_11;
  int in_stack_00000038;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (in_stack_0000001c != 0)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_sl == 1)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_r9 != in_stack_00000018 * 0x1000 + param_11 + 0x200U)
  {
    FUN_0000fa20();
    return;
  }
  if (5 < unaff_sl)
  {
    FUN_0000f780();
    return;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if (((in_stack_00000018 + 1) * 0x1000 + param_11) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar5 = bVar1 - 0x7b;
    bVar2 = (byte)iVar5;
    if (((iVar5 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar7 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar7 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar5 = param_11;
    if ((unaff_sl < 6) || (iVar5 = in_stack_00000038, param_9 == 0))
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar6 * (in_stack_00000018 + 1) + iVar5) - uVar7 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar7;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)

void FUN_0000f780(void)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  u32 uVar6;
  int iVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int param_9;
  int param_11;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int in_stack_00000034;
  int param_12;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (param_9 == 0)
  {
    iVar7 = 0x1000;
  }
  else
  {
    iVar7 = 0x2000;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if ((iVar7 * (param_11 + 1) + param_12) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar7 = bVar1 - 0x7b;
    bVar2 = (byte)iVar7;
    if (((iVar7 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar6 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar6 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar7 = in_stack_00000034;
    if ((unaff_sl < 6) || (iVar7 = param_12, param_9 == 0))
    {
      iVar5 = 0x1000;
    }
    else
    {
      iVar5 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar5 * (param_11 + 1) + iVar7) - uVar6 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar6;
  } while (true);
}

void FUN_0000f7a4(void)

{
  bool bVar1;
  byte bVar2;
  buf_sts_t bVar3;
  nv_sts_t nVar4;
  int iVar5;
  int iVar6;
  u8 uVar7;
  uint uVar8;
  u32 uVar9;
  uint uVar10;
  int iVar11;
  undefined4 *puVar12;
  u8 *unaff_r5;
  int iVar13;
  u8 *unaff_r6;
  int iVar14;
  int iVar15;
  uint unaff_r8;
  u32 addr;
  u32 unaff_r9;
  uint unaff_sl;
  int unaff_fp;
  int param_9;
  int param_10;
  int param_11;
  int in_stack_0000001c;
  uint param_12;
  uint param_13;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  u8 param_14;
  int in_stack_00000038;
  int param_15;
  int in_stack_00000048;
  uint in_stack_0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

code_r0x0000f7a4:
  uVar10 = (uint)unaff_r6[6];
  do
  {
    uVar7 = (u8)uVar10;
    param_10 = param_13 << 0x10;
    iVar14 = param_10 >> 0x10;
    if (iVar14 == 0)
    {
    LAB_0000f520:
      unaff_r5[param_10 >> 0x10] = uVar7;
      param_13 = param_13 + 1 & 0xffff;
    }
    else
    {
      bVar1 = true;
      iVar11 = 0;
      while (true)
      {
        if (unaff_r5[iVar11] == uVar10)
        {
          nv_itemDeleteByIndex(param_14, (u8)param_12, (u8)param_11, (u16)((uint)unaff_fp >> 0x10));
          bVar1 = false;
        }
        if (iVar14 <= iVar11 + 1)
          break;
        iVar11 = iVar11 + 1;
        uVar10 = (uint)unaff_r6[6];
      }
      if (bVar1)
      {
        uVar7 = unaff_r6[6];
        goto LAB_0000f520;
      }
    }
    do
    {
      do
      {
        unaff_fp = (unaff_sl - 2) * 0x10000;
        unaff_sl = unaff_sl - 2 & 0xffff;
        unaff_r9 = unaff_r9 - 9;
        if (unaff_fp < 0)
        {
          bVar3 = ev_buf_free(unaff_r5);
          if (5 < unaff_r8)
          {
            FUN_0000f928(bVar3);
            return;
          }
          flash_read(param_11 * 0x1000 + (unaff_r8 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
          if (in_stack_00000084 != 0x7a7a)
          {
            FUNBBBBB();
            return;
          }
          uStack00000050 = param_11 * in_stack_00000038 + in_stack_00000048 + 4;
          iVar14 = (unaff_r8 + 0x1a) * 0x2000;
          iVar11 = (unaff_r8 + 0x37) * 0x2000;
          uVar10 = 0;
          addr = 0;
          bVar1 = true;
          do
          {
            uVar8 = in_stack_0000004c;
            if (4 < (int)in_stack_0000004c)
            {
              uVar8 = 4;
            }
            uVar8 = uVar8 & 0xff;
            flash_read(uStack00000050, uVar8 * 8, (u8 *)&stack0x00000054);
            if (uVar8 != 0)
            {
              iVar13 = 0;
              puVar12 = &stack0x00000054;
              if (!bVar1)
                goto LAB_0000f6cc;
              iVar15 = 0;
              if (unaff_r8 < 6)
              {
                FUN_0000f778();
                return;
              }
              if (param_9 == 0)
              {
                FUN_0000f7c2();
                return;
              }
              if (in_stack_0000001c != 0)
              {
                FUN_0000f772();
                return;
              }
              if (unaff_r8 == 1)
              {
                FUN_0000f772();
                return;
              }
              if (in_stack_00000054 != param_11 * 0x2000 + iVar11 + 0x200U)
              {
                FUN_0000fa20();
                return;
              }
              if (5 < unaff_r8)
              {
                FUN_0000f780();
                return;
              }
              uVar10 = (uint)uStack00000058;
              addr = in_stack_00000054;
              bVar2 = bStack0000005b;
              if (((param_11 + 1) * 0x1000 + iVar14) - in_stack_00000054 < uVar10)
              {
                FUN_0000fa20();
                return;
              }
              while (true)
              {
                param_10 = bVar2 - 0x7b;
                if (((param_10 == 0) || (bVar2 == 0x5a)) &&
                    ((*(byte *)((int)puVar12 + 6) != param_12 ||
                      (~in_stack_00000030 + in_stack_00000030 +
                           (uint)((unaff_r8 + 0x37 >> 0x13 & 1) != 0) !=
                       0))))
                {
                  flash_read(addr, 8, &stack0x0000007c);
                  if (in_stack_00000080._3_1_ == 0x7a)
                  {
                    FUN_0000f8b0();
                    return;
                  }
                  nVar4 = nv_write_item(~(byte)param_10 + (byte)param_10 +
                                            (0x79 < in_stack_00000080._3_1_),
                                        (u16)unaff_r8,
                                        *(u8 *)((int)puVar12 + 6), in_stack_0000002c,
                                        in_stack_0000008c._2_2_,
                                        *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                        *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
                  if (nVar4 == NV_SUCC)
                  {
                    in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
                    FUN_0000f6c0();
                    return;
                  }
                  if (nVar4 == NV_ITEM_CHECK_ERROR)
                  {
                    FUN_0000fa20();
                    return;
                  }
                  if (nVar4 == NV_CHECK_SUM_ERROR)
                  {
                    FUN_0000f992();
                    return;
                  }
                  if (nVar4 == NV_NOT_ENOUGH_SAPCE)
                  {
                    FUN_0000f992();
                    return;
                  }
                }
                iVar13 = iVar13 + 1;
                puVar12 = puVar12 + 2;
                if ((int)uVar8 <= iVar13)
                  break;
              LAB_0000f6cc:
                iVar15 = iVar13 * 8;
                uVar9 = (&stack0x00000054)[iVar13 * 2];
                if (uVar9 != (uVar10 + addr + 3 & 0xfffffffc))
                {
                  FUN_0000fa20();
                  return;
                }
                iVar5 = iVar14;
                if ((unaff_r8 < 6) || (iVar5 = iVar11, param_9 == 0))
                {
                  iVar6 = 0x1000;
                }
                else
                {
                  iVar6 = 0x2000;
                }
                uVar10 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
                if ((iVar6 * (param_11 + 1) + iVar5) - uVar9 < uVar10)
                {
                  FUN_0000fa20();
                  return;
                }
                addr = uVar9;
                bVar2 = *(byte *)((int)puVar12 + 7);
              }
              bVar1 = false;
            }
            in_stack_0000004c = in_stack_0000004c - uVar8;
            if ((int)in_stack_0000004c < 1)
            {
              FUN_0000fa20();
              return;
            }
            uStack00000050 = uStack00000050 + uVar8 * 8;
          } while (true);
        }
        flash_read(unaff_r9, 8, unaff_r6);
        uVar7 = unaff_r6[7];
      } while ((uVar7 != 'z') && (uVar7 != 'Z'));
      if (uVar7 == 'z')
        goto code_r0x0000f7a4;
      uVar10 = (uint)unaff_r6[6];
    } while ((unaff_r8 != uVar10) || (param_15 == 0));
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)

void FUN_0000f7c2(void)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  u32 uVar7;
  u8 *unaff_r4;
  int unaff_r6;
  u8 *unaff_r7;
  int unaff_r8;
  u32 unaff_r9;
  uint unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  uint in_stack_00000028;
  u8 in_stack_0000002c;
  int in_stack_00000034;
  int param_11;
  int in_stack_0000003c;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined4 in_stack_0000008c;

  if (in_stack_0000001c != 0)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_sl == 1)
  {
    FUN_0000f772();
    return;
  }
  if (unaff_r9 != in_stack_00000018 * 0x1000 + param_11 + 0x200U)
  {
    FUN_0000fa20();
    return;
  }
  if (5 < unaff_sl)
  {
    FUN_0000f780();
    return;
  }
  uVar4 = (uint) * (ushort *)(unaff_r7 + 4);
  if (((in_stack_00000018 + 1) * 0x1000 + in_stack_00000034) - unaff_r9 < uVar4)
  {
    FUN_0000fa20();
    return;
  }
  bVar1 = unaff_r4[7];
  do
  {
    iVar5 = bVar1 - 0x7b;
    bVar2 = (byte)iVar5;
    if (((iVar5 == 0) || (bVar1 == 0x5a)) &&
        ((unaff_r4[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
    {
      flash_read(unaff_r9, 8, &stack0x0000007c);
      if (in_stack_00000080._3_1_ == 0x7a)
      {
        FUN_0000f8b0();
        return;
      }
      nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                            unaff_r4[6], in_stack_0000002c, in_stack_0000008c._2_2_,
                            *(short *)(unaff_r7 + unaff_r8 + 4) - 8, *(u8 **)(unaff_r7 + unaff_r8),
                            '\x01');
      if (nVar3 == NV_SUCC)
      {
        in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
        FUN_0000f6c0();
        return;
      }
      if (nVar3 == NV_ITEM_CHECK_ERROR)
      {
        FUN_0000fa20();
        return;
      }
      if (nVar3 == NV_CHECK_SUM_ERROR)
      {
        FUN_0000f992();
        return;
      }
      if (nVar3 == NV_NOT_ENOUGH_SAPCE)
      {
        FUN_0000f992();
        return;
      }
    }
    unaff_r6 = unaff_r6 + 1;
    unaff_r4 = unaff_r4 + 8;
    if ((int)in_stack_00000028 <= unaff_r6)
    {
      do
      {
        in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
        if ((int)in_stack_0000004c < 1)
        {
          FUN_0000fa20();
          return;
        }
        in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
        in_stack_00000028 = in_stack_0000004c;
        if (4 < (int)in_stack_0000004c)
        {
          in_stack_00000028 = 4;
        }
        in_stack_00000028 = in_stack_00000028 & 0xff;
        in_stack_00000048 = in_stack_00000028 << 3;
        flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
      } while (in_stack_00000028 == 0);
      unaff_r6 = 0;
      unaff_r4 = unaff_r7;
    }
    unaff_r8 = unaff_r6 * 8;
    uVar7 = *(u32 *)(unaff_r7 + unaff_r8);
    if (uVar7 != (uVar4 + unaff_r9 + 3 & 0xfffffffc))
    {
      FUN_0000fa20();
      return;
    }
    iVar5 = in_stack_00000034;
    if ((unaff_sl < 6) || (iVar5 = param_11, param_9 == 0))
    {
      iVar6 = 0x1000;
    }
    else
    {
      iVar6 = 0x2000;
    }
    uVar4 = (uint) * (ushort *)(unaff_r7 + unaff_r8 + 4);
    if ((iVar6 * (in_stack_00000018 + 1) + iVar5) - uVar7 < uVar4)
    {
      FUN_0000fa20();
      return;
    }
    bVar1 = unaff_r4[7];
    unaff_r9 = uVar7;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f856)
// WARNING: Removing unreachable block (RAM,0x0000f84e)

uint FUN_0000f7d2(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  u32 unaff_r6;
  int param_11;
  int in_stack_0000001c;
  u16 param_12;
  u8 in_stack_00000024;
  byte in_stack_0000002c;
  int in_stack_00000030;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined2 uStack0000008c;
  u16 uStack0000008e;
  u8 *in_stack_000000b8;

  nVar1 = nv_index_read((u16)unaff_r4, 0xff, param_12, (u8)param_11, unaff_r6,
                        (u16 *)((int)&stack0x0000008c + 2));
  if (nVar1 == NV_SUCC)
  {
    uVar2 = FUN_0000fa42();
    return uVar2;
  }
  uStack0000008c = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa3e();
    return uVar2;
  }
  if (in_stack_00000030 != 0)
  {
    uVar2 = FUN_0000f9ae();
    return uVar2;
  }
  nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, (u8)param_11, uStack0000008e, param_12,
                        in_stack_000000b8, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (uStack0000008e == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}

// WARNING: Removing unreachable block (RAM,0x0000f856)
// WARNING: Removing unreachable block (RAM,0x0000f84e)

uint FUN_0000f7ec(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  int param_11;
  int in_stack_0000001c;
  u16 in_stack_00000020;
  u8 in_stack_00000024;
  byte in_stack_0000002c;
  int in_stack_00000030;
  int param_12;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined2 uStack0000008c;
  u16 uStack0000008e;
  u8 *in_stack_000000b8;

  param_12 = param_11;
  uStack0000008c = 0;
  if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa3e();
    return uVar2;
  }
  if (in_stack_00000030 != 0)
  {
    uVar2 = FUN_0000f9ae();
    return uVar2;
  }
  nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, (u8)param_11, uStack0000008e,
                        in_stack_00000020, in_stack_000000b8, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (uStack0000008e == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(param_12 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}

// WARNING: Removing unreachable block (RAM,0x0000f84e)

uint FUN_0000f80a(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  int unaff_r8;
  u16 in_stack_00000020;
  u8 in_stack_00000024;
  byte in_stack_0000002c;
  int param_11;
  int in_stack_00000040;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined4 in_stack_0000008c;
  u8 *in_stack_000000b8;

  if (param_11 != 0)
  {
    uVar2 = FUN_0000f9ae();
    return uVar2;
  }
  nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, (u8)in_stack_00000040,
                        in_stack_0000008c._2_2_, in_stack_00000020, in_stack_000000b8, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (unaff_r8 != 0)
    {
      uVar2 = FUN_0000fb1e();
      return uVar2;
    }
    if (in_stack_0000008c._2_2_ == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(in_stack_00000040 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}

uint FUN_0000f814(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  uint unaff_r4;
  int unaff_r7;
  int unaff_r8;
  u16 param_11;
  u8 param_12;
  byte in_stack_0000002c;
  u8 param_13;
  int param_14;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined4 in_stack_0000008c;
  u8 *param_16;

  nVar1 = nv_write_item(param_13, (u16)unaff_r4, param_12, (u8)param_14, in_stack_0000008c._2_2_,
                        param_11, param_16, '\0');
  if (nVar1 == 0)
  {
    if (5 < unaff_r4)
    {
      uVar2 = FUN_0000f99c();
      return uVar2;
    }
    if (unaff_r7 != 0)
    {
      uVar2 = FUN_0000f9c4();
      return uVar2;
    }
    if (unaff_r8 != 0)
    {
      uVar2 = FUN_0000fb1e();
      return uVar2;
    }
    if (in_stack_0000008c._2_2_ == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar2 = FUN_0000fc04();
        return uVar2;
      }
      flash_writeWithCheck(param_14 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
  }
  return (uint)nVar1;
}

undefined4 FUN_0000f850(void)

{
  undefined4 uVar1;
  uint uVar2;
  uint unaff_r4;
  undefined4 unaff_r6;
  int unaff_r8;
  byte param_11;
  int in_stack_00000040;
  undefined2 param_12;
  uchar param_13;
  byte param_14;
  undefined4 in_stack_0000008c;

  if (unaff_r8 != 0)
  {
    uVar1 = FUN_0000fb1e();
    return uVar1;
  }
  if (in_stack_0000008c._2_2_ == 0)
  {
    param_13 = (uchar)unaff_r4;
    param_12 = 0x7a7a;
    param_14 = param_11;
    uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
    param_14 = param_14 | (byte)(uVar2 << 2);
    if (5 < unaff_r4)
    {
      uVar1 = FUN_0000fc04();
      return uVar1;
    }
    flash_writeWithCheck(in_stack_00000040 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
  }
  return unaff_r6;
}

void FUN_0000f8b0(void)

{
  uint uVar1;
  uchar *unaff_r4;
  uint param_11;

  uVar1 = xcrc32(unaff_r4, 7, 0xfffffffe);
  if ((uVar1 & 0xffff) != param_11 >> 0x10)
  {
    FUN_0000f6c0();
    return;
  }
  FUN_0000f67a();
  return;
}

// WARNING: Removing unreachable block (RAM,0x0000f858)
// WARNING: Removing unreachable block (RAM,0x0000f864)
// WARNING: Removing unreachable block (RAM,0x0000f896)
// WARNING: Removing unreachable block (RAM,0x0000f898)
// WARNING: Removing unreachable block (RAM,0x0000f862)
// WARNING: Removing unreachable block (RAM,0x0000f84e)
// WARNING: Unknown calling convention -- yet parameter storage is locked

uint FUNBBBBB(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  int iVar3;
  u16 uVar4;
  int in_r3;
  int iVar5;
  uint unaff_r4;
  int in_stack_00000010;
  int in_stack_0000001c;
  int in_stack_00000020;
  u8 in_stack_00000024;
  int in_stack_0000002c;
  int in_stack_00000030;
  u8 in_stack_00000040;
  int in_stack_00000044;
  undefined2 uStack0000008c;
  u16 in_stack_0000008e;
  u8 *in_stack_000000b8;

  if (in_r3 == 0x5a5a)
  {
    uVar2 = FUN_0000f582();
    return uVar2;
  }
  uVar4 = 0x7f;
  if ((in_stack_0000001c == 0) && (uVar4 = 0x3f, unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa1c();
    return uVar2;
  }
  uVar2 = 4;
  if (uVar4 != in_stack_0000008e)
  {
    if (unaff_r4 < 6)
    {
      iVar3 = (unaff_r4 + 0x1a) * 0x2000;
      iVar5 = 0x1000;
    }
    else
    {
      iVar3 = (unaff_r4 + 0x37) * 0x2000;
      if (in_stack_00000010 == 0)
      {
        iVar5 = 0x1000;
      }
      else
      {
        iVar5 = 0x2000;
      }
    }
    uVar2 = 4;
    if ((uint)(in_stack_00000020 + 8 + in_stack_00000044) <=
        (uint)(iVar5 * (in_stack_0000002c + 1) + iVar3))
    {
      uStack0000008c = 0;
      if ((in_stack_0000001c == 0) && (unaff_r4 == 1))
      {
        uVar2 = FUN_0000fa3e();
        return uVar2;
      }
      if (in_stack_00000030 != 0)
      {
        uVar2 = FUN_0000f9ae();
        return uVar2;
      }
      nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, in_stack_00000040, in_stack_0000008e, (u16)in_stack_00000020, in_stack_000000b8, '\0');
      uVar2 = (uint)nVar1;
      if (nVar1 == 0)
      {
        if (5 < unaff_r4)
        {
          uVar2 = FUN_0000f99c();
          return uVar2;
        }
        uVar2 = FUN_0000fb1e();
        return uVar2;
      }
    }
  }
  return uVar2;
}

// WARNING: Removing unreachable block (RAM,0x0000f858)
// WARNING: Removing unreachable block (RAM,0x0000f864)
// WARNING: Removing unreachable block (RAM,0x0000f896)
// WARNING: Removing unreachable block (RAM,0x0000f898)
// WARNING: Removing unreachable block (RAM,0x0000f862)
// WARNING: Removing unreachable block (RAM,0x0000f84e)

uint FUN_0000f8de(void)

{
  nv_sts_t nVar1;
  uint uVar2;
  int iVar3;
  u16 uVar4;
  int iVar5;
  uint unaff_r4;
  int param_9;
  int param_11;
  int in_stack_00000020;
  u8 in_stack_00000024;
  int in_stack_0000002c;
  int in_stack_00000030;
  u8 in_stack_00000040;
  int in_stack_00000044;
  undefined4 in_stack_0000008c;
  u8 *in_stack_000000b8;

  uVar4 = 0x7f;
  if ((param_11 == 0) && (uVar4 = 0x3f, unaff_r4 == 1))
  {
    uVar2 = FUN_0000fa1c();
    return uVar2;
  }
  uVar2 = 4;
  if (uVar4 != in_stack_0000008c._2_2_)
  {
    if (unaff_r4 < 6)
    {
      iVar3 = (unaff_r4 + 0x1a) * 0x2000;
      iVar5 = 0x1000;
    }
    else
    {
      iVar3 = (unaff_r4 + 0x37) * 0x2000;
      if (param_9 == 0)
      {
        iVar5 = 0x1000;
      }
      else
      {
        iVar5 = 0x2000;
      }
    }
    uVar2 = 4;
    if ((uint)(in_stack_00000020 + 8 + in_stack_00000044) <=
        (uint)(iVar5 * (in_stack_0000002c + 1) + iVar3))
    {
      if ((param_11 == 0) && (unaff_r4 == 1))
      {
        uVar2 = FUN_0000fa3e();
        return uVar2;
      }
      if (in_stack_00000030 != 0)
      {
        uVar2 = FUN_0000f9ae();
        return uVar2;
      }
      nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, in_stack_00000040,
                            in_stack_0000008c._2_2_, (u16)in_stack_00000020, in_stack_000000b8, '\0');
      uVar2 = (uint)nVar1;
      if (nVar1 == 0)
      {
        if (5 < unaff_r4)
        {
          uVar2 = FUN_0000f99c();
          return uVar2;
        }
        uVar2 = FUN_0000fb1e();
        return uVar2;
      }
    }
  }
  return uVar2;
}

// WARNING: Removing unreachable block (RAM,0x0000f858)
// WARNING: Removing unreachable block (RAM,0x0000f864)
// WARNING: Removing unreachable block (RAM,0x0000f896)
// WARNING: Removing unreachable block (RAM,0x0000f898)
// WARNING: Removing unreachable block (RAM,0x0000f862)
// WARNING: Removing unreachable block (RAM,0x0000f84e)

uint FUN_0000f8ee(void)

{
  nv_sts_t nVar1;
  int iVar2;
  uint in_r3;
  int iVar3;
  uint unaff_r4;
  uint uVar4;
  int param_9;
  int param_11;
  int param_12;
  u8 in_stack_00000024;
  int param_13;
  int in_stack_00000030;
  u8 in_stack_00000040;
  int param_14;
  undefined4 param_15;
  u8 *in_stack_000000b8;

  uVar4 = 4;
  if (in_r3 != param_15._2_2_)
  {
    if (unaff_r4 < 6)
    {
      iVar2 = (unaff_r4 + 0x1a) * 0x2000;
      iVar3 = 0x1000;
    }
    else
    {
      iVar2 = (unaff_r4 + 0x37) * 0x2000;
      if (param_9 == 0)
      {
        iVar3 = 0x1000;
      }
      else
      {
        iVar3 = 0x2000;
      }
    }
    uVar4 = 4;
    if ((uint)(param_12 + 8 + param_14) <= (uint)(iVar3 * (param_13 + 1) + iVar2))
    {
      if ((param_11 == 0) && (unaff_r4 == 1))
      {
        uVar4 = FUN_0000fa3e();
        return uVar4;
      }
      if (in_stack_00000030 != 0)
      {
        uVar4 = FUN_0000f9ae();
        return uVar4;
      }
      nVar1 = nv_write_item('\0', (u16)unaff_r4, in_stack_00000024, in_stack_00000040, param_15._2_2_,
                            (u16)param_12, in_stack_000000b8, '\0');
      uVar4 = (uint)nVar1;
      if (nVar1 == 0)
      {
        if (5 < unaff_r4)
        {
          uVar4 = FUN_0000f99c();
          return uVar4;
        }
        uVar4 = FUN_0000fb1e();
        return uVar4;
      }
    }
  }
  return uVar4;
}

void FUN_0000f928(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  u32 uVar9;
  int iVar10;
  undefined4 *puVar11;
  uint unaff_r4;
  int iVar12;
  int iVar13;
  u32 addr;
  uint uVar14;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int in_stack_00000038;
  int in_stack_00000048;
  uint in_stack_0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000080;
  short param_12;
  undefined4 in_stack_0000008c;

  if (param_9 == 0)
  {
    iVar10 = 0x1000;
  }
  else
  {
    iVar10 = 0x2000;
  }
  flash_read(iVar10 * param_11 + (unaff_r4 + 0x37) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (param_12 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = param_11 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar10 = (unaff_r4 + 0x1a) * 0x2000;
  iVar7 = (unaff_r4 + 0x37) * 0x2000;
  uVar14 = 0;
  addr = 0;
  bVar1 = true;
  do
  {
    uVar8 = in_stack_0000004c;
    if (4 < (int)in_stack_0000004c)
    {
      uVar8 = 4;
    }
    uVar8 = uVar8 & 0xff;
    flash_read(uStack00000050, uVar8 * 8, (u8 *)&stack0x00000054);
    if (uVar8 != 0)
    {
      iVar12 = 0;
      puVar11 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar13 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != param_11 * 0x2000 + iVar7 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar14 = (uint)uStack00000058;
      addr = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((param_11 + 1) * 0x1000 + iVar10) - in_stack_00000054 < uVar14)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar11 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(addr, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar11 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar13) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar13), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar12 = iVar12 + 1;
        puVar11 = puVar11 + 2;
        if ((int)uVar8 <= iVar12)
          break;
      LAB_0000f6cc:
        iVar13 = iVar12 * 8;
        uVar9 = (&stack0x00000054)[iVar12 * 2];
        if (uVar9 != (uVar14 + addr + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar10;
        if ((unaff_r4 < 6) || (iVar5 = iVar7, param_9 == 0))
        {
          iVar6 = 0x1000;
        }
        else
        {
          iVar6 = 0x2000;
        }
        uVar14 = (uint) * (ushort *)((int)&stack0x00000058 + iVar12 * 2 * 4);
        if ((iVar6 * (param_11 + 1) + iVar5) - uVar9 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        addr = uVar9;
        bVar3 = *(byte *)((int)puVar11 + 7);
      }
      bVar1 = false;
    }
    in_stack_0000004c = in_stack_0000004c - uVar8;
    if ((int)in_stack_0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar8 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f60c)

void FUN_0000f93a(undefined4 param_1, undefined4 param_2, int param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  int iVar15;
  uint uVar16;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int param_11;
  uint param_12;
  u32 param_13;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  param_12 = param_3 + 0x400;
  if (unaff_r4 < 6)
  {
    param_13 = (unaff_r4 + 0x1a) * 0x2000;
    param_11 = 0x1000;
  }
  else
  {
    param_13 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 == 0)
    {
      FUN_0000fa2a();
      return;
    }
    param_11 = 0x2000;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f96e();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * param_11 + param_13 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iVar13 = (unaff_r4 + 0x37) * 0x2000;
  uVar16 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    param_13 = uVar11 << 3;
    flash_read(uStack00000050, param_13, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar6 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar15 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar13 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar16 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar16)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
          if (nVar4 == NV_SUCC)
          {
            param_12 = *(ushort *)((int)&stack0x00000058 + iVar15) + 3 + param_12 & 0xfffffffc;
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar15 = iVar6 * 8;
        uVar12 = (&stack0x00000054)[iVar6 * 2];
        if (uVar12 != (uVar16 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iVar13, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar16 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar16)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar11;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + param_13;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000f940(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  int iVar15;
  uint uVar16;
  int param_9;
  int in_stack_00000018;
  int param_11;
  uint in_stack_00000024;
  u8 param_12;
  uint in_stack_00000030;
  int iStack00000038;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  if (param_11 != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (unaff_r4 < 6)
  {
    iStack00000048 = unaff_r4 + 0x1a;
    iStack00000038 = 0x1000;
  }
  else
  {
    iStack00000048 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa2a();
      return;
    }
    iStack00000038 = 0x2000;
  }
  iStack00000048 = iStack00000048 * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * iStack00000038 + iStack00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iVar13 = (unaff_r4 + 0x37) * 0x2000;
  uVar16 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar6 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar15 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar13 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar16 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar16)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), param_12, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar15 = iVar6 * 8;
        uVar12 = (&stack0x00000054)[iVar6 * 2];
        if (uVar12 != (uVar16 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iVar13, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar16 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar16)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar11;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}

void FUN_0000f952(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  int iVar5;
  u8 *pBuf;
  int iVar6;
  int iVar7;
  uint uVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  int iVar15;
  int iVar16;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int in_stack_00000038;
  int in_stack_00000048;
  uint param_11;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  pBuf = ev_buf_allocate(0x7f);
  uVar8 = 0x7e;
  param_11 = 0x7f;
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x7f);
    iVar6 = 0x7e0000;
    uVar10 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 0x3f4;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar15 = (int)sVar9;
        if (iVar15 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar15 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar15] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar8 - 2) * 0x10000;
      uVar8 = uVar8 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar6 = (unaff_r4 + 0x1a) * 0x2000;
  iVar15 = (unaff_r4 + 0x37) * 0x2000;
  uVar8 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = param_11;
    if (4 < (int)param_11)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar16 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar15 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar8 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar6) - in_stack_00000054 < uVar8)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar16) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar16), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar16 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar8 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar6;
        if ((unaff_r4 < 6) || (iVar5 = iVar15, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar8 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar8)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    param_11 = param_11 - uVar11;
    if ((int)param_11 < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}

void FUN_0000f96e(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint uVar15;
  int iVar16;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int in_stack_00000038;
  int in_stack_00000048;
  uint param_11;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  uVar15 = 0x7e;
  param_11 = 0x7f;
  pBuf = ev_buf_allocate(0x7f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x7f);
    iVar6 = 0x7e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 0x3f4;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar15 - 2) * 0x10000;
      uVar15 = uVar15 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iVar13 = (unaff_r4 + 0x37) * 0x2000;
  uVar15 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = param_11;
    if (4 < (int)param_11)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar6 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar16 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar13 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar15 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar15)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar16) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar16), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar16 = iVar6 * 8;
        uVar12 = (&stack0x00000054)[iVar6 * 2];
        if (uVar12 != (uVar15 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iVar13, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar15 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar15)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    param_11 = param_11 - uVar11;
    if ((int)param_11 < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f60c)

void FUN_0000f97a(undefined4 param_1, undefined4 param_2, int param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint uVar15;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000038;
  uint param_11;
  u32 uStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  param_11 = param_3 + 0x400;
  uStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  iStack00000038 = 0x1000;
  if (in_stack_0000001c != 0)
  {
    FUN_0000f96e();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar15 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar15 - 2) * 0x10000;
      uVar15 = uVar15 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * iStack00000038 + uStack00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  iStack00000038 = (unaff_r4 + 0x37) * 0x2000;
  uVar15 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    uStack00000048 = uVar11 << 3;
    flash_read(uStack00000050, uStack00000048, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar6 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iStack00000038 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar15 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar15)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar6) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar6), '\x01');
          if (nVar4 == NV_SUCC)
          {
            param_11 = *(ushort *)((int)&stack0x00000058 + iVar6) + 3 + param_11 & 0xfffffffc;
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar6 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar15 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = iStack00000038, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar15 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar15)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar11;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uStack00000048;
  } while (true);
}

undefined4 FUN_0000f992(undefined4 param_1)

{
  return param_1;
}

// WARNING: Removing unreachable block (RAM,0x0000f79c)
// WARNING: Removing unreachable block (RAM,0x0000f47a)
// WARNING: Removing unreachable block (RAM,0x0000f442)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000f996(void)

{
  bool bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  u8 *pBuf;
  uint uVar4;
  short sVar5;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined4 *puVar9;
  uint unaff_r4;
  int iVar10;
  u32 uVar11;
  int iVar12;
  int unaff_r8;
  u32 uVar13;
  uint uVar14;
  int unaff_sl;
  int param_9;
  int in_stack_00000018;
  int param_11;
  uint in_stack_00000024;
  int in_stack_0000002c;
  uint in_stack_00000030;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  undefined4 in_stack_00000054;
  undefined2 in_stack_00000058;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  u16 param_12;

  param_12 = 0;
  if ((param_11 == 0) && (unaff_r4 == 1))
  {
    FUN_0000fa02();
    return;
  }
  if (unaff_r8 == 0)
  {
    FUN_0000f7d2();
    return;
  }
  param_12 = 0;
  uVar4 = in_stack_0000002c + 1U & 1;
  if (param_9 != 0)
  {
    FUN_0000fa06();
    return;
  }
  uVar11 = uVar4 * 0x1000 + unaff_sl;
  iVar10 = 0;
  do
  {
    flash_erase(uVar11);
    uVar11 = uVar11 + 0x1000;
    iVar10 = iVar10 + 1;
  } while (iVar10 < 1);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (param_11 != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fa2a();
    return;
  }
  iStack00000048 = (unaff_r4 + 0x1a) * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar14 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (5 < unaff_r4)
  {
    FUN_0000fa24();
    return;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar10 = 0x3e0000;
    uVar11 = in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 500;
    sVar5 = 0;
    do
    {
      flash_read(uVar11, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar12 = (int)sVar5;
        if (iVar12 != 0)
        {
          bVar1 = true;
          iVar8 = 0;
          while (true)
          {
            if (pBuf[iVar8] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar10 >> 0x10));
              bVar1 = false;
            }
            if (iVar12 <= iVar8 + 1)
              break;
            iVar8 = iVar8 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar12] = in_stack_00000078._2_1_;
        sVar5 = sVar5 + 1;
      }
    LAB_0000f530:
      iVar10 = (uVar14 - 2) * 0x10000;
      uVar14 = uVar14 - 2 & 0xffff;
      uVar11 = uVar11 - 9;
    } while (-1 < iVar10);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * 0x1000 + iStack00000048 + 4;
  uVar14 = 0;
  uVar11 = 0;
  bVar1 = true;
  do
  {
    uVar6 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar6 = 4;
    }
    uVar6 = uVar6 & 0xff;
    flash_read(uStack00000050, uVar6 * 8, (u8 *)&stack0x00000054);
    if (uVar6 != 0)
    {
      iVar10 = 0;
      puVar9 = &stack0x00000054;
      uVar13 = uVar11;
      if (bVar1)
      {
        if (unaff_r4 < 6)
        {
          FUN_0000f778();
          return;
        }
        FUN_0000f7c2();
        return;
      }
      do
      {
        uVar11 = (&stack0x00000054)[iVar10 * 2];
        if (uVar11 != (uVar14 + uVar13 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        uVar7 = unaff_r4 + 0x37;
        if (unaff_r4 < 6)
        {
          uVar7 = unaff_r4 + 0x1a;
        }
        uVar14 = (uint)(ushort)(&stack0x00000058)[iVar10 * 4];
        if (((in_stack_00000018 + 1) * 0x1000 + uVar7 * 0x2000) - uVar11 < uVar14)
        {
          FUN_0000fa20();
          return;
        }
        iVar12 = *(byte *)((int)puVar9 + 7) - 0x7b;
        if (((iVar12 == 0) || (*(byte *)((int)puVar9 + 7) == 0x5a)) &&
            ((*(byte *)((int)puVar9 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar11, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          bVar2 = (byte)iVar12;
          nVar3 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar9 + 6), (u8)uVar4, param_12,
                                (&stack0x00000058)[iVar10 * 4] - 8,
                                (u8 *)(&stack0x00000054)[iVar10 * 2], '\x01');
          if (nVar3 == NV_SUCC)
          {
            param_12 = param_12 + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar3 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar3 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar3 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar10 = iVar10 + 1;
        puVar9 = puVar9 + 2;
        uVar13 = uVar11;
      } while (iVar10 < (int)uVar6);
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar6;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar6 * 8;
  } while (true);
}

undefined4 FUN_0000f99c(undefined4 param_1, undefined4 param_2)

{
  undefined4 uVar1;
  uint uVar2;
  uint unaff_r4;
  undefined4 unaff_r6;
  int unaff_r7;
  int unaff_r8;
  undefined4 param_9;
  byte in_stack_0000002c;
  int in_stack_00000040;
  undefined2 in_stack_00000088;
  uchar uStack0000008a;
  byte bStack0000008b;
  undefined4 in_stack_0000008c;

  if (unaff_r7 != 0)
  {
    uVar1 = FUN_0000f9c4(param_9, param_2, (unaff_r4 + 0x37) * 0x2000);
    return uVar1;
  }
  if (unaff_r8 == 0)
  {
    if (in_stack_0000008c._2_2_ == 0)
    {
      uStack0000008a = (uchar)unaff_r4;
      in_stack_00000088 = 0x7a7a;
      bStack0000008b = in_stack_0000002c;
      uVar2 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
      bStack0000008b = bStack0000008b | (byte)(uVar2 << 2);
      if (5 < unaff_r4)
      {
        uVar1 = FUN_0000fc04();
        return uVar1;
      }
      flash_writeWithCheck(in_stack_00000040 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000088);
    }
    return unaff_r6;
  }
  uVar1 = FUN_0000fb1e();
  return uVar1;
}

void FUN_0000f9ae(void)

{
  u32 in_r3;
  u16 unaff_r4;
  u16 *unaff_r5;
  u16 param_11;
  u8 param_12;
  u8 param_13;

  nv_index_read(unaff_r4, param_12, param_11, param_13, in_r3, unaff_r5);
  FUN_0000f814();
  return;
}

undefined4 FUN_0000f9c4(undefined4 param_1, undefined4 param_2, int param_3, int param_4)

{
  u8 uVar1;
  undefined4 uVar2;
  ushort *unaff_r5;
  int param_11;
  u8 uStack0000005b;

  uStack0000005b = 'P';
  uVar1 = flash_writeWithCheck((uint)*unaff_r5 * 8 + 0xb + param_4 * param_11 + param_3, 1, &stack0x0000005b);
  if (uVar1 == '\x01')
  {
    uVar2 = FUN_0000f850();
    return uVar2;
  }
  return 6;
}

undefined4 FUN_0000f9e8(void)

{
  return 6;
}

void FUN_0000fa02(void)

{
  FUN_0000f3ba();
  return;
}

// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f44e)

void FUN_0000fa06(undefined4 param_1, undefined4 param_2, undefined4 param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  short sVar8;
  uint uVar9;
  u32 uVar10;
  int iVar11;
  undefined4 *puVar12;
  uint unaff_r4;
  int iVar13;
  u32 uVar14;
  int iVar15;
  uint uVar16;
  int unaff_sl;
  int param_9;
  int in_stack_00000018;
  int in_stack_0000001c;
  uint in_stack_00000024;
  int param_11;
  uint in_stack_00000030;
  int iStack00000038;
  undefined4 param_12;
  int iStack00000048;
  uint uStack0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  uVar14 = param_11 * 0x2000 + unaff_sl;
  iVar13 = 0;
  param_12 = param_3;
  do
  {
    flash_erase(uVar14);
    uVar14 = uVar14 + 0x1000;
    iVar13 = iVar13 + 1;
  } while (iVar13 < 2);
  if (5 < unaff_r4)
  {
    FUN_0000f940();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000f93a();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f97a();
    return;
  }
  if (unaff_r4 < 6)
  {
    iStack00000048 = unaff_r4 + 0x1a;
    iStack00000038 = 0x1000;
  }
  else
  {
    iStack00000048 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa2a();
      return;
    }
    iStack00000038 = 0x2000;
  }
  iStack00000048 = iStack00000048 * 0x2000;
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar16 = 0x3e;
  uStack0000004c = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar13 = unaff_r4 + 0x1a;
    iVar11 = 0x1000;
  }
  else
  {
    iVar13 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar11 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar14 = iVar11 * in_stack_00000018 + iVar13 * 0x2000 + 500;
    sVar8 = 0;
    do
    {
      flash_read(uVar14, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar13 = (int)sVar8;
        if (iVar13 != 0)
        {
          bVar1 = true;
          iVar11 = 0;
          while (true)
          {
            if (pBuf[iVar11] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar13 <= iVar11 + 1)
              break;
            iVar11 = iVar11 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar13] = in_stack_00000078._2_1_;
        sVar8 = sVar8 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar16 - 2) * 0x10000;
      uVar16 = uVar16 - 2 & 0xffff;
      uVar14 = uVar14 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * iStack00000038 + iStack00000048 + 4;
  iVar13 = (unaff_r4 + 0x1a) * 0x2000;
  iVar11 = (unaff_r4 + 0x37) * 0x2000;
  uVar16 = 0;
  uVar14 = 0;
  bVar1 = true;
  do
  {
    uVar9 = uStack0000004c;
    if (4 < (int)uStack0000004c)
    {
      uVar9 = 4;
    }
    uVar9 = uVar9 & 0xff;
    flash_read(uStack00000050, uVar9 * 8, (u8 *)&stack0x00000054);
    if (uVar9 != 0)
    {
      iVar6 = 0;
      puVar12 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar15 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + iVar11 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar16 = (uint)uStack00000058;
      uVar14 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar13) - in_stack_00000054 < uVar16)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar12 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar14, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar12 + 6), (u8)param_11, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar15) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar15), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar6 = iVar6 + 1;
        puVar12 = puVar12 + 2;
        if ((int)uVar9 <= iVar6)
          break;
      LAB_0000f6cc:
        iVar15 = iVar6 * 8;
        uVar10 = (&stack0x00000054)[iVar6 * 2];
        if (uVar10 != (uVar16 + uVar14 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar13;
        if ((unaff_r4 < 6) || (iVar5 = iVar11, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar16 = (uint) * (ushort *)((int)&stack0x00000058 + iVar6 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar10 < uVar16)
        {
          FUN_0000fa20();
          return;
        }
        uVar14 = uVar10;
        bVar3 = *(byte *)((int)puVar12 + 7);
      }
      bVar1 = false;
    }
    uStack0000004c = uStack0000004c - uVar9;
    if ((int)uStack0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar9 * 8;
  } while (true);
}

void FUN_0000fa1c(void)

{
  FUN_0000f8ee();
  return;
}

void FUN_0000fa20(void)

{
  FUN_0000f8de();
  return;
}

void FUN_0000fa24(undefined4 param_1, undefined4 param_2, int param_3)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  buf_sts_t bVar4;
  nv_sts_t nVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint unaff_r5;
  int iVar15;
  int iVar16;
  u8 *unaff_r8;
  uint unaff_sl;
  uint uVar17;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint param_13;
  int in_stack_00000038;
  int in_stack_00000048;
  uint in_stack_0000004c;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  bVar4 = BUFFER_SUCC;
  if (unaff_r8 != (u8 *)0x0)
  {
    memset(unaff_r8, 0, unaff_r5);
    iVar7 = unaff_sl << 0x10;
    uVar10 = (iVar7 >> 0xd) + 4 + param_11 * 0x1000 + param_3;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (param_13 != 0))))))
      {
        iVar15 = (int)sVar9;
        if (iVar15 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (unaff_r8[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)param_11, (u16)((uint)iVar7 >> 0x10));
              bVar1 = false;
            }
            if (iVar15 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        unaff_r8[iVar15] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar7 = (unaff_sl - 2) * 0x10000;
      unaff_sl = unaff_sl - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar7);
    bVar4 = ev_buf_free(unaff_r8);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928(bVar4);
    return;
  }
  flash_read(param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = param_11 * in_stack_00000038 + in_stack_00000048 + 4;
  iVar7 = (unaff_r4 + 0x1a) * 0x2000;
  iVar15 = (unaff_r4 + 0x37) * 0x2000;
  uVar17 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = in_stack_0000004c;
    if (4 < (int)in_stack_0000004c)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar16 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (in_stack_0000001c != 0)
      {
        FUN_0000f772();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != param_11 * 0x2000 + iVar15 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar17 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((param_11 + 1) * 0x1000 + iVar7) - in_stack_00000054 < uVar17)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar6 = bVar3 - 0x7b;
        bVar2 = (byte)iVar6;
        if (((iVar6 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~param_13 + param_13 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) != 0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar5 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar16) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar16), '\x01');
          if (nVar5 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar5 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar5 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar5 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar16 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar17 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar6 = iVar7;
        if ((unaff_r4 < 6) || (iVar6 = iVar15, param_9 == 0))
        {
          iVar8 = 0x1000;
        }
        else
        {
          iVar8 = 0x2000;
        }
        uVar17 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar8 * (param_11 + 1) + iVar6) - uVar12 < uVar17)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    in_stack_0000004c = in_stack_0000004c - uVar11;
    if ((int)in_stack_0000004c < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0000f60c)

void FUN_0000fa2a(void)

{
  bool bVar1;
  byte bVar2;
  byte bVar3;
  nv_sts_t nVar4;
  u8 *pBuf;
  int iVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  short sVar9;
  u32 uVar10;
  uint uVar11;
  u32 uVar12;
  int iVar13;
  undefined4 *puVar14;
  uint unaff_r4;
  uint uVar15;
  int param_9;
  int in_stack_00000018;
  int param_11;
  uint in_stack_00000024;
  u8 in_stack_0000002c;
  uint in_stack_00000030;
  int param_12;
  int in_stack_00000048;
  uint param_13;
  u32 uStack00000050;
  u32 in_stack_00000054;
  ushort uStack00000058;
  byte bStack0000005b;
  undefined4 in_stack_00000078;
  undefined4 in_stack_00000080;
  short in_stack_00000084;
  undefined4 in_stack_0000008c;

  param_12 = 0x1000;
  if (param_11 != 0)
  {
    FUN_0000f96e();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000f952();
    return;
  }
  uVar15 = 0x3e;
  param_13 = 0x3f;
  pBuf = ev_buf_allocate(0x3f);
  if (unaff_r4 < 6)
  {
    iVar8 = unaff_r4 + 0x1a;
    iVar13 = 0x1000;
  }
  else
  {
    iVar8 = unaff_r4 + 0x37;
    if (param_9 == 0)
    {
      FUN_0000fa24();
      return;
    }
    iVar13 = 0x2000;
  }
  if (pBuf != (u8 *)0x0)
  {
    memset(pBuf, 0, 0x3f);
    iVar6 = 0x3e0000;
    uVar10 = iVar13 * in_stack_00000018 + iVar8 * 0x2000 + 500;
    sVar9 = 0;
    do
    {
      flash_read(uVar10, 8, &stack0x00000074);
      if (((in_stack_00000078._3_1_ == 'z') || (in_stack_00000078._3_1_ == 'Z')) &&
          ((in_stack_00000078._3_1_ == 'z' ||
            ((unaff_r4 == in_stack_00000078._2_1_ && (in_stack_00000030 != 0))))))
      {
        iVar8 = (int)sVar9;
        if (iVar8 != 0)
        {
          bVar1 = true;
          iVar13 = 0;
          while (true)
          {
            if (pBuf[iVar13] == in_stack_00000078._2_1_)
            {
              nv_itemDeleteByIndex((u8)unaff_r4, (u8)in_stack_00000024, (u8)in_stack_00000018,
                                   (u16)((uint)iVar6 >> 0x10));
              bVar1 = false;
            }
            if (iVar8 <= iVar13 + 1)
              break;
            iVar13 = iVar13 + 1;
          }
          if (!bVar1)
            goto LAB_0000f530;
        }
        pBuf[iVar8] = in_stack_00000078._2_1_;
        sVar9 = sVar9 + 1;
      }
    LAB_0000f530:
      iVar6 = (uVar15 - 2) * 0x10000;
      uVar15 = uVar15 - 2 & 0xffff;
      uVar10 = uVar10 - 9;
    } while (-1 < iVar6);
    ev_buf_free(pBuf);
  }
  if (5 < unaff_r4)
  {
    FUN_0000f928();
    return;
  }
  flash_read(in_stack_00000018 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000, 4, (u8 *)&stack0x00000084);
  if (in_stack_00000084 != 0x7a7a)
  {
    FUNBBBBB();
    return;
  }
  uStack00000050 = in_stack_00000018 * param_12 + in_stack_00000048 + 4;
  iVar8 = (unaff_r4 + 0x1a) * 0x2000;
  param_12 = (unaff_r4 + 0x37) * 0x2000;
  uVar15 = 0;
  uVar10 = 0;
  bVar1 = true;
  do
  {
    uVar11 = param_13;
    if (4 < (int)param_13)
    {
      uVar11 = 4;
    }
    uVar11 = uVar11 & 0xff;
    flash_read(uStack00000050, uVar11 * 8, (u8 *)&stack0x00000054);
    if (uVar11 != 0)
    {
      iVar13 = 0;
      puVar14 = &stack0x00000054;
      if (!bVar1)
        goto LAB_0000f6cc;
      iVar6 = 0;
      if (unaff_r4 < 6)
      {
        FUN_0000f778();
        return;
      }
      if (param_9 == 0)
      {
        FUN_0000f7c2();
        return;
      }
      if (unaff_r4 == 1)
      {
        FUN_0000f772();
        return;
      }
      if (in_stack_00000054 != in_stack_00000018 * 0x2000 + param_12 + 0x200U)
      {
        FUN_0000fa20();
        return;
      }
      if (5 < unaff_r4)
      {
        FUN_0000f780();
        return;
      }
      uVar15 = (uint)uStack00000058;
      uVar10 = in_stack_00000054;
      bVar3 = bStack0000005b;
      if (((in_stack_00000018 + 1) * 0x1000 + iVar8) - in_stack_00000054 < uVar15)
      {
        FUN_0000fa20();
        return;
      }
      while (true)
      {
        iVar5 = bVar3 - 0x7b;
        bVar2 = (byte)iVar5;
        if (((iVar5 == 0) || (bVar3 == 0x5a)) &&
            ((*(byte *)((int)puVar14 + 6) != in_stack_00000024 ||
              (~in_stack_00000030 + in_stack_00000030 + (uint)((unaff_r4 + 0x37 >> 0x13 & 1) != 0) !=
               0))))
        {
          flash_read(uVar10, 8, &stack0x0000007c);
          if (in_stack_00000080._3_1_ == 0x7a)
          {
            FUN_0000f8b0();
            return;
          }
          nVar4 = nv_write_item(~bVar2 + bVar2 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_r4,
                                *(u8 *)((int)puVar14 + 6), in_stack_0000002c, in_stack_0000008c._2_2_,
                                *(short *)((int)&stack0x00000058 + iVar6) - 8,
                                *(u8 **)((int)&stack0x00000054 + iVar6), '\x01');
          if (nVar4 == NV_SUCC)
          {
            in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
            FUN_0000f6c0();
            return;
          }
          if (nVar4 == NV_ITEM_CHECK_ERROR)
          {
            FUN_0000fa20();
            return;
          }
          if (nVar4 == NV_CHECK_SUM_ERROR)
          {
            FUN_0000f992();
            return;
          }
          if (nVar4 == NV_NOT_ENOUGH_SAPCE)
          {
            FUN_0000f992();
            return;
          }
        }
        iVar13 = iVar13 + 1;
        puVar14 = puVar14 + 2;
        if ((int)uVar11 <= iVar13)
          break;
      LAB_0000f6cc:
        iVar6 = iVar13 * 8;
        uVar12 = (&stack0x00000054)[iVar13 * 2];
        if (uVar12 != (uVar15 + uVar10 + 3 & 0xfffffffc))
        {
          FUN_0000fa20();
          return;
        }
        iVar5 = iVar8;
        if ((unaff_r4 < 6) || (iVar5 = param_12, param_9 == 0))
        {
          iVar7 = 0x1000;
        }
        else
        {
          iVar7 = 0x2000;
        }
        uVar15 = (uint) * (ushort *)((int)&stack0x00000058 + iVar13 * 2 * 4);
        if ((iVar7 * (in_stack_00000018 + 1) + iVar5) - uVar12 < uVar15)
        {
          FUN_0000fa20();
          return;
        }
        uVar10 = uVar12;
        bVar3 = *(byte *)((int)puVar14 + 7);
      }
      bVar1 = false;
    }
    param_13 = param_13 - uVar11;
    if ((int)param_13 < 1)
    {
      FUN_0000fa20();
      return;
    }
    uStack00000050 = uStack00000050 + uVar11 * 8;
  } while (true);
}

void FUN_0000fa3e(void)

{
  FUN_0000f80a();
  return;
}

void FUN_0000fa42(void)

{
  uint unaff_r4;
  int unaff_r5;
  int iVar1;
  int unaff_r6;
  int unaff_r7;
  int param_11;
  int in_stack_0000001c;
  int param_12;
  uint param_13;
  ushort uStack00000058;
  char cStack0000005b;
  undefined4 in_stack_0000008c;

  flash_read((uint)in_stack_0000008c._2_2_ * 8 + 4 + unaff_r5 * param_11 + unaff_r7, 8,
             (u8 *)&stack0x00000054);
  if ((uint)in_stack_0000008c._2_2_ == unaff_r6 - 1U)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fbee();
    return;
  }
  iVar1 = param_11 + 1;
  if (iVar1 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 < param_13 + 8 + (uint)uStack00000058 + param_12)
  {
    FUN_0000f3c2();
    return;
  }
  if ((((cStack0000005b != 'z') && (cStack0000005b != 'Z')) && (cStack0000005b != 'P')) &&
      (cStack0000005b != -6))
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc4a();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000fc44();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000fc44();
    return;
  }
  if (param_13 < param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 0x200)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (iVar1 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_13)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((iVar1 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_13 < (uint)uStack00000058)
  {
    FUN_0000f3c2();
    return;
  }
  in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
  FUN_0000f7ec();
  return;
}

// WARNING: Removing unreachable block (RAM,0x0000f5e4)
// WARNING: Removing unreachable block (RAM,0x0000f5f0)
// WARNING: Removing unreachable block (RAM,0x0000f5f2)
// WARNING: Removing unreachable block (RAM,0x0000f5f8)
// WARNING: Removing unreachable block (RAM,0x0000f5fa)
// WARNING: Removing unreachable block (RAM,0x0000f60c)
// WARNING: Removing unreachable block (RAM,0x0000f60e)
// WARNING: Removing unreachable block (RAM,0x0000f614)
// WARNING: Removing unreachable block (RAM,0x0000f616)
// WARNING: Removing unreachable block (RAM,0x0000f620)
// WARNING: Removing unreachable block (RAM,0x0000f622)
// WARNING: Removing unreachable block (RAM,0x0000f628)
// WARNING: Removing unreachable block (RAM,0x0000f62a)
// WARNING: Removing unreachable block (RAM,0x0000f644)
// WARNING: Removing unreachable block (RAM,0x0000f646)

void FUN_0000fb1e(void)

{
  byte bVar1;
  nv_sts_t nVar2;
  u8 uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  u8 *puVar9;
  uint unaff_r4;
  u8 *unaff_r7;
  u32 uVar10;
  u32 unaff_r9;
  uint unaff_sl;
  uint unaff_fp;
  int param_9;
  int param_11;
  uint in_stack_00000024;
  uint in_stack_00000028;
  byte param_12;
  int in_stack_00000034;
  int in_stack_00000038;
  int in_stack_0000003c;
  int param_13;
  u32 in_stack_00000048;
  uint in_stack_0000004c;
  u32 in_stack_00000050;
  undefined4 in_stack_00000080;
  undefined2 param_14;
  uchar param_15;
  byte param_16;
  undefined4 in_stack_0000008c;

  param_15 = (uchar)unaff_r4;
  param_14 = 0xfafa;
  param_16 = param_12;
  uVar5 = xcrc32(&stack0x0000008a, 2, 0xfffffffe);
  param_16 = param_16 | (byte)((uVar5 & 0x3f) << 2);
  if (unaff_r4 < 6)
  {
    iVar6 = (unaff_r4 + 0x1a) * 0x2000;
    iVar8 = 0x1000;
  }
  else
  {
    iVar6 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 == 0)
    {
      iVar8 = 0x1000;
    }
    else
    {
      iVar8 = 0x2000;
    }
  }
  uVar3 = flash_writeWithCheck(iVar8 * param_13 + iVar6, 4, (u8 *)&stack0x00000088);
  if (uVar3 != '\x01')
  {
    FUN_0000f9e8();
    return;
  }
  param_14 = 0x5050;
  if (unaff_r4 < 6)
  {
    iVar6 = (unaff_r4 + 0x1a) * 0x2000;
    iVar8 = 0x1000;
  }
  else
  {
    iVar6 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 == 0)
    {
      iVar8 = 0x1000;
    }
    else
    {
      iVar8 = 0x2000;
    }
  }
  uVar3 = flash_writeWithCheck(iVar8 * param_11 + iVar6, 2, (u8 *)&stack0x00000088);
  if (uVar3 != '\x01')
  {
    FUN_0000f342();
  }
  param_14 = 0x7a7a;
  if (unaff_r4 < 6)
  {
    iVar6 = (unaff_r4 + 0x1a) * 0x2000;
  }
  else
  {
    iVar6 = (unaff_r4 + 0x37) * 0x2000;
    if (param_9 != 0)
    {
      iVar8 = 0x2000;
      goto LAB_0000fbae;
    }
  }
  iVar8 = 0x1000;
LAB_0000fbae:
  uVar3 = flash_writeWithCheck(iVar8 * param_13 + iVar6, 2, (u8 *)&stack0x00000088);
  FUN_0000f342(uVar3);
  do
  {
    do
    {
      in_stack_0000004c = in_stack_0000004c - in_stack_00000028;
      if ((int)in_stack_0000004c < 1)
      {
        FUN_0000fa20();
        return;
      }
      in_stack_00000050 = in_stack_00000050 + in_stack_00000048;
      in_stack_00000028 = in_stack_0000004c;
      if (4 < (int)in_stack_0000004c)
      {
        in_stack_00000028 = 4;
      }
      in_stack_00000028 = in_stack_00000028 & 0xff;
      in_stack_00000048 = in_stack_00000028 << 3;
      flash_read(in_stack_00000050, in_stack_00000048, unaff_r7);
    } while (in_stack_00000028 == 0);
    iVar6 = 0;
    puVar9 = unaff_r7;
    uVar10 = unaff_r9;
    do
    {
      iVar8 = iVar6 * 8;
      unaff_r9 = *(u32 *)(unaff_r7 + iVar8);
      if (unaff_r9 != (unaff_fp + uVar10 + 3 & 0xfffffffc))
      {
        FUN_0000fa20();
        return;
      }
      iVar4 = in_stack_00000034;
      if ((unaff_sl < 6) || (iVar4 = in_stack_00000038, param_9 == 0))
      {
        iVar7 = 0x1000;
      }
      else
      {
        iVar7 = 0x2000;
      }
      unaff_fp = (uint) * (ushort *)(unaff_r7 + iVar8 + 4);
      if ((iVar7 * (param_11 + 1) + iVar4) - unaff_r9 < unaff_fp)
      {
        FUN_0000fa20();
        return;
      }
      iVar4 = puVar9[7] - 0x7b;
      if (((iVar4 == 0) || (puVar9[7] == 0x5a)) &&
          ((puVar9[6] != in_stack_00000024 || (in_stack_0000003c != 0))))
      {
        flash_read(unaff_r9, 8, &stack0x0000007c);
        if (in_stack_00000080._3_1_ == 0x7a)
        {
          FUN_0000f8b0();
          return;
        }
        bVar1 = (byte)iVar4;
        nVar2 = nv_write_item(~bVar1 + bVar1 + (0x79 < in_stack_00000080._3_1_), (u16)unaff_sl,
                              puVar9[6], param_12, in_stack_0000008c._2_2_,
                              *(short *)(unaff_r7 + iVar8 + 4) - 8, *(u8 **)(unaff_r7 + iVar8), '\x01');
        if (nVar2 == NV_SUCC)
        {
          in_stack_0000008c._2_2_ = in_stack_0000008c._2_2_ + 1;
          FUN_0000f6c0();
          return;
        }
        if (nVar2 == NV_ITEM_CHECK_ERROR)
        {
          FUN_0000fa20();
          return;
        }
        if (nVar2 == NV_CHECK_SUM_ERROR)
        {
          FUN_0000f992();
          return;
        }
        if (nVar2 == NV_NOT_ENOUGH_SAPCE)
        {
          FUN_0000f992();
          return;
        }
      }
      iVar6 = iVar6 + 1;
      puVar9 = puVar9 + 8;
      uVar10 = unaff_r9;
    } while (iVar6 < (int)in_stack_00000028);
  } while (true);
}

void FUN_0000fbee(uint param_1, undefined4 param_2, short param_3)

{
  char cVar1;
  int iVar2;
  uint unaff_r4;
  int iVar3;
  uint unaff_r6;
  int unaff_r7;
  uint unaff_ip;
  int param_9;
  int param_11;
  int in_stack_0000001c;
  short sStack0000008e;

  iVar3 = param_11 + 1;
  if (param_9 == 0)
  {
    iVar2 = 0x1000;
  }
  else
  {
    iVar2 = 0x2000;
  }
  if (iVar2 * iVar3 + (unaff_r4 + 0x37) * 0x2000 < unaff_r6)
  {
    FUN_0000f3c2();
    return;
  }
  cVar1 = *(char *)(unaff_r7 + 7);
  if ((((cVar1 != 'z') && (cVar1 != 'Z')) && (cVar1 != 'P')) && (cVar1 != -6))
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc4a();
    return;
  }
  if (in_stack_0000001c != 0)
  {
    FUN_0000fc44();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000fc44();
    return;
  }
  if (param_1 < param_11 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 + 0x200)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (iVar3 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((iVar3 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}

undefined4 FUN_0000fc04(void)

{
  int iVar1;
  int unaff_r4;
  undefined4 unaff_r6;
  int param_9;
  int param_11;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  flash_writeWithCheck(iVar1 * param_11 + (unaff_r4 + 0x37) * 0x2000, 4, &stack0x00000088);
  return unaff_r6;
}

void FUN_0000fc44(uint param_1, int param_2, short param_3)

{
  uint unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  short sStack0000008e;

  if (param_1 < param_2 + 0x400U)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}

void FUN_0000fc4a(uint param_1, undefined4 param_2, short param_3)

{
  int iVar1;
  uint unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  int param_9;
  int param_11;
  int param_12;
  short sStack0000008e;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  if (param_12 != 0)
  {
    FUN_0000fc44();
    return;
  }
  if (unaff_r4 == 1)
  {
    FUN_0000fc44();
    return;
  }
  if (param_1 < iVar1 * param_11 + (unaff_r4 + 0x37) * 0x2000 + 0x200)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc62();
    return;
  }
  if (unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}

void FUN_0000fc62(uint param_1, undefined4 param_2, short param_3)

{
  int iVar1;
  uint unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  int param_9;
  short sStack0000008e;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  if (iVar1 * unaff_r5 + (unaff_r4 + 0x37) * 0x2000 <= param_1)
  {
    FUN_0000f3c2();
    return;
  }
  if (5 < unaff_r4)
  {
    FUN_0000fc8a();
    return;
  }
  if ((unaff_r5 * 0x1000 + (unaff_r4 + 0x1a) * 0x2000) - param_1 < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  sStack0000008e = param_3 + 1;
  FUN_0000f7ec();
  return;
}

void FUN_0000fc8a(int param_1, undefined4 param_2, short param_3)

{
  int iVar1;
  int unaff_r4;
  int unaff_r5;
  uint unaff_ip;
  int param_9;
  short param_11;

  if (param_9 == 0)
  {
    iVar1 = 0x1000;
  }
  else
  {
    iVar1 = 0x2000;
  }
  if ((uint)((iVar1 * unaff_r5 + (unaff_r4 + 0x37) * 0x2000) - param_1) < unaff_ip)
  {
    FUN_0000f3c2();
    return;
  }
  param_11 = param_3 + 1;
  FUN_0000f7ec();
  return;
}

nv_sts_t nv_flashSingleItemRemove(u8 id, u8 itemId, u16 len)

{
  nv_sts_t nVar1;
  u32 totalItemNum;
  nv_sect_info_t nStack_20;
  u16 local_1a;

  local_1a = 0;
  nVar1 = nv_sector_read((ushort)id, '\x02', &nStack_20);
  if (nVar1 == NV_SUCC)
  {
    if (((id == '\a') || (id == '\x05')) || (totalItemNum = 0x3f, id == '\x01'))
    {
      totalItemNum = 0x7f;
    }
    nVar1 = nv_index_read((ushort)id, itemId, len, nStack_20.opSect, totalItemNum, &local_1a);
    if (nVar1 == NV_SUCC)
    {
      nVar1 = nv_itemDeleteByIndex(id, itemId, nStack_20.opSect, local_1a);
    }
  }
  return nVar1;
}

nv_sts_t nv_flashSingleItemSizeGet(u8 id, u8 itemId, u16 *len)

{
  nv_sts_t nVar1;
  u32 totalItemNum;
  nv_sect_info_t nStack_20;
  u16 local_1a;

  local_1a = 0;
  nVar1 = nv_sector_read((ushort)id, '\x02', &nStack_20);
  if (nVar1 == NV_SUCC)
  {
    if (((id == '\a') || (id == '\x05')) || (totalItemNum = 0x3f, id == '\x01'))
    {
      totalItemNum = 0x7f;
    }
    nVar1 = nv_index_read_op((ushort)id, itemId, len, nStack_20.opSect, totalItemNum, &local_1a, '\0');
  }
  return nVar1;
}

nv_sts_t nv_flashWriteNew(u8 single, u16 id, u8 itemId, u16 len, u8 *buf)

{
  nv_sts_t nVar1;

  nVar1 = NV_INVALID_MODULS;
  if (id != 4)
  {
    nVar1 = nv_flashWriteNewHandler('\0', single, id, itemId, len, buf);
    if (nVar1 == NV_ITEM_CHECK_ERROR)
    {
      nVar1 = nv_flashWriteNewHandler('\x01', single, id, itemId, len, buf);
    }
  }
  return nVar1;
}

// WARNING: Could not reconcile some variable overlaps

nv_sts_t nv_flashReadNew(u8 single, u8 id, u8 itemId, u16 len, u8 *buf)

{
  nv_sts_t nVar1;
  u32 totalItemNum;
  nv_sect_info_t nStack_28;
  undefined2 local_22;

  local_22 = 0;
  nVar1 = NV_INVALID_MODULS;
  if ((id != '\x04') && (nVar1 = nv_sector_read((ushort)id, '\x02', &nStack_28), nVar1 == NV_SUCC))
  {
    if ((id == '\a') || ((id == '\x05' || (totalItemNum = 0x3f, id == '\x01'))))
    {
      totalItemNum = 0x7f;
    }
    nVar1 = nv_index_read((ushort)id, itemId, len, nStack_28.opSect, totalItemNum, &local_22);
    if (single == '\0')
    {
      *buf = (u8)local_22;
      buf[1] = local_22._1_1_;
      buf[2] = nStack_28.opSect;
    }
    else if ((nVar1 == NV_SUCC) &&
             (nVar1 = nv_flashReadByIndex(id, itemId, nStack_28.opSect, local_22, len, buf),
              nVar1 == NV_CHECK_SUM_ERROR))
    {
      nv_itemDeleteByIndex(id, itemId, nStack_28.opSect, local_22);
    }
  }
  return nVar1;
}

nv_sts_t nv_nwkFrameCountSearch(u8 id, u8 opSect, u32 *frameCount, u32 *validAddr)

{
  u32 *puVar1;
  u32 uVar2;
  int iVar3;
  u32 uVar4;
  int iVar5;
  u32 uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  u32 local_34;
  u32 uStack_30;
  u32 local_2c[2];

  uVar9 = (uint)id;
  uVar2 = (uint)opSect * 0x1000 + 0x3c004;
  *validAddr = uVar2;
  if (uVar9 < 6)
  {
    iVar5 = (uVar9 + 0x1a) * 0x2000;
  }
  else
  {
    iVar5 = (uVar9 + 0x37) * 0x2000;
    if (uVar9 == 7)
    {
      iVar3 = 0x2000;
      goto LAB_0000fe9e;
    }
  }
  iVar3 = 0x1000;
LAB_0000fe9e:
  uVar6 = iVar5 + -0x100 + (opSect + 1) * iVar3;
  uVar4 = uVar6 - 0xe00;
  iVar5 = 0;
  do
  {
    flash_read(uVar6, 4, (u8 *)&local_34);
    if (local_34 != 0xffffffff)
    {
      uVar9 = 0x100;
    LAB_0000ff02:
      uVar2 = uVar6 + 0x100 & 0xffffff00;
      do
      {
        uVar7 = uVar9;
        if (0x10 < uVar9)
        {
          uVar7 = 0x10;
        }
        uVar8 = (uVar7 << 0x18) >> 0x1a;
        uVar2 = uVar2 + uVar8 * -4;
        flash_read(uVar2, uVar7 & 0xff, (u8 *)&local_34);
        if (local_34 == 0xffffffff)
        {
          *validAddr = uVar2;
        }
        else
        {
          *frameCount = local_34;
          if (1 < uVar8)
          {
            if (uStack_30 == 0xffffffff)
            {
              iVar5 = 4;
            }
            else
            {
              *frameCount = uStack_30;
              if (uVar8 - 1 != 1)
              {
                puVar1 = local_2c;
                iVar5 = 1;
              LAB_0000ff62:
                iVar3 = iVar5;
                iVar5 = iVar3 + 1;
                if (iVar5 < (int)uVar8)
                {
                  uVar6 = *puVar1;
                  puVar1 = puVar1 + 1;
                  if (uVar6 != 0xffffffff)
                    goto code_r0x0000ff5c;
                  goto LAB_0000ff86;
                }
                goto LAB_0000ff68;
              }
              iVar5 = 8;
            }
          LAB_0000ff88:
            *validAddr = iVar5 + uVar2;
            return NV_SUCC;
          }
        }
      LAB_0000ff68:
        uVar9 = uVar9 - (uVar7 & 0xff) & 0xffff;
        if (uVar9 == 0)
        {
          return NV_ITEM_NOT_FOUND;
        }
      } while (true);
    }
    *validAddr = uVar6;
    iVar5 = iVar5 + 1;
    if (uVar6 == uVar4)
    {
      if (iVar5 != 0xf)
      {
        return NV_ITEM_NOT_FOUND;
      }
      uVar9 = 0xfc;
      uVar6 = uVar2;
      goto LAB_0000ff02;
    }
    uVar6 = uVar6 - 0x100;
  } while (true);
code_r0x0000ff5c:
  *frameCount = uVar6;
  if (iVar5 == uVar8 - 1)
  {
    iVar5 = iVar3 + 2;
  LAB_0000ff86:
    iVar5 = iVar5 << 2;
    goto LAB_0000ff88;
  }
  goto LAB_0000ff62;
}

nv_sts_t nv_nwkFrameCountSaveToFlashHandler(u8 forceChgSec, u8 *errSect, u32 frameCount)

{
  nv_sts_t nVar1;
  nv_sts_t nVar2;
  u8 uVar3;
  uint uVar4;
  byte bVar5;
  int iVar6;
  u32 addr;
  uint uVar7;
  uint uVar8;
  u32 local_30;
  u32 uStack_2c;
  u32 uStack_28;
  nv_sect_info_t local_24;

  local_30 = frameCount;
  if (forceChgSec == '\0')
  {
    nVar2 = nv_sector_read(4, '\x02', &local_24);
    if (nVar2 == NV_SUCC)
    {
      uVar8 = (uint)local_24.opSect;
    }
    else
    {
      flash_erase(0x3c000);
      flash_erase(0x3d000);
      uVar8 = 0;
    }
  }
  else
  {
    uVar8 = *errSect + 1 & 1;
    flash_erase(uVar8 * 0x1000 + 0x3c000);
    nVar2 = NV_SUCC;
  }
  nVar1 = nv_nwkFrameCountSearch('\x04', (u8)uVar8, &uStack_28, &uStack_2c);
  uVar7 = uVar8;
  if (nVar1 == NV_SUCC)
  {
    bVar5 = 0;
    if (uVar8 * 0x1000 + 0x3d000 == uStack_2c)
    {
      uVar7 = uVar8 + 1 & 1;
      flash_erase(uVar7 * 0x1000 + 0x3c000);
      iVar6 = (uVar7 + 0x3c) * 0x1000;
      uVar3 = flash_writeWithCheck(iVar6 + 4, 4, (u8 *)&uStack_28);
      if (uVar3 != '\x01')
      {
        return NV_CHECK_SUM_ERROR;
      }
      uStack_2c = iVar6 + 8;
      bVar5 = 1;
    }
    uVar3 = flash_writeWithCheck(uStack_2c, 4, (u8 *)&local_30);
  }
  else
  {
    bVar5 = 0;
    uVar3 = flash_writeWithCheck(uStack_2c, 4, (u8 *)&local_30);
  }
  if (uVar3 == '\x01')
  {
    if ((bVar5 == 0) && (uVar7 * 0x1000 + 0x3c004 != uStack_2c))
    {
      return nVar2;
    }
    local_24.idName = '\x04';
    local_24.usedFlag = 0xfafa;
    local_24.opSect = (u8)uVar7;
    uVar4 = xcrc32(&local_24.idName, 2, 0xfffffffe);
    local_24.opSect = (byte)((uVar4 & 0x3f) << 2) | local_24.opSect;
    addr = uVar7 * 0x1000 + 0x3c000;
    uVar3 = flash_writeWithCheck(addr, 4, (u8 *)&local_24);
    if (uVar3 == '\x01')
    {
      if ((bVar5 | forceChgSec) == 0)
      {
        return nVar2;
      }
      if (forceChgSec != '\0')
      {
        uVar8 = (uint)*errSect;
      }
      local_24.usedFlag = 0x5050;
      uVar3 = flash_writeWithCheck(uVar8 * 0x1000 + 0x3c000, 2, (u8 *)&local_24);
      if (uVar3 == '\x01')
      {
        local_24.usedFlag = 0x7a7a;
        flash_writeWithCheck(addr, 2, (u8 *)&local_24);
        return nVar2;
      }
    }
  }
  return NV_CHECK_SUM_ERROR;
}

nv_sts_t nv_nwkFrameCountSaveToFlash(u32 frameCount)

{
  nv_sts_t nVar1;
  u8 local_d[5];

  local_d[0] = 0xff;
  nVar1 = nv_nwkFrameCountSaveToFlashHandler('\0', local_d, frameCount);
  if (nVar1 == NV_CHECK_SUM_ERROR)
  {
    nv_nwkFrameCountSaveToFlashHandler('\x01', local_d, frameCount);
  }
  return NV_SUCC;
}

nv_sts_t nv_nwkFrameCountFromFlash(u32 *frameCount)

{
  nv_sts_t nVar1;
  int local_2c;
  int iStack_28;
  uint uStack_24;
  u32 uStack_20;
  nv_sect_info_t nStack_1c;
  byte local_15[5];

  local_15[0] = 0;
  nVar1 = nv_sector_read(4, '\x02', &nStack_1c);
  if (nVar1 == NV_SUCC)
  {
    local_15[0] = nStack_1c.opSect;
    nVar1 = nv_nwkFrameCountSearch('\x04', nStack_1c.opSect, &uStack_20, &uStack_24);
    if (nVar1 == NV_SUCC)
    {
      *frameCount = uStack_20;
      if ((uint)local_15[0] * 0x1000 + 0x3c00c < uStack_24)
      {
        flash_read(uStack_24 - 8, 8, (u8 *)&local_2c);
        if (0x400 < (uint)(iStack_28 - local_2c))
        {
          *frameCount = local_2c + 0x400U;
          nv_nwkFrameCountSaveToFlashHandler('\x01', local_15, local_2c + 0x400U);
        }
      }
    }
  }
  return nVar1;
}

nv_sts_t nv_resetModule(u8 modules)

{
  uint uVar1;
  int iVar2;
  u32 addr;
  int iVar3;
  u32 uVar4;
  int iVar5;

  uVar1 = (uint)modules;
  if (uVar1 < 6)
  {
    uVar4 = (uVar1 + 0x1a) * 0x2000;
  }
  else
  {
    uVar4 = (uVar1 + 0x37) * 0x2000;
    iVar3 = 2;
    if (uVar1 == 7)
      goto LAB_000101f2;
  }
  iVar3 = 1;
LAB_000101f2:
  iVar5 = 2;
  do
  {
    iVar2 = 0;
    addr = uVar4;
    do
    {
      flash_erase(addr);
      addr = addr + 0x1000;
      iVar2 = iVar2 + 1;
    } while (iVar2 < iVar3);
    uVar4 = uVar4 + iVar3 * 0x1000;
    iVar5 = iVar5 + -2;
  } while (iVar5 != 0);
  return NV_SUCC;
}

u8 nv_facrotyNewRstFlagCheck(void)

{
  u8 local_9[5];

  local_9[0] = 0xff;
  flash_read(0x79000, 1, local_9);
  return '\x01' - (local_9[0] == 0xff);
}

void nv_facrotyNewRstFlagSet(void)

{
  u8 local_5[5];

  local_5[0] = 'Z';
  flash_writeWithCheck(0x79000, 1, local_5);
  return;
}

void nv_facrotyNewRstFlagClear(void)

{
  flash_erase(0x79000);
  return;
}

nv_sts_t nv_resetToFactoryNew(void)

{
  u8 uVar1;
  int iVar2;
  int iVar3;

  uVar1 = nv_facrotyNewRstFlagCheck();
  if (uVar1 == '\0')
  {
    nv_facrotyNewRstFlagSet();
  }
  iVar2 = 0;
  for (iVar3 = 1; (iVar2 == 4 || (nv_resetModule((u8)iVar2), iVar3 < 8)); iVar3 = iVar3 + 1)
  {
    iVar2 = iVar2 + 1;
  }
  nv_facrotyNewRstFlagClear();
  return NV_SUCC;
}

u32 drv_pm_deepSleep_frameCnt_get(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;

  analog_write(':', '\0');
  bVar1 = analog_read('8');
  bVar2 = analog_read('7');
  bVar3 = analog_read('6');
  bVar4 = analog_read('5');
  return (uint)bVar4 | (uint)bVar2 << 0x10 | (uint)bVar1 << 0x18 | (uint)bVar3 << 8;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void hwTimerStop(u8 tmrIdx)

{
  if (tmrIdx < 3)
  {
    timer_stop(tmrIdx);
  }
  else
  {
    _DAT_00800640 = _DAT_00800640 & 0xffefffff;
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void drv_hwTmr_irq_process(u8 tmrIdx)

{
  uint uVar1;
  int iVar2;
  u32 uVar3;
  int iVar4;

  uVar1 = (uint)tmrIdx;
  iVar4 = uVar1 * 4;
  if ((*(byte *)&hwTmr_vars.timerInfo[uVar1].flags & 3) == 2)
  {
    if (hwTmr_vars.timerInfo[uVar1].cb != ll_reset)
    {
      iVar2 = FUNBBBBC();
      if (iVar2 < 0)
      {
        hwTimerStop(tmrIdx);
        hwTmr_vars.timerInfo[uVar1].expireInfo.low = 0;
        hwTmr_vars.timerInfo[uVar1].expireInfo.high = 0;
        hwTmr_vars.timerInfo[uVar1].cb = ll_reset;
        hwTmr_vars.timerInfo[uVar1].arg = (void *)0x0;
        hwTmr_vars.timerInfo[uVar1].flags.byteVal = 0;
      }
      else
      {
        if (iVar2 != 0)
        {
          uVar3 = 0x30;
          if (2 < uVar1)
          {
            uVar3 = sysTimerPerUs;
          }
          hwTmr_vars.timerInfo[uVar1].expireInfo.low = iVar2 * uVar3;
        }
        if (hwTmr_vars.timerInfo[uVar1].expireInfo.high == 0)
        {
          uVar3 = hwTmr_vars.timerInfo[uVar1].expireInfo.low;
        }
        else
        {
          uVar3 = 0xfffffffd;
        }
        if (uVar1 < 3)
        {
          *(undefined4 *)(iVar4 + 0x800630) = 0;
          *(u32 *)(iVar4 + 0x800624) = uVar3;
        }
        else
        {
          _DAT_00800744 = uVar3 + _DAT_00800740;
        }
      }
    }
  }
  else
  {
    uVar3 = hwTmr_vars.timerInfo[uVar1].expireInfo.high - 1;
    hwTmr_vars.timerInfo[uVar1].expireInfo.high = uVar3;
    if (uVar3 == 0)
    {
      uVar3 = hwTmr_vars.timerInfo[uVar1].expireInfo.low;
      if (uVar1 < 3)
      {
        *(undefined4 *)(iVar4 + 0x800630) = 0;
        *(u32 *)(iVar4 + 0x800624) = uVar3;
      }
      else
      {
        _DAT_00800744 = _DAT_00800740 + uVar3;
      }
      *(byte *)&hwTmr_vars.timerInfo[uVar1].flags =
          *(byte *)&hwTmr_vars.timerInfo[uVar1].flags & 0xfc | 2;
    }
    else if (uVar1 < 3)
    {
      *(undefined4 *)(iVar4 + 0x800630) = 0;
      *(undefined4 *)(iVar4 + 0x800624) = 0xfffffffd;
    }
    else
    {
      _DAT_00800744 = _DAT_00800740 + -2;
    }
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNBBBBC(void)

{
  uint uVar1;
  TIMER_ModeTypeDef mode;
  code *in_r3;

  uVar1 = (*in_r3)();
  uVar1 = uVar1 & 0xff;
  if (uVar1 < 4)
  {
    memset(hwTmr_vars.timerInfo + uVar1, 0, 0x14);
    if (uVar1 == 3)
    {
      DAT_0080074c = DAT_0080074c | 2;
    }
    else
    {
      timer_set_mode((TIMER_TypeDef)uVar1, mode);
      _DAT_00800640 = 1 << uVar1 | _DAT_00800640;
    }
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void drv_hwTmr_init(u8 tmrIdx, u8 mode)

{
  uint uVar1;

  uVar1 = (uint)tmrIdx;
  if (uVar1 < 4)
  {
    memset(hwTmr_vars.timerInfo + uVar1, 0, 0x14);
    if (uVar1 == 3)
    {
      DAT_0080074c = DAT_0080074c | 2;
    }
    else
    {
      timer_set_mode(tmrIdx, mode);
      _DAT_00800640 = 1 << uVar1 | _DAT_00800640;
    }
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

hw_timer_sts_t drv_hwTmr_set(u8 tmrIdx, u32 t_us, timerCb_t func, void *arg)

{
  byte bVar1;
  uint uVar2;
  u32 en;
  uint uVar3;
  uint uVar4;
  hw_timer_sts_t hVar5;
  u32 uStack_2c;

  uVar2 = (uint)tmrIdx;
  hVar5 = HW_TIMER_INVALID;
  if (uVar2 < 4)
  {
    uStack_2c = 0x30;
    if (uVar2 == 3)
    {
      uStack_2c = sysTimerPerUs;
    }
    bVar1 = *(byte *)&hwTmr_vars.timerInfo[uVar2].flags;
    hVar5 = HW_TIMER_IS_RUNNING;
    if ((bVar1 & 3) == 0)
    {
      en = drv_disable_irq();
      hwTmr_vars.timerInfo[uVar2].expireInfo.high = bVar1 & 3;
      hwTmr_vars.timerInfo[uVar2].expireInfo.low = t_us * uStack_2c;
      hwTmr_vars.timerInfo[uVar2].cb = func;
      hwTmr_vars.timerInfo[uVar2].arg = arg;
      *(byte *)&hwTmr_vars.timerInfo[uVar2].flags =
          *(byte *)&hwTmr_vars.timerInfo[uVar2].flags & 0xfc | 2;
      uVar4 = hwTmr_vars.timerInfo[uVar2].expireInfo.low;
      if (uVar2 == 3)
      {
        uVar3 = sysTimerPerUs * 10;
      }
      else
      {
        uVar3 = 0x1e0;
      }
      if (uVar4 < uVar3)
      {
        drv_restore_irq(en);
        hwTmr_vars.timerInfo[uVar2].expireInfo.low = 0;
        hwTmr_vars.timerInfo[uVar2].expireInfo.high = 0;
        hwTmr_vars.timerInfo[uVar2].cb = ll_reset;
        hwTmr_vars.timerInfo[uVar2].arg = (void *)0x0;
        hwTmr_vars.timerInfo[uVar2].flags.byteVal = 0;
        hVar5 = HW_TIMER_SUCC;
        if (func != ll_reset)
        {
          FUNBBBBD();
        }
      }
      else
      {
        if (uVar2 == 3)
        {
          _DAT_00800744 = uVar4 + _DAT_00800740;
          _DAT_00800640 = _DAT_00800640 | 0x100000;
        }
        else
        {
          *(undefined4 *)(uVar2 * 4 + 0x800630) = 0;
          *(uint *)(uVar2 * 4 + 0x800624) = uVar4;
          timer_start(tmrIdx);
        }
        drv_restore_irq(en);
        hVar5 = HW_TIMER_SUCC;
      }
    }
  }
  return hVar5;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNBBBBD(void)

{
  code *unaff_r8;

  (*unaff_r8)();
  drv_hwTmr_irq_process('\0');
  return;
}

void drv_timer_irq0_handler(void)

{
  drv_hwTmr_irq_process('\0');
  return;
}

void drv_timer_irq1_handler(void)

{
  drv_hwTmr_irq_process('\x01');
  return;
}

void drv_timer_irq3_handler(void)

{
  drv_hwTmr_irq_process('\x03');
  return;
}

void drv_uart_rx_irq_handler(void)

{
  if (myUartDriver.recvCb != ll_reset)
  {
    FUNBBBBE();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNBBBBE(void)

{
  code *in_r3;

  (*in_r3)();
  if (uartDrvTxBuf != (u8 *)0x0)
  {
    ev_buf_free(uartDrvTxBuf);
    uartDrvTxBuf = (u8 *)0x0;
  }
  myUartDriver.status = '\x02';
  return;
}

void drv_uart_tx_irq_handler(void)

{
  if (uartDrvTxBuf != (u8 *)0x0)
  {
    ev_buf_free(uartDrvTxBuf);
    uartDrvTxBuf = (u8 *)0x0;
  }
  myUartDriver.status = '\x02';
  return;
}

void *listHead(list_t list)

{
  return *list;
}

void listAdd(list_t list, void *item)

{
  int *piVar1;
  int *piVar2;

  *(undefined *)item = 0;
  *(undefined *)((int)item + 1) = 0;
  *(undefined *)((int)item + 2) = 0;
  *(undefined *)((int)item + 3) = 0;
  piVar1 = (int *)*list;
  if ((int *)*list == (int *)0x0)
  {
    *list = item;
  }
  else
  {
    do
    {
      piVar2 = piVar1;
      piVar1 = (int *)*piVar2;
    } while ((int *)*piVar2 != (int *)0x0);
    *(char *)piVar2 = (char)item;
    *(char *)((int)piVar2 + 1) = (char)((uint)item >> 8);
    *(char *)((int)piVar2 + 2) = (char)((uint)item >> 0x10);
    *(char *)((int)piVar2 + 3) = (char)((uint)item >> 0x18);
  }
  return;
}

void listRemove(list_t list, void *item)

{
  void *pvVar1;
  void **ppvVar2;
  void **ppvVar3;

  ppvVar2 = (void **)*list;
  if (ppvVar2 != (void **)0x0)
  {
    if (ppvVar2 == (void **)item)
    {
      *list = *ppvVar2;
    }
    else
    {
      do
      {
        ppvVar3 = ppvVar2;
        ppvVar2 = (void **)*ppvVar3;
        if (ppvVar2 == (void **)0x0)
        {
          return;
        }
      } while ((void **)item != ppvVar2);
      pvVar1 = *ppvVar2;
      *(char *)ppvVar3 = (char)pvVar1;
      *(char *)((int)ppvVar3 + 1) = (char)((uint)pvVar1 >> 8);
      *(char *)((int)ppvVar3 + 2) = (char)((uint)pvVar1 >> 0x10);
      *(char *)((int)ppvVar3 + 3) = (char)((uint)pvVar1 >> 0x18);
    }
    *(undefined *)ppvVar2 = 0;
    *(undefined *)((int)ppvVar2 + 1) = 0;
    *(undefined *)((int)ppvVar2 + 2) = 0;
    *(undefined *)((int)ppvVar2 + 3) = 0;
  }
  return;
}

int listLength(list_t list)

{
  int iVar1;
  undefined4 *puVar2;

  iVar1 = 0;
  for (puVar2 = (undefined4 *)*list; puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2)
  {
    iVar1 = iVar1 + 1;
  }
  return iVar1;
}

mem_pool_t *mempool_init(mem_pool_t *pool, void *mem, int itemsize, int itemcount)

{
  uint uVar1;
  undefined *puVar2;
  undefined *puVar3;
  int iVar4;

  if ((mem == (void *)0x0) || (pool == (mem_pool_t *)0x0))
  {
    pool = (mem_pool_t *)0x0;
  }
  else
  {
    *(char *)&pool->free_list = (char)mem;
    *(char *)((int)&pool->free_list + 1) = (char)((uint)mem >> 8);
    *(char *)((int)&pool->free_list + 2) = (char)((uint)mem >> 0x10);
    *(char *)((int)&pool->free_list + 3) = (char)((uint)mem >> 0x18);
    uVar1 = itemsize + 3U & 0xfffffffc;
    if (1 < itemcount)
    {
      iVar4 = 0;
      puVar2 = (undefined *)mem;
      do
      {
        puVar3 = puVar2 + uVar1;
        *puVar2 = (char)puVar3;
        puVar2[1] = (char)((uint)puVar3 >> 8);
        puVar2[2] = (char)((uint)puVar3 >> 0x10);
        puVar2[3] = (char)((uint)puVar3 >> 0x18);
        iVar4 = iVar4 + 1;
        puVar2 = puVar3;
      } while (iVar4 != itemcount + -2);
      mem = (void *)((int)mem + uVar1 * (itemcount + -3) + uVar1);
    }
    *(undefined *)mem = 0;
    *(undefined *)((int)mem + 1) = 0;
    *(undefined *)((int)mem + 2) = 0;
    *(undefined *)((int)mem + 3) = 0;
  }
  return pool;
}

void *mempool_alloc(mem_pool_t *pool)

{
  mem_block_t *pmVar1;
  mem_block_t *pmVar2;
  char *pcVar3;

  pmVar1 = pool->free_list;
  pcVar3 = (char *)0x0;
  if (pmVar1 != (mem_block_t *)0x0)
  {
    pmVar2 = pmVar1->next_block;
    *(char *)&pool->free_list = (char)pmVar2;
    *(char *)((int)&pool->free_list + 1) = (char)((uint)pmVar2 >> 8);
    *(char *)((int)&pool->free_list + 2) = (char)((uint)pmVar2 >> 0x10);
    *(char *)((int)&pool->free_list + 3) = (char)((uint)pmVar2 >> 0x18);
    pcVar3 = pmVar1->data;
  }
  return pcVar3;
}

void mempool_free(mem_pool_t *pool, void *p)

{
  mem_block_t *pmVar1;
  undefined *puVar2;

  puVar2 = (undefined *)((int)p + -4);
  pmVar1 = pool->free_list;
  *puVar2 = (char)pmVar1;
  *(char *)((int)p + -3) = (char)((uint)pmVar1 >> 8);
  *(char *)((int)p + -2) = (char)((uint)pmVar1 >> 0x10);
  *(char *)((int)p + -1) = (char)((uint)pmVar1 >> 0x18);
  *(char *)&pool->free_list = (char)puVar2;
  *(char *)((int)&pool->free_list + 1) = (char)((uint)puVar2 >> 8);
  *(char *)((int)&pool->free_list + 2) = (char)((uint)puVar2 >> 0x10);
  *(char *)((int)&pool->free_list + 3) = (char)((uint)puVar2 >> 0x18);
  return;
}

int memcmp(void *m1, void *m2, uint n)

{
  int iVar1;
  uint uVar2;
  uint uVar3;

  iVar1 = 0;
  if (n != 0)
  {
    // WARNING: Load size is inaccurate
    uVar3 = (uint)*m1;
    // WARNING: Load size is inaccurate
    uVar2 = (uint)*m2;
    if (uVar3 == uVar2)
    {
      iVar1 = 0;
      do
      {
        if (n - 1 == iVar1)
        {
          return 0;
        }
        m1 = (void *)((int)m1 + 1);
        // WARNING: Load size is inaccurate
        uVar3 = (uint)*m1;
        iVar1 = iVar1 + 1;
        uVar2 = (uint) * (byte *)((int)m2 + iVar1);
      } while (uVar3 == uVar2);
    }
    iVar1 = uVar3 - uVar2;
  }
  return iVar1;
}

void bcopy(char *src, char *dest, int len)

{
  int iVar1;
  uint uVar2;

  if (dest < src)
  {
    if (len != 0)
    {
      iVar1 = 0;
      do
      {
        dest[iVar1] = src[iVar1];
        iVar1 = iVar1 + 1;
      } while (iVar1 != len);
    }
  }
  else if (len != 0)
  {
    uVar2 = 0;
    do
    {
      dest[uVar2 + len + -1] = src[uVar2 + len + -1];
      uVar2 = uVar2 - 1;
    } while (uVar2 != ~len);
  }
  return;
}

void *memset(void *dest, int val, uint len)

{
  u8 uVar1;
  uint uVar2;

  uVar1 = is_ev_buf(dest);
  if ((uVar1 == '\0') || (len < 0x3f9))
  {
    if (len != 0)
    {
      uVar2 = 0;
      do
      {
        *(char *)((int)dest + uVar2) = (char)val;
        uVar2 = uVar2 + 1;
      } while (uVar2 != len);
    }
  }
  else
  {
    sys_exceptionPost(0x74, '\0');
    dest = (void *)0x0;
  }
  return dest;
}

void *memcpy(void *out, void *in, uint length)

{
  u8 uVar1;

  if (length == 0)
  {
    out = (void *)0x0;
  }
  else
  {
    uVar1 = is_ev_buf(out);
    if ((uVar1 == '\0') || (length < 0x3f9))
    {
      bcopy((char *)in, (char *)out, length);
    }
    else
    {
      sys_exceptionPost(0x8b, '\0');
      out = (void *)0x0;
    }
  }
  return out;
}

uint xcrc32(uchar *buf, int len, uint init)

{
  byte *pbVar1;

  if (len != 0)
  {
    pbVar1 = buf + len;
    do
    {
      init = crc32_table[(init ^ *buf) & 0xff] ^ init >> 8;
      buf = buf + 1;
    } while (buf != pbVar1);
  }
  return init;
}

void adc_set_ref_voltage(ADC_ChTypeDef ch_n, ADC_RefVolTypeDef v_ref)

{
  byte bVar1;

  analog_write(0xe7, v_ref << 2 | v_ref << 4 | v_ref);
  if (v_ref == 2)
  {
    bVar1 = analog_read(0xfa);
    analog_write(0xfa, bVar1 & 0xc0 | 0x3d);
  }
  else
  {
    bVar1 = analog_read(0xfa);
    analog_write(0xfa, bVar1 & 0xc0 | 0x15);
    adc_gpio_calib_vref = adc_ref_vol[v_ref];
  }
  return;
}

void adc_set_resolution(ADC_ChTypeDef ch_n, ADC_ResTypeDef v_res)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    bVar1 = analog_read(0xeb);
    analog_write(0xeb, bVar1 & 0xfc | v_res);
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    bVar1 = analog_read(0xeb);
    analog_write(0xeb, bVar1 & 0xcf | v_res << 4);
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    bVar1 = analog_read(0xec);
    analog_write(0xec, v_res | bVar1 & 0xfc);
  }
  return;
}

void adc_set_tsample_cycle(ADC_ChTypeDef ch_n, ADC_SampCycTypeDef adcST)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    bVar1 = analog_read(0xed);
    analog_write(0xed, bVar1 & 0xf0 | adcST);
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    bVar1 = analog_read(0xed);
    analog_write(0xed, bVar1 & 0xf | (byte)((adcST & 0xf) << 4));
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    analog_write(0xee, adcST);
  }
  return;
}

void adc_set_input_mode(ADC_ChTypeDef ch_n, ADC_InputModeTypeDef m_input)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    if (m_input == SINGLE_ENDED_MODE)
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 & 0xef);
    }
    else
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 | 0x10);
    }
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    if (m_input == SINGLE_ENDED_MODE)
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 & 0xdf);
    }
    else
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 | 0x20);
    }
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    if (m_input == SINGLE_ENDED_MODE)
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 & 0xbf);
    }
    else
    {
      bVar1 = analog_read(0xec);
      analog_write(0xec, bVar1 | 0x40);
    }
  }
  return;
}

void adc_set_ain_channel_differential_mode(ADC_ChTypeDef ch_n, ADC_InputPchTypeDef InPCH, ADC_InputNchTypeDef InNCH)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;

  uVar3 = (uint)InPCH;
  uVar2 = (uint)ch_n;
  if ((int)(uVar2 << 0x1f) < 0)
  {
    analog_write(0xe9, (byte)((uVar3 & 0xf) << 4) | InNCH);
    bVar1 = analog_read(0xec);
    analog_write(0xec, bVar1 | 0x10);
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    analog_write(0xea, (byte)((uVar3 & 0xf) << 4) | InNCH);
    bVar1 = analog_read(0xec);
    analog_write(0xec, bVar1 | 0x20);
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    analog_write(0xe8, InNCH | (byte)((uVar3 & 0xf) << 4));
    bVar1 = analog_read(0xec);
    analog_write(0xec, bVar1 | 0x40);
  }
  return;
}

void adc_vbat_pin_init(GPIO_PinTypeDef pin)

{
  char cVar1;
  byte *pbVar2;
  GPIO_PinTypeDef *pGVar3;
  ADC_InputPchTypeDef InPCH;
  int iVar4;

  gpio_set_func(pin, AS_GPIO);
  gpio_set_input_en(pin, 0);
  iVar4 = (((uint)pin << 0x10) >> 0x18) * 8;
  pbVar2 = (byte *)(iVar4 + 0x800582);
  *pbVar2 = *pbVar2 & ~(byte)pin;
  pbVar2 = (byte *)(iVar4 + 0x800583);
  *pbVar2 = (byte)pin | *pbVar2;
  pGVar3 = ADC_GPIO_tab;
  cVar1 = '\0';
  do
  {
    if ((uint)*pGVar3 == (uint)pin)
    {
      InPCH = cVar1 + B0P;
      goto LAB_00010b5e;
    }
    cVar1 = cVar1 + '\x01';
    pGVar3 = pGVar3 + 1;
  } while (cVar1 != '\n');
  InPCH = NOINPUTP;
LAB_00010b5e:
  adc_set_input_mode(ADC_MISC_CHN, DIFFERENTIAL_MODE);
  adc_set_ain_channel_differential_mode(ADC_MISC_CHN, InPCH, GND);
  return;
}

void adc_base_pin_init(GPIO_PinTypeDef pin)

{
  char cVar1;
  ADC_InputPchTypeDef InPCH;
  byte *pbVar2;
  GPIO_PinTypeDef *pGVar3;
  int iVar4;

  gpio_set_func(pin, AS_GPIO);
  gpio_set_input_en(pin, 0);
  iVar4 = (((uint)pin << 0x10) >> 0x18) * 8;
  pbVar2 = (byte *)(iVar4 + 0x800582);
  *pbVar2 = *pbVar2 | (byte)pin;
  pbVar2 = (byte *)(iVar4 + 0x800583);
  *pbVar2 = *pbVar2 & ~(byte)pin;
  pGVar3 = ADC_GPIO_tab;
  cVar1 = '\0';
  do
  {
    if ((uint)*pGVar3 == (uint)pin)
    {
      InPCH = cVar1 + B0P;
      goto LAB_00010bd2;
    }
    cVar1 = cVar1 + '\x01';
    pGVar3 = pGVar3 + 1;
  } while (cVar1 != '\n');
  InPCH = NOINPUTP;
LAB_00010bd2:
  adc_set_ain_channel_differential_mode(ADC_MISC_CHN, InPCH, GND);
  return;
}

void adc_set_ain_pre_scaler(ADC_PreScalingTypeDef v_scl)

{
  byte bVar1;
  uint uVar2;

  uVar2 = (uint)v_scl;
  bVar1 = analog_read(0xfa);
  analog_write(0xfa, bVar1 & 0x3f | (byte)((uVar2 & 3) << 6));
  if (uVar2 == 0)
  {
    bVar1 = analog_read(0xf9);
    analog_write(0xf9, bVar1 & 0xcf);
  }
  else
  {
    bVar1 = analog_read(0xf9);
    analog_write(0xf9, bVar1 | 0x10);
  }
  adc_pre_scale = (uchar)(1 << uVar2);
  return;
}

void adc_init(void)

{
  byte bVar1;

  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xdf | 0x20);
  DAT_00800061 = 0;
  bVar1 = analog_read(0x82);
  analog_write(0x82, bVar1 | 0x40);
  analog_write(0xf4, '\x05');
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xbf | 0x40);
  analog_read(0xfc);
  analog_write(0xfc, '\x7f');
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xfc | 1);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xf3 | 4);
  DAT_00800b10 = DAT_00800b10 & 0xfb;
  analog_write(0xef, 0xff);
  analog_write(0xf0, '\0');
  analog_write(0xf1, 0xcf);
  return;
}

void adc_set_gpio_calib_vref(ushort data)

{
  adc_gpio_calib_vref = data;
  return;
}

void adc_set_gpio_two_point_calib_offset(char offset)

{
  adc_gpio_calib_vref_offset = offset;
  return;
}

void adc_base_init(GPIO_PinTypeDef pin)

{
  byte bVar1;

  analog_write(0xf2, '$');
  adc_vref = adc_gpio_calib_vref;
  adc_vref_offset = adc_gpio_calib_vref_offset;
  adc_set_ref_voltage(ADC_MISC_CHN, ADC_VREF_1P2V);
  bVar1 = analog_read(0xf9);
  analog_write(0xf9, bVar1 & 0xf3);
  adc_base_pin_init(pin);
  adc_set_resolution(ADC_MISC_CHN, RES14);
  adc_set_tsample_cycle(ADC_MISC_CHN, SAMPLING_CYCLES_6);
  adc_set_ain_pre_scaler(ADC_PRESCALER_1F8);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xef);
  return;
}

void adc_vbat_init(GPIO_PinTypeDef pin)

{
  byte bVar1;

  analog_write(0xf2, '$');
  bVar1 = analog_read(0xf9);
  analog_write(0xf9, bVar1 & 0xf3);
  adc_vref = adc_gpio_calib_vref;
  adc_vref_offset = adc_gpio_calib_vref_offset;
  adc_vbat_pin_init(pin);
  adc_set_ref_voltage(ADC_MISC_CHN, ADC_VREF_1P2V);
  adc_set_resolution(ADC_MISC_CHN, RES14);
  adc_set_tsample_cycle(ADC_MISC_CHN, SAMPLING_CYCLES_6);
  adc_set_ain_pre_scaler(ADC_PRESCALER_1F8);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xef);
  return;
}

void flash_erase_sector(ulong addr)

{
  flash_mspi_write_ram(' ', addr, '\x01', (uchar *)0x0, 0);
  return;
}

void flash_read_page(ulong addr, ulong len, uchar *buf)

{
  flash_mspi_read_ram('\x03', addr, '\x01', '\0', buf, len);
  return;
}

void flash_write_page(ulong addr, ulong len, uchar *buf)

{
  uint data_len;

  data_len = 0x100 - (addr & 0xff);
  while (true)
  {
    if (len < data_len)
    {
      data_len = len;
    }
    flash_mspi_write_ram('\x02', addr, '\x01', buf, data_len);
    addr = addr + data_len;
    buf = buf + data_len;
    len = len - data_len;
    if (len == 0)
      break;
    data_len = 0x100;
  }
  return;
}

uchar flash_read_status(uchar cmd)

{
  uchar local_9[5];

  local_9[0] = '\0';
  flash_mspi_read_ram(cmd, 0, '\0', '\0', local_9, 1);
  return local_9[0];
}

void flash_write_status(flash_status_typedef_e type, ushort data)

{
  ushort local_8[4];

  local_8[0] = data;
  if (type == FLASH_TYPE_8BIT_STATUS)
  {
    flash_mspi_write_ram('\x01', 0, '\0', (uchar *)local_8, 1);
  }
  else if (type == FLASH_TYPE_16BIT_STATUS_ONE_CMD)
  {
    flash_mspi_write_ram('\x01', 0, '\0', (uchar *)local_8, 2);
  }
  return;
}

// WARNING: Variable defined which should be unmapped: flash_mid

uint flash_read_mid(void)

{
  uchar buf[4];
  uint auStack_10[2];
  uint flash_mid;

  auStack_10[0] = 0;
  flash_mspi_read_ram(0x9f, 0, '\0', '\0', (uchar *)auStack_10, 3);
  if (auStack_10[0] == 0x1460c8)
  {
    buf = (uchar[4])0x0;
    flash_mspi_read_ram('Z', 0, '\x01', '\x01', buf, 4);
    if ((((buf[0] == 'S') && (buf[1] == 'F')) && (buf[2] == 'D')) && (buf[3] == 'P'))
    {
      auStack_10[0] = 0x11460c8;
    }
  }
  return auStack_10[0];
}

void flash_read_uid(uchar idcmd, uchar *buf)

{
  if (idcmd == 'K')
  {
    flash_mspi_read_ram('K', 0, '\x01', '\x01', buf, 0x10);
  }
  else if (idcmd == 'Z')
  {
    flash_mspi_read_ram('Z', 0x80, '\x01', '\x01', buf, 0x10);
  }
  return;
}

int flash_read_mid_uid_with_check(uint *flash_mid, uchar *flash_uid)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  undefined4 local_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 local_18;

  uStack_1c = 0x1510151;
  uStack_20 = 0x1510151;
  local_24 = 0x1510151;
  local_18 = 0x1510151;
  uVar1 = flash_read_mid();
  *flash_mid = uVar1;
  if ((((((uVar1 == 0x11460c8) || (uVar1 == 0x1460c8)) || (uVar1 == 0x1060c8)) ||
        ((uVar1 == 0x134051 || (uVar1 == 0x136085)))) ||
       ((uVar1 == 0x1360c8 || ((uVar1 == 0x1360eb || (uVar1 == 0x13325e)))))) ||
      (uVar2 = 0, uVar1 == 0x14325e))
  {
    flash_read_uid('K', flash_uid);
    iVar3 = 0;
    iVar4 = 0;
    do
    {
      uVar1 = (uint)flash_uid[iVar4] - (uint) * (byte *)((int)&local_24 + iVar4);
      iVar3 = iVar3 + uVar1 + ~uVar1 +
              (uint)((uint) * (byte *)((int)&local_24 + iVar4) <= (uint)flash_uid[iVar4]);
      iVar4 = iVar4 + 1;
    } while (iVar4 != 0x10);
    uVar2 = (uint)(iVar3 != 0x10);
  }
  return uVar2;
}

uchar flash_is_zb(void)

{
  uchar uVar1;
  uint uVar2;

  uVar2 = flash_read_mid();
  if ((uVar2 == 0x14325e) ||
      (~(uVar2 - 0x13325e) + (uVar2 - 0x13325e) + (uint)(0x13325d < uVar2) != 0))
  {
    g_flashIsZbit = '\x01';
    uVar1 = '\x01';
  }
  else
  {
    g_flashIsZbit = '\0';
    uVar1 = '\0';
  }
  return uVar1;
}

void flash_safe_voltage_set(ushort vol)

{
  g_flashWorkVol = vol;
  return;
}

void flash_vdd_f_calib(void)

{
  uchar uVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  byte local_9[5];

  uVar4 = flash_read_mid();
  local_9[0] = 0;
  switch ((uVar4 << 8) >> 0x18)
  {
  case 0x10:
    flash_read_page(0xe1c0, 1, local_9);
    break;
  case 0x11:
    flash_read_page(0x1e1c0, 1, local_9);
    break;
  default:
    local_9[0] = 0xff;
    goto LAB_000110b6;
  case 0x13:
    flash_read_page(0x771c0, 1, local_9);
    break;
  case 0x14:
    flash_read_page(0xfe1c0, 1, local_9);
    break;
  case 0x15:
    flash_read_page(0x1fe1c0, 1, local_9);
  }
  bVar2 = local_9[0];
  if ((local_9[0] == 0xff) || ((local_9[0] & 0xf8) != 0))
  {
  LAB_000110b6:
    uVar1 = flash_is_zb();
    if (uVar1 != '\0')
    {
      bVar2 = analog_read('\f');
      analog_write('\f', bVar2 | 7);
    }
  }
  else
  {
    bVar3 = analog_read('\f');
    analog_write('\f', bVar2 | bVar3 & 0xf8);
  }
  return;
}

void flash_write_status_mid13325e(uchar data, mid13325e_write_status_bit_e bit)

{
  mid13325e_write_status_bit_e mVar1;

  mVar1 = flash_read_status('\x05');
  if ((bit & mVar1) != data)
  {
    flash_write_status(FLASH_TYPE_8BIT_STATUS, (ushort)data | (ushort)mVar1 & ~(ushort)bit);
  }
  return;
}

void flash_unlock_mid13325e(void)

{
  flash_write_status_mid13325e('\0', FLASH_WRITE_STATUS_BP_MID13325E);
  return;
}

s32 brc_toggleCb(void *arg)

{
  int iVar1;
  u8 seqNo;
  undefined4 local_18;
  undefined4 uStack_14;
  undefined4 uStack_10;
  undefined4 uStack_c;
  undefined2 local_8;

  seqNo = zcl_seqNum;
  uStack_14 = 0;
  local_8 = 0;
  uStack_c = 0x1020000;
  local_18 = 0xfffe;
  uStack_10 = 0x104;
  iVar1 = (uint)brc_toggleCb::toggle + ~(uint)brc_toggleCb::toggle;
  brc_toggleCb::toggle = (u8)iVar1;
  if (iVar1 == 0)
  {
    zcl_seqNum = zcl_seqNum + '\x01';
    zcl_onOff_off('\x01', (epInfo_t *)&local_18, '\0', seqNo);
  }
  else
  {
    zcl_seqNum = zcl_seqNum + '\x01';
    zcl_onOff_on('\x01', (epInfo_t *)&local_18, '\0', seqNo);
  }
  return 0;
}

void led_on(u32 pin)

{
  drv_gpio_write(pin, '\x01');
  return;
}

void led_off(u32 pin)

{
  drv_gpio_write(pin, '\0');
  return;
}

void light_on(void)

{
  led_on(8);
  return;
}

void light_off(void)

{
  led_off(8);
  return;
}

s32 zclLightTimerCb(void *arg)

{
  ushort uVar1;
  uint uVar2;
  int iVar3;
  bool bVar4;

  uVar2 = (uint)g_appGwCtx.sta;
  bVar4 = uVar2 <= g_appGwCtx.oriSta;
  if (g_appGwCtx.oriSta == uVar2)
  {
    g_appGwCtx.times = g_appGwCtx.times + 0xff;
    bVar4 = true;
    if (g_appGwCtx.times == '\0')
    {
      g_appGwCtx.timerLedEvt._0_1_ = g_appGwCtx.times;
      g_appGwCtx.timerLedEvt._1_1_ = g_appGwCtx.times;
      g_appGwCtx.timerLedEvt._2_1_ = g_appGwCtx.times;
      g_appGwCtx.timerLedEvt._3_1_ = g_appGwCtx.times;
      return -2;
    }
  }
  iVar3 = uVar2 + ~uVar2 + (uint)bVar4;
  g_appGwCtx.sta = (u8)iVar3;
  if (iVar3 == 0)
  {
    light_off();
    uVar1 = g_appGwCtx.ledOffTime;
  }
  else
  {
    light_on();
    uVar1 = g_appGwCtx.ledOnTime;
  }
  return (uint)uVar1;
}

void light_init(void)

{
  led_on(8);
  return;
}

void light_blink_start(u8 times, u16 ledOnTime, u16 ledOffTime)

{
  uint t_ms;
  bool bVar1;

  g_appGwCtx.times = times;
  if (g_appGwCtx.timerLedEvt == (ev_timer_event_t *)0x0)
  {
    bVar1 = g_appGwCtx.oriSta != '\0';
    if (bVar1)
    {
      light_off();
      t_ms = (uint)ledOffTime;
    }
    else
    {
      light_on();
      t_ms = (uint)ledOnTime;
    }
    g_appGwCtx.sta = !bVar1;
    g_appGwCtx.ledOnTime._0_1_ = (undefined)ledOnTime;
    g_appGwCtx.ledOnTime._1_1_ = (undefined)((uint)ledOnTime >> 8);
    g_appGwCtx.ledOffTime._0_1_ = (undefined)ledOffTime;
    g_appGwCtx.ledOffTime._1_1_ = (undefined)((uint)ledOffTime >> 8);
    g_appGwCtx.timerLedEvt = ev_timer_taskPost(zclLightTimerCb, (void *)0x0, t_ms);
  }
  return;
}

void light_blink_stop(void)

{
  if (g_appGwCtx.timerLedEvt != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_appGwCtx.timerLedEvt);
    g_appGwCtx.times = '\0';
    if (g_appGwCtx.oriSta == '\0')
    {
      light_off();
    }
    else
    {
      light_on();
    }
  }
  return;
}

void brc_toggle(void)

{
  if (brc_toggleEvt == (ev_timer_event_t *)0x0)
  {
    brc_toggleEvt = ev_timer_taskPost(brc_toggleCb, (void *)0x0, 1000);
  }
  else
  {
    ev_timer_taskCancel(&brc_toggleEvt);
  }
  return;
}

void buttonShortPressed(u8 btNum)

{
  bool bVar1;
  char cVar2;

  if (btNum == '\x01')
  {
    bVar1 = zb_isDeviceJoinedNwk();
    if (bVar1 != false)
    {
      brc_toggle();
    }
  }
  else if (btNum == '\x02')
  {
    bVar1 = zb_isDeviceJoinedNwk();
    cVar2 = '\x01';
    if (bVar1 != false)
    {
      bVar1 = zb_getMacAssocPermit();
      zb_nlmePermitJoiningRequest(~(bVar1 + ~bVar1 + cVar2) & 0xb4);
      gpsCommissionModeInvork();
    }
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void keyScan_keyPressedCB(kb_data_t *kbEvt)

{
  u8 btNum;

  btNum = kbEvt->keycode[0];
  buttonShortPressed(btNum);
  if (btNum == '\x01')
  {
    g_appGwCtx.keyPressedTime._0_1_ = (undefined)_DAT_00800740;
    g_appGwCtx.keyPressedTime._1_1_ = (undefined)((uint)_DAT_00800740 >> 8);
    g_appGwCtx.keyPressedTime._2_1_ = (undefined)((uint)_DAT_00800740 >> 0x10);
    g_appGwCtx.keyPressedTime._3_1_ = (undefined)((uint)_DAT_00800740 >> 0x18);
    g_appGwCtx.state = '\x01';
  }
  return;
}

void app_key_handler(void)

{
  u32 uVar1;

  uVar1 = kb_scan_key(0, 1);
  if (uVar1 != 0)
  {
    T_keyPressedNum = T_keyPressedNum + '\x01';
    if (kb_event.cnt == '\0')
    {
      g_appGwCtx.state = '\0';
      app_key_handler::valid_keyCode = 0xff;
    }
    else
    {
      keyScan_keyPressedCB(&kb_event);
      if (kb_event.cnt == '\x01')
      {
        app_key_handler::valid_keyCode = kb_event.keycode[0];
      }
    }
  }
  return;
}

void sampleGwSysException(void)

{
  DAT_0080006f = 0x20;
  return;
}

void app_task(void)

{
  bool bVar1;

  bVar1 = zb_getMacAssocPermit();
  if ((bool)app_task::assocPermit != bVar1)
  {
    app_task::assocPermit = zb_getMacAssocPermit();
    if ((bool)app_task::assocPermit == false)
    {
      led_off(4);
    }
    else
    {
      led_on(4);
    }
  }
  if (g_bdbCtx.state == '\0')
  {
    app_key_handler();
  }
  return;
}

void stack_init(void)

{
  zb_init();
  zb_zdoCbRegister(&appCbLst);
  return;
}

void user_app_init(void)

{
  af_nodeDescManuCodeUpdate(0x1141);
  zcl_init(sampleGW_zclProcessIncomingMsg);
  af_endpointRegister('\x01', &sampleGW_simpleDesc, zcl_rx_handler, sampleGW_dataSendConfirm);
  zcl_register('\x01', SAMPLE_GW_CB_CLUSTER_NUM, g_sampleGwClusterList);
  gp_init('\x01');
  ota_init(OTA_TYPE_SERVER, &sampleGW_simpleDesc, &sampleGW_otaInfo, (ota_callBack_t *)0x0);
  return;
}

void led_init(void)

{
  led_off(4);
  light_init();
  return;
}

void user_init(u8 isRetention)

{
  u8 uVar1;

  uVar1 = firmwareCheckWithUID();
  if (uVar1 != '\0')
  {
    do
    {
      // WARNING: Do nothing block with infinite loop
    } while (true);
  }
  led_init();
  stack_init();
  sys_exceptHandlerRegister(sampleGwSysException);
  user_app_init();
  ev_on_poll(EV_POLL_IDLE, app_task);
  bdb_init(&sampleGW_simpleDesc, &g_bdbCommissionSetting, &g_zbDemoBdbCb, '\x01');
  return;
}

void zbdemo_bdbIdentifyCb(u8 endpoint, u16 srcAddr, u16 identifyTime)

{
  sampleGW_zclIdentifyCmdHandler(endpoint, srcAddr, identifyTime);
  return;
}

void zbdemo_bdbCommissioningCb(u8 status, void *arg)

{
  if (status != '\0')
  {
    if (status == '\x01')
    {
      return;
    }
    if (status == '\x02')
    {
      return;
    }
    if (status == '\x03')
    {
      return;
    }
    if (status == '\x04')
    {
      return;
    }
    if (status == '\x05')
    {
      return;
    }
    if (status == '\x06')
    {
      return;
    }
    if (status == '\a')
    {
      return;
    }
    if (status == '\b')
    {
      return;
    }
    if (status == '\t')
    {
      return;
    }
    if (status == '\n')
    {
      return;
    }
    if (status != '\r')
    {
      return;
    }
    tl_zbMacChannelSet('\x0f');
  }
  heartInterval = 1000;
  return;
}

void zbdemo_bdbInitCb(u8 status, u8 joinedNetwork)

{
  if (status == '\0')
  {
    if (joinedNetwork == '\0')
    {
      bdb_networkFormationStart();
      heartInterval = 500;
    }
    else
    {
      heartInterval = 1000;
    }
  }
  else
  {
    heartInterval = 200;
  }
  return;
}

void sampleGW_devAnnHandler(zdo_device_annce_req_t *pDevAnnceReq)

{
  return;
}

void sampleGW_leaveCnfHandler(nlme_leave_cnf_t *pLeaveCnf)

{
  return;
}

void sampleGW_leaveIndHandler(nlme_leave_ind_t *pLeaveInd)

{
  return;
}

void sampleGW_dataSendConfirm(void *arg)

{
  return;
}

u8 sampleGW_nwkUpdateIndicateHandler(nwkCmd_nwkUpdate_t *pNwkUpdateCmd)

{
  return '\0';
}

u8 sampleGW_tcJoinIndHandler(zdo_tc_join_ind_t *pTcJoinInd)

{
  return '\x01';
}

void sampleGW_tcFrameCntReachedHandler(void)

{
  ss_tcUpdateNwkKey_t updateNwkKey;

  updateNwkKey.dstAddr._0_4_ = 0;
  updateNwkKey.dstAddr._4_4_ = 0;
  drv_generateRandomData(updateNwkKey.key, '\x10');
  zb_tcUpdateNwkKey(&updateNwkKey);
  return;
}

s32 sampleGW_zclIdentifyTimerCb(void *arg)

{
  s32 sVar1;

  if (g_zcl_identifyAttrs.identifyTime == 0)
  {
    identifyTimerEvt = (ev_timer_event_t *)0x0;
    sVar1 = -2;
  }
  else
  {
    g_zcl_identifyAttrs.identifyTime = g_zcl_identifyAttrs.identifyTime - 1;
    sVar1 = 0;
  }
  return sVar1;
}

void sampleGW_zclProcessIncomingMsg(zclIncoming_t *pInHdlrMsg)

{
  return;
}

status_t sampleGW_basicCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}

void sampleGW_zclIdentifyTimerStop(void)

{
  if (identifyTimerEvt != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&identifyTimerEvt);
  }
  return;
}

void sampleGW_zclIdentifyCmdHandler(u8 endpoint, u16 srcAddr, u16 identifyTime)

{
  g_zcl_identifyAttrs.identifyTime._0_1_ = (u8)identifyTime;
  g_zcl_identifyAttrs.identifyTime._1_1_ = (undefined)((uint)identifyTime >> 8);
  if (identifyTime == 0)
  {
    sampleGW_zclIdentifyTimerStop();
    light_blink_stop();
  }
  else if (identifyTimerEvt == (ev_timer_event_t *)0x0)
  {
    light_blink_start((u8)g_zcl_identifyAttrs.identifyTime, 500, 500);
    identifyTimerEvt = ev_timer_taskPost(sampleGW_zclIdentifyTimerCb, (void *)0x0, 1000);
  }
  return;
}

status_t sampleGW_identifyCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  byte bVar1;
  u8 times;

  if ((pAddrInfo->dstEp == '\x01') && ((pAddrInfo->field_0x9 & 1) == 0))
  {
    if (cmdId == '\0')
    {
      // WARNING: Load size is inaccurate
      sampleGW_zclIdentifyCmdHandler('\x01', pAddrInfo->srcAddr, *cmdPayload);
    }
    else if (cmdId == '@')
    {
      // WARNING: Load size is inaccurate
      bVar1 = *cmdPayload;
      if (bVar1 == 2)
      {
        light_blink_start('\x02', 0xfa, 0xfa);
      }
      else
      {
        if (bVar1 < 3)
        {
          if (bVar1 == 0)
          {
            light_blink_start('\x01', 500, 500);
            return '\0';
          }
          if (bVar1 != 1)
          {
            return '\0';
          }
          times = '\x0f';
        }
        else
        {
          if (bVar1 != 0xfe)
          {
            if (0xfe < bVar1)
            {
              light_blink_stop();
              return '\0';
            }
            if (bVar1 != 0xb)
            {
              return '\0';
            }
            light_blink_start('\x01', 500, 0x1d4c);
            return '\0';
          }
          times = '\x01';
        }
        light_blink_start(times, 300, 700);
      }
    }
  }
  return '\0';
}

status_t sampleGW_groupCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}

status_t sampleGW_sceneCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}

status_t sampleGW_doorLockCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  return '\0';
}

status_t sampleGW_iasZoneCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  if (((pAddrInfo->dstEp == '\x01') && ((pAddrInfo->field_0x9 & 1) != 0)) && (cmdId == '\0'))
  {
    light_blink_start('\x05', 0xfa, 0xfa);
  }
  return '\0';
}

status_t sampleGW_pollCtrlCb(zclIncomingAddrInfo_t *pAddrInfo, u8 cmdId, void *cmdPayload)

{
  status_t sVar1;
  uint local_20;
  undefined4 uStack_1c;
  uint uStack_18;
  undefined4 uStack_14;
  undefined2 local_10;
  uint local_c;

  sVar1 = '\0';
  if (((pAddrInfo->dstEp == '\x01') && ((pAddrInfo->field_0x9 & 1) != 0)) && (cmdId == '\0'))
  {
    uStack_1c = 0;
    local_10 = 0;
    local_20 = (uint)pAddrInfo->srcAddr;
    uStack_14 = CONCAT13(pAddrInfo->srcEp, 0x20000);
    uStack_18 = (uint)pAddrInfo->profileId;
    local_c = (local_c >> 8 & 0xff0000) << 8;
    zcl_pollCtrl_chkInRsp('\x01', (epInfo_t *)&local_20, '\x01', pAddrInfo->seqNum, (zcl_chkInRsp_t *)&local_c);
    sVar1 = 0xff;
  }
  return sVar1;
}

u8 firmwareCheckWithUID(void)

{
  return '\0';
}

void main(void)

{
  u8 isRetention;
  byte bVar1;
  int iVar2;

  iVar2 = drv_platform_init();
  bVar1 = (char)iVar2 - 1;
  isRetention = bVar1 + ~bVar1 + (iVar2 != 0);
  os_init(isRetention);
  user_init(isRetention);
  drv_enable_irq();
  do
  {
    ev_main();
    tl_zbTaskProcedure();
  } while (true);
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 secondClockPeriodic(void)

{
  uint uVar1;

  if (g_secondCnt != -1)
  {
    g_secondCnt = g_secondCnt + 1;
  }
  uVar1 = 0;
  do
  {
    secondClockStop();
    uVar1 = uVar1 + 1 & 0xff;
  } while (*(int *)(timeoutsCb + uVar1 * 4) != 0);
  return 0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void secondClockStop(void)

{
  code *in_r3;

  (*in_r3)();
  secondTimer._4_4_ = secondClockPeriodic;
  ev_on_timer((ev_timer_event_t *)secondTimer, 1000);
  return;
}

void secondClockInit(void)

{
  secondTimer._4_4_ = secondClockPeriodic;
  ev_on_timer((ev_timer_event_t *)secondTimer, 1000);
  return;
}

void secondClockRun(void)

{
  u8 uVar1;

  uVar1 = ev_timer_exist((ev_timer_event_t *)secondTimer);
  if (uVar1 == '\0')
  {
    secondClockInit();
  }
  return;
}

void tl_zbBufferInit(void)

{
  u32 len;
  uint uVar1;
  int iVar2;
  int iVar3;
  int iVar4;

  len = zbBufferSizeGet();
  memset(&g_mPool, 0, len);
  iVar3 = 0x844130;
  g_mPool.head._0_1_ = 0x30;
  g_mPool.head._1_1_ = 0x41;
  g_mPool.head._2_1_ = 0x84;
  g_mPool.head._3_1_ = 0;
  uVar1 = (uint)ZB_BUF_POOL_SIZE;
  if (1 < uVar1)
  {
    iVar2 = 0;
    iVar4 = iVar3;
    do
    {
      iVar3 = iVar4 + 0xd0;
      *(char *)(iVar4 + 0xc4) = (char)iVar3;
      *(char *)(iVar4 + 0xc5) = (char)((uint)iVar3 >> 8);
      *(char *)(iVar4 + 0xc6) = (char)((uint)iVar3 >> 0x10);
      *(char *)(iVar4 + 199) = (char)((uint)iVar3 >> 0x18);
      iVar2 = iVar2 + 1;
      iVar4 = iVar3;
    } while (iVar2 < (int)(uVar1 - 1));
  }
  *(undefined *)(iVar3 + 0xc4) = 0;
  *(undefined *)(iVar3 + 0xc5) = 0;
  *(undefined *)(iVar3 + 0xc6) = 0;
  *(undefined *)(iVar3 + 199) = 0;
  return;
}

u8 *tl_phyRxBufTozbBuf(u8 *p)

{
  return p + -(uint)RX_ZBBUF_OFFSET;
}

u8 zb_buf_free(zb_buf_t *buf)

{
  u32 en;
  uint uVar1;
  uint uVar2;

  en = drv_disable_irq();
  if (buf == (zb_buf_t *)g_zbMacCtx.txRawDataBuf)
  {
    if (buf == (zb_buf_t *)0x0)
    {
      sys_exceptionPost(0xa6, '\x11');
    }
    goto LAB_00011a76;
  }
  if ((buf < g_mPool.pool) || (&g_mPool.pool[ZB_BUF_POOL_SIZE - 1].hdr <= buf))
  {
    sys_exceptionPost(0xb2, '\x11');
  }
  uVar2 = buf->freeCnt + 1;
  *(char *)&buf->freeCnt = (char)uVar2;
  *(char *)((int)&buf->freeCnt + 1) = (char)(uVar2 >> 8);
  *(char *)((int)&buf->freeCnt + 2) = (char)(uVar2 >> 0x10);
  *(char *)((int)&buf->freeCnt + 3) = (char)(uVar2 >> 0x18);
  uVar1 = (uint)(byte)(buf->hdr).field_0x3;
  if ((int)(uVar1 << 0x1e) < 0)
  {
    uVar1 = ((uVar1 << 0x1e) >> 0x1f) << 0x18;
    if (buf->allocCnt < uVar2)
    {
      uVar2 = 0x10000;
    }
    else
    {
    LAB_000119a0:
      uVar2 = 0;
    }
  LAB_000119a2:
    T_zbBufFreeDbg = uVar2 | uVar1 | (byte)(buf->hdr).field_0x3 & 1;
    T_zbBufDbg = buf;
    sys_exceptionPost(0xc5, '\x12');
  }
  else
  {
    if (buf->allocCnt < uVar2)
    {
      uVar1 = ((uVar1 << 0x1e) >> 0x1f) << 0x18;
      uVar2 = 0x10000;
      goto LAB_000119a2;
    }
    if (-1 < (int)(uVar1 << 0x1f))
    {
      uVar1 = ((uVar1 << 0x1e) >> 0x1f) << 0x18;
      goto LAB_000119a0;
    }
  }
  if (((g_mPool.head < g_mPool.pool) && (g_mPool.head != (zb_buf_t *)0x0)) ||
      ((zb_buf_t *)((int)&g_mPool + (ZB_BUF_POOL_SIZE - 1) * 0xd0 + 8) < g_mPool.head))
  {
    sys_exceptionPost(0xca, '\x13');
  }
  g_mPool.usedNum = g_mPool.usedNum - 1;
  *(char *)&buf->next = (char)g_mPool.head;
  *(char *)((int)&buf->next + 1) = (char)((uint)g_mPool.head >> 8);
  *(char *)((int)&buf->next + 2) = (char)((uint)g_mPool.head >> 0x10);
  *(char *)((int)&buf->next + 3) = (char)((uint)g_mPool.head >> 0x18);
  g_mPool.head = buf;
  if ((buf < g_mPool.pool) ||
      ((zb_buf_t *)((int)&g_mPool + (ZB_BUF_POOL_SIZE - 1) * 0xd0 + 8) < buf))
  {
    sys_exceptionPost(0xd3, '\x13');
  }
  (buf->hdr).field_0x3 = (buf->hdr).field_0x3 & 0xfe;
  (buf->hdr).handle = 0xff;
LAB_00011a76:
  drv_restore_irq(en);
  return '\0';
}

void *tl_bufInitalloc(zb_buf_t *p, u8 size)

{
  return p->buf + (0xc0 - ((uint)size * 0x1000000 + 0x8000000 >> 0x18) & 0xfffffffc);
}

void zb_buf_clear(zb_buf_t *p)

{
  byte bVar1;
  u32 en;

  bVar1 = (p->hdr).field_0x3;
  en = drv_disable_irq();
  (p->hdr).id = '\0';
  (p->hdr).handle = '\0';
  (p->hdr).rssi = '\0';
  (p->hdr).field_0x3 = 0;
  (p->hdr).field_0x3 = bVar1 & 1 | (p->hdr).field_0x3 & 0xfe;
  drv_restore_irq(en);
  return;
}

bool is_zb_buf(void *p)

{
  byte bVar1;

  bVar1 = 0;
  if ((void *)((int)&g_mPool.usedNum + 3) < p)
  {
    bVar1 = ~-(p < &g_mPool.pool[ZB_BUF_POOL_SIZE - 1].hdr);
  }
  return (bool)bVar1;
}

u8 zb_info_load(void)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashReadNew('\x01', '\0', '\x01', 0xc0, (u8 *)&g_zbInfo);
  return nVar1;
}

void zb_info_save(void *arg)

{
  nv_flashWriteNew('\x01', 0, '\x01', 0xc0, (u8 *)&g_zbInfo);
  return;
}

void zb_nwkKeySet(void)

{
  u32 uVar1;
  undefined4 *puVar2;
  u8 *puVar3;
  undefined4 *puVar4;
  undefined4 local_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined4 uStack_14;
  undefined2 auStack_10[2];

  puVar4 = &local_20;
  local_20 = 0;
  uStack_1c = 0;
  uStack_18 = 0;
  uStack_14 = 0;
  puVar3 = "";
  do
  {
    puVar2 = (undefined4 *)"";
    if (*puVar3 != '\0')
      goto LAB_00011c00;
    puVar3 = puVar3 + 1;
  } while (puVar3 != linkKeyDistributedCertification);
  do
  {
    uVar1 = drv_u32Rand();
    *(short *)puVar4 = (short)uVar1;
    puVar4 = (undefined4 *)((int)puVar4 + 2);
    puVar2 = &local_20;
  } while (puVar4 != (undefined4 *)auStack_10);
LAB_00011c00:
  (*(code *)&ss_zdoNwkKeyConfigure)(puVar2, 0, 1);
  return;
}

void zb_reset(void)

{
  tl_zbMacReset();
  tl_zbNwkInit('\x01');
  aps_init();
  zb_nwkKeySet();
  ss_zdoUseKey(0);
  tl_bdbAttrInit();
  return;
}

void zb_init(void)

{
  u8 uVar1;

  uVar1 = nv_facrotyNewRstFlagCheck();
  if (uVar1 != '\0')
  {
    nv_resetToFactoryNew();
  }
  uVar1 = zb_info_load();
  if (uVar1 == '\0')
  {
    tl_zbMacInit('\0');
    tl_zbNwkInit('\0');
    aps_init();
  }
  else
  {
    tl_zbMacInit('\x01');
    tl_zbNwkInit('\x01');
    aps_init();
    zb_nwkKeySet();
    ss_zdoUseKey(0);
    tl_bdbAttrInit();
  }
  af_init();
  zdo_init();
  return;
}

void os_reset(u8 isRetention)

{
  if (isRetention == '\0')
  {
    ev_buf_init();
    ev_timer_init();
    zb_sched_init();
    tl_zbBufferInit();
  }
  secondClockRun();
  return;
}

void os_init(u8 isRetention)

{
  os_reset(isRetention);
  return;
}

int buf_type_get(void *param_1)

{
  bool bVar1;
  u8 uVar2;
  int iVar3;

  bVar1 = is_zb_buf(param_1);
  iVar3 = 0;
  if (bVar1 == false)
  {
    uVar2 = is_ev_buf(param_1);
    iVar3 = 2 - (uint)(uVar2 != '\0');
  }
  return iVar3;
}

tl_zb_task_t *tl_zbTaskQPop(u8 idx, tl_zb_task_t *taskInfo)

{
  byte bVar1;
  void *pvVar2;
  tl_zb_callback_t pvVar3;
  u32 en;
  int iVar4;
  tl_zb_task_t *ptVar5;

  *(undefined *)&taskInfo->data = 0;
  *(undefined *)((int)&taskInfo->data + 1) = 0;
  *(undefined *)((int)&taskInfo->data + 2) = 0;
  *(undefined *)((int)&taskInfo->data + 3) = 0;
  *(undefined *)&taskInfo->tlCb = 0;
  *(undefined *)((int)&taskInfo->tlCb + 1) = 0;
  *(undefined *)((int)&taskInfo->tlCb + 2) = 0;
  *(undefined *)((int)&taskInfo->tlCb + 3) = 0;
  en = drv_disable_irq();
  if (idx == 0)
  {
    ptVar5 = (tl_zb_task_t *)0x0;
    if ((uint)taskQ_user[256] == (uint)taskQ_user[257])
      goto LAB_00011de4;
    ptVar5 = (tl_zb_task_t *)(taskQ_user + (taskQ_user[257] & 0x1f) * 8);
    taskQ_user[257] = taskQ_user[257] + 1;
  }
  else
  {
    iVar4 = (idx - 1) * 0x84;
    bVar1 = g_zbTaskQ[iVar4 + 0x81];
    ptVar5 = (tl_zb_task_t *)0x0;
    if ((uint)(byte)g_zbTaskQ[iVar4 + 0x80] == (uint)bVar1)
      goto LAB_00011de4;
    ptVar5 = (tl_zb_task_t *)(g_zbTaskQ + (bVar1 & 0xf) * 8 + iVar4);
    g_zbTaskQ[iVar4 + 0x81] = bVar1 + 1;
  }
  pvVar2 = ptVar5->data;
  *(char *)&taskInfo->data = (char)pvVar2;
  *(char *)((int)&taskInfo->data + 1) = (char)((uint)pvVar2 >> 8);
  *(char *)((int)&taskInfo->data + 2) = (char)((uint)pvVar2 >> 0x10);
  *(char *)((int)&taskInfo->data + 3) = (char)((uint)pvVar2 >> 0x18);
  pvVar3 = ptVar5->tlCb;
  *(char *)&taskInfo->tlCb = (char)pvVar3;
  *(char *)((int)&taskInfo->tlCb + 1) = (char)((uint)pvVar3 >> 8);
  *(char *)((int)&taskInfo->tlCb + 2) = (char)((uint)pvVar3 >> 0x10);
  *(char *)((int)&taskInfo->tlCb + 3) = (char)((uint)pvVar3 >> 0x18);
  iVar4 = buf_type_get(ptVar5->data);
  if ((iVar4 == 0) && (-1 < (int)((uint) * (byte *)((int)ptVar5->data + 0xc3) << 0x1f)))
  {
    T_DBG_taskQPop_cb = ptVar5->tlCb;
    T_DBG_taskQPop_idx = idx;
    T_DBG_taskQPop_data = ptVar5->data;
    sys_exceptionPost(0x56, '\x13');
  }
LAB_00011de4:
  drv_restore_irq(en);
  return ptVar5;
}

void zb_sched_init(void)

{
  memset(taskQ_user, 0, 0x102);
  memset(g_zbTaskQ, 0, 0x294);
  return;
}

u8 tl_zbUserTaskQNum(void)

{
  return taskQ_user[256] - taskQ_user[257];
}

void tl_zbTaskProcedure(void)

{
  tl_zb_task_t *ptVar1;
  tl_zb_task_t local_10;

  tl_zbMacTaskProc();
  tl_zbNwkTaskProc();
  ptVar1 = tl_zbTaskQPop('\0', &local_10);
  if (ptVar1 != (tl_zb_task_t *)0x0)
  {
    FUN_00011e70(local_10.data);
  }
  zdo_ssInfoUpdate();
  return;
}

u8 FUN_00011e70(void)

{
  u8 uVar1;
  int iVar2;
  zb_buf_t *buf;
  code *in_r3;
  tl_zb_task_t tStack_14;

  tStack_14.tlCb = (tl_zb_callback_t)(*in_r3)();
  uVar1 = tl_zbTaskQPush('\0', &tStack_14);
  if (uVar1 != '\0')
  {
    iVar2 = buf_type_get(buf);
    if (iVar2 == 0)
    {
      sys_exceptionPost(0xc1, '\x15');
      zb_buf_free(buf);
    }
    else if (iVar2 == 1)
    {
      sys_exceptionPost(0xc5, 's');
      ev_buf_free(buf->buf);
    }
    else
    {
      sys_exceptionPost(0xc9, '\x05');
    }
  }
  return uVar1;
}

u8 tl_zbTaskPost(tl_zb_callback_t func, void *arg)

{
  u8 uVar1;
  int iVar2;
  tl_zb_task_t local_14;

  local_14.tlCb = func;
  local_14.data = arg;
  uVar1 = tl_zbTaskQPush('\0', &local_14);
  if (uVar1 != '\0')
  {
    iVar2 = buf_type_get(arg);
    if (iVar2 == 0)
    {
      sys_exceptionPost(0xc1, '\x15');
      zb_buf_free((zb_buf_t *)arg);
    }
    else if (iVar2 == 1)
    {
      sys_exceptionPost(0xc5, 's');
      ev_buf_free((u8 *)arg);
    }
    else
    {
      sys_exceptionPost(0xc9, '\x05');
    }
  }
  return uVar1;
}

u8 tl_zbPrimitivePost(u8 layerQ, u8 primitive, void *arg)

{
  u8 uVar1;
  tl_zb_task_t local_1c;

  T_exceptTaskPost._0_1_ = layerQ;
  T_exceptTaskPost._1_1_ = primitive;
  if (arg == (void *)0x0)
  {
    sys_exceptionPost(0xd8, '\x10');
  }
  *(u8 *)((int)arg + 0xc0) = primitive;
  local_1c.tlCb = (tl_zb_callback_t)0x0;
  local_1c.data = arg;
  uVar1 = tl_zbTaskQPush(layerQ, &local_1c);
  if (uVar1 != '\0')
  {
    if ((layerQ == '\x01') && ((primitive == 'L' || (primitive == 'B'))))
    {
      zb_buf_free((zb_buf_t *)arg);
    }
    else
    {
      sys_exceptionPost(0xe6, '\x15');
    }
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbPhyIndication(void)

{
  byte bVar1;
  u8 uVar2;
  u8 uVar3;
  u8 uVar4;
  bool bVar5;
  zb_buf_t *in_r0;
  int iVar6;
  int in_r1;
  char *pcVar7;
  uint in_r2;
  uint length;
  uint uVar8;
  char *pcVar9;
  uint uVar10;
  byte bVar11;

  uVar10 = in_r2 & 0xff;
  bVar1 = **(byte **)(in_r0->buf + 4);
  bVar11 = bVar1 & 7;
  if (*(char *)(in_r1 + 2) == '\x02')
  {
    if (*(short *)(in_r1 + 8) == -1)
    {
      g_sysDiags.macRxBcast = g_sysDiags.macRxBcast + 1;
    }
    else
    {
      g_sysDiags.macRxUcast = g_sysDiags.macRxUcast + 1;
    }
  }
  if (macAppIndCb == (int *)0x0)
  {
  LAB_00011fde:
    pcVar7 = (char *)(*(int *)(in_r0->buf + 4) + uVar10);
    in_r0->buf[4] = (u8)pcVar7;
    in_r0->buf[5] = (u8)((uint)pcVar7 >> 8);
    in_r0->buf[6] = (u8)((uint)pcVar7 >> 0x10);
    in_r0->buf[7] = (u8)((uint)pcVar7 >> 0x18);
    if (bVar11 == 1)
    {
      tl_zbPhyMldeIndication();
      return;
    }
    if ((bVar1 & 7) != 0)
    {
      if (bVar11 == 3)
      {
      LAB_0001200e:
        tl_zbPhyMlmeIndicate();
        return;
      }
      goto LAB_00011fd2;
    }
  }
  else
  {
    if ((bVar1 & 7) != 0)
    {
      if (bVar11 == 3)
      {
        if (*macAppIndCb == 0)
        {
          iVar6 = *(int *)(in_r0->buf + 4) + uVar10;
          in_r0->buf[4] = (u8)iVar6;
          in_r0->buf[5] = (u8)((uint)iVar6 >> 8);
          in_r0->buf[6] = (u8)((uint)iVar6 >> 0x10);
          in_r0->buf[7] = (u8)((uint)iVar6 >> 0x18);
        }
        else
        {
          pcVar7 = (char *)(*(int *)(in_r0->buf + 4) + uVar10);
          if (*pcVar7 == '\a')
          {
            iVar6 = FUNBBBBF();
            if (iVar6 == 0)
              goto LAB_00011fd2;
            pcVar7 = (char *)(*(int *)(in_r0->buf + 4) + uVar10);
          }
          in_r0->buf[4] = (u8)pcVar7;
          in_r0->buf[5] = (u8)((uint)pcVar7 >> 8);
          in_r0->buf[6] = (u8)((uint)pcVar7 >> 0x10);
          in_r0->buf[7] = (u8)((uint)pcVar7 >> 0x18);
        }
        goto LAB_0001200e;
      }
      goto LAB_00011fde;
    }
    if (macAppIndCb[1] == 0)
      goto LAB_00011fde;
    iVar6 = FUNBBBBF();
    if (iVar6 == 0)
      goto LAB_00011fd2;
    pcVar7 = (char *)(*(int *)(in_r0->buf + 4) + uVar10);
    in_r0->buf[4] = (u8)pcVar7;
    in_r0->buf[5] = (u8)((uint)pcVar7 >> 8);
    in_r0->buf[6] = (u8)((uint)pcVar7 >> 0x10);
    in_r0->buf[7] = (u8)((uint)pcVar7 >> 0x18);
  }
  uVar10 = in_r0->buf[0x13] - uVar10;
  length = uVar10 & 0xff;
  in_r0->buf[0x13] = (u8)(uVar10 * 0x1000000 >> 0x18);
  if (g_zbInfo.macPib.autoReq == '\0')
  {
    uVar2 = in_r0->buf[0x14];
    uVar3 = in_r0->buf[0x15];
    if ((((*pcVar7 != -1) || ((pcVar7[1] & 0xfU) != 0xf)) || (pcVar7[2] != '\0')) || (length < 5))
      goto LAB_00011fd2;
    bVar1 = pcVar7[3];
    uVar10 = 4;
    if ((bVar1 & 7) != 0)
    {
      uVar10 = (bVar1 & 7) * 0x2000000 + 0x4000000 >> 0x18;
    }
    uVar8 = ((uint)bVar1 << 0x19) >> 0x1d;
    if (uVar8 != 0)
    {
      uVar10 = uVar8 * 8 + uVar10;
    }
    if (length < uVar10 + 0xf)
      goto LAB_00011fd2;
    uVar8 = length;
    if (length < 0x1e)
    {
      uVar8 = 0x1e;
    }
    if ((char *)0xc0 < pcVar7 + (length - (int)in_r0) + uVar8)
      goto LAB_00011fd2;
    pcVar9 = pcVar7 + uVar8;
    memcpy(pcVar9, pcVar7, length);
    memcpy(in_r0->buf + 6, pcVar9, 2);
    uVar4 = pcVar9[2];
    in_r0->buf[0x1e] = uVar4;
    if ((uVar4 != '\0') || ((in_r0->buf[6] & 0xf) != 0xf))
      goto LAB_00011fd2;
    memcpy(in_r0->buf + 4, (void *)(in_r1 + 0x10), 2);
    in_r0->buf[0x10] = *(u8 *)(in_r1 + 3);
    in_r0->buf[0x1f] = uVar2;
    in_r0->buf[0x1c] = uVar3;
    memcpy(in_r0->buf + 8, (void *)(in_r1 + 0x12), 8);
    in_r0->buf[0x2c] = *(u8 *)(in_r1 + 5);
    in_r0->buf[0x24] = '\0';
    in_r0->buf[0x25] = '\0';
    in_r0->buf[0x26] = '\0';
    in_r0->buf[0x27] = '\0';
    in_r0->buf[0x2e] = '\x0f';
    pcVar9 = pcVar9 + uVar10;
    in_r0->buf[0x28] = (u8)pcVar9;
    in_r0->buf[0x29] = (u8)((uint)pcVar9 >> 8);
    in_r0->buf[0x2a] = (u8)((uint)pcVar9 >> 0x10);
    in_r0->buf[0x2b] = (u8)((uint)pcVar9 >> 0x18);
    tl_zbPrimitivePost('\x01', 'L', in_r0);
    if (g_zbMacCtx.status == '\x02')
    {
      tl_zbMacActiveScanListAdd();
    }
    bVar5 = false;
    if (g_zbInfo.macPib.autoReq == '\0')
    {
      return;
    }
  }
  else
  {
    bVar5 = true;
  }
  if (g_zbMacCtx.status == '\x02')
  {
    tl_zbMacActiveScanListAdd();
  }
  if (!bVar5)
  {
    return;
  }
LAB_00011fd2:
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNBBBBF(void)

{
  code *in_r3;

  g_zbMacCtx.curChannel = (*in_r3)();
  rf_setChannel(g_zbMacCtx.curChannel);
  return;
}

void tl_zbMacChannelSet(u8 chan)

{
  g_zbMacCtx.curChannel = chan;
  rf_setChannel(chan);
  return;
}

void mac_pibNvInit(char param_1)

{
  u32 uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;

  if (param_1 != '\0')
  {
    memcpy(&g_zbInfo, &macPibDefault, 0x4c);
    generateIEEEAddr();
    uVar1 = drv_u32Rand();
    g_zbInfo.macPib.seqNum = (u8)uVar1;
    uVar1 = drv_u32Rand();
    uVar3 = (uint)g_zbInfo.macPib.maxBe;
    uVar2 = (uint)g_zbInfo.macPib.minBe;
    if (uVar3 < uVar2)
    {
      uVar7 = 0;
      uVar3 = uVar2;
      g_zbInfo.macPib.maxBe = g_zbInfo.macPib.minBe;
    }
    else
    {
      uVar7 = uVar3 - uVar2;
    }
    uVar5 = (uint)g_zbInfo.macPib.maxCsmaBackoffs;
    if ((int)uVar5 < (int)uVar7)
    {
      uVar7 = uVar5;
    }
    uVar7 = uVar7 & 0xff;
    iVar4 = 0;
    if (uVar7 != 0)
    {
      iVar6 = 0;
      do
      {
        iVar4 = iVar4 + (1 << iVar6 + uVar2);
        iVar6 = iVar6 + 1;
      } while (iVar6 < (int)uVar7);
    }
    iVar4 = (((1 << uVar3) + -1) * (uVar5 - uVar7) + 1 + iVar4) * 0x1280000;
    g_zbInfo.macPib.frameTotalWaitTime._0_1_ = (undefined)((uint)iVar4 >> 0x10);
    g_zbInfo.macPib.frameTotalWaitTime._1_1_ = (undefined)((uint)iVar4 >> 0x18);
    g_zbInfo.macPib.beaconSeqNum = (u8)uVar1;
  }
  tl_zbMacChannelSet(g_zbInfo.macPib.phyChannelCur);
  return;
}

void tl_zbMacReset(void)

{
  mac_pibNvInit(1);
  g_zbInfo.macPib.associationPermit = '\0';
  return;
}

void tl_zbMacInit(u8 coldReset)

{
  mac_pibNvInit(coldReset);
  mac_trxInit();
  g_zbInfo.macPib.associationPermit = '\0';
  g_zbMacCtx.txRawDataBuf = (u8 *)c1();
  return;
}

void tl_zbMaxTxConfirmCb(u8 *param_1, undefined param_2)

{
  u8 uVar1;

  uVar1 = param_1[0xc1];
  if (param_1 == g_zbMacCtx.txRawDataBuf)
  {
    param_1[0xc3] = param_1[0xc3] & 0xf7;
  }
  if (uVar1 == 0xe0)
  {
    tl_zbMacAssociateRequestStatusCheck(param_1, param_2);
  }
  else if (uVar1 == 0xe1)
  {
    tl_zbMacCommStatusSend();
  }
  else if (uVar1 == 0xe2)
  {
    tl_zbMacDisassociateNotifyCmdConfirm();
  }
  else if ((byte)(uVar1 + 0x18) < 2)
  {
    tl_zbMacDataRequestStatusCheck();
  }
  else if (uVar1 == 0xe6)
  {
    tl_zbMacStartReqConfirm();
  }
  else if ((uVar1 != 0xea) && (uVar1 != 0xe4))
  {
    if (uVar1 == 0xe7)
    {
      tl_zbMacCmdPanIdConflictNotifySendCheck();
    }
    else if (uVar1 == 0xe3)
    {
      tl_zbMacMlmeBeaconSendConfirm();
    }
    else if (uVar1 == 0xe5)
    {
      tl_zbMacOrphanResponseStatusCheck();
    }
    else
    {
      tl_zbMacMcpsDataRequestSendConfirm();
    }
  }
  return;
}

void tl_zbMacTaskProc(void)

{
  tl_zb_task_t *ptVar1;
  int iVar2;
  undefined1 *puVar3;
  tl_zb_task_t tStack_1c;

  ptVar1 = tl_zbTaskQPop('\x02', &tStack_1c);
  if ((ptVar1 != (tl_zb_task_t *)0x0) && (tStack_1c.data != (void *)0x0))
  {
    puVar3 = g_zbMacEventFromNwkTbl;
    iVar2 = 0;
    do
    {
      if ((*puVar3 == *(char *)((int)tStack_1c.data + 0xc0)) &&
          (*(int *)(g_zbMacEventFromNwkTbl + iVar2 * 5 + 1) != 0))
      {
        tl_zbReadyToPullParentForAssoRsp();
        break;
      }
      iVar2 = iVar2 + 1;
      puVar3 = puVar3 + 5;
    } while (iVar2 != 8);
  }
  zb_macTimerEventProc();
  return;
}

undefined4 tl_zbReadyToPullParentForAssoRsp(void)

{
  void *pvVar1;
  void *out;
  code *in_r3;
  undefined local_24;
  undefined uStack_23;
  undefined auStack_22[8];
  undefined auStack_1a[8];
  undefined uStack_12;

  (*in_r3)();
  if (associationReqOrigBuffer != (void *)0x0)
  {
    out = (void *)c1();
    pvVar1 = associationReqOrigBuffer;
    if (out == (void *)0x0)
    {
      memset(associationReqOrigBuffer, 0, 0x16);
      *(undefined *)((int)pvVar1 + 10) = 0x1a;
      tl_zbPrimitivePost('\x01', 'F', associationReqOrigBuffer);
      associationReqOrigBuffer = (void *)0x0;
    }
    else
    {
      memcpy(out, associationReqOrigBuffer, 0x19);
      local_24 = 3;
      memcpy(auStack_22, g_zbInfo.macPib.extAddress, 8);
      uStack_23 = *(undefined *)((int)out + 0xc);
      memcpy(auStack_1a, (void *)((int)out + 4), 8);
      uStack_12 = 0;
      tl_zbMacMlmeDataRequestCmdSend(&local_24, out, 0xe9);
      tl_zbMacIndirectDataTimerStart(tl_zbWaitForAssociationRespTimeout, associationReqOrigBuffer);
    }
  }
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbWaitForAssociationRespTimeout(void)

{
  void *in_r0;
  undefined4 uVar1;

  uVar1 = 0;
  if (in_r0 != (void *)0x0)
  {
    memset(in_r0, 0, 0x16);
    *(undefined *)((int)in_r0 + 10) = 0xeb;
    tl_zbPrimitivePost('\x01', 'F', in_r0);
    associationReqOrigBuffer = 0;
    g_zbMacCtx.status = '\0';
    tl_zbSwitchOffRx();
    g_zbMacCtx.indirectData.timer._0_1_ = 0;
    g_zbMacCtx.indirectData.timer._1_1_ = 0;
    g_zbMacCtx.indirectData.timer._2_1_ = 0;
    g_zbMacCtx.indirectData.timer._3_1_ = 0;
    uVar1 = 0xfffffffe;
  }
  return uVar1;
}

void tl_zbMacAssociateRespReceived(void)

{
  tl_zbMacIndirectDataTimerCancel();
  g_zbMacCtx.status = '\0';
  return;
}

void tl_zbMacAssociateRequestStatusCheck(undefined4 param_1, byte param_2)

{
  void *pvVar1;
  u32 t_ms;
  uint uVar2;

  pvVar1 = associationReqOrigBuffer;
  uVar2 = (uint)param_2;
  if ((uVar2 == 0x20) || (~uVar2 + uVar2 + (uint)(0x1f < uVar2) != 0))
  {
    t_ms = FUN_00001624((uint)g_zbInfo.macPib.respWaitTime * 0x3c00, 1000);
    ev_timer_taskPost(tl_zbReadyToPullParentForAssoRsp, (void *)0x0, t_ms);
  }
  else
  {
    memset(associationReqOrigBuffer, 0, 0x16);
    *(byte *)((int)pvVar1 + 10) = param_2;
    tl_zbPrimitivePost('\x01', 'F', associationReqOrigBuffer);
    associationReqOrigBuffer = (void *)0x0;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacAssociateRequestHandler(void)

{
  u8 *p;
  u8 uVar1;
  u8 *in_r0;
  undefined *puVar2;
  int iVar3;
  undefined auStack_34[8];
  undefined2 uStack_2c;
  undefined auStack_2a[10];

  p = g_zbMacCtx.txRawDataBuf;
  if ((-1 < (int)((uint)g_zbMacCtx.txRawDataBuf[0xc3] << 0x1c)) &&
      (associationReqOrigBuffer == (u8 *)0x0))
  {
    g_zbMacCtx.txRawDataBuf[0xc3] = g_zbMacCtx.txRawDataBuf[0xc3] | 8;
    g_zbMacCtx.curChannel = *in_r0;
    associationReqOrigBuffer = in_r0;
    rf_setChannel(*in_r0);
    uStack_2c = 0xfffe;
    memcpy(auStack_34, in_r0 + 4, 8);
    memcpy(auStack_2a, g_zbInfo.macPib.extAddress, 8);
    uVar1 = tl_zbMacHdrSize((ushort)in_r0[0xc] << 10 | 0xc023);
    tl_bufInitalloc((zb_buf_t *)p, uVar1 + '\x02');
    p[0xc1] = 0xe0;
    puVar2 = (undefined *)tl_zbMacHdrBuilder();
    *puVar2 = 1;
    puVar2[1] = in_r0[0xd];
    iVar3 = tl_zbMacTx();
    if (iVar3 == 0)
    {
      return;
    }
  }
  memset(in_r0, 0, 0x16);
  in_r0[10] = 0xf2;
  tl_zbPrimitivePost('\x01', 'F', in_r0);
  associationReqOrigBuffer = (u8 *)0x0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacAssociateResponseHandler(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;
  void *pvVar2;
  undefined *puVar3;
  int iVar4;
  undefined auStack_38[8];
  u16 uStack_30;
  undefined auStack_2e[10];
  undefined auStack_24[8];
  undefined uStack_1c;

  if ((int)((uint)g_zbNwkCtx._45_1_ << 0x1a) < 0)
  {
    zb_buf_free(in_r0);
  }
  else
  {
    uStack_30 = g_zbInfo.macPib.panId;
    memcpy(auStack_38, in_r0->buf + 2, 8);
    memcpy(auStack_2e, g_zbInfo.macPib.extAddress, 8);
    uVar1 = tl_zbMacHdrSize(0xcc63);
    pvVar2 = tl_bufInitalloc(in_r0, uVar1 + '\x04');
    puVar3 = (undefined *)tl_zbMacHdrBuilder();
    *puVar3 = 2;
    memcpy(puVar3 + 1, in_r0, 2);
    puVar3[3] = in_r0->buf[10];
    uStack_1c = 3;
    memcpy(auStack_24, in_r0->buf + 2, 8);
    in_r0->buf[0] = (u8)pvVar2;
    in_r0->buf[1] = (u8)((uint)pvVar2 >> 8);
    in_r0->buf[2] = (u8)((uint)pvVar2 >> 0x10);
    in_r0->buf[3] = (u8)((uint)pvVar2 >> 0x18);
    in_r0->buf[4] = uVar1 + '\x04';
    (in_r0->hdr).handle = 0xe1;
    iVar4 = macDataPending();
    if (iVar4 != 0)
    {
      tl_zbMacCommStatusSend();
    }
  }
  return;
}

void tl_zbMacDisassociateNotifyCmdConfirm(void *param_1, undefined param_2)

{
  *(undefined *)((int)param_1 + 0xb) = param_2;
  tl_zbPrimitivePost('\x01', 'J', param_1);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int tl_macMlmeDisassociateNotifyCmdSend(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;
  undefined *puVar2;
  int iVar3;
  char in_r1;
  u16 auStack_38[4];
  u16 uStack_30;
  undefined auStack_2e[10];
  undefined auStack_24[8];
  u8 uStack_1c;

  uStack_30 = g_zbInfo.macPib.panId;
  if (in_r0->buf[0xb] == '\x01')
  {
    memcpy(auStack_38, in_r0->buf + 2, 8);
  }
  else if (in_r0->buf[0xb] == '\x02')
  {
    if (in_r0->buf[10] == '\x02')
    {
      auStack_38[0] = g_zbInfo.macPib.coordShortAddress;
    }
    else
    {
      memcpy(auStack_38, g_zbInfo.macPib.coordExtAddress, 8);
    }
  }
  memcpy(auStack_2e, g_zbInfo.macPib.extAddress, 8);
  uVar1 = tl_zbMacHdrSize((ushort)in_r0->buf[10] << 10 | 0xc063);
  tl_bufInitalloc(in_r0, uVar1 + '\x02');
  puVar2 = (undefined *)tl_zbMacHdrBuilder();
  (in_r0->hdr).handle = 0xe2;
  *puVar2 = 3;
  puVar2[1] = in_r0->buf[0xb];
  if (in_r1 == '\0')
  {
    iVar3 = tl_zbMacTx();
    if (iVar3 != 0)
    {
      iVar3 = 0xe1;
    }
  }
  else
  {
    uStack_1c = in_r0->buf[10];
    memcpy(auStack_24, auStack_38, 8);
    iVar3 = macDataPending();
  }
  return iVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacDisassociateRequestHandler(void)

{
  u16 *in_r0;
  int iVar1;

  iVar1 = 0xe8;
  if ((g_zbInfo.macPib.panId != *in_r0) ||
      (iVar1 = tl_macMlmeDisassociateNotifyCmdSend(), iVar1 != 0))
  {
    *(char *)((int)in_r0 + 0xb) = (char)iVar1;
    tl_zbPrimitivePost('\x01', 'J', in_r0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined *tl_zbMacHdrBuilder(void)

{
  undefined *in_r0;
  uint uVar1;
  ushort *in_r1;
  uint uVar2;
  uint uVar3;
  undefined *out;

  uVar3 = (uint)*in_r1;
  uVar1 = (uVar3 << 0x14) >> 0x1e;
  uVar2 = (uVar3 << 0x10) >> 0x1e;
  *in_r0 = (char)*in_r1;
  in_r0[1] = (char)(uVar3 >> 8);
  in_r0[2] = g_zbInfo.macPib.seqNum;
  out = in_r0 + 3;
  g_zbInfo.macPib.seqNum = g_zbInfo.macPib.seqNum + '\x01';
  if (uVar1 != 0)
  {
    in_r0[3] = *(undefined *)(in_r1 + 3);
    in_r0[4] = *(undefined *)((int)in_r1 + 7);
    if (uVar1 == 3)
    {
      memcpy(in_r0 + 5, in_r1 + 4, 8);
      out = in_r0 + 0xd;
    }
    else
    {
      in_r0[5] = *(undefined *)(in_r1 + 4);
      in_r0[6] = *(undefined *)((int)in_r1 + 9);
      out = in_r0 + 7;
    }
  }
  if (uVar2 != 0)
  {
    if (-1 < (int)(uVar3 << 0x19))
    {
      *out = *(undefined *)(in_r1 + 8);
      out[1] = *(undefined *)((int)in_r1 + 0x11);
      out = out + 2;
    }
    if (uVar2 == 3)
    {
      memcpy(out, in_r1 + 9, 8);
      out = out + 8;
    }
    else
    {
      *out = *(undefined *)(in_r1 + 9);
      out[1] = *(undefined *)((int)in_r1 + 0x13);
      out = out + 2;
    }
  }
  return out;
}

uint tl_zbMacHdrParse(ushort *param_1, ushort *param_2)

{
  ushort uVar1;
  uint uVar2;
  uint uVar3;
  void *in;

  uVar1 = *param_2;
  uVar2 = (uint)uVar1;
  memset(param_1, 0, 0x1a);
  *param_1 = uVar1;
  *(undefined *)((int)param_1 + 5) = *(undefined *)(param_2 + 1);
  in = (void *)((int)param_2 + 3);
  *(byte *)(param_1 + 1) = (byte)((uVar2 << 0x14) >> 0x1e);
  uVar3 = (uVar2 << 0x10) >> 0x1e;
  *(byte *)((int)param_1 + 3) = (byte)(uVar2 >> 8) >> 6;
  *(byte *)(param_1 + 2) = (byte)((uVar2 << 0x19) >> 0x1f);
  if ((uVar2 << 0x14) >> 0x1e != 0)
  {
    memcpy(param_1 + 3, in, 2);
    if (*(char *)(param_1 + 1) == '\x02')
    {
      memcpy(param_1 + 4, (void *)((int)param_2 + 5), 2);
      in = (void *)((int)param_2 + 7);
      uVar3 = (uint) * (byte *)((int)param_1 + 3);
    }
    else
    {
      memcpy(param_1 + 4, (void *)((int)param_2 + 5), 8);
      in = (void *)((int)param_2 + 0xd);
      uVar3 = (uint) * (byte *)((int)param_1 + 3);
    }
  }
  if (uVar3 == 0)
    goto LAB_000129d6;
  if (*(char *)(param_1 + 2) == '\0')
  {
    memcpy(param_1 + 8, in, 2);
    in = (void *)((int)in + 2);
    if (*(char *)((int)param_1 + 3) == '\x02')
      goto LAB_00012a1a;
  }
  else if (uVar3 == 2)
  {
  LAB_00012a1a:
    memcpy(param_1 + 9, in, 2);
    in = (void *)((int)in + 2);
    goto LAB_000129d6;
  }
  memcpy(param_1 + 9, in, 8);
  in = (void *)((int)in + 8);
LAB_000129d6:
  return (int)in - (int)param_2 & 0xff;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int tl_zbMacPacketDelaySend(void)

{
  int iVar1;

  g_zbMacCtx.txRawDataBuf[0xc1] = 0xe3;
  iVar1 = tl_zbMacTx();
  return -(uint)(iVar1 == 0);
}

void tl_zbMacOrphanResponseStatusCheck(zb_buf_t *param_1, char param_2)

{
  undefined auStack_1c[8];
  undefined auStack_14[8];

  memcpy(auStack_1c, param_1, 0xb);
  if (param_2 == '\0')
  {
    param_1->buf[0x14] = '\0';
    param_1->buf[0x15] = '\0';
    memcpy(param_1->buf + 2, auStack_1c, 8);
    param_1->buf[10] = '\x03';
    memcpy(param_1->buf + 0xb, auStack_14, 2);
    param_1->buf[0x13] = '\x02';
    tl_zbPrimitivePost('\x01', 'W', param_1);
  }
  else
  {
    zb_buf_free(param_1);
  }
  return;
}

undefined4 tl_zbMacMlmeBeaconCmdSend(byte *param_1)

{
  u8 *p;
  u8 uVar1;
  void *dest;
  byte *pbVar2;
  u32 uVar3;
  byte bVar4;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;

  uStack_24 = 0;
  local_20 = 0;
  uStack_28 = (uint)g_zbInfo.macPib.panId;
  bVar4 = *param_1;
  if (bVar4 == 3)
  {
    memcpy((void *)((int)&uStack_28 + 2), g_zbInfo.macPib.extAddress, 8);
  }
  else
  {
    memcpy((void *)((int)&uStack_28 + 2), &g_zbInfo.macPib.shortAddress, 2);
  }
  uVar1 = tl_zbMacHdrSize((ushort)param_1[2] << 4 | (ushort)bVar4 << 0xe);
  p = g_zbMacCtx.txRawDataBuf;
  if (-1 < (int)((uint)g_zbMacCtx.txRawDataBuf[0xc3] << 0x1c))
  {
    bVar4 = uVar1 + g_zbInfo.macPib.beaconPayloadLen + '\x04';
    g_zbMacCtx.txRawDataBuf[0xc3] = g_zbMacCtx.txRawDataBuf[0xc3] | 8;
    dest = tl_bufInitalloc((zb_buf_t *)p, bVar4);
    *p = (u8)dest;
    p[1] = (u8)((uint)dest >> 8);
    p[2] = (u8)((uint)dest >> 0x10);
    p[3] = (u8)((uint)dest >> 0x18);
    p[4] = bVar4;
    memset(dest, 0, (uint)bVar4);
    pbVar2 = (byte *)tl_zbMacHdrBuilder();
    *pbVar2 = param_1[4] & 0xf | param_1[5] << 4;
    bVar4 = g_zbInfo.macPib.associationPermit << 7 | 0xf | (byte)((param_1[3] & 1) << 4);
    pbVar2[1] = bVar4;
    if (aps_ib.aps_designated_coordinator == '\x01')
    {
      pbVar2[1] = bVar4 | 0x40;
    }
    memcpy(pbVar2 + 4, &g_zbInfo.macPib.beaconPayload, (uint)g_zbInfo.macPib.beaconPayloadLen);
    uVar3 = drv_u32Rand();
    ev_timer_taskPost(tl_zbMacPacketDelaySend, (void *)0x0, (uVar3 & 0x14) + 1);
  }
  return 0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacMlmeCoordRealignmentCmdSend(void)

{
  char in_r0;
  u8 uVar1;
  void *out;
  void *in_r1;
  undefined2 in_r2;
  zb_buf_t *in_r3;
  undefined4 local_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined2 local_34;
  undefined local_30;
  undefined auStack_2f[2];
  undefined auStack_2d[2];
  u8 uStack_2b;
  undefined2 local_2a;
  u8 uStack_28;
  undefined2 local_26;

  local_26 = 0xfffe;
  uStack_40 = 0;
  uStack_38 = 0;
  local_34 = 0;
  uStack_3c = (uint)g_zbInfo.macPib.panId;
  local_44 = 0xfffe;
  memcpy((void *)((int)&uStack_3c + 2), g_zbInfo.macPib.extAddress, 8);
  if (in_r0 == '\0')
  {
    memcpy(&local_44, in_r1, 8);
    uVar1 = tl_zbMacHdrSize(0xcc23);
    local_30 = 8;
    memcpy(auStack_2f, in_r3->buf + 4, 2);
    memcpy(auStack_2d, &g_zbInfo.macPib.shortAddress, 2);
    uStack_2b = in_r3->buf[6];
    local_2a = in_r2;
  }
  else
  {
    uVar1 = tl_zbMacHdrSize(0xc803);
    local_30 = 8;
    memcpy(auStack_2f, in_r3->buf + 4, 2);
    memcpy(auStack_2d, &g_zbInfo.macPib.shortAddress, 2);
    uStack_2b = in_r3->buf[6];
    local_2a = 0xfffe;
  }
  uStack_28 = in_r3->buf[7];
  tl_bufInitalloc(in_r3, uVar1 + '\t');
  out = (void *)tl_zbMacHdrBuilder();
  memcpy(out, &local_30, 9);
  tl_zbMacTx();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacBeaconRequestCb(void)

{
  if ((((byte)g_zbInfo.nwkNib.capabilityInfo & 2) != 0) &&
      (g_zbInfo.macPib.beaconPayloadLen != '\0'))
  {
    tl_zbNwkBeaconPayloadUpdate();
    tl_zbMacMlmeBeaconCmdSend();
    g_zbMacCtx.beaconTriesNum = g_zbMacCtx.beaconTriesNum + 0xff;
  }
  return;
}

void tl_zbMacMlmeBeaconSendConfirm(undefined4 param_1, char param_2)

{
  if ((param_2 != '\0') && (g_zbMacCtx.beaconTriesNum != '\0'))
  {
    tl_zbMacBeaconRequestCb();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacOrphanResponseHandler(void)

{
  u16 uVar1;
  void *in_r0;
  int iVar2;
  undefined4 local_1c;
  undefined4 uStack_18;
  undefined2 local_14;
  undefined local_12;

  local_1c = 0;
  uStack_18 = 0;
  local_14 = 0;
  local_12 = 0;
  memcpy(&local_1c, in_r0, 0xb);
  uVar1 = g_zbInfo.macPib.panId;
  *(char *)((int)in_r0 + 4) = (char)g_zbInfo.macPib.panId;
  *(char *)((int)in_r0 + 5) = (char)(uVar1 >> 8);
  *(u8 *)((int)in_r0 + 6) = g_zbMacCtx.curChannel;
  *(undefined *)((int)in_r0 + 7) = 0;
  *(undefined *)((int)in_r0 + 0xc1) = 0xe5;
  iVar2 = tl_zbMacMlmeCoordRealignmentCmdSend();
  if (iVar2 != 0)
  {
    tl_zbMacOrphanResponseStatusCheck(in_r0, 0xf1);
  }
  return;
}

void tl_zbMacMcpsDataRequestSendConfirm(undefined *param_1, undefined param_2)

{
  char cVar1;
  undefined4 uVar2;
  u8 uVar3;
  undefined2 uVar4;

  cVar1 = param_1[0x19];
  if (param_1[0x13] == '\x02')
  {
    uVar4 = *(undefined2 *)(param_1 + 0xb);
  }
  else
  {
    uVar4 = 0xfffe;
  }
  param_1[0xc3] = param_1[0xc3] & 0xfd;
  if ((byte)(cVar1 + 0x90U) < 0x50)
  {
    param_1[1] = cVar1;
    *param_1 = param_2;
    tl_zbTaskPost(cGp_dataCnf, param_1);
  }
  else
  {
    param_1[8] = cVar1;
    param_1[9] = param_2;
    param_1[10] = (char)uVar4;
    param_1[0xb] = (char)((ushort)uVar4 >> 8);
    uVar2 = *(undefined4 *)(param_1 + 0x15);
    param_1[4] = (char)uVar2;
    param_1[5] = (char)((uint)uVar2 >> 8);
    param_1[6] = (char)((uint)uVar2 >> 0x10);
    param_1[7] = (char)((uint)uVar2 >> 0x18);
    param_1[0xc] = param_1[0xc2];
    uVar3 = rf_getLqi(param_1[0xc2]);
    param_1[0xd] = uVar3;
    tl_zbPrimitivePost('\x01', 'A', param_1);
  }
  return;
}

void tl_zbMacMcpsDataRequestProc(void *arg)

{
  byte bVar1;
  byte bVar2;
  ushort uVar3;
  uint uVar4;
  int iVar5;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined2 local_2c;
  undefined auStack_28[8];
  undefined uStack_20;

  uStack_3c = 0;
  uStack_38 = 0;
  uStack_30 = 0;
  local_2c = 0;
  uVar4 = (uint) * (byte *)((int)arg + 0x13);
  if (uVar4 == 2)
  {
    if (*(short *)((int)arg + 0xb) == -1)
    {
      g_sysDiags.macTxBcast = g_sysDiags.macTxBcast + 1;
      uVar4 = (uint) * (byte *)((int)arg + 0x13);
    }
    else
    {
      g_sysDiags.macTxUcast = g_sysDiags.macTxUcast + 1;
      uVar4 = (uint) * (byte *)((int)arg + 0x13);
    }
  }
  uStack_34 = (uint)g_zbInfo.macPib.panId;
  bVar1 = *(byte *)((int)arg + 8);
  uVar3 = 0;
  if ((bVar1 != 0) && (uVar4 != 0))
  {
    uVar3 = *(ushort *)((int)arg + 9) - g_zbInfo.macPib.panId;
    uVar3 = (uVar3 + ~uVar3 + (ushort)(g_zbInfo.macPib.panId <= *(ushort *)((int)arg + 9))) * 0x40;
  }
  bVar2 = *(byte *)((int)arg + 0x1a);
  memcpy(&uStack_3c, (void *)((int)arg + 0xb), 8);
  if (bVar1 == 2)
  {
    uStack_34 = uStack_34 & 0xffff | (uint)g_zbInfo.macPib.shortAddress << 0x10;
  }
  else if (bVar1 == 3)
  {
    memcpy((void *)((int)&uStack_34 + 2), g_zbInfo.macPib.extAddress, 8);
  }
  bVar2 = tl_zbMacHdrSize(uVar3 | (ushort)bVar1 << 0xe | 1 | (ushort)((bVar2 & 1) << 5) |
                          (ushort)(uVar4 << 10));
  *(undefined *)((int)arg + 0xc1) = *(undefined *)((int)arg + 0x19);
  bVar1 = *(byte *)((int)arg + 0x14);
  iVar5 = *(int *)((int)arg + 0x15) - (uint)bVar2;
  tl_zbMacHdrBuilder();
  *(byte *)((int)arg + 0xc3) = *(byte *)((int)arg + 0xc3) | 2;
  if ((*(byte *)((int)arg + 0x1a) & 4) == 0)
  {
    iVar5 = tl_zbMacTx();
  }
  else
  {
    *(char *)arg = (char)iVar5;
    *(char *)((int)arg + 1) = (char)((uint)iVar5 >> 8);
    *(char *)((int)arg + 2) = (char)((uint)iVar5 >> 0x10);
    *(char *)((int)arg + 3) = (char)((uint)iVar5 >> 0x18);
    *(char *)((int)arg + 4) = (char)(((uint)bVar2 + (uint)bVar1) * 0x1000000 >> 0x18);
    uStack_20 = *(undefined *)((int)arg + 0x13);
    memcpy(auStack_28, (void *)((int)arg + 0xb), 8);
    iVar5 = macDataPending();
  }
  if (iVar5 != 0)
  {
    tl_zbMacMcpsDataRequestSendConfirm(arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbPhyMldeIndication(void)

{
  undefined uVar1;
  undefined4 uVar2;
  undefined2 uVar3;
  void *in_r0;
  byte *in_r1;
  char in_r2;

  uVar1 = *(undefined *)((int)in_r0 + 0x14);
  uVar2 = *(undefined4 *)((int)in_r0 + 4);
  *(char *)((int)in_r0 + 4) = (char)uVar2;
  *(char *)((int)in_r0 + 5) = (char)((uint)uVar2 >> 8);
  *(char *)((int)in_r0 + 6) = (char)((uint)uVar2 >> 0x10);
  *(char *)((int)in_r0 + 7) = (char)((uint)uVar2 >> 0x18);
  *(char *)((int)in_r0 + 0x1d) = *(char *)((int)in_r0 + 0x13) - in_r2;
  *(byte *)((int)in_r0 + 0x26) = in_r1[2];
  memcpy((void *)((int)in_r0 + 0x1e), in_r1 + 8, 8);
  uVar3 = *(undefined2 *)(in_r1 + 6);
  *(char *)((int)in_r0 + 0x12) = (char)uVar3;
  *(char *)((int)in_r0 + 0x13) = (char)((ushort)uVar3 >> 8);
  *(byte *)((int)in_r0 + 0x1c) = in_r1[3];
  memcpy((void *)((int)in_r0 + 0x14), in_r1 + 0x12, 8);
  if (in_r1[4] == 0)
  {
    uVar3 = *(undefined2 *)(in_r1 + 0x10);
    *(char *)((int)in_r0 + 0x10) = (char)uVar3;
    *(char *)((int)in_r0 + 0x11) = (char)((ushort)uVar3 >> 8);
  }
  *(byte *)((int)in_r0 + 0x28) = in_r1[5];
  *(undefined *)((int)in_r0 + 0x27) = uVar1;
  if ((g_zbInfo.macPib.rxOnWhenIdle == '\0') && ((int)((uint)*in_r1 << 0x1b) < 0))
  {
    *(byte *)((int)in_r0 + 0xc3) = *(byte *)((int)in_r0 + 0xc3) | 0x10;
  }
  tl_zbPrimitivePost('\x01', 'B', in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void macDataPendingListProc(void)

{
  u8 uVar1;
  u8 *in_r0;

  uVar1 = in_r0[0x14];
  if (((uVar1 == ' ') || (uVar1 == '\0')) || (uVar1 == '\x04'))
  {
    tl_zbMaxTxConfirmCb(*(undefined4 *)(in_r0 + 4));
    listRemove((list_t)&macPendingQueue_list, in_r0);
    ev_buf_free(in_r0);
  }
  else
  {
    in_r0[0x13] = '\x01';
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacMlmeDataRequestConfirm(void)

{
  zb_buf_t *in_r0;
  u8 in_r1;

  if ((in_r0->hdr).handle == 0xe9)
  {
    zb_buf_free(in_r0);
  }
  else
  {
    in_r0->buf[0] = in_r1;
    tl_zbPrimitivePost('\x01', '^', in_r0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbSwitchOffRx(void)

{
  if (g_zbInfo.macPib.rxOnWhenIdle == '\0')
  {
    rf_setTrxState('\x03');
  }
  tl_zbTaskPost(mac_trigger_tx, (void *)0x0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbWaitForPendingDataTimeout(void)

{
  tl_zbSwitchOffRx();
  g_zbMacCtx.indirectData.timer._0_1_ = 0;
  g_zbMacCtx.indirectData.timer._1_1_ = 0;
  g_zbMacCtx.indirectData.timer._2_1_ = 0;
  g_zbMacCtx.indirectData.timer._3_1_ = 0;
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacIndirectDataTimerCancel(void)

{
  if (g_zbMacCtx.indirectData.timer != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_zbMacCtx.indirectData.timer);
  }
  tl_zbSwitchOffRx();
  return;
}

void tl_zbMacIndirectDataTimerStart(ev_timer_callback_t param_1, void *param_2)

{
  u32 t_ms;

  if (g_zbMacCtx.indirectData.timer != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&g_zbMacCtx.indirectData.timer);
  }
  t_ms = FUN_00001624((uint)g_zbInfo.macPib.frameTotalWaitTime << 4, 1000);
  g_zbMacCtx.indirectData.timer = ev_timer_taskPost(param_1, param_2, t_ms);
  return;
}

void tl_zbMacDataRequestStatusCheck(zb_buf_t *param_1, uint param_2)

{
  u8 uVar1;
  int iVar2;

  param_2 = param_2 & 0xff;
  iVar2 = (param_2 - 0x20) + ~(param_2 - 0x20) + (uint)(0x1f < param_2);
  if ((iVar2 == 0) && (param_2 != 0))
  {
    tl_zbMacMlmeDataRequestConfirm();
  }
  else
  {
    uVar1 = (param_1->hdr).handle;
    if (uVar1 == 0xe8)
    {
      if (iVar2 == 0)
      {
        param_1->buf[0] = 0xeb;
        tl_zbPrimitivePost('\x01', '^', param_1);
      }
      else
      {
        param_1->buf[0] = ' ';
        tl_zbPrimitivePost('\x01', '^', param_1);
        tl_zbMacIndirectDataTimerStart(tl_zbWaitForPendingDataTimeout, 0);
      }
    }
    else if (uVar1 == 0xe9)
    {
      zb_buf_free(param_1);
    }
  }
  return;
}

int tl_zbMacMlmeDataRequestCmdSend(byte *param_1, zb_buf_t *param_2, u8 param_3)

{
  u8 uVar1;
  undefined *puVar2;
  int iVar3;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;

  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  local_20 = 0;
  memcpy(&uStack_30, param_1 + 10, 8);
  memcpy((void *)((int)&uStack_28 + 2), param_1 + 2, 8);
  uVar1 = tl_zbMacHdrSize((ushort)param_1[1] << 10 | (ushort)*param_1 << 0xe | 99);
  tl_bufInitalloc(param_2, uVar1 + '\x01');
  puVar2 = (undefined *)tl_zbMacHdrBuilder();
  *puVar2 = 4;
  (param_2->hdr).handle = param_3;
  iVar3 = tl_zbMacTx();
  if (iVar3 == 0)
  {
    if (param_3 == 0xe9)
    {
      g_zbMacCtx.status = '\x05';
    }
  }
  else
  {
    tl_zbMacMlmeDataRequestConfirm();
  }
  return iVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 macDataPending(void)

{
  u8 uVar1;
  undefined4 in_r0;
  int iVar2;
  u8 *dest;
  undefined4 uVar3;
  undefined local_24[12];

  iVar2 = listLength((list_t)&macPendingQueue_list);
  uVar3 = 0xf1;
  if ((iVar2 < (int)(uint)ZB_MAC_PENDING_TRANS_QUEUE_SIZE) &&
      (dest = ev_buf_allocate(0x15), dest != (u8 *)0x0))
  {
    memset(dest, 0, 0x15);
    listAdd((list_t)&macPendingQueue_list, dest);
    dest[4] = (u8)in_r0;
    dest[5] = (u8)((uint)in_r0 >> 8);
    dest[6] = (u8)((uint)in_r0 >> 0x10);
    dest[7] = (u8)((uint)in_r0 >> 0x18);
    memcpy(dest + 8, local_24, 9);
    uVar1 = FUN_00001624((uint)g_zbInfo.macPib.transactionPersistenceTime * 0x3c00, 1000000);
    dest[0x11] = uVar1;
    dest[0x12] = ZB_MAC_EXT_EXPEIRY_CNT;
    dest[0x13] = '\x01';
    uVar3 = 0;
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void macDataPendingListManage(void)

{
  void *in_r0;
  undefined in_r1;
  undefined uVar1;

  uVar1 = in_r1;
  if ((in_r0 != (void *)0x0) && (uVar1 = 0xf0, *(char *)((int)in_r0 + 0x13) != '\x04'))
  {
    uVar1 = in_r1;
  }
  *(undefined *)((int)in_r0 + 0x14) = uVar1;
  tl_zbTaskPost(macDataPendingListProc, in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int tl_zbMacPendingDataSearch(void)

{
  char in_r0;
  int iVar1;
  undefined4 *puVar2;
  void *in_r1;
  char cVar3;

  iVar1 = listLength((list_t)&macPendingQueue_list);
  cVar3 = '\0';
  if (iVar1 != 0)
  {
    for (puVar2 = (undefined4 *)listHead((list_t)&macPendingQueue_list); puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2)
    {
      if ((puVar2[1] != 0) && (*(char *)(puVar2 + 4) == in_r0))
      {
        if (in_r0 == '\x03')
        {
          iVar1 = memcmp(in_r1, puVar2 + 2, 8);
        }
        else
        {
          iVar1 = memcmp(in_r1, puVar2 + 2, 2);
        }
        if (iVar1 == 0)
        {
          cVar3 = cVar3 + '\x01';
        }
      }
    }
  }
  return (int)cVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacMlmeDataRequestCb(void)

{
  byte **ppbVar1;
  byte *pbVar2;
  char cVar3;
  undefined *in_r0;
  int iVar4;
  undefined4 *puVar5;
  undefined *m1;
  undefined auStack_24[12];

  m1 = in_r0 + 10;
  cVar3 = tl_zbMacPendingDataSearch();
  iVar4 = listLength((list_t)&macPendingQueue_list);
  if (iVar4 != 0)
  {
    for (puVar5 = (undefined4 *)listHead((list_t)&macPendingQueue_list); puVar5 != (undefined4 *)0x0; puVar5 = (undefined4 *)*puVar5)
    {
      ppbVar1 = (byte **)puVar5[1];
      if (((ppbVar1 != (byte **)0x0) && (*(char *)((int)puVar5 + 0x13) == '\x02')) &&
          (*(char *)(puVar5 + 4) == in_r0[0x12]))
      {
        if (*(char *)(puVar5 + 4) == '\x03')
        {
          iVar4 = memcmp(m1, puVar5 + 2, 8);
        }
        else
        {
          iVar4 = memcmp(m1, puVar5 + 2, 2);
        }
        if (iVar4 == 0)
        {
          pbVar2 = *ppbVar1;
          if ('\x01' < cVar3)
          {
            *pbVar2 = *pbVar2 | 0x10;
          }
          iVar4 = tl_zbMacTx();
          if (iVar4 == 0)
          {
            *(undefined *)((int)puVar5 + 0x13) = 3;
          }
          else
          {
            *(undefined *)((int)puVar5 + 0x13) = 1;
          }
          break;
        }
      }
    }
  }
  memcpy(auStack_24, m1, 9);
  *in_r0 = in_r0[0x12];
  memcpy(in_r0 + 1, auStack_24, 8);
  tl_zbPrimitivePost('\x01', 'c', in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void macIndirPeriodic(void)

{
  int iVar1;
  undefined4 *pBuf;

  iVar1 = listLength((list_t)&macPendingQueue_list);
  if (iVar1 != 0)
  {
    for (pBuf = (undefined4 *)listHead((list_t)&macPendingQueue_list); pBuf != (undefined4 *)0x0;
         pBuf = (undefined4 *)*pBuf)
    {
      if (*(char *)((int)pBuf + 0x11) == '\0')
      {
        if (*(char *)((int)pBuf + 0x12) == '\0')
        {
          if (1 < (byte)(*(char *)((int)pBuf + 0x13) - 3U))
          {
            if (pBuf[1] != 0)
            {
              tl_zbMaxTxConfirmCb(pBuf[1], 0xf0);
            }
            listRemove((list_t)&macPendingQueue_list, pBuf);
            ev_buf_free((u8 *)pBuf);
            return;
          }
          *(undefined *)((int)pBuf + 0x13) = 4;
          return;
        }
        *(char *)((int)pBuf + 0x12) = *(char *)((int)pBuf + 0x12) + -1;
      }
      else
      {
        *(char *)((int)pBuf + 0x11) = *(char *)((int)pBuf + 0x11) + -1;
      }
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMlmeCmdCoordRealignRecvd(void)

{
  zb_buf_t *in_r0;
  ushort *in_r1;
  int iVar1;

  iVar1 = *(int *)(in_r0->buf + 4);
  if (((((ushort)((ushort) * (byte *)(iVar1 + 2) * 0x100 + (ushort) * (byte *)(iVar1 + 1)) ==
         g_zbInfo.macPib.panId) &&
        (g_zbInfo.macPib.phyChannelCur == *(u8 *)(iVar1 + 5))) &&
       ((ushort)((ushort) * (byte *)(iVar1 + 6) + (ushort) * (byte *)(iVar1 + 7) * 0x100) ==
        g_zbInfo.macPib.shortAddress)) &&
      (g_zbMacCtx.status == '\x03'))
  {
    iVar1 = (uint) * (byte *)(iVar1 + 4) * 0x100 + (uint) * (byte *)(iVar1 + 3);
    g_zbInfo.macPib.coordShortAddress._0_1_ = (undefined)iVar1;
    g_zbInfo.macPib.coordShortAddress._1_1_ = (undefined)((uint)iVar1 >> 8);
    if (((uint)*in_r1 << 0x10) >> 0x1e == 3)
    {
      memcpy(g_zbInfo.macPib.coordExtAddress, in_r1 + 9, 8);
    }
    else
    {
      g_zbInfo.macPib.coordExtAddress[0] = '\0';
      g_zbInfo.macPib.coordExtAddress[1] = '\0';
      g_zbInfo.macPib.coordExtAddress[2] = '\0';
      g_zbInfo.macPib.coordExtAddress[3] = '\0';
      g_zbInfo.macPib.coordExtAddress[4] = '\0';
      g_zbInfo.macPib.coordExtAddress[5] = '\0';
      g_zbInfo.macPib.coordExtAddress[6] = '\0';
      g_zbInfo.macPib.coordExtAddress[7] = '\0';
    }
    tl_zbMacOrphanScanStatusUpdate();
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMlmeCmdOrphanNotifyRecvd(void)

{
  zb_buf_t *in_r0;
  int in_r1;

  if (*(byte *)(in_r1 + 1) >> 6 == 3)
  {
    memcpy(in_r0, (void *)(in_r1 + 0x12), 8);
    tl_zbPrimitivePost('\x01', 'O', in_r0);
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMlmeCmdPanIdConflictNotifyRecvd(void)

{
  u16 *in_r0;

  *in_r0 = g_zbInfo.macPib.panId;
  *(undefined *)(in_r0 + 1) = 0;
  *(u8 *)((int)in_r0 + 3) = g_zbInfo.macPib.phyChannelCur;
  *(u8 *)(in_r0 + 2) = g_zbInfo.macPib.phyPageCur;
  tl_zbPrimitivePost('\x01', '\\', in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMlmeCmdAssociateReqRecvd(void)

{
  zb_buf_t *in_r0;
  int iVar1;
  int in_r1;

  iVar1 = *(int *)(in_r0->buf + 4);
  memcpy(in_r0, (void *)(in_r1 + 0x12), 8);
  in_r0->buf[9] = in_r0->buf[0x14];
  in_r0->buf[8] = *(u8 *)(iVar1 + 1);
  if (((macAppIndCb == 0) || (*(int *)(macAppIndCb + 8) == 0)) || (iVar1 = FUNBBBBG(), iVar1 != 0))
  {
    tl_zbPrimitivePost('\x01', 'G', in_r0);
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNBBBBG(void)

{
  code *in_r3;

  (*in_r3)();
  tl_zbMacMlmeDataRequestCb();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMlmeCmdDataReqRecvd(void)

{
  tl_zbMacMlmeDataRequestCb();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMlmeCmdAssociateRespRecvd(void)

{
  int iVar1;
  zb_buf_t *in_r0;
  int in_r1;

  iVar1 = *(int *)(in_r0->buf + 4);
  memset(in_r0, 0, 0x16);
  if (*(char *)(in_r1 + 3) == '\x03')
  {
    memcpy(in_r0, (void *)(in_r1 + 0x12), 8);
  }
  else
  {
    in_r0->buf[0] = '\0';
    in_r0->buf[1] = '\0';
    in_r0->buf[2] = '\0';
    in_r0->buf[3] = '\0';
    in_r0->buf[4] = '\0';
    in_r0->buf[5] = '\0';
    in_r0->buf[6] = '\0';
    in_r0->buf[7] = '\0';
  }
  if ((g_zbMacCtx.status == '\x05') && (associationReqOrigBuffer != (zb_buf_t *)0x0))
  {
    tl_zbMacAssociateRespReceived(0);
    zb_buf_free(associationReqOrigBuffer);
    associationReqOrigBuffer = (zb_buf_t *)0x0;
    memcpy(in_r0->buf + 8, (void *)(iVar1 + 1), 2);
    memcpy(&g_zbInfo.macPib.shortAddress, in_r0->buf + 8, 2);
    in_r0->buf[10] = *(u8 *)(iVar1 + 3);
    tl_zbPrimitivePost('\x01', 'F', in_r0);
    return;
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMlmeCmdBeaconReqRecvd(void)

{
  byte bVar1;
  zb_buf_t *in_r0;

  bVar1 = rf_lqi2cost(in_r0->buf[0x14]);
  if ((bVar1 < 6) && ((g_zbNwkCtx._45_1_ & 0x24) == 4))
  {
    g_zbMacCtx.beaconTriesNum = '\x03';
    tl_zbMacBeaconRequestCb();
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbPhyMlmeIndicate(void)

{
  zb_buf_t *in_r0;
  undefined1 *puVar1;
  int iVar2;
  char cVar3;

  if (g_zbMacCtx.status == '\x05')
  {
    if (**(char **)(in_r0->buf + 4) != '\x02')
      goto LAB_000139b2;
    cVar3 = '\x02';
  }
  else
  {
    cVar3 = **(char **)(in_r0->buf + 4);
  }
  puVar1 = g_zbMacMlmeEventFromPhyTbl;
  iVar2 = 0;
  do
  {
    if ((*puVar1 == cVar3) && (*(int *)(g_zbMacMlmeEventFromPhyTbl + iVar2 * 5 + 1) != 0))
    {
      tl_zbPhyMlmeIndicate_sub();
      if (iVar2 != 8)
      {
        return;
      }
      break;
    }
    iVar2 = iVar2 + 1;
    puVar1 = puVar1 + 5;
  } while (iVar2 != 8);
LAB_000139b2:
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbPhyMlmeIndicate_sub(void)

{
  int iVar1;
  code *in_r3;
  undefined local_20;
  char cStack_1f;
  undefined auStack_1e[8];
  undefined auStack_16[8];
  undefined uStack_e;

  iVar1 = (*in_r3)();
  if (g_zbInfo.macPib.shortAddress < 0xfffe)
  {
    local_20 = 2;
    memcpy(auStack_1e, &g_zbInfo.macPib.shortAddress, 2);
    cStack_1f = *(char *)(iVar1 + 10);
  }
  else
  {
    local_20 = 3;
    memcpy(auStack_1e, g_zbInfo.macPib.extAddress, 8);
    cStack_1f = *(char *)(iVar1 + 10);
  }
  if (cStack_1f == '\x03')
  {
    memcpy(auStack_16, (void *)(iVar1 + 2), 8);
  }
  else
  {
    memcpy(auStack_16, (void *)(iVar1 + 2), 2);
  }
  uStack_e = 1;
  tl_zbMacMlmeDataRequestCmdSend(&local_20, iVar1, 0xe8);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacPollRequestHandler(void)

{
  int in_r0;
  undefined local_20;
  char cStack_1f;
  undefined auStack_1e[8];
  undefined auStack_16[8];
  undefined uStack_e;

  if (g_zbInfo.macPib.shortAddress < 0xfffe)
  {
    local_20 = 2;
    memcpy(auStack_1e, &g_zbInfo.macPib.shortAddress, 2);
    cStack_1f = *(char *)(in_r0 + 10);
  }
  else
  {
    local_20 = 3;
    memcpy(auStack_1e, g_zbInfo.macPib.extAddress, 8);
    cStack_1f = *(char *)(in_r0 + 10);
  }
  if (cStack_1f == '\x03')
  {
    memcpy(auStack_16, (void *)(in_r0 + 2), 8);
  }
  else
  {
    memcpy(auStack_16, (void *)(in_r0 + 2), 2);
  }
  uStack_e = 1;
  tl_zbMacMlmeDataRequestCmdSend(&local_20, in_r0, 0xe8);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacResetRequestHandler(void)

{
  undefined *in_r0;

  *in_r0 = 0;
  tl_zbPrimitivePost('\x01', 'R', in_r0);
  return;
}

void tl_zbMacStartReqConfirm(char *param_1, char param_2)

{
  if (param_2 == '\0')
  {
    g_zbInfo.macPib.beaconOrder = param_1[8];
    if (g_zbInfo.macPib.beaconOrder == '\x0f')
    {
      g_zbInfo.macPib.superframeOrder._0_1_ = '\x0f';
      g_zbInfo.macPib.superframeOrder._1_1_ = param_2;
    }
    else
    {
      g_zbInfo.macPib.superframeOrder._0_1_ = param_1[9];
      g_zbInfo.macPib.superframeOrder._1_1_ = '\0';
    }
    g_zbInfo.macPib.panId._0_1_ = (undefined) * (undefined2 *)(param_1 + 4);
    g_zbInfo.macPib.panId._1_1_ = (undefined)((ushort) * (undefined2 *)(param_1 + 4) >> 8);
    g_zbInfo.macPib.phyPageCur = param_1[7];
    g_zbInfo.macPib.phyChannelCur = param_1[6];
    tl_zbMacChannelSet(g_zbInfo.macPib.phyChannelCur);
    rf_setTrxState('\x01');
  }
  *param_1 = param_2;
  tl_zbPrimitivePost('\x01', '[', param_1);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacStartRequestHandler(void)

{
  int in_r0;
  int iVar1;
  ushort uVar2;
  ushort uVar3;

  uVar3 = 0xe8;
  if ((*(byte *)(in_r0 + 8) < 0x10) &&
      ((*(byte *)(in_r0 + 9) <= *(byte *)(in_r0 + 8) || (*(byte *)(in_r0 + 9) == 0xf))))
  {
    uVar3 = ~(g_zbInfo.macPib.shortAddress + 1 + ~(g_zbInfo.macPib.shortAddress + 1) +
              (ushort)(0xfffe < g_zbInfo.macPib.shortAddress)) &
            0xec;
  }
  uVar2 = 0xe8;
  if (((int)((uint)g_zbNwkCtx._45_1_ << 0x1a) < 0) || (uVar2 = uVar3, uVar3 != 0))
  {
    tl_zbMacStartReqConfirm(in_r0, uVar2);
  }
  else if (*(char *)(in_r0 + 0x17) == '\0')
  {
    tl_zbMacStartReqConfirm(in_r0, 0);
  }
  else
  {
    *(undefined *)(in_r0 + 0xc1) = 0xe6;
    iVar1 = tl_zbMacMlmeCoordRealignmentCmdSend();
    if (iVar1 != 0)
    {
      tl_zbMacStartReqConfirm(in_r0, 0xe1);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbMacCommStatusSend(void)

{
  undefined4 *in_r0;
  undefined in_r1;
  undefined auStack_2c[2];
  undefined uStack_2a;
  undefined uStack_29;
  undefined auStack_24[10];
  undefined auStack_1a[14];

  tl_zbMacHdrParse(auStack_2c, *in_r0);
  *(undefined *)(in_r0 + 5) = in_r1;
  *(undefined *)((int)in_r0 + 0x15) = 1;
  memcpy((void *)((int)in_r0 + 2), auStack_1a, 8);
  *(undefined *)((int)in_r0 + 10) = uStack_29;
  memcpy((void *)((int)in_r0 + 0xb), auStack_24, 8);
  *(undefined *)((int)in_r0 + 0x13) = uStack_2a;
  tl_zbPrimitivePost('\x01', 'W', in_r0);
  return 0;
}

void tl_zbMacCmdPanIdConflictNotifySendCheck(undefined4 param_1, char param_2)

{
  u16 uVar1;
  undefined *arg;

  if ((param_2 == '\0') &&
      (arg = (undefined *)c1(), uVar1 = g_zbInfo.macPib.panId, arg != (undefined *)0x0))
  {
    *arg = (char)g_zbInfo.macPib.panId;
    arg[1] = (char)(uVar1 >> 8);
    arg[2] = 0;
    arg[3] = g_zbInfo.macPib.phyChannelCur;
    arg[4] = g_zbInfo.macPib.phyPageCur;
    tl_zbPrimitivePost('\x01', '\\', arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbMacMlmeBeaconRequestCmdSend(void)

{
  u8 *p;
  undefined *puVar1;
  undefined4 uVar2;

  p = g_zbMacCtx.txRawDataBuf;
  uVar2 = 0;
  if (-1 < (int)((uint)g_zbMacCtx.txRawDataBuf[0xc3] << 0x1c))
  {
    g_zbMacCtx.txRawDataBuf[0xc3] = g_zbMacCtx.txRawDataBuf[0xc3] | 8;
    p[0xc1] = 0xe4;
    tl_bufInitalloc((zb_buf_t *)p, '\b');
    puVar1 = (undefined *)tl_zbMacHdrBuilder();
    *puVar1 = 7;
    uVar2 = tl_zbMacTx();
  }
  return uVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbMacScanRunning(void)

{
  u8 *p;
  byte bVar1;
  u8 uVar2;
  undefined4 uVar3;
  undefined *puVar4;
  uint uVar5;
  uint uVar6;
  undefined4 uStack_28;
  int iStack_24;
  undefined2 local_20;

  bVar1 = g_macScanParam[17];
  puVar4 = g_macScanParam._4_4_;
  uVar6 = (uint)g_macScanParam[12];
  if ((chan_8321 < 0x1b) && (g_macScanParam[16] == '\0'))
  {
    iStack_24 = ~uVar6 + uVar6 + 1;
    if ((iStack_24 != 0) && (edChan_8323 != 0xff))
    {
      uVar5 = (uint)g_macScanParam[17];
      uVar2 = rf_stopED();
      puVar4[uVar5 + 8] = uVar2;
      g_macScanParam[17] = bVar1 + 1;
      if (0x1a < chan_8321)
      {
        return 0;
      }
    }
    do
    {
      if ((g_macScanParam._8_4_ & 1 << chan_8321) != 0)
      {
        tl_zbMacChannelSet((u8)chan_8321);
        p = g_zbMacCtx.txRawDataBuf;
        g_macScanParam[13] = (undefined)chan_8321;
        if (iStack_24 == 0)
        {
          if (uVar6 == 3)
          {
            local_20 = 0;
            if (-1 < (int)((uint)g_zbMacCtx.txRawDataBuf[0xc3] << 0x1c))
            {
              g_zbMacCtx.txRawDataBuf[0xc3] = g_zbMacCtx.txRawDataBuf[0xc3] | 8;
              uStack_28 = 0xfffe;
              memcpy((void *)((int)&uStack_28 + 2), g_zbInfo.macPib.extAddress, 8);
              uVar2 = tl_zbMacHdrSize(0xc803);
              p[0xc1] = 0xea;
              tl_bufInitalloc((zb_buf_t *)p, uVar2 + '\x01');
              puVar4 = (undefined *)tl_zbMacHdrBuilder();
              *puVar4 = 6;
              tl_zbMacTx();
            }
          }
          else if (uVar6 == 1)
          {
            tl_zbMacMlmeBeaconRequestCmdSend();
          }
          g_macScanParam._8_4_ = g_macScanParam._8_4_ & ~(1 << chan_8321);
          return 0;
        }
        rf_startED();
        edChan_8323 = chan_8321;
        g_macScanParam._8_4_ = g_macScanParam._8_4_ & ~(1 << chan_8321);
        return 0;
      }
      chan_8321 = chan_8321 + 1;
    } while (chan_8321 != 0x1b);
    chan_8321 = 0x1b;
    uVar3 = 0;
  }
  else
  {
    chan_8321 = 0xb;
    edChan_8323 = 0xff;
    g_macScanParam._4_4_[1] = g_macScanParam[12];
    *puVar4 = 0xea;
    puVar4[3] = g_macScanParam[17];
    if ((uVar6 == 0) || ((g_macScanParam[17] != 0 || (g_macScanParam[16] != '\0'))))
    {
      *puVar4 = 0;
    }
    tl_zbPrimitivePost('\x01', 'V', puVar4);
    g_zbMacCtx.status = '\0';
    tl_zbMacChannelSet(g_macScanParam[14]);
    rf_setTrxState(g_macScanParam[18]);
    g_macScanParam._0_4_ = 0;
    uVar3 = 0xfffffffe;
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacActiveScanListAdd(void)

{
  g_macScanParam[17] = g_macScanParam[17] + '\x01';
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacOrphanScanStatusUpdate(void)

{
  g_macScanParam[16] = 1;
  return;
}

// WARNING: Removing unreachable block (RAM,0x00013e88)
// WARNING: Removing unreachable block (RAM,0x00013f1c)
// WARNING: Removing unreachable block (RAM,0x00013f2a)
// WARNING: Removing unreachable block (RAM,0x00013f20)
// WARNING: Removing unreachable block (RAM,0x00013f26)
// WARNING: Removing unreachable block (RAM,0x00013eca)
// WARNING: Removing unreachable block (RAM,0x00013ece)
// WARNING: Removing unreachable block (RAM,0x00013eda)
// WARNING: Removing unreachable block (RAM,0x00013ee0)
// WARNING: Removing unreachable block (RAM,0x00013f30)
// WARNING: Removing unreachable block (RAM,0x00013ee6)
// WARNING: Removing unreachable block (RAM,0x00013ee8)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacScanRequestHandler(void)

{
  undefined *in_r0;
  undefined uVar1;

  uVar1 = 0xfc;
  if (7 < (byte)in_r0[5])
  {
    uVar1 = 0xe8;
  }
  *in_r0 = uVar1;
  in_r0[1] = in_r0[4];
  tl_zbPrimitivePost('\x01', 'V', in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 mac_waitTxIrqCb(void)

{
  if (g_macTimerEvt[8] != '\0')
  {
    rf_busyFlag = rf_busyFlag & 0xfd;
    rf_setTrxState('\x01');
    tl_zbTaskPost(mac_trxTask, &DAT_00000004);
  }
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 mac_ackWaitingTimerCb(void)

{
  if (g_macTimerEvt[8] != '\0')
  {
    tl_zbTaskPost(mac_trxTask, &DAT_00000006);
  }
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_rxDataParse(void)

{
  byte bVar1;
  byte bVar2;
  undefined4 uVar3;
  byte *pbVar4;
  u8 uVar5;
  zb_buf_t *in_r0;
  uint uVar6;
  uint uVar7;
  int iVar8;
  undefined auStack_40[3];
  u8 uStack_3d;
  u8 uStack_30;
  u8 uStack_2f;
  u8 uStack_2e;
  u8 uStack_2d;

  (in_r0->hdr).rssi = in_r0->buf[8];
  uVar5 = rf_getLqi(in_r0->buf[8]);
  uVar3 = *(undefined4 *)(in_r0->buf + 4);
  bVar1 = in_r0->buf[9];
  pbVar4 = *(byte **)in_r0->buf;
  bVar2 = *pbVar4;
  uVar6 = tl_zbMacHdrParse(auStack_40, pbVar4);
  if ((uVar6 < bVar1) && (g_zbMacCtx.status != '\x01'))
  {
    uVar7 = bVar2 & 7;
    if (g_zbMacCtx.status == '\x02')
    {
      iVar8 = ~uVar7 + uVar7 + (uint)(1 < g_zbMacCtx.status);
    LAB_0001407e:
      if (iVar8 == 0)
        goto LAB_00014066;
    }
    else if (g_zbMacCtx.status == '\x03')
    {
      if (uVar7 != 3)
        goto LAB_00014066;
      uVar7 = pbVar4[uVar6] - 8;
      iVar8 = uVar7 + ~uVar7 + (uint)(7 < pbVar4[uVar6]);
      goto LAB_0001407e;
    }
    in_r0->buf[0] = (u8)uVar3;
    in_r0->buf[1] = (u8)((uint)uVar3 >> 8);
    in_r0->buf[2] = (u8)((uint)uVar3 >> 0x10);
    in_r0->buf[3] = (u8)((uint)uVar3 >> 0x18);
    in_r0->buf[4] = (u8)pbVar4;
    in_r0->buf[5] = (u8)((uint)pbVar4 >> 8);
    in_r0->buf[6] = (u8)((uint)pbVar4 >> 0x10);
    in_r0->buf[7] = (u8)((uint)pbVar4 >> 0x18);
    in_r0->buf[0x14] = uVar5;
    in_r0->buf[0x13] = bVar1;
    uVar5 = rf_getChannel();
    in_r0->buf[0x15] = uVar5;
    in_r0->buf[8] = uStack_30;
    in_r0->buf[9] = uStack_2f;
    in_r0->buf[0x12] = uStack_3d;
    if (uStack_3d == '\x03')
    {
      memcpy(in_r0->buf + 10, &uStack_2e, 8);
    }
    else
    {
      in_r0->buf[10] = uStack_2e;
      in_r0->buf[0xb] = uStack_2d;
    }
    tl_zbPhyIndication();
  }
  else
  {
  LAB_00014066:
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 mac_csmaStart(void)

{
  u32 uVar1;
  int iVar2;
  u32 uVar3;

  uVar1 = drv_disable_irq();
  iVar2 = rf_performCCA();
  if ((iVar2 == 4) || (g_zbInfo.macPib.maxCsmaBackoffs == '\0'))
  {
    if ((rf_busyFlag & 4) != 0)
    {
      rf_busyFlag = rf_busyFlag & 0xfb;
    }
    mac_trx_vars[4] = 2;
    rf_busyFlag = rf_busyFlag | 2;
    rf802154_tx();
    drv_restore_irq(uVar1);
    uVar1 = drv_disable_irq();
    if (g_macTimerEvt[8] == '\0')
    {
      g_macTimerEvt._0_4_ = mac_waitTxIrqCb;
      uVar3 = mac_currentTickGet();
      g_macTimerEvt._4_4_ = uVar3 + sysTimerPerUs * 10000;
      g_macTimerEvt[8] = '\x01';
    }
    else
    {
      sys_exceptionPost(0x6a, '#');
    }
    drv_restore_irq(uVar1);
  }
  else
  {
    drv_restore_irq(uVar1);
    tl_zbTaskPost(mac_trxTask, &_d);
  }
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zb_macTimerEventProc(void)

{
  int iVar1;
  u32 uVar2;

  iVar1 = g_macTimerEvt._4_4_;
  if ((g_macTimerEvt[8] != '\0') && (uVar2 = mac_currentTickGet(), 0x80000000 < iVar1 - uVar2))
  {
    uVar2 = drv_disable_irq();
    if (g_macTimerEvt._0_4_ != 0)
    {
      FUNBBBBH();
    }
    g_macTimerEvt[8] = '\0';
    drv_restore_irq(uVar2);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int FUNBBBBH(void)

{
  int iVar1;
  code *in_r3;

  (*in_r3)();
  iVar1 = 0;
  if ((uint)tx_fifo_wptr != (uint)tx_fifo_rptr)
  {
    iVar1 = g_pTxQueue + ((uint)tx_fifo_rptr & MAC_TX_QUEUE_SIZE - 1) * 0x10;
  }
  return iVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int get_next_data(void)

{
  int iVar1;

  iVar1 = 0;
  if ((uint)tx_fifo_wptr != (uint)tx_fifo_rptr)
  {
    iVar1 = g_pTxQueue + ((uint)tx_fifo_rptr & MAC_TX_QUEUE_SIZE - 1) * 0x10;
  }
  return iVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void free_tx_buff(void)

{
  u32 en;

  en = drv_disable_irq();
  tx_fifo_rptr = tx_fifo_rptr + '\x01';
  drv_restore_irq(en);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_resetTx_info(void)

{
  if (mac_trx_vars[10] == '\0')
  {
    free_tx_buff();
  }
  g_macTimerEvt[8] = 0;
  mac_trx_vars._0_4_ = 0;
  mac_trx_vars._4_4_ = 0;
  mac_trx_vars._8_4_ = 0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_sendTxCnf(void)

{
  char cVar1;
  bool bVar2;
  byte *in_r0;

  mac_resetTx_info();
  cVar1 = *(char *)(*(int *)(in_r0 + 4) + 0xc1);
  bVar2 = false;
  if ((in_r0[2] == 0) && ((*in_r0 & 0xf0) != 0))
  {
    in_r0[2] = 0x20;
    bVar2 = true;
  }
  if (((g_zbInfo.macPib.rxOnWhenIdle == '\0') && (g_zbMacCtx.status == '\0')) &&
      ((!bVar2 || (1 < (byte)(cVar1 + 0x18U)))))
  {
    rf_setTrxState('\x03');
  }
  if (*(int *)(in_r0 + 0xc) == 0)
  {
    tl_zbMaxTxConfirmCb(*(undefined4 *)(in_r0 + 4), in_r0[2]);
  }
  else
  {
    macDataPendingListManage();
  }
  if ((!bVar2) && (tx_fifo_wptr != tx_fifo_rptr))
  {
    mac_trigger_tx((void *)0x0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_trxTask(void)

{
  byte *arg;
  u8 uVar1;
  hw_timer_sts_t hVar2;
  uint in_r0;
  int iVar3;
  u32 uVar4;
  byte bVar5;
  char cVar6;
  u32 uVar7;
  uint uVar8;
  uint uVar9;
  bool bVar10;

  arg = mac_trx_vars._0_4_;
  uVar8 = in_r0 & 0xff;
  bVar5 = mac_trx_vars[4];
  uVar9 = (uint)mac_trx_vars[4];
  if (((uVar9 == 4) || (~uVar9 + uVar9 != 0)) && (uVar8 == 0))
  {
    if (~uVar9 + uVar9 != 0)
    {
      mac_trx_vars[11] = mac_trx_vars._0_4_[3];
      mac_trx_vars[9] = (byte)(((uint)*mac_trx_vars._0_4_ << 0x1c) >> 0x1c);
      mac_trx_vars[8] = (byte)uVar8;
      rf802154_tx_ready(*(u8 **)(mac_trx_vars._0_4_ + 8), mac_trx_vars._0_4_[1]);
    }
    mac_trx_vars[6] = 0;
    mac_trx_vars[7] = g_zbInfo.macPib.minBe;
    mac_trx_vars[4] = 1;
    mac_trx_vars[5] = 0;
  }
  else
  {
    if (uVar9 != 1)
    {
      if (uVar9 == 2)
      {
        if (uVar8 != 3)
        {
          if (uVar8 != 4)
          {
            return;
          }
          mac_trx_vars[4] = 6;
          mac_trx_vars._0_4_[2] = 0x1d;
          g_sysDiags.macTxIrqTimeoutCnt = g_sysDiags.macTxIrqTimeoutCnt + '\x01';
          mac_sendTxCnf();
          return;
        }
        if (g_macTimerEvt[8] != '\x01')
        {
          return;
        }
        g_macTimerEvt[8] = 0;
        if (mac_trx_vars[9] == 0)
        {
          mac_trx_vars[4] = 6;
          mac_trx_vars._0_4_[2] = 0;
          tl_zbTaskPost(mac_sendTxCnf, arg);
          return;
        }
        mac_trx_vars[4] = (byte)uVar8;
        uVar7 = drv_disable_irq();
        if (g_macTimerEvt[8] == 0)
        {
          g_macTimerEvt._0_4_ = mac_ackWaitingTimerCb;
          uVar4 = mac_currentTickGet();
          g_macTimerEvt._4_4_ = uVar4 + sysTimerPerUs * 2000;
          g_macTimerEvt[8] = bVar5;
        }
        else
        {
          sys_exceptionPost(0x6a, '#');
        }
        drv_restore_irq(uVar7);
        return;
      }
      if (uVar9 != 3)
      {
        return;
      }
      if (uVar8 == 5)
      {
        if (g_macTimerEvt[8] != '\x02')
        {
          return;
        }
        g_macTimerEvt[8] = 0;
        if ((in_r0 << 8) >> 0x18 == 0)
        {
          *mac_trx_vars._0_4_ = *mac_trx_vars._0_4_ & 0xf;
        }
        else
        {
          *mac_trx_vars._0_4_ = *mac_trx_vars._0_4_ & 0xf | 0x10;
        }
        mac_trx_vars[4] = 6;
        arg[2] = 0;
        *(char *)(*(int *)(arg + 4) + 0xc2) = (char)(in_r0 >> 8);
        mac_sendTxCnf();
        return;
      }
      if (uVar8 != 6)
      {
        return;
      }
      if (g_zbInfo.macPib.frameRetryNum <= mac_trx_vars[8])
      {
        g_sysDiags.macTxUcastFail = g_sysDiags.macTxUcastFail + 1;
        mac_trx_vars[4] = (byte)in_r0;
        mac_trx_vars[8] = mac_trx_vars[8] + 1;
        mac_trx_vars._0_4_[2] = 0xe9;
        *(undefined *)(*(int *)(arg + 4) + 0xc2) = 0x92;
        mac_sendTxCnf();
        return;
      }
      g_sysDiags.macTxUcastRetry = g_sysDiags.macTxUcastRetry + 1;
      mac_trx_vars[8] = mac_trx_vars[8] + 1;
      goto LAB_0001432a;
    }
    if (uVar8 != 2)
    {
      return;
    }
  }
  bVar5 = mac_trx_vars[6] + 1;
  if (g_zbInfo.macPib.maxCsmaBackoffs <= mac_trx_vars[6])
  {
    cVar6 = mac_trx_vars[8] + 1;
    bVar10 = g_zbInfo.macPib.frameRetryNum <= mac_trx_vars[8];
    mac_trx_vars[6] = bVar5;
    mac_trx_vars[8] = cVar6;
    if (bVar10)
    {
      g_sysDiags.macTxCcaFail = g_sysDiags.macTxCcaFail + 1;
      mac_trx_vars[4] = 6;
      arg[2] = 0xe1;
      mac_sendTxCnf();
      return;
    }
  LAB_0001432a:
    mac_trx_vars[4] = 4;
    tl_zbTaskPost(mac_trxTask, (void *)0x0);
    return;
  }
  mac_trx_vars[6] = bVar5;
  uVar1 = rf_TrxStateGet();
  if (uVar1 != '\x01')
  {
    rf_setTrxState('\x01');
  }
  if (mac_trx_vars[6] == 1)
  {
    mac_csmaStart();
    return;
  }
  if (mac_trx_vars[7] != 0)
  {
    uVar7 = drv_u32Rand();
    iVar3 = FUN_00001628(uVar7 & 0xffff, (1 << (uint)mac_trx_vars[7]) + -1);
    uVar7 = iVar3 * 0x140;
    if (uVar7 != 0)
      goto LAB_000144ac;
  }
  uVar7 = 200;
LAB_000144ac:
  hVar2 = drv_hwTmr_set('\x03', uVar7, mac_csmaStart, arg);
  if (hVar2 != HW_TIMER_SUCC)
  {
    drv_disable_irq();
    sys_exceptionPost(0x12f, '!');
  }
  if (g_zbInfo.macPib.maxBe <= mac_trx_vars[7])
  {
    mac_trx_vars[7] = g_zbInfo.macPib.maxBe;
    return;
  }
  mac_trx_vars[7] = mac_trx_vars[7] + 1;
  return;
}

void mac_trigger_tx(void *arg)

{
  int iVar1;

  if (((mac_trx_vars[4] == '\0') && (g_zbMacCtx.indirectData.timer == (ev_timer_event_t *)0x0)) &&
      (iVar1 = get_next_data(), iVar1 != 0))
  {
    mac_trx_vars._0_4_ = iVar1;
    mac_trxTask();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbMacTx(void)

{
  undefined4 in_r0;
  u32 en;
  int in_r1;
  int in_r2;
  char in_r3;
  byte *pbVar1;
  undefined4 uVar2;
  undefined4 in_stack_00000000;

  if (in_r2 * 0x1000000 < 0)
  {
    mac_trigger_tx((void *)0x0);
    uVar2 = 0xe5;
  }
  else
  {
    en = drv_disable_irq();
    if (((uint)tx_fifo_wptr - (uint)tx_fifo_rptr & 0xff) < (uint)MAC_TX_QUEUE_SIZE)
    {
      pbVar1 = (byte *)(g_pTxQueue + (MAC_TX_QUEUE_SIZE - 1 & (uint)tx_fifo_wptr) * 0x10);
      tx_fifo_wptr = tx_fifo_wptr + 1;
      drv_restore_irq(en);
      uVar2 = 0x1a;
      if (pbVar1 != (byte *)0x0)
      {
        pbVar1[4] = (byte)in_r0;
        pbVar1[5] = (byte)((uint)in_r0 >> 8);
        pbVar1[6] = (byte)((uint)in_r0 >> 0x10);
        pbVar1[7] = (byte)((uint)in_r0 >> 0x18);
        *pbVar1 = *pbVar1 & 0xf0 | 1U - (in_r3 == '\0');
        pbVar1[1] = (byte)((uint)(in_r2 * 0x1000000) >> 0x18);
        pbVar1[8] = (byte)in_r1;
        pbVar1[9] = (byte)((uint)in_r1 >> 8);
        pbVar1[10] = (byte)((uint)in_r1 >> 0x10);
        pbVar1[0xb] = (byte)((uint)in_r1 >> 0x18);
        pbVar1[3] = *(byte *)(in_r1 + 2);
        pbVar1[0xc] = (byte)in_stack_00000000;
        pbVar1[0xd] = (byte)((uint)in_stack_00000000 >> 8);
        pbVar1[0xe] = (byte)((uint)in_stack_00000000 >> 0x10);
        pbVar1[0xf] = (byte)((uint)in_stack_00000000 >> 0x18);
        uVar2 = 0;
      }
    }
    else
    {
      drv_restore_irq(en);
      uVar2 = 0x1a;
    }
    mac_trigger_tx((void *)0x0);
  }
  return uVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void mac_trxInit(void)

{
  mac_trx_vars._0_4_ = 0;
  mac_trx_vars._4_4_ = 0;
  mac_trx_vars._8_4_ = 0;
  g_pTxQueue = g_txQueue;
  rf_init();
  return;
}

void tl_zbMacMlmeScanConfirmHandler(void *arg)

{
  switch (g_zbNwkCtx._47_1_ >> 4)
  {
  default:
    zb_buf_free((zb_buf_t *)arg);
    break;
  case 1:
    nwk_formationScanCnfHandler();
    break;
  case 3:
    nwk_discoveryScanCnfHandler();
    break;
  case 4:
    nwk_rejoinScanCnfHandler();
    break;
  case 5:
    nwk_directJoinScanCnfHandler();
    break;
  case 7:
    nwk_edScanCnfHandler();
  }
  return;
}

void tl_zbMacMlmeStartConfirmHandler(void *arg)

{
  byte bVar1;

  bVar1 = g_zbNwkCtx._47_1_ >> 4;
  if (bVar1 == 2)
  {
    nwk_startRouterCnfHandler();
  }
  else if (bVar1 == 6)
  {
    nwk_panIdConflictCnfHandler();
  }
  else if (bVar1 == 1)
  {
    nwk_formationStartCnfHandler();
  }
  else
  {
    zb_buf_free((zb_buf_t *)arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkNibInit(void)

{
  char in_r0;
  device_type_t dVar1;

  if (in_r0 == '\0')
  {
    g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xfe;
    dVar1 = af_nodeDevTypeGet();
    if (dVar1 == DEVICE_TYPE_COORDINATOR)
    {
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x10;
    }
  }
  else
  {
    memcpy(&g_zbInfo.nwkNib, &nwkNibDefault, 0x3c);
    g_zbInfo.nwkNib.extPANId[0] = '\0';
    g_zbInfo.nwkNib.extPANId[1] = '\0';
    g_zbInfo.nwkNib.extPANId[2] = '\0';
    g_zbInfo.nwkNib.extPANId[3] = '\0';
    g_zbInfo.nwkNib.extPANId[4] = '\0';
    g_zbInfo.nwkNib.extPANId[5] = '\0';
    g_zbInfo.nwkNib.extPANId[6] = '\0';
    g_zbInfo.nwkNib.extPANId[7] = '\0';
    g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 1;
  }
  return;
}

void tl_zbNwkInit(u8 coldReset)

{
  u32 uVar1;

  memset(&g_zbNwkCtx, 0, 0x4f);
  g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ | 0x10;
  tl_zbNwkAddrMapInit();
  tl_zbNwkNibInit();
  tl_zbNeighborTableInit();
  nwkTxDataPendTabInit();
  nwkBrcTransTabInit();
  nwkRouteDiscTabInit();
  nwkRoutingTabInit();
  uVar1 = drv_u32Rand();
  g_zbInfo.nwkNib.seqNum = (u8)uVar1;
  if (g_zbInfo.macPib.maxBe != 0)
  {
    g_zbInfo.nwkNib.passiveAckTimeout =
        ((0x140 << (uint)g_zbInfo.macPib.maxBe) + -0x140) * (uint)g_zbInfo.macPib.maxCsmaBackoffs;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint nwkHdrParse(void)

{
  byte bVar1;
  undefined *in_r0;
  uint uVar2;
  void *in_r1;
  int iVar3;
  byte *pbVar4;

  memcpy(in_r0 + 4, in_r1, 2);
  uVar2 = 2;
  if ((in_r0[4] & 3) != 3)
  {
    iVar3 = (uint) * (byte *)((int)in_r1 + 3) * 0x100 + (uint) * (byte *)((int)in_r1 + 2);
    *in_r0 = (char)iVar3;
    in_r0[1] = (char)((uint)iVar3 >> 8);
    iVar3 = (uint) * (byte *)((int)in_r1 + 5) * 0x100 + (uint) * (byte *)((int)in_r1 + 4);
    in_r0[2] = (char)iVar3;
    in_r0[3] = (char)((uint)iVar3 >> 8);
    in_r0[6] = *(undefined *)((int)in_r1 + 6);
    in_r0[7] = *(undefined *)((int)in_r1 + 7);
    pbVar4 = (byte *)((int)in_r1 + 8);
    uVar2 = (uint)(byte)in_r0[5];
    if ((int)(uVar2 << 0x1c) < 0)
    {
      memcpy(in_r0 + 8, pbVar4, 8);
      pbVar4 = (byte *)((int)in_r1 + 0x10);
      uVar2 = (uint)(byte)in_r0[5];
    }
    if ((int)(uVar2 << 0x1b) < 0)
    {
      memcpy(in_r0 + 0x10, pbVar4, 8);
      pbVar4 = pbVar4 + 8;
      uVar2 = (uint)(byte)in_r0[5];
    }
    if ((int)(uVar2 << 0x1f) < 0)
    {
      in_r0[0x18] = *pbVar4;
      pbVar4 = pbVar4 + 1;
    }
    if ((int)(uVar2 << 0x1d) < 0)
    {
      bVar1 = *pbVar4;
      in_r0[0x1a] = bVar1;
      in_r0[0x1b] = pbVar4[1];
      pbVar4 = pbVar4 + 2;
      in_r0[0x1c] = (char)pbVar4;
      in_r0[0x1d] = (char)((uint)pbVar4 >> 8);
      in_r0[0x1e] = (char)((uint)pbVar4 >> 0x10);
      in_r0[0x1f] = (char)((uint)pbVar4 >> 0x18);
      pbVar4 = pbVar4 + (uint)bVar1 * 2;
    }
    if ((int)(uVar2 << 0x1e) < 0)
    {
      pbVar4 = pbVar4 + 0xe;
    }
    uVar2 = (int)pbVar4 - (int)in_r1 & 0xff;
  }
  return uVar2;
}

u8 getNwkHdrSize(nwk_hdr_t *pNwkHdr)

{
  u8 uVar1;
  uint uVar2;

  uVar2 = (uint)(byte)(pNwkHdr->framecontrol).field_0x1;
  uVar1 = '\b';
  if ((int)(uVar2 << 0x1c) < 0)
  {
    uVar1 = '\x10';
  }
  if ((int)(uVar2 << 0x1b) < 0)
  {
    uVar1 = uVar1 + '\b';
  }
  if ((int)(uVar2 << 0x1f) < 0)
  {
    uVar1 = uVar1 + '\x01';
  }
  if ((int)(uVar2 << 0x1d) < 0)
  {
    uVar1 = uVar1 + (pNwkHdr->srcRouteSubFrame).relayCnt * '\x02' + '\x02';
  }
  if ((int)(uVar2 << 0x1e) < 0)
  {
    uVar1 = uVar1 + '\x0e';
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined *nwkHdrBuilder(void)

{
  void *in_r0;
  undefined *in_r1;
  uint uVar1;
  undefined *out;

  memcpy(in_r0, in_r1 + 4, 2);
  *(undefined *)((int)in_r0 + 2) = *in_r1;
  *(undefined *)((int)in_r0 + 3) = in_r1[1];
  *(undefined *)((int)in_r0 + 4) = in_r1[2];
  *(undefined *)((int)in_r0 + 5) = in_r1[3];
  *(undefined *)((int)in_r0 + 6) = in_r1[6];
  *(undefined *)((int)in_r0 + 7) = in_r1[7];
  out = (undefined *)((int)in_r0 + 8);
  uVar1 = (uint)(byte)in_r1[5];
  if ((int)(uVar1 << 0x1c) < 0)
  {
    memcpy(out, in_r1 + 8, 8);
    out = (undefined *)((int)in_r0 + 0x10);
    uVar1 = (uint)(byte)in_r1[5];
  }
  if ((int)(uVar1 << 0x1b) < 0)
  {
    memcpy(out, in_r1 + 0x10, 8);
    out = out + 8;
    uVar1 = (uint)(byte)in_r1[5];
  }
  if ((int)(uVar1 << 0x1f) < 0)
  {
    *out = in_r1[0x18];
    out = out + 1;
    uVar1 = (uint)(byte)in_r1[5];
  }
  if ((int)(uVar1 << 0x1d) < 0)
  {
    *out = in_r1[0x1a];
    out[1] = in_r1[0x1b];
    memcpy(out + 2, *(void **)(in_r1 + 0x1c), (uint)(byte)in_r1[0x1a] << 1);
    out = out + 2 + (uint)(byte)in_r1[0x1a] * 2;
  }
  return out;
}

void tl_zbNwkLinkStatusStop(void)

{
  if (linkStExpiry != '\0')
  {
    linkStExpiry = '\0';
  }
  if (linkStTimer != 0)
  {
    ev_timer_taskCancel((ev_timer_event_t **)&linkStTimer);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkNeighborTabAging(void)

{
  byte bVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  byte bVar3;
  byte idx;

  bVar1 = tl_zbNeighborTableNumGet();
  if (bVar1 != 0)
  {
    idx = 0;
    do
    {
      ptVar2 = tl_zbNeighborEntryGetFromIdx(idx);
      if ((((ptVar2 != (tl_zb_normal_neighbor_entry_t *)0x0) && ((ptVar2->field_0x1e & 0xe) != 4)) && (g_zbInfo.nwkNib.addrAlloc != '\0')) &&
          (bVar3 = ptVar2->age + 1, ptVar2->age = bVar3, g_zbInfo.nwkNib.routerAgeLimit <= bVar3))
      {
        ptVar2->outgoingCost = '\0';
        ptVar2->lqi = '\0';
        ptVar2->age = '\0';
        ptVar2->transFailure = '\0';
        g_sysDiags.neighborStale = g_sysDiags.neighborStale + 1;
      }
      idx = idx + 1;
    } while (idx < bVar1);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint nwk_linkStEntryBuild(void)

{
  ushort uVar1;
  byte bVar2;
  u16 uVar3;
  ushort *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  uint in_r1;
  ushort *puVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  ushort *puVar9;
  uint uVar10;
  ushort *puVar11;
  byte bVar12;
  uint uVar13;
  uint uVar14;
  ushort *in;

  uVar10 = 0;
  puVar11 = in_r0;
  for (bVar12 = 0; bVar2 = tl_zbNeighborTableNumGet(), bVar12 < bVar2; bVar12 = bVar12 + 1)
  {
    ptVar4 = tl_zbNeighborEntryGetFromIdx(bVar12);
    if (((ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0) && (ptVar4->lqi != '\0')) &&
        (((ptVar4->field_0x1e & 0xe) == 0 || ((ptVar4->field_0x1e & 0xe) == 2))))
    {
      uVar3 = tl_zbshortAddrByIdx(ptVar4->addrmapIdx);
      bVar2 = rf_lqi2cost(ptVar4->lqi);
      *(byte *)puVar11 = (byte)uVar3;
      *(byte *)((int)puVar11 + 1) = (byte)((uint)uVar3 >> 8);
      *(byte *)(puVar11 + 1) = 0;
      *(byte *)(puVar11 + 1) = (bVar2 & 7) + (ptVar4->outgoingCost & 7) * '\x10';
      uVar10 = uVar10 + 1 & 0xff;
      if ((in_r1 & 0xff) <= uVar10)
        break;
      puVar11 = (ushort *)((int)puVar11 + 3);
    }
  }
  if (1 < uVar10)
  {
    uVar8 = 1;
    puVar11 = in_r0;
    uVar14 = 0;
    if (1 < uVar10)
    {
      do
      {
        uVar6 = uVar8;
        uVar8 = uVar6;
        puVar9 = puVar11;
        uVar13 = uVar14;
        in = (ushort *)0x0;
        do
        {
          while (true)
          {
            uVar7 = uVar8;
            puVar5 = (ushort *)((int)in_r0 + uVar7 * 3);
            if ((*(byte *)((int)puVar9 + 1) <= *(byte *)((int)puVar5 + 1)) &&
                ((*(byte *)((int)puVar5 + 1) != *(byte *)((int)puVar9 + 1) ||
                  (*(byte *)puVar9 <= *(byte *)puVar5))))
              break;
            uVar8 = uVar7 + 1 & 0xff;
            puVar9 = puVar5;
            uVar13 = uVar7;
            in = puVar5;
            if (uVar10 <= uVar8)
              goto LAB_00014b9a;
          }
          uVar8 = uVar7 + 1 & 0xff;
        } while (uVar8 < uVar10);
      LAB_00014b9a:
        if ((in != (ushort *)0x0) && (uVar13 != uVar14))
        {
          uVar1 = *puVar11;
          bVar12 = *(byte *)(puVar11 + 1);
          uVar8 = (uint)bVar12;
          memcpy(puVar11, in, 3);
          *(byte *)in = (byte)uVar1;
          *(byte *)((int)in + 1) = (byte)((uint)uVar1 >> 8);
          *(byte *)(in + 1) = *(byte *)(in + 1) & 0xf8 | (byte)((uVar8 << 0x1d) >> 0x1d);
          *(byte *)(in + 1) = *(byte *)(in + 1) & 0xf7 | (byte)(((uVar8 << 0x1c) >> 0x1f) << 3);
          *(byte *)(in + 1) = *(byte *)(in + 1) & 0x8f | (byte)(((uVar8 << 0x19) >> 0x1d) << 4);
          *(byte *)(in + 1) = *(byte *)(in + 1) & 0x7f | bVar12 & 0x80;
        }
        puVar11 = (ushort *)((int)puVar11 + 3);
        uVar8 = uVar6 + 1 & 0xff;
        uVar14 = uVar6;
      } while (uVar8 < uVar10);
    }
  }
  return uVar10;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkLinkStatusCmdSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, (in_r2[8] & 0x1f) * '\x03' + '\x02');
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[8];
  if ((in_r2[8] & 0x1f) != 0)
  {
    memcpy(puVar1 + 2, *(void **)(in_r2 + 4), ((byte)in_r2[8] & 0x1f) * 3);
  }
  (in_r0->hdr).handle = in_r3;
  nwk_fwdPacket();
  return;
}

// WARNING: Could not reconcile some variable overlaps

void tl_zbNwkSendLinkStatus(void)

{
  byte bVar1;
  uint uVar2;
  byte bVar3;
  u8 uVar4;
  bool bVar5;
  char cVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  u8 *puVar11;
  u8 *puVar12;
  uint local_68;
  u8 *puStack_64;
  undefined local_60[4];
  undefined4 uStack_5c;
  undefined4 uStack_58;
  undefined4 uStack_54;
  undefined4 uStack_50;
  undefined4 uStack_4c;
  uint uStack_48;
  u8 *puStack_44;
  undefined4 local_40;
  u8 *puStack_3c;
  uint uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;
  undefined local_26;
  uint extraout_r0;

  bVar3 = tl_zbNeighborTableRouterValidNumGet();
  extraout_r0 = (uint)bVar3;
  puStack_64 = (u8 *)0x0;
  if (extraout_r0 == 0)
  {
  LAB_00014cee:
    local_68 = 1;
    uVar10 = 0;
  }
  else
  {
    uVar9 = ev_buf_getFreeMaxSize();
    uVar10 = extraout_r0;
    if (uVar9 < extraout_r0 * 3)
    {
      uVar10 = FUN_0000162c(uVar9, 3);
      uVar10 = uVar10 & 0xff;
    }
    puStack_64 = ev_buf_allocate((u16)(uVar10 * 0x30000 >> 0x10));
    if (puStack_64 == (u8 *)0x0)
    {
      sys_exceptionPost(0x162, '5');
      return;
    }
    uVar10 = nwk_linkStEntryBuild();
    if (uVar10 == 0)
      goto LAB_00014cee;
    uVar9 = FUN_0000162c(uVar10, 0x1a);
    cVar6 = FUN_00001628(uVar10, 0x1a);
    local_68 = (uVar9 & 0xff) + (uint)(cVar6 != '\0') & 0xff;
    if (local_68 == 0)
      goto LAB_00014e46;
  }
  uVar9 = 0;
  puVar12 = puStack_64;
  while (iVar7 = c1(), iVar7 != 0)
  {
    local_60 = (undefined[4])0x0;
    uStack_5c = 0;
    uStack_58 = 0;
    uStack_54 = 0;
    uStack_50 = 0;
    uStack_4c = 0;
    uStack_48 = 0;
    puStack_44 = (u8 *)0x0;
    uVar8 = 0;
    if (((ss_ib._62_1_ & 8) != 0) && (uVar8 = 0, (ss_ib._62_1_ & 7) != 0))
    {
      bVar5 = ss_keyPreconfigured();
      uVar8 = (uint)(bVar5 != false);
    }
    uVar2 = (ushort)((ushort)uStack_5c & 0xff00 | (ushort)uStack_5c & 0xc0 | 1 | 0x1008) &
            0xfffff7ff;
    uStack_5c._1_1_ = (byte)(uVar2 >> 8);
    uStack_5c._0_2_ =
        (nwkFrameCtrl_t)CONCAT11(uStack_5c._1_1_ & 0xfd | (byte)(uVar8 << 1), (char)uVar2);
    uStack_5c = uStack_5c & 0xffff0000 | (uint)(ushort)uStack_5c._0_2_;
    memcpy(&uStack_50, g_zbInfo.macPib.extAddress, 8);
    local_60 = (undefined[4])CONCAT22(g_zbInfo.nwkNib.nwkAddr, 0xfffb);
    uStack_5c = CONCAT13(g_zbInfo.nwkNib.seqNum, CONCAT12(1, uStack_5c._0_2_));
    g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
    uVar4 = getNwkHdrSize((nwk_hdr_t *)local_60);
    uStack_48._0_2_ = CONCAT11(uVar4, uStack_48._0_1_);
    uStack_48 = uStack_48 & 0xffff0000 | (uint)(ushort)uStack_48;
    uVar8 = uVar10;
    if (0x1a < (uVar10 & 0xff))
    {
      uVar8 = 0x1a;
    }
    uStack_34 = 0;
    uStack_30 = 0;
    uStack_2c = 0;
    local_28 = 0;
    local_26 = 0;
    local_40 = 8;
    uStack_38._0_1_ = (byte)uVar8 & 0x1f;
    bVar3 = (byte)uVar9;
    bVar1 = bVar3 - (char)(local_68 - 1);
    uStack_38 = (uint)(byte)((bVar1 + ~bVar1 + (local_68 - 1 <= uVar9)) * '@' |
                             (~bVar3 + bVar3) * ' ' & 0xbf | (byte)uStack_38);
    puVar11 = puVar12;
    if (puVar12 != (u8 *)0x0)
    {
      puVar11 = puVar12 + (uVar8 & 0xff) * 3;
    }
    puStack_3c = puVar12;
    nwkLinkStatusCmdSend();
    uVar9 = uVar9 + 1 & 0xff;
    if (local_68 <= uVar9)
      break;
    uVar10 = uVar10 - (uVar8 & 0xff) & 0xff;
    puVar12 = puVar11;
  }
  if (puStack_64 == (u8 *)0x0)
  {
    return;
  }
LAB_00014e46:
  ev_buf_free(puStack_64);
  return;
}

void tl_zbNwkLinkStatusStart(void)

{
  tl_zbNwkSendLinkStatus();
  if (g_zbInfo.nwkNib.linkStatusPeriod != '\0')
  {
    linkStExpiry = g_zbInfo.nwkNib.linkStatusPeriod;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbNwkLinkStatusTimerEvtCb(void)

{
  if ((int)((uint)g_zbNwkCtx._45_1_ << 0x1d) < 0)
  {
    T_DBG_linkStatus = T_DBG_linkStatus + '\x01';
    tl_zbNwkNeighborTabAging();
    tl_zbNwkLinkStatusStart();
  }
  linkStTimer = 0;
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_linkStPeriodic(void)

{
  u32 uVar1;

  if ((linkStExpiry != '\0') && (linkStExpiry = linkStExpiry + -1, linkStExpiry == '\0'))
  {
    uVar1 = drv_u32Rand();
    linkStTimer = ev_timer_taskPost(tl_zbNwkLinkStatusTimerEvtCb, (void *)0x0, (uVar1 & 0x7f) + 5);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkLinkStatusCmdHandler(void)

{
  byte bVar1;
  u16 *puVar2;
  u16 uVar3;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  int iVar5;
  short sVar6;
  int in_r1;
  int in_r2;
  uint uVar7;
  u16 *puVar8;
  uint uVar9;
  nebTbl_t *in_stack_ffffffbc;
  nebTbl_t *in_stack_ffffffc0;

  if ((byte)(in_r0->buf[0x1d] - *(char *)(in_r1 + 0x19)) !=
      (byte)((*(byte *)(in_r2 + 8) & 0x1f) * '\x03' + '\x02'))
    goto LAB_00014f9a;
  bVar1 = in_r0->buf[0x27];
  ptVar4 = nwk_neTblGetByShortAddr(*(u16 *)(in_r1 + 2));
  if (ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    if ((((int)((uint) * (byte *)(in_r1 + 5) << 0x1b) < 0) && (in_r0->buf[0x1c] == '\x02')) &&
        (*(u16 *)(in_r0->buf + 0x14) == *(u16 *)(in_r1 + 2)))
    {
      tl_zbNwkAddrMapAdd(*(u16 *)(in_r1 + 2),
                         (addrExt_t)CONCAT44(in_stack_ffffffc0, in_stack_ffffffbc),
                         (u16 *)(in_r1 + 0x10));
    }
    iVar5 = FUNBBBBK();
    if (iVar5 != 0)
      goto LAB_00014f9a;
    sVar6 = 0;
    if ((*(short *)(in_r1 + 2) == 0) &&
        (sVar6 = *(short *)(in_r1 + 2), (*(byte *)(in_r2 + 8) & 0x1f) != 0))
    {
      puVar2 = *(u16 **)(in_r2 + 4);
      sVar6 = 1;
      if (*puVar2 != g_zbInfo.nwkNib.nwkAddr)
      {
        uVar9 = 0;
        do
        {
          uVar9 = uVar9 + 1 & 0xff;
          if ((*(byte *)(in_r2 + 8) & 0x1f) <= uVar9)
          {
            sVar6 = 0;
            goto LAB_00015152;
          }
        } while (CONCAT11(*(undefined *)((int)puVar2 + uVar9 * 3 + 1),
                          *(undefined *)(uVar9 * 3 + (int)puVar2)) != g_zbInfo.nwkNib.nwkAddr);
        sVar6 = 1;
      }
    }
  LAB_00015152:
    ptVar4 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)&stack0xffffffbc, (u8)sVar6);
    if (ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0)
      goto LAB_00014f9a;
  }
  else
  {
    ptVar4->age = '\0';
    ptVar4->lqi = (u8)((int)((uint)bVar1 + (uint)ptVar4->lqi) >> 1);
    ptVar4->field_0x1e =
        ptVar4->field_0x1e & 0xf1 | ('\x01' - (*(short *)(in_r1 + 2) == 0)) * '\x02';
  }
  uVar7 = (uint) * (byte *)(in_r2 + 8);
  uVar9 = 0;
  if ((*(byte *)(in_r2 + 8) & 0x1f) == 0)
  {
  LAB_00015048:
    if ((uVar7 & 0x1f) != uVar9)
      goto LAB_00014f9a;
  }
  else
  {
    puVar2 = *(u16 **)(in_r2 + 4);
    uVar3 = *puVar2;
    puVar8 = puVar2;
    while (uVar3 != g_zbInfo.nwkNib.nwkAddr)
    {
      uVar9 = uVar9 + 1 & 0xff;
      if ((uVar7 & 0x1f) <= uVar9)
        goto LAB_00015048;
      puVar8 = (u16 *)((int)puVar2 + uVar9 * 3);
      uVar3 = *puVar8;
    }
    ptVar4->outgoingCost = (byte)(((uint) * (byte *)(puVar8 + 1) << 0x1d) >> 0x1d);
    uVar7 = (uint) * (byte *)(in_r2 + 8);
    if ((uVar7 & 0x1f) != uVar9)
      goto LAB_00014f9a;
  }
  if ((uVar7 & 0x60) == 0x60)
  {
    ptVar4->outgoingCost = '\0';
  }
LAB_00014f9a:
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint tl_zbNwkReportCmdHandler(void)

{
  byte bVar1;
  zb_buf_t *in_r0;
  uint uVar2;
  u16 *in_r1;

  if (*in_r1 == g_zbInfo.nwkNib.nwkAddr)
  {
    uVar2 = nwkReportCmdHandler();
  }
  else if (*(char *)(in_r1 + 3) == '\0')
  {
    bVar1 = zb_buf_free(in_r0);
    uVar2 = (uint)bVar1;
  }
  else
  {
    uVar2 = nwkReportCmdSend();
  }
  return uVar2;
}

void tl_zbNwkSendNwkStatusCmd(void *arg, nwk_hdr_t *pNwkHdr, nwkCmd_t *pNwkStatus, u8 handle)

{
  u16 uVar1;
  nwk_cmdId_t *pnVar2;
  int iVar3;

  if ((pNwkStatus->field2_0x4).rreq.dstIeeeAddr[2] == '\f')
  {
    if ((pNwkHdr->srcAddr != g_zbInfo.nwkNib.nwkAddr) &&
        (iVar3 = nwkRoutingTabEntryDstFind(), iVar3 != 0))
    {
      if ((*(u16 *)(iVar3 + 2) !=
           CONCAT11(g_zbNwkCtx.manyToOneRepair.senderAddr._1_1_,
                    (undefined)g_zbNwkCtx.manyToOneRepair.senderAddr)) &&
          (*(u16 *)(iVar3 + 2) != pNwkHdr->srcAddr))
        goto LAB_00015214;
      nwkRoutingTabEntryClear();
    }
    iVar3 = nwkVaildNeighborToFwd();
    if ((iVar3 == 0) || (pNwkHdr->srcAddr == g_zbInfo.nwkNib.nwkAddr))
    {
      do
      {
        iVar3 = tl_zbNeighborTabSearchForRouter();
        if (iVar3 == 0)
          break;
        uVar1 = tl_zbshortAddrByIdx(*(u16 *)(iVar3 + 0x16));
      } while (((uint)CONCAT11(g_zbNwkCtx.manyToOneRepair.senderAddr._1_1_,
                               (undefined)g_zbNwkCtx.manyToOneRepair.senderAddr) == (uint)uVar1) ||
               ((uint)(g_zbNwkCtx._72_4_ << 8) >> 0x10 == (uint)uVar1));
    }
    pnVar2 = (nwk_cmdId_t *)tl_bufInitalloc((zb_buf_t *)arg, '\x04');
    *pnVar2 = pNwkStatus->cmdId;
    pnVar2[1] = (pNwkStatus->field2_0x4).rreq.dstIeeeAddr[2];
    memcpy(pnVar2 + 2, &pNwkStatus->field2_0x4, 2);
    *(u8 *)((int)arg + 0xc1) = handle;
    nwk_tx();
  }
  else
  {
  LAB_00015214:
    pnVar2 = (nwk_cmdId_t *)tl_bufInitalloc((zb_buf_t *)arg, '\x04');
    *pnVar2 = pNwkStatus->cmdId;
    pnVar2[1] = (pNwkStatus->field2_0x4).rreq.dstIeeeAddr[2];
    memcpy(pnVar2 + 2, &pNwkStatus->field2_0x4, 2);
    *(u8 *)((int)arg + 0xc1) = handle;
    nwk_fwdPacket();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkStatusCmdHandler(void)

{
  byte bVar1;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  int iVar3;
  ushort uVar4;
  nwk_hdr_t *in_r1;
  nwkCmd_t *in_r2;
  u16 uVar5;

  bVar1 = (in_r2->field2_0x4).rreq.dstIeeeAddr[2];
  if (bVar1 == 0)
  {
  LAB_00015376:
    uVar4 = in_r1->dstAddr;
    uVar5 = g_zbInfo.nwkNib.nwkAddr;
  }
  else if (bVar1 < 3)
  {
    ptVar2 = nwk_neTblGetByShortAddr(*(u16 *)&in_r2->field2_0x4);
    if ((*(u16 *)&in_r2->field2_0x4 == g_zbInfo.nwkNib.nwkAddr) ||
        ((ptVar2 != (tl_zb_normal_neighbor_entry_t *)0x0 && ((ptVar2->field_0x1e & 0x7e) == 0x14))))
    {
      iVar3 = nwkRoutingTabEntryDstActiveGet();
      if (iVar3 != 0)
      {
        *(undefined *)(iVar3 + 4) = 3;
      }
      uVar4 = in_r1->dstAddr;
      uVar5 = g_zbInfo.nwkNib.nwkAddr;
    }
    else
    {
      uVar4 = in_r1->dstAddr;
      uVar5 = g_zbInfo.nwkNib.nwkAddr;
    }
  }
  else
  {
    if (bVar1 != 0xc)
      goto LAB_00015376;
    uVar4 = in_r1->dstAddr;
    uVar5 = uVar4;
    if ((uVar4 != g_zbInfo.nwkNib.nwkAddr) &&
        (uVar5 = g_zbInfo.nwkNib.nwkAddr, in_r1->radius != '\0'))
    {
      g_zbNwkCtx.manyToOneRepair.senderAddr._0_1_ = (undefined) * (undefined2 *)(in_r0->buf + 0x14);
      g_zbNwkCtx.manyToOneRepair.senderAddr._1_1_ =
          (undefined)((ushort) * (undefined2 *)(in_r0->buf + 0x14) >> 8);
      uVar4 = in_r1->dstAddr;
    }
  }
  if ((uVar4 & 0xfff8) == 0xfff8)
  {
    if (*(u16 *)&in_r2->field2_0x4 == uVar5)
      goto LAB_000153c2;
    if (in_r1->radius == '\0')
    {
      tl_zbNwkNlmeNwkStatusInd(in_r0, *(u16 *)&in_r2->field2_0x4, (in_r2->field2_0x4).rreq.dstIeeeAddr[2]);
      return;
    }
    iVar3 = nwkBrcTimerStart();
    if (iVar3 != 0)
    {
      iVar3 = nwkBrcTransEntryFind();
      if (iVar3 != 0)
      {
        nwkBrcTransTabEntryClear();
      }
      goto LAB_000153c2;
    }
    uVar4 = in_r1->dstAddr;
    uVar5 = g_zbInfo.nwkNib.nwkAddr;
    if ((uVar4 & 0xfff8) == 0xfff8)
      goto LAB_000154d0;
  }
  if (uVar4 == uVar5)
  {
  LAB_000154d0:
    tl_zbNwkNlmeNwkStatusInd(in_r0, *(u16 *)&in_r2->field2_0x4, (in_r2->field2_0x4).rreq.dstIeeeAddr[2]);
    return;
  }
  if (in_r1->radius != '\0')
  {
    tl_zbNwkSendNwkStatusCmd(in_r0, in_r1, in_r2, 0xc9);
    return;
  }
LAB_000153c2:
  zb_buf_free(in_r0);
  return;
}

void tl_zbNwkTaskProc(void)

{
  tl_zb_task_t *ptVar1;
  int iVar2;
  undefined1 *puVar3;
  tl_zb_task_t tStack_20;

  ptVar1 = tl_zbTaskQPop('\x03', &tStack_20);
  if ((ptVar1 != (tl_zb_task_t *)0x0) && (iVar2 = 0, tStack_20.data != (void *)0x0))
  {
    puVar3 = g_zbNwkEventFromHighTbl;
    do
    {
      if ((*puVar3 == *(char *)((int)tStack_20.data + 0xc0)) &&
          (*(int *)(g_zbNwkEventFromHighTbl + iVar2 * 5 + 1) != 0))
      {
        FUNBBBBJ();
        break;
      }
      iVar2 = iVar2 + 1;
      puVar3 = puVar3 + 5;
    } while (iVar2 != 0xb);
  }
  ptVar1 = tl_zbTaskQPop('\x01', &tStack_20);
  if ((ptVar1 != (tl_zb_task_t *)0x0) && (tStack_20.data != (void *)0x0))
  {
    puVar3 = g_zbNwkEventFromMacTbl;
    iVar2 = 0;
    do
    {
      if ((*puVar3 == *(char *)((int)tStack_20.data + 0xc0)) &&
          (*(int *)(g_zbNwkEventFromMacTbl + iVar2 * 5 + 1) != 0))
      {
        FUNBBBBJ();
        return;
      }
      iVar2 = iVar2 + 1;
      puVar3 = puVar3 + 5;
    } while (iVar2 != 0xc);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

byte FUNBBBBJ(void)

{
  code *in_r3;

  (*in_r3)();
  return g_zbNwkCtx._45_1_ & 1;
}

u8 is_device_factory_new(void)

{
  return g_zbNwkCtx._45_1_ & 1;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwk_addrConflictCb(void)

{
  ushort uVar1;
  uint uVar2;
  u8 uVar3;
  bool bVar4;
  zb_buf_t *in_r0;
  uint uVar5;
  undefined local_54[4];
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined4 uStack_40;
  uint uStack_3c;
  u8 *puStack_38;
  undefined local_34[8];
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined2 local_1c;
  undefined local_1a;

  if (conflictInfo != (ushort *)0x0)
  {
    uVar1 = *conflictInfo;
    zb_buf_clear(in_r0);
    local_54 = (undefined[4])0x0;
    uStack_50 = 0;
    uStack_4c = 0;
    uStack_48 = 0;
    uStack_44 = 0;
    uStack_40 = 0;
    uStack_3c = 0;
    puStack_38 = (u8 *)0x0;
    local_34._0_4_ = 0;
    local_34._4_4_ = 0;
    uStack_2c = 0;
    uStack_28 = 0;
    uStack_24 = 0;
    uStack_20 = 0;
    local_1c = 0;
    local_1a = 0;
    uVar5 = 0;
    if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
    {
      bVar4 = ss_keyPreconfigured();
      uVar5 = (uint)(bVar4 != false);
    }
    uVar2 = (ushort)((ushort)uStack_50 & 0xff00 | (ushort)uStack_50 & 0xc0 | 1 | 0x1008) &
            0xfffff7ff;
    uStack_50._1_1_ = (byte)(uVar2 >> 8);
    uStack_50._0_2_ =
        (nwkFrameCtrl_t)CONCAT11(uStack_50._1_1_ & 0xfd | (byte)(uVar5 << 1), (char)uVar2);
    uStack_50 = uStack_50 & 0xffff0000 | (uint)(ushort)uStack_50._0_2_;
    memcpy(&uStack_44, g_zbInfo.macPib.extAddress, 8);
    local_54 = (undefined[4])CONCAT22(g_zbInfo.macPib.shortAddress, 0xfffc);
    uStack_50 = CONCAT13(g_zbInfo.nwkNib.seqNum,
                         CONCAT12(g_zbInfo.nwkNib.maxDepth << 1, uStack_50._0_2_));
    g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
    uVar3 = getNwkHdrSize((nwk_hdr_t *)local_54);
    uStack_3c._0_2_ = CONCAT11(uVar3, uStack_3c._0_1_);
    uStack_3c = uStack_3c & 0xffff0000 | (uint)(ushort)uStack_3c;
    local_34._0_4_ = CONCAT31(local_34._1_3_, 3);
    local_34._4_4_ = local_34._4_4_ & 0xff000000 | (uint)uVar1 | 0xd0000;
    tl_zbNwkSendNwkStatusCmd(conflictInfo, (nwk_hdr_t *)local_54, (nwkCmd_t *)local_34, 0xc9);
  }
  conflictInfo = (ushort *)0x0;
  addrConflictHandleTimer = 0;
  return 0xfffffffe;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkNeighborAddrConflictHandle(void)

{
  byte bVar1;
  ushort uVar2;
  u8 uVar3;
  bool bVar4;
  u16 uVar5;
  u16 uVar6;
  int in_r0;
  int iVar7;
  int in_r1;
  int iVar8;
  undefined4 in_stack_ffffff90;
  undefined uVar9;
  undefined4 in_stack_ffffff94;
  undefined local_68[4];
  undefined4 uStack_64;
  undefined4 local_60;
  undefined4 uStack_5c;
  undefined4 uStack_58;
  undefined4 uStack_54;
  uint uStack_50;
  u8 *puStack_4c;
  undefined4 local_48;
  uint uStack_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined2 local_30;
  undefined local_2e;
  undefined4 local_2c;
  undefined4 uStack_28;

  uVar5 = tl_zbNwkStochasticAddrCal();
  uVar6 = tl_zbshortAddrByIdx(*(u16 *)(in_r1 + 0x16));
  tl_zbExtAddrByIdx(*(u16 *)(in_r1 + 0x16), (addrExt_t)CONCAT44(in_stack_ffffff94, in_stack_ffffff90));
  local_68 = (undefined[4])0x0;
  uStack_64 = 0;
  local_60 = 0;
  uStack_5c = 0;
  uStack_58 = 0;
  uStack_54 = 0;
  uStack_50 = 0;
  puStack_4c = (u8 *)0x0;
  local_48 = 0;
  uStack_44 = 0;
  uStack_40 = 0;
  uStack_3c = 0;
  uStack_38 = 0;
  uStack_34 = 0;
  local_30 = 0;
  local_2e = 0;
  if ((int)((uint)ss_ib._62_1_ << 0x1c) < 0)
  {
    if ((ss_ib._62_1_ & 7) == 0)
    {
      iVar8 = 0;
      uVar9 = 0;
    }
    else
    {
      bVar4 = ss_keyPreconfigured();
      if (bVar4 == false)
      {
        iVar8 = 0;
        uVar9 = 0;
      }
      else
      {
        iVar8 = 1;
        uVar9 = 1;
      }
    }
  }
  else
  {
    iVar8 = 0;
    uVar9 = 0;
  }
  uStack_64 = uStack_64 & 0xffff0000 |
              (uint)(ushort)((ushort)uStack_64 & 0xff00 | (ushort)uStack_64 & 0xc0 | 1 | 8) | 0x1000;
  iVar7 = memcmp(&local_2c, &g_zero_addr, 8);
  bVar1 = ('\x01' - (iVar7 == 0)) * '\b';
  uStack_64._0_2_ =
      (nwkFrameCtrl_t)
          CONCAT11(uStack_64._1_1_ & 0xf5 | bVar1 | (byte)(iVar8 << 1), (undefined)uStack_64);
  uStack_64 = uStack_64 & 0xffff0000 | (uint)(ushort)uStack_64._0_2_;
  if ((bVar1 & 8) != 0)
  {
    local_60 = uStack_28;
    uStack_5c = local_2c;
  }
  memcpy(&uStack_58, g_zbInfo.macPib.extAddress, 8);
  local_68 = (undefined[4])CONCAT22(g_zbInfo.macPib.shortAddress, uVar6);
  uStack_64 = CONCAT13(g_zbInfo.nwkNib.seqNum,
                       CONCAT12(g_zbInfo.nwkNib.maxDepth << 1, uStack_64._0_2_));
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar3 = getNwkHdrSize((nwk_hdr_t *)local_68);
  uStack_50._0_2_ = CONCAT11(uVar3, uStack_50._0_1_);
  uStack_50 = uStack_50 & 0xffff0000 | (uint)(ushort)uStack_50;
  local_48 = CONCAT31(local_48._1_3_, 7);
  uStack_44 = uStack_44 & 0xff000000 | (uint)uVar5;
  *(undefined *)(in_r0 + 0x28) = uVar9;
  tl_zbNwkSendRejoinRespCmd();
  uVar2 = *(ushort *)(in_r1 + 0x16);
  *(char *)&g_nwkAddrMap.addrMap[uVar2].shortAddr = (char)uVar5;
  *(char *)((int)&g_nwkAddrMap.addrMap[uVar2].shortAddr + 1) = (char)((uint)uVar5 >> 8);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void tl_zbNwkAddrConflictStatusSend(u16 dstAddr, u16 statusAddr, u8 forceSeqNum)

{
  uint uVar1;
  u8 uVar2;
  bool bVar3;
  void *arg;
  uint uVar4;
  undefined local_58[4];
  undefined4 uStack_54;
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  u8 *puStack_3c;
  undefined local_38[8];
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  undefined local_1e;

  arg = (void *)c1();
  if (arg != (void *)0x0)
  {
    local_58 = (undefined[4])0x0;
    uStack_54 = 0;
    uStack_50 = 0;
    uStack_4c = 0;
    uStack_48 = 0;
    uStack_44 = 0;
    uStack_40 = 0;
    puStack_3c = (u8 *)0x0;
    local_38._0_4_ = 0;
    local_38._4_4_ = 0;
    uStack_30 = 0;
    uStack_2c = 0;
    uStack_28 = 0;
    uStack_24 = 0;
    local_20 = 0;
    local_1e = 0;
    uVar4 = 0;
    if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
    {
      bVar3 = ss_keyPreconfigured();
      uVar4 = (uint)(bVar3 != false);
    }
    uVar1 = (ushort)((ushort)uStack_54 & 0xff00 | (ushort)uStack_54 & 0xc0 | 1 | 0x1008) &
            0xfffff7ff;
    uStack_54._1_1_ = (byte)(uVar1 >> 8);
    uStack_54._0_2_ =
        (nwkFrameCtrl_t)CONCAT11(uStack_54._1_1_ & 0xfd | (byte)(uVar4 << 1), (char)uVar1);
    uStack_54 = uStack_54 & 0xffff0000 | (uint)(ushort)uStack_54._0_2_;
    memcpy(&uStack_48, g_zbInfo.macPib.extAddress, 8);
    local_58 = (undefined[4])CONCAT22(g_zbInfo.macPib.shortAddress, dstAddr);
    uVar2 = '\0';
    if (forceSeqNum == '\0')
    {
      uVar2 = g_zbInfo.nwkNib.seqNum;
      g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
    }
    uStack_54 = CONCAT13(uVar2, CONCAT12(g_zbInfo.nwkNib.maxDepth << 1, uStack_54._0_2_));
    uVar2 = getNwkHdrSize((nwk_hdr_t *)local_58);
    uStack_40._0_2_ = CONCAT11(uVar2, uStack_40._0_1_);
    uStack_40 = uStack_40 & 0xffff0000 | (uint)(ushort)uStack_40;
    local_38._0_4_ = CONCAT31(local_38._1_3_, 3);
    local_38._4_4_ = local_38._4_4_ & 0xff000000 | (uint)statusAddr | 0xd0000;
    tl_zbNwkSendNwkStatusCmd(arg, (nwk_hdr_t *)local_58, (nwkCmd_t *)local_38, 0xc9);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkAddrConflictHandle(void)

{
  u16 shortAddr;
  undefined2 *in_r0;
  u32 uVar1;
  int iVar2;
  undefined2 in_r1;
  int in_r2;
  undefined4 unaff_r8;
  undefined in_stack_ffffffe4;
  undefined in_stack_ffffffe5;

  if (addrConflictHandleTimer != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel(&addrConflictHandleTimer);
  }
  if (conflictInfo != (zb_buf_t *)0x0)
  {
    zb_buf_free(conflictInfo);
  }
  conflictInfo = (zb_buf_t *)in_r0;
  *in_r0 = in_r1;
  uVar1 = drv_u32Rand();
  addrConflictHandleTimer = ev_timer_taskPost(nwk_addrConflictCb, in_r0, (uVar1 & 0x3f) + 1);
  if (in_r2 == 0)
  {
    shortAddr = tl_zbNwkStochasticAddrCal();
    g_zbInfo.macPib.shortAddress._0_1_ = (undefined)shortAddr;
    g_zbInfo.macPib.shortAddress._1_1_ = (undefined)((uint)shortAddr >> 8);
    g_zbInfo.nwkNib.nwkAddr._0_1_ = (undefined)g_zbInfo.macPib.shortAddress;
    g_zbInfo.nwkNib.nwkAddr._1_1_ = g_zbInfo.macPib.shortAddress._1_1_;
    tl_zbNwkAddrMapAdd(shortAddr,
                       (addrExt_t)
                           CONCAT44(unaff_r8, (uint)CONCAT11(in_stack_ffffffe5, in_stack_ffffffe4)),
                       (u16 *)g_zbInfo.macPib.extAddress);
    zb_info_save((void *)0x0);
    zdo_device_announce_send();
  }
  else if (((*(byte *)(in_r2 + 0x1e) & 0x7f) == 0x14) && (iVar2 = c1(), iVar2 != 0))
  {
    tl_zbNwkNeighborAddrConflictHandle();
  }
  return;
}

bool tl_zbNwkAddrConflictDetect(void *arg, u16 nwkAddr, addrExt_t ieeeAddr)

{
  tl_zb_normal_neighbor_entry_t *ptVar1;
  int iVar2;
  uint uVar3;
  void *in_r2;
  undefined in_stack_ffffffd4;
  undefined7 in_stack_ffffffd5;

  uVar3 = (uint)nwkAddr;
  if ((~uVar3 + uVar3 != 0) && (g_zbInfo.nwkNib.nwkAddr == uVar3))
  {
    return false;
  }
  if ((g_zbInfo.nwkNib.nwkAddr != uVar3) ||
      (iVar2 = memcmp(in_r2, g_zbInfo.macPib.extAddress, 8), iVar2 == 0))
  {
    ptVar1 = tl_zbNeighborTableSearchFromShortAddr(nwkAddr, (addrExt_t)CONCAT71(in_stack_ffffffd5, in_stack_ffffffd4),
                                                   (u16 *)&stack0xffffffd4);
    if (ptVar1 == (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      return false;
    }
    iVar2 = memcmp(in_r2, &stack0xffffffd4, 8);
    if (iVar2 == 0)
    {
      return false;
    }
    iVar2 = memcmp(&stack0xffffffd4, &g_zero_addr, 8);
    if ((iVar2 == 0) || (~uVar3 + uVar3 != 0))
    {
      return false;
    }
  }
  tl_zbNwkAddrConflictHandle();
  g_sysDiags.nwkAddrConflict = g_sysDiags.nwkAddrConflict + '\x01';
  return true;
}

void tl_zbNwkStatusAddrConflictInd(void *arg)

{
  u16 uVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  undefined in_stack_ffffffe8;
  undefined7 in_stack_ffffffe9;

  if ((conflictInfo != (zb_buf_t *)0x0) && (addrConflictHandleTimer != 0))
  {
    // WARNING: Load size is inaccurate
    uVar1 = *arg;
    if (*(u16 *)conflictInfo->buf != uVar1)
      goto LAB_00015af0;
    ev_timer_taskCancel((ev_timer_event_t **)&addrConflictHandleTimer);
    zb_buf_free(conflictInfo);
    conflictInfo = (zb_buf_t *)0x0;
  }
  // WARNING: Load size is inaccurate
  uVar1 = *arg;
LAB_00015af0:
  if ((g_zbInfo.macPib.shortAddress == uVar1) && (uVar1 != 0))
  {
    zb_buf_free((zb_buf_t *)arg);
    uVar1 = tl_zbNwkStochasticAddrCal();
    g_zbInfo.nwkNib.nwkAddr._0_1_ = (undefined)uVar1;
    g_zbInfo.nwkNib.nwkAddr._1_1_ = (byte)((uint)uVar1 >> 8);
    g_zbInfo.macPib.shortAddress = uVar1 & 0xff | (ushort)g_zbInfo.nwkNib.nwkAddr._1_1_ << 8;
    tl_zbNwkAddrMapAdd(uVar1, (addrExt_t)CONCAT71(in_stack_ffffffe9, in_stack_ffffffe8),
                       (u16 *)g_zbInfo.macPib.extAddress);
    zb_info_save((void *)0x0);
    zdo_device_announce_send();
  }
  else
  {
    nwkRoutingTabEntryDstDel();
    nwkRouteRecTabEntryDstDel();
    // WARNING: Load size is inaccurate
    ptVar2 = tl_zbNeighborTableSearchFromShortAddr(*arg, (addrExt_t)CONCAT71(in_stack_ffffffe9, in_stack_ffffffe8),
                                                   (u16 *)&stack0xffffffe8);
    if ((ptVar2 == (tl_zb_normal_neighbor_entry_t *)0x0) || ((ptVar2->field_0x1e & 0x7e) != 0x14))
    {
      zb_buf_free((zb_buf_t *)arg);
    }
    else
    {
      tl_zbNwkNeighborAddrConflictHandle();
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_addrMapListDelete(void)

{
  addrMapping_t *paVar1;
  tl_zb_addr_map_entry_t *ptVar2;
  char in_r0;
  tl_zb_addr_map_entry_t *in_r1;
  tl_zb_addr_map_entry_t *ptVar3;

  if (in_r0 == '\0')
  {
    ptVar2 = g_nwkAddrMap.activeHead;
    if (in_r1 == g_nwkAddrMap.activeHead)
    {
      g_nwkAddrMap.activeHead = in_r1->activeNext;
    }
    else
    {
      do
      {
        ptVar3 = ptVar2;
        ptVar2 = ptVar3->activeNext;
        if (ptVar2 == (tl_zb_addr_map_entry_t *)0x0)
        {
          return;
        }
      } while (in_r1 != ptVar2);
      paVar1 = in_r1->activeNext;
      *(char *)&ptVar3->activeNext = (char)paVar1;
      *(char *)((int)&ptVar3->activeNext + 1) = (char)((uint)paVar1 >> 8);
      *(char *)((int)&ptVar3->activeNext + 2) = (char)((uint)paVar1 >> 0x10);
      *(char *)((int)&ptVar3->activeNext + 3) = (char)((uint)paVar1 >> 0x18);
    }
  }
  else
  {
    ptVar2 = g_nwkAddrMap.freeHead;
    if (g_nwkAddrMap.freeHead == in_r1)
    {
      g_nwkAddrMap.freeHead = (g_nwkAddrMap.freeHead)->freeNext;
    }
    else
    {
      do
      {
        ptVar3 = ptVar2;
        ptVar2 = ptVar3->freeNext;
        if (ptVar2 == (tl_zb_addr_map_entry_t *)0x0)
        {
          return;
        }
      } while (in_r1 != ptVar2);
      paVar1 = in_r1->freeNext;
      *(char *)&ptVar3->freeNext = (char)paVar1;
      *(char *)((int)&ptVar3->freeNext + 1) = (char)((uint)paVar1 >> 8);
      *(char *)((int)&ptVar3->freeNext + 2) = (char)((uint)paVar1 >> 0x10);
      *(char *)((int)&ptVar3->freeNext + 3) = (char)((uint)paVar1 >> 0x18);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkAddrMapRst(void)

{
  u32 len;
  uint uVar1;
  tl_zb_addr_map_entry_t *ptVar2;
  tl_zb_addr_map_entry_t *ptVar3;
  uint uVar4;

  len = addrMapTblSizeGet();
  memset(&g_nwkAddrMap, 0, len);
  g_nwkAddrMap.activeHead._0_1_ = 0;
  g_nwkAddrMap.activeHead._1_1_ = 0;
  g_nwkAddrMap.activeHead._2_1_ = 0;
  g_nwkAddrMap.activeHead._3_1_ = 0;
  ptVar2 = g_nwkAddrMap.addrMap;
  g_nwkAddrMap.freeHead._0_1_ = 0x7c;
  g_nwkAddrMap.freeHead._1_1_ = 0x5e;
  g_nwkAddrMap.freeHead._2_1_ = 0x84;
  g_nwkAddrMap.freeHead._3_1_ = 0;
  uVar4 = (uint)TL_ZB_NWK_ADDR_MAP_SIZE;
  if (1 < uVar4)
  {
    uVar1 = 0;
    ptVar3 = ptVar2;
    do
    {
      ptVar3->field_0x13 = ptVar3->field_0x13 & 0xfe;
      *(undefined *)&ptVar3->activeNext = 0;
      *(undefined *)((int)&ptVar3->activeNext + 1) = 0;
      *(undefined *)((int)&ptVar3->activeNext + 2) = 0;
      *(undefined *)((int)&ptVar3->activeNext + 3) = 0;
      ptVar2 = ptVar3 + 1;
      *(char *)&ptVar3->freeNext = (char)ptVar2;
      *(char *)((int)&ptVar3->freeNext + 1) = (char)((uint)ptVar2 >> 8);
      *(char *)((int)&ptVar3->freeNext + 2) = (char)((uint)ptVar2 >> 0x10);
      *(char *)((int)&ptVar3->freeNext + 3) = (char)((uint)ptVar2 >> 0x18);
      uVar1 = uVar1 + 1 & 0xffff;
      ptVar3 = ptVar2;
    } while ((int)uVar1 < (int)(uVar4 - 1));
  }
  ptVar2->field_0x13 = ptVar2->field_0x13 & 0xfe;
  *(undefined *)&ptVar2->freeNext = 0;
  *(undefined *)((int)&ptVar2->freeNext + 1) = 0;
  *(undefined *)((int)&ptVar2->freeNext + 2) = 0;
  *(undefined *)((int)&ptVar2->freeNext + 3) = 0;
  *(undefined *)&ptVar2->activeNext = 0;
  *(undefined *)((int)&ptVar2->activeNext + 1) = 0;
  *(undefined *)((int)&ptVar2->activeNext + 2) = 0;
  *(undefined *)((int)&ptVar2->activeNext + 3) = 0;
  g_nwkAddrMap.validNum._0_1_ = 0;
  g_nwkAddrMap.validNum._1_1_ = 0;
  g_nwkAddrMap.validNum._2_1_ = 0;
  g_nwkAddrMap.validNum._3_1_ = 0;
  return;
}

void tl_zbNwkAddrMapInit(void)

{
  tl_zbNwkAddrMapRst();
  return;
}

void tl_zbNwkAddrMapDelete(u16 idx)

{
  if ((g_nwkAddrMap.addrMap[idx].field_0x13 & 1) != 0)
  {
    g_nwkAddrMap.addrMap[idx].field_0x13 = g_nwkAddrMap.addrMap[idx].field_0x13 & 0xfe;
    g_nwkAddrMap.addrMap[idx].field_0x13 = g_nwkAddrMap.addrMap[idx].field_0x13 & 0xef;
    tl_addrMapListDelete();
    *(char *)&g_nwkAddrMap.addrMap[idx].freeNext = (char)g_nwkAddrMap.freeHead;
    *(char *)((int)&g_nwkAddrMap.addrMap[idx].freeNext + 1) =
        (char)((uint)g_nwkAddrMap.freeHead >> 8);
    *(char *)((int)&g_nwkAddrMap.addrMap[idx].freeNext + 2) =
        (char)((uint)g_nwkAddrMap.freeHead >> 0x10);
    *(char *)((int)&g_nwkAddrMap.addrMap[idx].freeNext + 3) =
        (char)((uint)g_nwkAddrMap.freeHead >> 0x18);
    g_nwkAddrMap.validNum = g_nwkAddrMap.validNum - 1;
    g_nwkAddrMap.freeHead = g_nwkAddrMap.addrMap + idx;
  }
  return;
}

u8 tl_zbShortAddrByExtAddr(u16 *shortAddr, addrExt_t extAddr, u16 *idx)

{
  undefined2 uVar1;
  int iVar2;
  undefined2 *in_r2;
  addrMapping_t *paVar3;

  paVar3 = g_nwkAddrMap.activeHead;
  if (g_nwkAddrMap.activeHead != (tl_zb_addr_map_entry_t *)0x0)
  {
    do
    {
      iVar2 = memcmp(idx, paVar3->extAddr, 8);
      if (iVar2 == 0)
      {
        *shortAddr = paVar3->shortAddr;
        uVar1 = FUN_0000162c(paVar3 + -0x69e53, 0x14);
        *in_r2 = uVar1;
        return '\0';
      }
      paVar3 = paVar3->activeNext;
    } while (paVar3 != (addrMapping_t *)0x0);
  }
  return 0xff;
}

u8 tl_zbExtAddrByShortAddr(u16 shortAddr, addrExt_t extAddr, u16 *idx)

{
  u16 uVar1;
  addrMapping_t *paVar2;
  u8 uVar3;
  undefined2 uVar4;
  undefined2 *in_r2;

  uVar3 = 0xff;
  if ((g_nwkAddrMap.activeHead != (tl_zb_addr_map_entry_t *)0x0) &&
      ((int)((uint)(byte)(g_nwkAddrMap.activeHead)->field_0x13 << 0x1f) < 0))
  {
    uVar1 = (g_nwkAddrMap.activeHead)->shortAddr;
    paVar2 = g_nwkAddrMap.activeHead;
    while (uVar1 != shortAddr)
    {
      paVar2 = paVar2->activeNext;
      if ((paVar2 == (addrMapping_t *)0x0) || ((paVar2->field_0x13 & 1) == 0))
      {
        return 0xff;
      }
      uVar1 = paVar2->shortAddr;
    }
    memcpy(idx, paVar2->extAddr, 8);
    uVar4 = FUN_0000162c(paVar2 + -0x69e53, 0x14);
    *in_r2 = uVar4;
    uVar3 = '\0';
  }
  return uVar3;
}

addrExt_t *tl_zbExtAddrPtrByShortAddr(u16 shortAddr)

{
  u16 uVar1;
  addrMapping_t *paVar2;
  u8 *puVar3;

  puVar3 = (u8 *)0x0;
  if ((g_nwkAddrMap.activeHead != (tl_zb_addr_map_entry_t *)0x0) &&
      ((int)((uint)(byte)(g_nwkAddrMap.activeHead)->field_0x13 << 0x1f) < 0))
  {
    uVar1 = (g_nwkAddrMap.activeHead)->shortAddr;
    paVar2 = g_nwkAddrMap.activeHead;
    while (uVar1 != shortAddr)
    {
      paVar2 = paVar2->activeNext;
      if ((paVar2 == (addrMapping_t *)0x0) || ((paVar2->field_0x13 & 1) == 0))
      {
        return (addrExt_t *)0x0;
      }
      uVar1 = paVar2->shortAddr;
    }
    puVar3 = paVar2->extAddr;
  }
  return (addrExt_t *)puVar3;
}

void tl_zbExtAddrByIdx(u16 idx, addrExt_t extAddr)

{
  void *in_r1;

  memcpy(in_r1, g_nwkAddrMap.addrMap[idx].extAddr, 8);
  return;
}

u16 tl_zbshortAddrByIdx(u16 idx)

{
  return g_nwkAddrMap.addrMap[idx].shortAddr;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 FUNBBBBK(void)

{
  u16 uVar1;
  addrMapping_t *paVar2;
  undefined2 uVar3;
  undefined2 *in_r0;
  undefined4 uVar4;
  u16 in_r1;

  uVar4 = 0xff;
  if ((g_nwkAddrMap.activeHead != (tl_zb_addr_map_entry_t *)0x0) &&
      ((int)((uint)(byte)(g_nwkAddrMap.activeHead)->field_0x13 << 0x1f) < 0))
  {
    uVar1 = (g_nwkAddrMap.activeHead)->shortAddr;
    paVar2 = g_nwkAddrMap.activeHead;
    while (uVar1 != in_r1)
    {
      paVar2 = paVar2->activeNext;
      if ((paVar2 == (addrMapping_t *)0x0) || ((paVar2->field_0x13 & 1) == 0))
      {
        return 0xff;
      }
      uVar1 = paVar2->shortAddr;
    }
    uVar3 = FUN_0000162c(paVar2 + -0x69e53, 0x14);
    *in_r0 = uVar3;
    uVar4 = 0;
  }
  return uVar4;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_idxByExtAddr(void)

{
  undefined2 uVar1;
  undefined2 *in_r0;
  int iVar2;
  void *in_r1;
  addrMapping_t *paVar3;

  if ((g_nwkAddrMap.activeHead != (tl_zb_addr_map_entry_t *)0x0) &&
      (paVar3 = g_nwkAddrMap.activeHead,
       (int)((uint)(byte)(g_nwkAddrMap.activeHead)->field_0x13 << 0x1f) < 0))
  {
    do
    {
      iVar2 = memcmp(paVar3->extAddr, in_r1, 8);
      if (iVar2 == 0)
      {
        uVar1 = FUN_0000162c(paVar3 + -0x69e53, 0x14);
        *in_r0 = uVar1;
        return 0;
      }
      paVar3 = paVar3->activeNext;
    } while ((paVar3 != (addrMapping_t *)0x0) && ((paVar3->field_0x13 & 1) != 0));
  }
  return 0xff;
}

// WARNING: Removing unreachable block (RAM,0x000160cc)

zb_nwk_status_t tl_zbNwkAddrMapAdd(u16 shortAddr, addrExt_t extAddr, u16 *ref)

{
  tl_zb_addr_map_entry_t *ptVar1;
  undefined2 uVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  undefined2 *in_r2;
  undefined uVar6;

  uVar3 = FUNBBBBK();
  uVar4 = tl_idxByExtAddr();
  *in_r2 = 0;
  uVar6 = (undefined)((uint)shortAddr >> 8);
  if (((uVar4 | uVar3) & 0xff) == 0)
  {
  LAB_000160d8:
    iVar5 = memcmp(g_nwkAddrMap.addrMap[0].extAddr, &g_zero_addr, 8);
    ptVar1 = g_nwkAddrMap.freeHead;
    if (iVar5 == 0)
      goto LAB_000161b2;
  }
  else
  {
    if (uVar4 == 0)
    {
      *in_r2 = 0;
    }
    ptVar1 = g_nwkAddrMap.freeHead;
    if (uVar3 == 0)
      goto LAB_000160d8;
  }
  g_nwkAddrMap.freeHead = ptVar1;
  if (uVar4 != 0)
  {
    if (ptVar1 == (tl_zb_addr_map_entry_t *)0x0)
    {
      return 199;
    }
    if ((int)((uint)(byte)ptVar1->field_0x13 << 0x1f) < 0)
    {
      return 199;
    }
    g_nwkAddrMap.validNum = g_nwkAddrMap.validNum + 1;
    ptVar1->field_0x13 = ptVar1->field_0x13 | 1;
    *(char *)&ptVar1->shortAddr = (char)shortAddr;
    *(undefined *)((int)&ptVar1->shortAddr + 1) = uVar6;
    if (ref == (u16 *)0x0)
    {
      ptVar1->extAddr[0] = '\0';
      ptVar1->extAddr[1] = '\0';
      ptVar1->extAddr[2] = '\0';
      ptVar1->extAddr[3] = '\0';
      ptVar1->extAddr[4] = '\0';
      ptVar1->extAddr[5] = '\0';
      ptVar1->extAddr[6] = '\0';
      ptVar1->extAddr[7] = '\0';
    }
    else
    {
      memcpy(ptVar1->extAddr, ref, 8);
    }
    ptVar1->aps_dup_cnt = '\0';
    ptVar1->field_0x13 = ptVar1->field_0x13 & 0xf1;
    uVar2 = FUN_0000162c(ptVar1 + -0x69e53, 0x14);
    *in_r2 = uVar2;
    tl_addrMapListDelete();
    *(char *)&ptVar1->activeNext = (char)g_nwkAddrMap.activeHead;
    *(char *)((int)&ptVar1->activeNext + 1) = (char)((uint)g_nwkAddrMap.activeHead >> 8);
    *(char *)((int)&ptVar1->activeNext + 2) = (char)((uint)g_nwkAddrMap.activeHead >> 0x10);
    *(char *)((int)&ptVar1->activeNext + 3) = (char)((uint)g_nwkAddrMap.activeHead >> 0x18);
    g_nwkAddrMap.activeHead = ptVar1;
    return NWK_STATUS_SUCCESS;
  }
LAB_000161b2:
  memcpy(g_nwkAddrMap.addrMap[0].extAddr, ref, 8);
  g_nwkAddrMap.addrMap[0].shortAddr._1_1_ = uVar6;
  g_nwkAddrMap.addrMap[0].shortAddr._0_1_ = (char)shortAddr;
  return NWK_STATUS_SUCCESS;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

zb_nwk_status_t tl_addrByShort(void)

{
  zb_nwk_status_t zVar1;
  u16 in_r0;
  int iVar2;
  char in_r1;
  int in_r3;
  undefined4 unaff_r4;
  undefined4 in_lr;

  if (in_r3 == 0)
  {
    sys_exceptionPost(0x140, '0');
    zVar1 = ~NWK_STATUS_SUCCESS;
  }
  else
  {
    iVar2 = FUNBBBBK();
    zVar1 = NWK_STATUS_SUCCESS;
    if ((iVar2 != 0) && (zVar1 = ~NWK_STATUS_SUCCESS, in_r1 != '\0'))
    {
      zVar1 = tl_zbNwkAddrMapAdd(in_r0, (addrExt_t)CONCAT44(unaff_r4, in_lr), (u16 *)&g_zero_addr);
    }
  }
  return zVar1;
}

void tl_addrMappingForBind(u8 bind, u16 idx)

{
  uint uVar1;

  uVar1 = (uint)idx;
  if ((uVar1 < TL_ZB_NWK_ADDR_MAP_SIZE) && ((g_nwkAddrMap.addrMap[uVar1].field_0x13 & 1) != 0))
  {
    g_nwkAddrMap.addrMap[uVar1].field_0x13 =
        g_nwkAddrMap.addrMap[uVar1].field_0x13 & 0xef | (byte)((bind & 1) << 4);
  }
  return;
}

u8 zb_address_ieee_by_short(u16 short_addr, addrExt_t ieee_address)

{
  u8 uVar1;
  u16 *in_r1;
  undefined4 in_lr;
  undefined4 in_stack_fffffff8;

  uVar1 = tl_zbExtAddrByShortAddr(short_addr, (addrExt_t)CONCAT44(in_lr, in_stack_fffffff8), in_r1);
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

buf_sts_t nwk_nodeAddrInfoStore(void)

{
  nv_sts_t nVar1;
  buf_sts_t bVar2;
  short *in_r0;
  int iVar3;
  int iVar4;
  short local_34;
  undefined auStack_32[10];
  ushort local_28;
  u8 uStack_26;

  local_28 = 0;
  uStack_26 = '\0';
  nVar1 = nv_flashReadNew('\0', '\x01', 0xff, 0xc, (u8 *)&local_28);
  if (nVar1 == NV_SUCC)
  {
    iVar4 = 0;
  LAB_0001631c:
    do
    {
      nVar1 = nv_flashReadByIndex('\x01', '\x02', uStack_26, (u16)iVar4, 0xc, (u8 *)&local_34);
      if (nVar1 == NV_SUCC)
      {
        iVar3 = memcmp(in_r0 + 1, auStack_32, 8);
        if (iVar3 == 0)
        {
          if (local_34 == *in_r0)
            goto LAB_0001636c;
        }
        else if (local_34 != *in_r0)
        {
          iVar4 = iVar4 + 1;
          if ((int)(uint)local_28 < iVar4)
            break;
          goto LAB_0001631c;
        }
        nv_itemDeleteByIndex('\x01', '\x02', uStack_26, (u16)iVar4);
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 <= (int)(uint)local_28);
  }
  nv_flashWriteNew('\0', 1, '\x02', 0xc, (u8 *)in_r0);
LAB_0001636c:
  bVar2 = ev_buf_free((u8 *)in_r0);
  return bVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwk_parentNodeInfoStore(void)

{
  nv_sts_t nVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  int iVar3;
  u16 local_3c;
  undefined auStack_3a[8];
  u8 uStack_32;
  byte bStack_31;
  u8 auStack_30[11];
  byte bStack_25;
  ushort local_24;
  u8 uStack_22;

  ptVar2 = tl_zbNeighborTableSearchForParent();
  local_24 = 0;
  uStack_22 = '\0';
  nVar1 = nv_flashReadNew('\0', '\x01', 0xff, 0xc, (u8 *)&local_24);
  if (nVar1 == NV_SUCC)
  {
    iVar3 = 0;
    do
    {
      while (true)
      {
        nVar1 = nv_flashReadByIndex('\x01', '\x02', uStack_22, (u16)iVar3, 0xc, auStack_30);
        if ((nVar1 != NV_SUCC) || ((bStack_25 & 0x70) != 0))
          break;
        nv_itemDeleteByIndex('\x01', '\x02', uStack_22, (u16)iVar3);
        iVar3 = iVar3 + 1;
        if ((int)(uint)local_24 < iVar3)
          goto LAB_000163f8;
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 <= (int)(uint)local_24);
  }
LAB_000163f8:
  if (ptVar2 != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    local_3c = g_nwkAddrMap.addrMap[ptVar2->addrmapIdx].shortAddr;
    memcpy(auStack_3a, g_nwkAddrMap.addrMap[ptVar2->addrmapIdx].extAddr, 8);
    uStack_32 = ptVar2->depth;
    bStack_31 = bStack_31 & 0x80 | ptVar2->field_0x1e & 0xe | ptVar2->field_0x1e & 1;
    nv_flashWriteNew('\0', 1, '\x02', 0xc, (u8 *)&local_3c);
  }
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwk_nodeAddrInfoDelete(void)

{
  nv_sts_t nVar1;
  int in_r0;
  int iVar2;
  int iVar3;
  u8 auStack_40[2];
  undefined auStack_3e[9];
  byte bStack_35;
  u8 auStack_34[4];
  undefined auStack_30[8];
  ushort local_28;
  u8 uStack_26;

  if ((*(byte *)(in_r0 + 0xb) & 0xe) == 4)
  {
    local_28 = 0;
    uStack_26 = '\0';
    nVar1 = nv_flashReadNew('\0', '\x01', 0xff, 0xc, (u8 *)&local_28);
    if (nVar1 == NV_SUCC)
    {
      iVar3 = 0;
      do
      {
        nVar1 = nv_flashReadByIndex('\x01', '\v', uStack_26, (u16)iVar3, 0xc, auStack_34);
        if ((nVar1 == NV_SUCC) && (iVar2 = memcmp((void *)(in_r0 + 2), auStack_30, 8), iVar2 == 0))
        {
          nv_itemDeleteByIndex('\x01', '\v', uStack_26, (u16)iVar3);
        }
        iVar3 = iVar3 + 1;
      } while (iVar3 <= (int)(uint)local_28);
    }
  }
  local_28 = 0;
  uStack_26 = '\0';
  nVar1 = nv_flashReadNew('\0', '\x01', 0xff, 0xc, (u8 *)&local_28);
  if (nVar1 == NV_SUCC)
  {
    iVar3 = 0;
    do
    {
      nVar1 = nv_flashReadByIndex('\x01', '\x02', uStack_26, (u16)iVar3, 0xc, auStack_40);
      if (((nVar1 == NV_SUCC) && (iVar2 = memcmp((void *)(in_r0 + 2), auStack_3e, 8), iVar2 == 0)) &&
          (((bStack_35 ^ *(byte *)(in_r0 + 0xb)) & 0x70) == 0))
      {
        nv_itemDeleteByIndex('\x01', '\x02', uStack_26, (u16)iVar3);
        return 0;
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 <= (int)(uint)local_28);
  }
  return 3;
}

u16 tl_zbNwkStochasticAddrCal(void)

{
  u8 uVar1;
  u32 uVar2;
  uint uVar3;
  undefined in_stack_ffffffdc;
  undefined7 in_stack_ffffffdd;

  do
  {
    do
    {
      uVar2 = drv_u32Rand();
      uVar3 = uVar2 & 0xffff;
    } while (0xfff7 < uVar3);
  } while (((g_zbInfo.macPib.shortAddress == uVar3) || (uVar3 == 0)) ||
           (uVar1 = tl_zbExtAddrByShortAddr((u16)uVar3, (addrExt_t)CONCAT71(in_stack_ffffffdd, in_stack_ffffffdc),
                                            (u16 *)&stack0xffffffdc),
            uVar1 == '\0'));
  return (u16)uVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkBrcMsgAllDevicesCb(void)

{
  u16 uVar1;
  int *in_r0;
  int iVar2;
  undefined auStack_3c[32];
  undefined auStack_1c[4];

  if (((in_r0 == (int *)0x0) || (*in_r0 == 0)) ||
      (pNebEntry_8462 = tl_zbNeighborTabSearchForChildEndDev(), pNebEntry_8462 == 0))
  {
    return 0xfffffffe;
  }
  uVar1 = tl_zbshortAddrByIdx(*(u16 *)(pNebEntry_8462 + 0x16));
  if (uVar1 == *(u16 *)(in_r0 + 3))
  {
    return 0;
  }
  if ((*(byte *)(pNebEntry_8462 + 0x1e) & 1) != 0)
  {
    return 0;
  }
  iVar2 = nwkTxDataCachePacketCopy();
  if (iVar2 == 0)
  {
    return 0;
  }
  memcpy(auStack_1c, (void *)(iVar2 + 1), 4);
  memcpy(auStack_3c, (void *)(iVar2 + 5), 0x20);
  tl_zbshortAddrByIdx(*(u16 *)(pNebEntry_8462 + 0x16));
  nwk_tx();
  return 0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkMsgSendCb(void)

{
  int in_r0;
  undefined auStack_34[32];
  undefined auStack_14[8];

  memcpy(auStack_14, (void *)(in_r0 + 1), 4);
  memcpy(auStack_34, (void *)(in_r0 + 5), 0x20);
  nwk_fwdPacket();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkMsgSendCbDelay(void)

{
  nwkMsgSendCb();
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcTransJitterSet(void)

{
  undefined4 in_r0;

  g_brcTransJitter = in_r0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcTransTabEntryRst(void)

{
  void *in_r0;

  if (*(u8 **)((int)in_r0 + 8) != (u8 *)0x0)
  {
    ev_buf_free(*(u8 **)((int)in_r0 + 8));
  }
  memset(in_r0, 0, 0x14);
  *(undefined *)((int)in_r0 + 0xc) = 0xfd;
  *(undefined *)((int)in_r0 + 0xd) = 0xfe;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcTransTabEntryClear(void)

{
  int *in_r0;

  if (((in_r0 != (int *)0x0) && (*(char *)((int)in_r0 + 0x13) != '\0')) && (*in_r0 == 0))
  {
    nwkBrcTransTabEntryRst();
    g_brcTransTabCnt = g_brcTransTabCnt + -1;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcTransTabInit(void)

{
  byte idx;

  if (NWK_BRC_TRANSTBL_SIZE != '\0')
  {
    idx = 0;
    do
    {
      brcTransRecordEntryGet(idx);
      nwkBrcTransTabEntryRst();
      idx = idx + 1;
    } while (idx < NWK_BRC_TRANSTBL_SIZE);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_brcTransRecordEntry_t *nwkBrcTransEntryFind(void)

{
  u16 in_r0;
  nwk_brcTransRecordEntry_t *pnVar1;
  u8 in_r1;
  byte idx;

  if (NWK_BRC_TRANSTBL_SIZE != '\0')
  {
    idx = 0;
    do
    {
      pnVar1 = brcTransRecordEntryGet(idx);
      if (((pnVar1->srcAddr == in_r0) && (pnVar1->seqNum == in_r1)) && (pnVar1->used != '\0'))
      {
        return pnVar1;
      }
      idx = idx + 1;
    } while (idx < NWK_BRC_TRANSTBL_SIZE);
  }
  return (nwk_brcTransRecordEntry_t *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_brcTransRecordEntry_t *nwkBrcTransEntryCreate(void)

{
  char cVar1;
  undefined4 in_r0;
  nwk_brcTransRecordEntry_t *pnVar2;
  undefined4 in_r1;
  u8 in_r2;
  byte idx;
  u8 *pBuf;

  pBuf = (u8 *)0x0;
  if ((NWK_BRC_PASSIVE_ACK_ENABLE != '\0') &&
      (pBuf = ev_buf_allocate((ushort)TL_ZB_NEIGHBOR_TABLE_SIZE << 1), pBuf == (u8 *)0x0))
  {
    return (nwk_brcTransRecordEntry_t *)0x0;
  }
  if (NWK_BRC_TRANSTBL_SIZE != '\0')
  {
    idx = 0;
    do
    {
      pnVar2 = brcTransRecordEntryGet(idx);
      if (pnVar2->used == '\0')
      {
        *(char *)&pnVar2->passiveAckAddr = (char)pBuf;
        *(char *)((int)&pnVar2->passiveAckAddr + 1) = (char)((uint)pBuf >> 8);
        *(char *)((int)&pnVar2->passiveAckAddr + 2) = (char)((uint)pBuf >> 0x10);
        *(char *)((int)&pnVar2->passiveAckAddr + 3) = (char)((uint)pBuf >> 0x18);
        *(char *)&pnVar2->entry = (char)in_r0;
        *(char *)((int)&pnVar2->entry + 1) = (char)((uint)in_r0 >> 8);
        *(char *)((int)&pnVar2->entry + 2) = (char)((uint)in_r0 >> 0x10);
        *(char *)((int)&pnVar2->entry + 3) = (char)((uint)in_r0 >> 0x18);
        *(char *)&pnVar2->srcAddr = (char)in_r1;
        *(char *)((int)&pnVar2->srcAddr + 1) = (char)((uint)in_r1 >> 8);
        pnVar2->seqNum = in_r2;
        pnVar2->retries = '\0';
        cVar1 = FUN_0000162c(g_zbInfo.nwkNib.nwkBroadcastDeliveryTime, 1000);
        pnVar2->expirationTime = cVar1 + '\x01';
        pnVar2->used = '\x01';
        pnVar2->status = '\x01';
        g_brcTransTabCnt = g_brcTransTabCnt + '\x01';
        return pnVar2;
      }
      idx = idx + 1;
    } while (idx < NWK_BRC_TRANSTBL_SIZE);
  }
  if (pBuf != (u8 *)0x0)
  {
    ev_buf_free(pBuf);
  }
  return (nwk_brcTransRecordEntry_t *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcMsgAddSender(void)

{
  byte bVar1;
  int in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  uint uVar3;
  u16 in_r1;
  u16 *puVar4;
  uint uVar5;
  u16 *puVar6;

  ptVar2 = nwk_neTblGetByShortAddr(in_r1);
  if (((ptVar2 != (tl_zb_normal_neighbor_entry_t *)0x0) && ((ptVar2->field_0x1e & 0xf) != 4)) &&
      (puVar6 = (u16 *)((uint) * (byte *)(in_r0 + 0xb) * 0x1000000 | (uint) * (uint3 *)(in_r0 + 8)),
       puVar6 != (u16 *)0x0))
  {
    bVar1 = *(byte *)(in_r0 + 0x10);
    uVar3 = (uint)bVar1;
    if (uVar3 == 0)
    {
    LAB_00016940:
      if (uVar3 < TL_ZB_NEIGHBOR_TABLE_SIZE)
      {
        puVar6[uVar3] = in_r1;
        *(byte *)(in_r0 + 0x10) = bVar1 + 1;
      }
    }
    else if (*puVar6 != in_r1)
    {
      uVar5 = 0;
      puVar4 = puVar6;
      do
      {
        puVar4 = puVar4 + 1;
        uVar5 = uVar5 + 1 & 0xff;
        if (uVar3 <= uVar5)
          goto LAB_00016940;
      } while (*puVar4 != in_r1);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkBrcAllRelayed(void)

{
  byte bVar1;
  u16 uVar2;
  int *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  u16 *puVar4;
  byte bVar5;
  byte idx;

  bVar1 = tl_zbNeighborTableNumGet();
  if (bVar1 != 0)
  {
    idx = 0;
    do
    {
      while (true)
      {
        ptVar3 = tl_zbNeighborEntryGetFromIdx(idx);
        if (*(short *)(*in_r0 + 6) != -1)
          break;
        if ((ptVar3->field_0x1e & 0xe) != 4)
        {
        LAB_000169ba:
          uVar2 = tl_zbshortAddrByIdx(ptVar3->addrmapIdx);
          puVar4 = (u16 *)in_r0[2];
          if ((puVar4 == (u16 *)0x0) || (*(byte *)(in_r0 + 4) == 0))
          {
            return 0;
          }
          if (*puVar4 != uVar2)
          {
            bVar5 = 0;
            do
            {
              puVar4 = puVar4 + 1;
              bVar5 = bVar5 + 1;
              if (*(byte *)(in_r0 + 4) <= bVar5)
              {
                return 0;
              }
            } while (uVar2 != *puVar4);
          }
        }
      LAB_00016980:
        idx = idx + 1;
        if (bVar1 <= idx)
        {
          return 1;
        }
      }
      if (1 < (ushort)(*(short *)(*in_r0 + 6) + 4U))
        goto LAB_00016980;
      if (((ptVar3->field_0x1e & 0xe) == 0) || ((ptVar3->field_0x1e & 0xe) == 2))
        goto LAB_000169ba;
      idx = idx + 1;
    } while (idx < bVar1);
  }
  return 1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkBrcMsgPassiveAckTimeoutCb(void)

{
  int **in_r0;
  int iVar1;
  void *arg;
  byte bVar2;

  if ((*(char *)((int)in_r0 + 0x13) != '\0') && (*in_r0 != (int *)0x0))
  {
    bVar2 = *(char *)((int)in_r0 + 0xf) + 1;
    *(byte *)((int)in_r0 + 0xf) = bVar2;
    if ((bVar2 < g_zbInfo.nwkNib.maxBroadcastRetries) &&
        (((iVar1 = nwkBrcAllRelayed(), iVar1 == 0 && ((*(byte *)((int)*in_r0 + 0xb) & 0x80) != 0)) &&
          (**in_r0 != 0))))
    {
      arg = (void *)nwkTxDataCachePacketCopy();
      if (arg == (void *)0x0)
      {
        return 0;
      }
      tl_zbTaskPost(nwkMsgSendCb, arg);
      *(undefined *)(in_r0 + 1) = 0;
      *(undefined *)((int)in_r0 + 5) = 0;
      *(undefined *)((int)in_r0 + 6) = 0;
      *(undefined *)((int)in_r0 + 7) = 0;
      return 0xfffffffe;
    }
    if (in_r0[2] != (int *)0x0)
    {
      ev_buf_free((u8 *)in_r0[2]);
      *(undefined *)(in_r0 + 2) = 0;
      *(undefined *)((int)in_r0 + 9) = 0;
      *(undefined *)((int)in_r0 + 10) = 0;
      *(undefined *)((int)in_r0 + 0xb) = 0;
    }
    nwkTxDataPendTabEntryClear();
    *(undefined *)in_r0 = 0;
    *(undefined *)((int)in_r0 + 1) = 0;
    *(undefined *)((int)in_r0 + 2) = 0;
    *(undefined *)((int)in_r0 + 3) = 0;
  }
  *(undefined *)(in_r0 + 1) = 0;
  *(undefined *)((int)in_r0 + 5) = 0;
  *(undefined *)((int)in_r0 + 6) = 0;
  *(undefined *)((int)in_r0 + 7) = 0;
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcMsgPassiveAckTimeoutStart(void)

{
  void *in_r0;
  u32 t_ms;
  ev_timer_event_t *peVar1;

  if (((in_r0 != (void *)0x0) && (*(char *)((int)in_r0 + 0x13) != '\0')) &&
      (*(int *)((int)in_r0 + 4) == 0))
  {
    t_ms = FUN_0000162c(g_zbInfo.nwkNib.passiveAckTimeout, 1000);
    peVar1 = ev_timer_taskPost(nwkBrcMsgPassiveAckTimeoutCb, in_r0, t_ms);
    *(char *)((int)in_r0 + 4) = (char)peVar1;
    *(char *)((int)in_r0 + 5) = (char)((uint)peVar1 >> 8);
    *(char *)((int)in_r0 + 6) = (char)((uint)peVar1 >> 0x10);
    *(char *)((int)in_r0 + 7) = (char)((uint)peVar1 >> 0x18);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcMsgAllEndDevStart(void)

{
  void *in_r0;
  int iVar1;
  undefined4 uVar2;
  u32 t_ms;

  iVar1 = tl_zbNeighborTabSearchForChildEndDev();
  if (iVar1 != 0)
  {
    uVar2 = FUN_0000162c(g_zbInfo.nwkNib.passiveAckTimeout, TL_ZB_NEIGHBOR_TABLE_SIZE);
    t_ms = FUN_0000162c(uVar2, 1000);
    ev_timer_taskPost(nwkBrcMsgAllDevicesCb, in_r0, t_ms);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkBrcTimerStart(void)

{
  u8 uVar1;
  void *in_r0;
  undefined *out;
  u32 uVar2;
  int iVar3;
  void *in_r1;
  int in_r2;
  undefined in_r3;
  undefined4 uVar4;
  undefined *puVar5;

  uVar1 = ev_timer_enough();
  uVar4 = 0x14;
  if (uVar1 != '\0')
  {
    out = (undefined *)c1();
    uVar4 = 0xd3;
    if (out != (undefined *)0x0)
    {
      memcpy(out, in_r0, 0xc3);
      *out = in_r3;
      puVar5 = out + (in_r2 - (int)in_r0 & 0xff);
      out[1] = (char)puVar5;
      out[2] = (char)((uint)puVar5 >> 8);
      out[3] = (char)((uint)puVar5 >> 0x10);
      out[4] = (char)((uint)puVar5 >> 0x18);
      memcpy(out + 5, in_r1, 0x20);
      uVar2 = drv_u32Rand();
      iVar3 = FUN_00001628(uVar2 & 0xffff, g_brcTransJitter);
      ev_timer_taskPost(nwkMsgSendCbDelay, out, iVar3 + 1);
      uVar4 = 0;
    }
  }
  return uVar4;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkBrcPeriodic(void)

{
  nwk_brcTransRecordEntry_t *pnVar1;
  u8 uVar2;
  byte idx;

  if ((g_brcTransTabCnt != '\0') && (NWK_BRC_TRANSTBL_SIZE != '\0'))
  {
    idx = 0;
    do
    {
      while (pnVar1 = brcTransRecordEntryGet(idx), pnVar1->used != '\0')
      {
        if ((pnVar1->expirationTime == '\0') ||
            (uVar2 = pnVar1->expirationTime + 0xff, pnVar1->expirationTime = uVar2, uVar2 == '\0'))
        {
          nwkBrcTransTabEntryClear();
          break;
        }
        idx = idx + 1;
        if (NWK_BRC_TRANSTBL_SIZE <= idx)
        {
          return;
        }
      }
      idx = idx + 1;
    } while (idx < NWK_BRC_TRANSTBL_SIZE);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint nwkBrcCheckDevMatch(void)

{
  short in_r0;
  uint uVar1;

  if (in_r0 == -3)
  {
    uVar1 = (uint)(g_zbInfo.macPib.rxOnWhenIdle != '\0');
  }
  else
  {
    uVar1 = 1;
    if ((in_r0 != -1) && (uVar1 = 0, in_r0 == -4))
    {
      uVar1 = ((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1e) >> 0x1f;
    }
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkNldeDataCnf(void)

{
  void *in_r0;
  undefined in_r1;
  undefined in_r2;

  *(undefined *)((int)in_r0 + 5) = in_r2;
  *(undefined *)((int)in_r0 + 4) = in_r1;
  tl_zbTaskPost(aps_nwk_data_confirm_cb, in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkNldeDataInd(void)

{
  byte bVar1;
  undefined4 *in_r0;
  undefined2 *in_r1;
  int local_20;
  char cStack_1c;
  char cStack_1b;
  byte bStack_1a;
  undefined uStack_19;
  undefined2 uStack_18;
  undefined2 uStack_16;
  undefined4 uStack_14;
  undefined2 uStack_10;

  uStack_14 = 0;
  bVar1 = *(byte *)((int)in_r1 + 5) & 1;
  cStack_1b = bVar1 + ~bVar1 + '\x01';
  uStack_18 = *in_r1;
  uStack_16 = in_r1[1];
  cStack_1c = *(char *)((int)in_r0 + 0x1d) - *(byte *)((int)in_r1 + 0x19);
  local_20 = in_r0[1] + (uint) * (byte *)((int)in_r1 + 0x19);
  uStack_19 = *(undefined *)((int)in_r0 + 0x27);
  uStack_10 = *(undefined2 *)(in_r0 + 5);
  if ((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x19) < 0)
  {
    uStack_14 = *in_r0;
  }
  bStack_1a = (byte)(((uint) * (byte *)((int)in_r1 + 5) << 0x1e) >> 0x1f);
  memcpy(in_r0, &local_20, 0x12);
  if (g_nwkDataIndCb != 0)
  {
    FUNCCCCA();
  }
  tl_zbTaskPost(aps_nwk_data_indication_cb, in_r0);
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void FUNCCCCA(void)

{
  void *in;
  void *out;
  code *in_r3;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  uint uStack_28;
  uint uStack_24;
  uint uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined2 uStack_14;
  undefined2 auStack_10[4];

  in = (void *)(*in_r3)();
  uStack_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_1c = 0;
  uStack_18 = 0;
  uStack_14 = 0;
  auStack_10[0] = 0xb;
  out = (void *)(*(int *)((int)in + 0x10) + -2);
  uStack_20 = (uint)out >> 0x18;
  uStack_24 = (int)out * 0x100 | (uint)(byte)(*(char *)((int)in + 0x14) + 2);
  memcpy(out, auStack_10, 2);
  uStack_30 = CONCAT31(uStack_30._1_3_, 3);
  uStack_28 = uStack_28 & 0xffffff | (uint) * (byte *)((int)in + 0xb) << 0x18;
  if ((dstPanID == 0) || (deviceInfoRsp == '\0'))
  {
    uStack_30 = uStack_30 | 0xffff00;
    uStack_20._0_2_ = CONCAT11(*(undefined *)((int)in + 0xf), (undefined)uStack_20);
    uStack_20 = uStack_20 & 0xffff0000 | (uint)(ushort)uStack_20;
  }
  else
  {
    deviceInfoRsp = '\0';
    uStack_30 = uStack_30 & 0xff0000ff | (uint)dstPanID << 8;
    uStack_20._0_2_ = CONCAT11(*(undefined *)((int)in + 0xf), (undefined)uStack_20);
    uStack_20 = uStack_20 & 0xffff0000 | (uint)(ushort)uStack_20;
  }
  if (*(byte *)((int)in + 0xb) == 3)
  {
    uStack_20._0_3_ = CONCAT12(1, (ushort)uStack_20);
    uStack_20 = uStack_20 & 0xff000000 | (uint)(uint3)uStack_20;
    memcpy((void *)((int)&uStack_30 + 3), in, 8);
  }
  else
  {
    uStack_30 = CONCAT13(0xfe, (undefined3)uStack_30);
    uStack_2c = CONCAT31(uStack_2c._1_3_, 0xfe);
  }
  memcpy(in, &uStack_38, 0x26);
  tl_zbMacMcpsDataRequestProc(in);
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkInterPanDataReq(void)

{
  void *in_r0;
  void *out;
  undefined4 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  uint uStack_28;
  uint uStack_24;
  uint uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined2 local_14;
  undefined2 local_10[4];

  local_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_1c = 0;
  uStack_18 = 0;
  local_14 = 0;
  local_10[0] = 0xb;
  out = (void *)(*(int *)((int)in_r0 + 0x10) + -2);
  uStack_20 = (uint)out >> 0x18;
  uStack_24 = (int)out * 0x100 | (uint)(byte)(*(char *)((int)in_r0 + 0x14) + 2);
  memcpy(out, local_10, 2);
  uStack_30 = CONCAT31(uStack_30._1_3_, 3);
  uStack_28 = uStack_28 & 0xffffff | (uint) * (byte *)((int)in_r0 + 0xb) << 0x18;
  if ((dstPanID == 0) || (deviceInfoRsp == '\0'))
  {
    uStack_30 = uStack_30 | 0xffff00;
    uStack_20._0_2_ = CONCAT11(*(undefined *)((int)in_r0 + 0xf), (undefined)uStack_20);
    uStack_20 = uStack_20 & 0xffff0000 | (uint)(ushort)uStack_20;
  }
  else
  {
    deviceInfoRsp = '\0';
    uStack_30 = uStack_30 & 0xff0000ff | (uint)dstPanID << 8;
    uStack_20._0_2_ = CONCAT11(*(undefined *)((int)in_r0 + 0xf), (undefined)uStack_20);
    uStack_20 = uStack_20 & 0xffff0000 | (uint)(ushort)uStack_20;
  }
  if (*(byte *)((int)in_r0 + 0xb) == 3)
  {
    uStack_20._0_3_ = CONCAT12(1, (ushort)uStack_20);
    uStack_20 = uStack_20 & 0xff000000 | (uint)(uint3)uStack_20;
    memcpy((void *)((int)&uStack_30 + 3), in_r0, 8);
  }
  else
  {
    uStack_30 = CONCAT13(0xfe, (undefined3)uStack_30);
    uStack_2c = CONCAT31(uStack_2c._1_3_, 0xfe);
  }
  memcpy(in_r0, &local_38, 0x26);
  tl_zbMacMcpsDataRequestProc(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMacInterPanDataHandle(void)

{
  void *in_r0;

  tl_zbTaskPost(aps_interPanDataIndCb, in_r0);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void tl_zbMacMcpsDataConfirmHandler(void *arg)

{
  byte bVar1;
  bool bVar2;
  u8 uVar3;
  int iVar4;
  tl_zb_normal_neighbor_entry_t *ptVar5;
  uint uVar6;
  uint uVar7;
  ushort local_54;
  byte bStack_4f;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;

  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  local_28 = 0;
  memcpy(&uStack_34, arg, 0xe);
  nwkHdrParse();
  if ((local_54 & 0xfff8) != 0xfff8)
  {
    iVar4 = nwkTxDataPendTabEntryFind();
    if (iVar4 != 0)
    {
      nwkTxDataPendTabEntryClear();
    }
    ptVar5 = nwk_neTblGetByShortAddr(uStack_2c._2_2_);
    uVar3 = NWKC_TRANSFAILURE_CNT_THRESHOLD;
    if (ptVar5 == (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      bVar2 = false;
    }
    else
    {
      if ((ptVar5->field_0x1e & 0xe) == 4)
        goto LAB_00016f68;
      if (uStack_2c._1_1_ == '\0')
      {
        ptVar5->lqi = (u8)((int)((uint)ptVar5->lqi + (uint)local_28._1_1_) >> 1);
        ptVar5->transFailure = '\0';
        ptVar5->age = '\0';
        bVar2 = false;
      }
      else
      {
        bVar2 = false;
        if (((uStack_2c._1_1_ == -0x17) &&
             (bVar1 = ptVar5->transFailure, ptVar5->transFailure = bVar1 + 1, uVar3 <= bVar1)) &&
            (ptVar5->lqi = ptVar5->lqi >> 1, (int)((uint)bStack_4f << 0x1d) < 0))
        {
          ptVar5->transFailure = '\0';
          bVar2 = true;
        }
      }
    }
    iVar4 = nwkRoutingTabEntryDstActiveGet();
    if (iVar4 == 0)
    {
      if ((ptVar5 != (tl_zb_normal_neighbor_entry_t *)0x0) || (-1 < (int)((uint)bStack_4f << 0x1d)))
        goto LAB_00016f54;
    }
    else
    {
      if (uStack_2c._1_1_ == '\0')
      {
        *(byte *)(iVar4 + 5) = *(byte *)(iVar4 + 5) & 0xf;
      }
      else if ((uStack_2c._1_1_ == -0x17) &&
               (uVar6 = (uint)(*(byte *)(iVar4 + 5) >> 4),
                uVar7 = (uint)NWKC_TRANSFAILURE_CNT_THRESHOLD,
                *(byte *)(iVar4 + 5) = *(byte *)(iVar4 + 5) & 0xf | (byte)((uVar6 + 1 & 0xf) << 4),
                uVar7 <= uVar6))
      {
        *(byte *)(iVar4 + 5) = *(byte *)(iVar4 + 5) & 0xf;
        goto LAB_00016f58;
      }
    LAB_00016f54:
      if (!bVar2)
        goto LAB_00016f66;
    }
  LAB_00016f58:
    if (uStack_2c._1_1_ == -0x17)
    {
      nwkRouteMaintenance();
    }
  }
LAB_00016f66:
LAB_00016f68:
  if ((byte)uStack_2c < 0xc0)
  {
    nwkNldeDataCnf();
    return;
  }
  if (((byte)uStack_2c != 0xc0) && ((byte)uStack_2c != 0xc1))
  {
    if ((byte)uStack_2c == 0xc3)
    {
      nwk_rejoinCmdSendCnf();
      return;
    }
    if ((byte)uStack_2c == 0xc6)
    {
      nwk_leaveCmdSendCnf();
      return;
    }
    if (((byte)uStack_2c != 199) && ((byte)uStack_2c != 200))
    {
      if ((byte)uStack_2c == 0xc5)
      {
        zb_buf_free((zb_buf_t *)arg);
        if (uStack_2c._1_1_ != '\0')
        {
          return;
        }
        tl_zbNwkPanidConflictSetPanidStart();
        return;
      }
      if ((byte)uStack_2c == 0xc4)
      {
        tl_zbMcpsRejoinRespCnfHandler();
        return;
      }
      if (((byte)uStack_2c != 0xcb) && ((byte)uStack_2c == 0xce))
      {
        nwkEndDevTimeoutRspCnfHandler();
        return;
      }
    }
  }
  zb_buf_free((zb_buf_t *)arg);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_tx(void)

{
  char cVar1;
  u16 uVar2;
  byte bVar3;
  void *in_r0;
  nwk_hdr_t *in_r1;
  uint in_r2;
  char in_r3;
  int iVar4;
  int in_stack_00000000;
  char in_stack_00000004;

  cVar1 = *(char *)((int)in_r0 + 0xc1);
  bVar3 = getNwkHdrSize(in_r1);
  in_r1->frameHdrLen = bVar3;
  iVar4 = in_stack_00000000 - (uint)bVar3;
  nwkHdrBuilder();
  memset(in_r0, 0, 0x26);
  *(undefined *)((int)in_r0 + 8) = 2;
  *(undefined *)((int)in_r0 + 0x13) = 2;
  *(char *)((int)in_r0 + 0xb) = (char)in_r2;
  *(char *)((int)in_r0 + 0xc) = (char)(in_r2 >> 8);
  uVar2 = g_zbInfo.macPib.panId;
  *(char *)((int)in_r0 + 9) = (char)g_zbInfo.macPib.panId;
  *(char *)((int)in_r0 + 10) = (char)(uVar2 >> 8);
  *(u8 *)((int)in_r0 + 0x14) = in_r1->frameHdrLen + in_stack_00000004;
  *(char *)((int)in_r0 + 0x15) = (char)iVar4;
  *(char *)((int)in_r0 + 0x16) = (char)((uint)iVar4 >> 8);
  *(char *)((int)in_r0 + 0x17) = (char)((uint)iVar4 >> 0x10);
  *(char *)((int)in_r0 + 0x18) = (char)((uint)iVar4 >> 0x18);
  *(char *)((int)in_r0 + 0x19) = cVar1;
  if ((in_r2 & 0xffff) != 0xffff)
  {
    *(undefined *)((int)in_r0 + 0x1a) = 1;
  }
  if (in_r3 != '\0')
  {
    *(byte *)((int)in_r0 + 0x1a) = *(byte *)((int)in_r0 + 0x1a) | 4;
  }
  if ((((int)((uint)g_zbNwkCtx._45_1_ << 0x1d) < 0) || (cVar1 == -0x3a)) || (cVar1 == -0x3d))
  {
    if (((int)((uint)(byte)(in_r1->framecontrol).field_0x1 << 0x1e) < 0) &&
        (iVar4 = ss_nwkSecureFrame(), iVar4 != 0))
    {
      g_sysDiags.nwkTxEnDecryptFail = g_sysDiags.nwkTxEnDecryptFail + 1;
      tl_zbMacMcpsDataRequestSendConfirm(in_r0, 0xd4);
    }
    else
    {
      g_sysDiags.nwkTxCnt = g_sysDiags.nwkTxCnt + 1;
      tl_zbMacMcpsDataRequestProc(in_r0);
    }
  }
  else
  {
    tl_zbMacMcpsDataRequestSendConfirm(in_r0, 0x19);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_fwdPacket(void)

{
  byte bVar1;
  byte bVar2;
  u8 uVar3;
  zb_buf_t *in_r0;
  int **ppiVar4;
  int iVar5;
  tl_zb_normal_neighbor_entry_t *ptVar6;
  u8 *pBuf;
  ushort *in_r1;
  char *in_r2;
  byte bVar7;
  int iVar8;
  zb_buf_t **ppzVar9;
  uint uVar10;

  if (in_r0 == (zb_buf_t *)0x0)
  {
    sys_exceptionPost(0x29c, '\x13');
    return;
  }
  bVar1 = (in_r0->hdr).handle;
  if (*(char *)(in_r1 + 3) == '\0')
  {
    sys_exceptionPost(0x2ad, '4');
    return;
  }
  if (-1 < (int)((uint)(byte)(in_r0->hdr).field_0x3 << 0x1f))
  {
    sys_exceptionPost(0x2b2, '\x13');
    return;
  }
  if (((((*(byte *)(in_r1 + 2) & 3) == 0) && (bVar1 != 0xc1)) ||
       ((ppzVar9 = (zb_buf_t **)0x0, (*(byte *)(in_r1 + 2) & 3) == 1 && ((byte)(bVar1 + 0x3b) < 2)))) &&
      (ppzVar9 = (zb_buf_t **)nwkTxDataPendTabEntryAdd(), in_r0 == *ppzVar9))
  {
    sys_exceptionPost(0x2be, '4');
  }
  if ((*in_r1 & 0xfff8) == 0xfff8)
  {
    if (((*(byte *)(in_r1 + 2) & 3) != 1) || ((*in_r2 != '\b' && (*in_r2 != '\x01'))))
    {
      if ((in_r1[1] != g_zbInfo.nwkNib.nwkAddr) || (*(char *)(in_r1 + 3) != '\x01'))
      {
        ppiVar4 = (int **)nwkBrcTransEntryFind();
        if (ppiVar4 != (int **)0x0)
        {
          if (bVar1 != 0xc1)
          {
            *(char *)ppiVar4 = (char)ppzVar9;
            *(char *)((int)ppiVar4 + 1) = (char)((uint)ppzVar9 >> 8);
            *(char *)((int)ppiVar4 + 2) = (char)((uint)ppzVar9 >> 0x10);
            *(char *)((int)ppiVar4 + 3) = (char)((uint)ppzVar9 >> 0x18);
          }
          else
          {
          LAB_000173c6:
            ppzVar9 = (zb_buf_t **)*ppiVar4;
          }
          if ((ppzVar9 != (zb_buf_t **)0x0) && (ppiVar4[1] == (int *)0x0))
          {
            uVar3 = ev_timer_enough();
            if (uVar3 == '\0')
            {
              pBuf = (u8 *)((uint) * (byte *)((int)ppiVar4 + 0xb) * 0x1000000 |
                            (uint) * (uint3 *)(ppiVar4 + 2));
              if (pBuf != (u8 *)0x0)
              {
                ev_buf_free(pBuf);
                *(undefined *)(ppiVar4 + 2) = 0;
                *(undefined *)((int)ppiVar4 + 9) = 0;
                *(undefined *)((int)ppiVar4 + 10) = 0;
                *(undefined *)((int)ppiVar4 + 0xb) = 0;
              }
              nwkTxDataPendTabEntryClear();
              *(undefined *)ppiVar4 = 0;
              *(undefined *)((int)ppiVar4 + 1) = 0;
              *(undefined *)((int)ppiVar4 + 2) = 0;
              *(undefined *)((int)ppiVar4 + 3) = 0;
            }
            else
            {
              if ((*in_r1 == 0xffff) && (*(char *)((int)ppiVar4 + 0xf) == '\0'))
              {
                nwkBrcMsgAllEndDevStart();
              }
              nwkBrcMsgPassiveAckTimeoutStart();
            }
          }
          goto LAB_00017276;
        }
        if (bVar1 != 0xc0)
        {
          ppiVar4 = (int **)nwkBrcTransEntryCreate();
          if (ppiVar4 != (int **)0x0)
            goto LAB_000173c6;
          nwkTxDataPendTabEntryClear();
          if (bVar1 < 0xc0)
          {
            nwkNldeDataCnf();
            return;
          }
        }
        goto LAB_000172fe;
      }
      nwkTxDataPendTabEntryClear();
    }
  LAB_00017276:
    nwk_tx();
  }
  else
  {
    iVar5 = nwkRouteRecTabEntryFind();
    if ((iVar5 == 0) || (*(byte *)(in_r1 + 3) < 2))
    {
      if ((int)((uint) * (byte *)((int)in_r1 + 5) << 0x1d) < 0)
      {
        uVar10 = nwkSrcRouteReplayNextHop();
        if (*(char *)((int)in_r1 + 0x1b) == '\0')
        {
          nwk_neTblGetByShortAddr((u16)uVar10);
        }
        goto LAB_000172e6;
      }
      iVar5 = nwkVaildNeighborToFwd();
      if (iVar5 != 0)
      {
        iVar8 = nwkRoutingTabGetNextHop();
      LAB_00017408:
        if ((((iVar8 != 0) && ((*(byte *)(in_r1 + 2) & 3) == 0)) &&
             ((*(byte *)(iVar8 + 5) & 6) == 6)) &&
            ((ptVar6 = nwk_neTblGetByShortAddr(in_r1[1]), in_r1[1] == g_zbInfo.nwkNib.nwkAddr ||
                                                              ((ptVar6 != (tl_zb_normal_neighbor_entry_t *)0x0 &&
                                                                ((ptVar6->field_0x1e & 0x7e) == 0x14))))))
        {
          nwkRouteRecordInitiation();
          if (-1 < (int)((uint) * (byte *)(iVar8 + 5) << 0x1f))
          {
            *(byte *)(iVar8 + 5) = *(byte *)(iVar8 + 5) & 0xfb;
          }
        }
        if (iVar5 == 0)
        {
          if (iVar8 == 0)
            goto LAB_000172ee;
          uVar10 = (uint) * (ushort *)(iVar8 + 2);
        }
        else
        {
          uVar10 = (uint)*in_r1;
        }
        goto LAB_000172e6;
      }
      iVar8 = nwkRoutingTabGetNextHop();
      if (iVar8 != 0)
        goto LAB_00017408;
      if ((*(byte *)(in_r1 + 2) & 0xc0) == 0)
        goto LAB_000172ee;
      if (ppzVar9 != (zb_buf_t **)0x0)
      {
        iVar5 = nwkTxDataRouteDiscStart();
        if (iVar5 == 0)
        {
          zb_buf_free(in_r0);
          iVar5 = nwkRouteDiscEntryDstFind();
          *(byte *)((int)ppzVar9 + 0xb) = *(byte *)((int)ppzVar9 + 0xb) | 0x40;
          *(undefined *)((int)ppzVar9 + 10) = *(undefined *)(iVar5 + 0x10);
          return;
        }
        goto LAB_000172ee;
      }
    }
    else
    {
      *(byte *)((int)in_r1 + 5) = *(byte *)((int)in_r1 + 5) | 4;
      bVar2 = *(byte *)(iVar5 + 0x12);
      bVar7 = (byte)(((uint)bVar2 << 0x19) >> 0x19);
      *(byte *)(in_r1 + 0xd) = bVar7;
      if ((bVar2 & 0x7f) == 0)
      {
        *(byte *)((int)in_r1 + 0x1b) = bVar7;
        uVar10 = (uint)*in_r1;
      }
      else
      {
        *(byte *)((int)in_r1 + 0x1b) = (byte)(((uint) * (byte *)(iVar5 + 0x12) << 0x19) >> 0x19) - 1;
        iVar8 = iVar5 + 2;
        *(char *)(in_r1 + 0xe) = (char)iVar8;
        *(char *)((int)in_r1 + 0x1d) = (char)((uint)iVar8 >> 8);
        *(char *)(in_r1 + 0xf) = (char)((uint)iVar8 >> 0x10);
        *(char *)((int)in_r1 + 0x1f) = (char)((uint)iVar8 >> 0x18);
        uVar10 = (uint) * (ushort *)(iVar5 + (((uint) * (byte *)(iVar5 + 0x12) << 0x19) >> 0x18));
      }
    LAB_000172e6:
      if (uVar10 != 0xfffe)
        goto LAB_00017276;
    LAB_000172ee:
      if (ppzVar9 != (zb_buf_t **)0x0)
      {
        nwkTxDataPendTabEntryClear();
      }
    }
    if (bVar1 < 0xc0)
    {
      nwkNldeDataCnf();
      return;
    }
  LAB_000172fe:
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Removing unreachable block (RAM,0x00017872)
// WARNING: Removing unreachable block (RAM,0x00017876)
// WARNING: Removing unreachable block (RAM,0x00017af8)
// WARNING: Removing unreachable block (RAM,0x000177b8)
// WARNING: Removing unreachable block (RAM,0x00017a06)
// WARNING: Removing unreachable block (RAM,0x00017ae8)
// WARNING: Removing unreachable block (RAM,0x00017af0)
// WARNING: Removing unreachable block (RAM,0x000177a6)
// WARNING: Removing unreachable block (RAM,0x0001773a)
// WARNING: Removing unreachable block (RAM,0x00017b58)
// WARNING: Removing unreachable block (RAM,0x00017b64)
// WARNING: Removing unreachable block (RAM,0x00017b62)
// WARNING: Removing unreachable block (RAM,0x00017b56)
// WARNING: Removing unreachable block (RAM,0x0001770a)
// WARNING: Removing unreachable block (RAM,0x00017718)
// WARNING: Removing unreachable block (RAM,0x0001772c)
// WARNING: Removing unreachable block (RAM,0x00017732)
// WARNING: Removing unreachable block (RAM,0x00017b46)
// WARNING: Removing unreachable block (RAM,0x00017b48)
// WARNING: Removing unreachable block (RAM,0x00017700)
// WARNING: Removing unreachable block (RAM,0x00017704)
// WARNING: Removing unreachable block (RAM,0x00017716)
// WARNING: Removing unreachable block (RAM,0x00017b86)
// WARNING: Removing unreachable block (RAM,0x00017734)
// WARNING: Removing unreachable block (RAM,0x0001773c)
// WARNING: Removing unreachable block (RAM,0x00017742)
// WARNING: Removing unreachable block (RAM,0x00017b84)
// WARNING: Removing unreachable block (RAM,0x00017832)
// WARNING: Removing unreachable block (RAM,0x0001785c)
// WARNING: Removing unreachable block (RAM,0x0001785e)
// WARNING: Removing unreachable block (RAM,0x0001774c)
// WARNING: Removing unreachable block (RAM,0x00017782)
// WARNING: Removing unreachable block (RAM,0x000178b6)
// WARNING: Removing unreachable block (RAM,0x000178ea)
// WARNING: Removing unreachable block (RAM,0x000179b0)
// WARNING: Removing unreachable block (RAM,0x000179d6)
// WARNING: Removing unreachable block (RAM,0x000178cc)
// WARNING: Removing unreachable block (RAM,0x000178e2)
// WARNING: Removing unreachable block (RAM,0x000178be)
// WARNING: Removing unreachable block (RAM,0x000178f8)
// WARNING: Removing unreachable block (RAM,0x00017900)
// WARNING: Removing unreachable block (RAM,0x00017914)
// WARNING: Removing unreachable block (RAM,0x0001794a)
// WARNING: Removing unreachable block (RAM,0x0001794c)
// WARNING: Removing unreachable block (RAM,0x00017952)
// WARNING: Removing unreachable block (RAM,0x00017950)
// WARNING: Removing unreachable block (RAM,0x0001797c)
// WARNING: Removing unreachable block (RAM,0x000179a2)
// WARNING: Removing unreachable block (RAM,0x000179a0)
// WARNING: Removing unreachable block (RAM,0x000178b4)
// WARNING: Removing unreachable block (RAM,0x00017784)
// WARNING: Removing unreachable block (RAM,0x0001778c)
// WARNING: Removing unreachable block (RAM,0x00017796)
// WARNING: Removing unreachable block (RAM,0x0001779c)
// WARNING: Removing unreachable block (RAM,0x000177a4)
// WARNING: Removing unreachable block (RAM,0x00017698)
// WARNING: Removing unreachable block (RAM,0x000176a0)
// WARNING: Removing unreachable block (RAM,0x000177ac)
// WARNING: Removing unreachable block (RAM,0x00017af2)
// WARNING: Removing unreachable block (RAM,0x00017afa)
// WARNING: Removing unreachable block (RAM,0x00017b04)
// WARNING: Removing unreachable block (RAM,0x00017b0e)
// WARNING: Removing unreachable block (RAM,0x00017b14)
// WARNING: Removing unreachable block (RAM,0x00017b22)
// WARNING: Removing unreachable block (RAM,0x00017b24)
// WARNING: Removing unreachable block (RAM,0x000177ba)
// WARNING: Removing unreachable block (RAM,0x000177c2)
// WARNING: Removing unreachable block (RAM,0x000177dc)
// WARNING: Removing unreachable block (RAM,0x000177da)
// WARNING: Removing unreachable block (RAM,0x00017a1c)
// WARNING: Removing unreachable block (RAM,0x00017a30)
// WARNING: Removing unreachable block (RAM,0x00017a2e)
// WARNING: Removing unreachable block (RAM,0x00017a38)
// WARNING: Removing unreachable block (RAM,0x00017a48)
// WARNING: Removing unreachable block (RAM,0x00017a4a)
// WARNING: Removing unreachable block (RAM,0x00017a56)
// WARNING: Removing unreachable block (RAM,0x000177de)
// WARNING: Removing unreachable block (RAM,0x000177f0)
// WARNING: Removing unreachable block (RAM,0x000177f8)
// WARNING: Removing unreachable block (RAM,0x00017816)
// WARNING: Removing unreachable block (RAM,0x00017822)
// WARNING: Removing unreachable block (RAM,0x00017824)
// WARNING: Removing unreachable block (RAM,0x000177ee)
// WARNING: Removing unreachable block (RAM,0x00017a58)
// WARNING: Removing unreachable block (RAM,0x00017b12)
// WARNING: Removing unreachable block (RAM,0x00017b0c)
// WARNING: Removing unreachable block (RAM,0x000177f6)
// WARNING: Removing unreachable block (RAM,0x00017878)
// WARNING: Removing unreachable block (RAM,0x0001787a)
// WARNING: Removing unreachable block (RAM,0x00017882)
// WARNING: Removing unreachable block (RAM,0x00017896)
// WARNING: Removing unreachable block (RAM,0x00017880)
// WARNING: Removing unreachable block (RAM,0x00017a68)
// WARNING: Removing unreachable block (RAM,0x00017a70)
// WARNING: Removing unreachable block (RAM,0x00017a7c)
// WARNING: Removing unreachable block (RAM,0x00017a88)
// WARNING: Removing unreachable block (RAM,0x00017a94)
// WARNING: Removing unreachable block (RAM,0x00017aa0)
// WARNING: Removing unreachable block (RAM,0x00017aac)
// WARNING: Removing unreachable block (RAM,0x00017ab8)
// WARNING: Removing unreachable block (RAM,0x00017ac4)
// WARNING: Removing unreachable block (RAM,0x00017ad0)
// WARNING: Removing unreachable block (RAM,0x00017adc)
// WARNING: Removing unreachable block (RAM,0x00017898)
// WARNING: Removing unreachable block (RAM,0x00017a66)
// WARNING: Recovered jumptable eliminated as dead code
// WARNING: Removing unreachable block (RAM,0x000176ca)

void tl_zbMacMcpsDataIndicationHandler(void *buf)

{
  uint uVar1;

  if (*(short *)((int)buf + 0x12) == -1)
  {
    uVar1 = ((uint) * *(byte **)((int)buf + 4) << 0x1a) >> 0x1c;
    if (uVar1 == 3)
    {
      tl_zbTaskPost(cGp_mcpsDataInd, buf);
      return;
    }
    if ((uVar1 != 2) || ((**(byte **)((int)buf + 4) & 3) != 3))
      goto switchD_00017a6e_caseD_0;
  }
  if ((((g_zbNwkCtx._47_1_ & 0xf) != 2) &&
       (uVar1 = nwkHdrParse(), uVar1 < *(byte *)((int)buf + 0x1d))) &&
      (((int)((uint)g_zbNwkCtx._45_1_ << 0x1d) < 0 || ((g_zbNwkCtx._47_1_ & 0xf) == 1))))
  {
    g_sysDiags.packetValidateDropCount = g_sysDiags.packetValidateDropCount + 1;
    zb_buf_free((zb_buf_t *)buf);
    return;
  }
switchD_00017a6e_caseD_0:
  zb_buf_free((zb_buf_t *)buf);
  return;
}

void tl_zbNwkNldeDataRequestHandler(void *arg)

{
  ushort uVar1;
  byte bVar2;

  if (((int)((uint)g_zbNwkCtx._45_1_ << 0x1d) < 0) && ((g_zbNwkCtx._47_1_ & 0xf) == 0))
  {
    uVar1 = *(ushort *)((int)arg + 8);
    if (*(ushort *)((int)arg + 8) == g_zbInfo.nwkNib.nwkAddr)
    {
      nwkNldeDataCnf();
    }
    else
    {
      *(undefined *)((int)arg + 0xc1) = *(undefined *)((int)arg + 0xf);
      bVar2 = *(char *)((int)arg + 0xb) - 1;
      if (*(char *)((int)arg + 0x15) == '\0')
      {
        g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
      }
      if ((int)((uint)(~bVar2 + bVar2 + (*(char *)((int)arg + 0xb) != '\0') & 0xfd) << 0x1f) < 0)
      {
        aps_group_search_by_addr(*(u16 *)((int)arg + 8));
      }
      if ((*(char *)((int)arg + 0x19) == '\0') || ((uVar1 & 0xfff8) == 0xfff8))
      {
        nwk_fwdPacket();
      }
      else
      {
        nwk_tx();
      }
    }
  }
  else if (*(byte *)((int)arg + 0xf) < 0xc0)
  {
    nwkNldeDataCnf();
  }
  else
  {
    zb_buf_free((zb_buf_t *)arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_nlmeNwkDiscCnf(void)

{
  void *in_r0;
  undefined in_r1;

  *(undefined *)((int)in_r0 + 0x80) = in_r1;
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf;
  tl_zbTaskPost(zdo_nlme_network_discovery_confirm_cb, in_r0);
  return;
}

void tl_zbNwkNlmeNwkDiscRequestHandler(void *arg)

{
  undefined4 uVar1;
  undefined uVar2;
  undefined uVar3;
  undefined uVar4;

  if ((g_zbNwkCtx._47_1_ & 0xf0) == 0)
  {
    // WARNING: Load size is inaccurate
    if ((*arg & 0x7fff800) == 0)
    {
      nwk_nlmeNwkDiscCnf();
    }
    else
    {
      g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf | 0x30;
      // WARNING: Load size is inaccurate
      uVar1 = *arg;
      uVar2 = (undefined)((uint)uVar1 >> 8);
      uVar3 = (undefined)((uint)uVar1 >> 0x10);
      uVar4 = (undefined)((uint)uVar1 >> 0x18);
      g_zbNwkCtx.scanDuration = *(u8 *)((int)arg + 4);
      g_zbNwkCtx.scanChannels._0_1_ = (char)uVar1;
      g_zbNwkCtx.scanChannels._1_1_ = uVar2;
      g_zbNwkCtx.scanChannels._2_1_ = uVar3;
      g_zbNwkCtx.scanChannels._3_1_ = uVar4;
      *(undefined *)((int)arg + 4) = 1;
      *(char *)arg = (char)uVar1;
      *(undefined *)((int)arg + 1) = uVar2;
      *(undefined *)((int)arg + 2) = uVar3;
      *(undefined *)((int)arg + 3) = uVar4;
      *(u8 *)((int)arg + 5) = g_zbNwkCtx.scanDuration;
      tl_zbPrimitivePost('\x02', 'U', arg);
    }
  }
  else
  {
    nwk_nlmeNwkDiscCnf();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_discoveryScanCnfHandler(void)

{
  zb_buf_t *in_r0;

  if (in_r0->buf[1] == '\x01')
  {
    nwk_nlmeNwkDiscCnf();
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

void tl_zbMacMlmeBeaconNotifyIndicationHandler(void *arg)

{
  byte bVar1;
  char *pcVar2;
  u16 uVar3;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  int iVar5;
  byte bVar6;
  byte bVar7;
  uint uVar8;
  uint uVar9;
  char *pcStack_48;
  undefined auStack_44[16];
  uint uStack_34;
  uint local_30;
  uint local_2c;
  undefined uStack_28;
  byte bStack_27;

  pcVar2 = *(char **)((int)arg + 0x28);
  memcpy(&uStack_28, (void *)((int)arg + 6), 2);
  bVar7 = *(byte *)((int)arg + 6);
  bVar1 = *(byte *)((int)arg + 7);
  uVar9 = (uint)bVar1;
  if ((((pcVar2 == (char *)0x0) || (*pcVar2 != '\0')) || ((pcVar2[1] & 0xf0U) != 0x20)) ||
      (((pcVar2[0xb] != -1 || (pcVar2[0xc] != -1)) || (pcVar2[0xd] != -1))))
    goto LAB_00017ef6;
  bVar6 = g_zbNwkCtx._47_1_ & 0xf0;
  if (bVar6 == 0x30)
  {
    if (((TL_ZB_ASSOCJOIN_PERMIT_PANID != 0xffff) &&
         (TL_ZB_ASSOCJOIN_PERMIT_PANID != *(u16 *)((int)arg + 4))) ||
        ((TL_ZB_ASSOCJOIN_FILTER_PANID != 0xffff &&
          (TL_ZB_ASSOCJOIN_FILTER_PANID == *(u16 *)((int)arg + 4)))))
      goto LAB_00017ef6;
    if ((bStack_27 & 0x80) != 0)
      goto LAB_0001801c;
  }
  else if ((bVar6 == 0x10) ||
           ((bVar6 == 0x40 && (iVar5 = memcmp(pcVar2 + 3, g_zbInfo.nwkNib.extPANId, 8), iVar5 == 0))))
  {
  LAB_0001801c:
    pcStack_48 = pcVar2 + 3;
    auStack_44._0_4_ = 0;
    auStack_44._4_4_ = 0;
    auStack_44._8_4_ = 0;
    auStack_44._12_4_ = 0;
    uStack_34 = 0;
    bVar6 = (byte)(((byte)pcVar2[2] >> 2 & 1) << 2);
    local_2c._0_3_ =
        CONCAT12(pcVar2[0xe], (ushort) * (byte *)((int)arg + 0x1f) << 8 | (ushort)(bVar7 >> 4) << 2);
    local_2c = (uint)(uint3)local_2c;
    uVar8 = 0;
    if (((byte)pcVar2[1] & 0xf) == (uint)g_zbInfo.nwkNib.stackProfile)
    {
      uVar8 = (uint)(bVar6 != 0);
    }
    local_30 = CONCAT13(bVar6 | bVar1 >> 7 | (byte)(((byte)pcVar2[1] & 0xf) << 4) |
                            ((byte)pcVar2[2] >> 7) << 3 | (byte)(uVar8 << 1),
                        (uint3) * (byte *)((int)arg + 0x1c) << 8 |
                            (uint3)(byte)((byte)((bVar7 & 0xf) << 4) | (byte)pcVar2[2] >> 3 & 0xf) << 0x10);
    memcpy(auStack_44, pcStack_48, 8);
    uStack_34 = uStack_34 & 0xffff | (uint) * (ushort *)((int)arg + 4) << 0x10;
    bVar7 = *(byte *)((int)arg + 0x10);
    local_30 = local_30 & 0xffffff00 | (uint)bVar7;
    if (bVar7 == 2)
    {
      memcpy(auStack_44 + 0x10, (void *)((int)arg + 8), 2);
    }
    else if (bVar7 == 3)
    {
      memcpy(auStack_44 + 8, (void *)((int)arg + 8), 8);
    }
    bVar7 = (byte)(((uVar9 << 0x19) >> 0x1f) << 6);
    bStack_27 = (byte)((uVar9 << 0x1c) >> 0x1c) | (byte)(((uVar9 << 0x1b) >> 0x1f) << 4) |
                (byte)(((uVar9 << 0x1a) >> 0x1f) << 5) | bVar7 | bVar1 & 0x80;
    local_2c = local_2c & 0xffffff00 | (uint)(byte)((byte)local_2c & 0xfc | ~bVar7 + bVar7);
    tl_zbAdditionNeighborTableUpdate((tl_zb_addition_neighbor_entry_t *)auStack_44);
    goto LAB_00017ef6;
  }
  uVar9 = (uint)g_zbNwkCtx._45_1_;
  if ((uVar9 & 0x24) == 4)
  {
    bVar7 = g_zbNwkCtx._46_1_ & 0xf;
    if (bVar7 < 8)
    {
      uVar3 = *(u16 *)((int)arg + 4);
      iVar5 = 0;
      do
      {
        if (g_zbNwkCtx.known_panids[iVar5] == uVar3)
          break;
        if (g_zbNwkCtx.known_panids[iVar5] == 0)
        {
          *(char *)(g_zbNwkCtx.known_panids + iVar5) = (char)uVar3;
          *(char *)((int)g_zbNwkCtx.known_panids + iVar5 * 2 + 1) = (char)(uVar3 >> 8);
          g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0xf0 | bVar7 + 1 & 0xf;
          break;
        }
        iVar5 = iVar5 + 1;
      } while (iVar5 != 8);
      if ((int)(uVar9 << 0x19) < 0)
        goto LAB_00017ef6;
      iVar5 = tl_zbNwkPanidConflictDetect();
      if (iVar5 != 0)
      {
        g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x40;
        g_sysDiags.panIdConflict = g_sysDiags.panIdConflict + '\x01';
        tl_zbNwkPanidConflictProcess();
        return;
      }
    }
    if ((((*(char *)((int)arg + 0x10) == '\x02') &&
          (ptVar4 = nwk_neTblGetByShortAddr(*(u16 *)((int)arg + 8)),
           ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0)) &&
         (*(u16 *)((int)arg + 4) == g_zbInfo.nwkNib.panId)) &&
        (iVar5 = memcmp(pcVar2 + 3, g_zbInfo.nwkNib.extPANId, 8), iVar5 == 0))
    {
      ptVar4->depth = (byte)(((uint)(byte)pcVar2[2] << 0x19) >> 0x1c);
    }
  }
LAB_00017ef6:
  zb_buf_free((zb_buf_t *)arg);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

buf_sts_t nwkEndDevTimeoutInfoNVStore(void)

{
  nv_sts_t nVar1;
  buf_sts_t bVar2;
  int *in_r0;
  int iVar3;
  int iVar4;
  int local_34;
  undefined auStack_30[8];
  ushort local_28;
  u8 uStack_26;

  local_28 = 0;
  uStack_26 = '\0';
  nVar1 = nv_flashReadNew('\0', '\x01', 0xff, 0xc, (u8 *)&local_28);
  if (nVar1 == NV_SUCC)
  {
    iVar4 = 0;
    do
    {
      nVar1 = nv_flashReadByIndex('\x01', '\v', uStack_26, (u16)iVar4, 0xc, (u8 *)&local_34);
      if ((nVar1 == NV_SUCC) && (iVar3 = memcmp(in_r0 + 1, auStack_30, 8), iVar3 == 0))
      {
        if (*in_r0 == local_34)
          goto LAB_000182c6;
        nv_itemDeleteByIndex('\x01', '\v', uStack_26, (u16)iVar4);
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 <= (int)(uint)local_28);
  }
  nv_flashWriteNew('\0', 1, '\v', 0xc, (u8 *)in_r0);
LAB_000182c6:
  bVar2 = ev_buf_free((u8 *)in_r0);
  return bVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkEndDevTimeoutRspCmdSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, '\x03');
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[4];
  puVar1[2] = in_r2[5];
  (in_r0->hdr).handle = in_r3;
  nwk_fwdPacket();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkEndDevTimeoutInfoStore(void)

{
  undefined4 uVar1;
  int in_r0;
  u8 *arg;
  undefined4 unaff_r4;
  undefined4 in_lr;

  arg = ev_buf_allocate(0xc);
  if (arg != (u8 *)0x0)
  {
    tl_zbExtAddrByIdx(*(u16 *)(in_r0 + 0x16), (addrExt_t)CONCAT44(unaff_r4, in_lr));
    uVar1 = *(undefined4 *)(in_r0 + 0x10);
    *arg = (u8)uVar1;
    arg[1] = (u8)((uint)uVar1 >> 8);
    arg[2] = (u8)((uint)uVar1 >> 0x10);
    arg[3] = (u8)((uint)uVar1 >> 0x18);
    tl_zbTaskPost(nwkEndDevTimeoutInfoNVStore, arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint nwkEndDevTimeoutReqCmdHandler(void)

{
  undefined uVar1;
  undefined uVar2;
  u8 uVar3;
  bool bVar4;
  byte bVar5;
  zb_buf_t *in_r0;
  uint uVar6;
  tl_zb_normal_neighbor_entry_t *ptVar7;
  int in_r1;
  int in_r2;
  undefined uVar8;
  int iVar9;
  nwk_hdr_t local_58;
  undefined4 local_38;
  uint uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  undefined local_1e;

  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  local_20 = 0;
  local_1e = 0;
  local_38 = 0xc;
  if ((*(byte *)(in_r2 + 4) < 0xf) && (*(char *)(in_r2 + 5) == '\0'))
  {
    ptVar7 = nwk_neTblGetByShortAddr(*(u16 *)(in_r1 + 2));
    if ((ptVar7 == (tl_zb_normal_neighbor_entry_t *)0x0) || ((ptVar7->field_0x1e & 0xe) != 4))
    {
      bVar5 = zb_buf_free(in_r0);
      return (uint)bVar5;
    }
    ptVar7->keepaliveRcvd = '\x01';
    iVar9 = 10;
    if (*(byte *)(in_r2 + 4) != 0)
    {
      iVar9 = 0x3c << (uint) * (byte *)(in_r2 + 4);
    }
    *(char *)&ptVar7->timeoutCnt = (char)iVar9;
    uVar1 = (undefined)((uint)iVar9 >> 8);
    *(undefined *)((int)&ptVar7->timeoutCnt + 1) = uVar1;
    uVar2 = (undefined)((uint)iVar9 >> 0x10);
    *(undefined *)((int)&ptVar7->timeoutCnt + 2) = uVar2;
    uVar8 = (undefined)((uint)iVar9 >> 0x18);
    *(undefined *)((int)&ptVar7->timeoutCnt + 3) = uVar8;
    *(char *)&ptVar7->devTimeout = (char)iVar9;
    *(undefined *)((int)&ptVar7->devTimeout + 1) = uVar1;
    *(undefined *)((int)&ptVar7->devTimeout + 2) = uVar2;
    *(undefined *)((int)&ptVar7->devTimeout + 3) = uVar8;
    *(undefined *)&ptVar7->endDevCfg = *(undefined *)(in_r2 + 5);
    *(undefined *)((int)&ptVar7->endDevCfg + 1) = 0;
    nwkEndDevTimeoutInfoStore();
    if ((int)((uint)g_zbInfo.nwkNib.parentInfo << 0x1e) < 0)
    {
      uStack_34 = uStack_34 & 0xffff0000 | (uint)g_zbInfo.nwkNib.parentInfo << 8;
    }
    else
    {
      uStack_34 = uStack_34 & 0xffff0000 | 0x100;
    }
  }
  else
  {
    uStack_34 = 1;
  }
  zb_buf_clear(in_r0);
  local_58._0_4_ = 0;
  local_58._4_4_ = 0;
  local_58.dstIeeeAddr._0_4_ = 0;
  local_58.dstIeeeAddr._4_4_ = 0;
  local_58.srcIeeeAddr._0_4_ = 0;
  local_58.srcIeeeAddr._4_4_ = 0;
  local_58._24_4_ = 0;
  local_58.srcRouteSubFrame.relayList = (u8 *)0x0;
  uVar6 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar4 = ss_keyPreconfigured();
    uVar6 = (uint)bVar4;
  }
  local_58._4_4_ =
      local_58._4_4_ & 0xffff0000 |
      (uint)(CONCAT11((byte)(local_58._4_4_ >> 8) & 0xfd | (byte)(uVar6 << 1), (char)local_58._4_4_) & 0xffc0 | 0x1009) | 0x800;
  memcpy(local_58.srcIeeeAddr, g_zbInfo.macPib.extAddress, 8);
  memcpy(local_58.dstIeeeAddr, (void *)(in_r1 + 0x10), 8);
  local_58._0_4_ = CONCAT22(g_zbInfo.nwkNib.nwkAddr, *(undefined2 *)(in_r1 + 2));
  local_58._4_4_ = CONCAT13(g_zbInfo.nwkNib.seqNum, CONCAT12(1, (short)local_58._4_4_));
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar3 = getNwkHdrSize(&local_58);
  local_58._24_2_ = CONCAT11(uVar3, local_58.mcaseControl);
  local_58._24_4_ = local_58._24_4_ & 0xffff0000 | (uint)local_58._24_2_;
  uVar6 = nwkEndDevTimeoutRspCmdSend();
  return uVar6;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 nwkEndDevTimeoutRspCnfHandler(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;

  uVar1 = zb_buf_free(in_r0);
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_nlmeNwkFormationCn(void)

{
  undefined *in_r0;
  undefined in_r1;

  *in_r0 = in_r1;
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf;
  tl_zbTaskPost(zdo_network_formation_confirm, in_r0);
  return;
}

void tl_zbNwkNlmeNetworkFormationRequestHandler(void *arg)

{
  int iVar1;
  byte bVar2;
  ushort uVar3;
  undefined uVar4;
  undefined uVar5;
  undefined uVar6;

  if (((g_zbNwkCtx._47_1_ & 0xf0) == 0) && (-1 < (int)((uint)g_zbNwkCtx._45_1_ << 0x1d)))
  {
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf | 0x10;
    // WARNING: Load size is inaccurate
    iVar1 = *arg;
    bVar2 = (byte)iVar1;
    uVar6 = (undefined)((uint)iVar1 >> 8);
    uVar4 = (undefined)((uint)iVar1 >> 0x10);
    uVar5 = (undefined)((uint)iVar1 >> 0x18);
    g_zbNwkCtx.scanDuration = *(u8 *)((int)arg + 8);
    if (*(char *)((int)arg + 6) == '\0')
    {
      g_zbInfo.nwkNib.nwkAddr._0_1_ = 0;
      g_zbInfo.nwkNib.nwkAddr._1_1_ = 0;
      uVar3 = 0;
    }
    else
    {
      uVar3 = *(ushort *)((int)arg + 4);
      g_zbInfo.nwkNib.nwkAddr._0_1_ = (undefined)uVar3;
      g_zbInfo.nwkNib.nwkAddr._1_1_ = (undefined)((uint)uVar3 >> 8);
    }
    g_zbInfo.macPib.shortAddress._0_1_ = (undefined)uVar3;
    g_zbInfo.macPib.shortAddress._1_1_ = (undefined)(uVar3 >> 8);
    g_zbNwkCtx.scanChannels._0_1_ = bVar2;
    g_zbNwkCtx.scanChannels._1_1_ = uVar6;
    g_zbNwkCtx.scanChannels._2_1_ = uVar4;
    g_zbNwkCtx.scanChannels._3_1_ = uVar5;
    *(byte *)arg = bVar2;
    *(undefined *)((int)arg + 1) = uVar6;
    *(undefined *)((int)arg + 2) = uVar4;
    *(undefined *)((int)arg + 3) = uVar5;
    *(u8 *)((int)arg + 5) = g_zbNwkCtx.scanDuration;
    bVar2 = bVar2 & bVar2 - 1;
    *(byte *)((int)arg + 4) = ~bVar2 + bVar2 + (iVar1 != 0);
    tl_zbPrimitivePost('\x02', 'U', arg);
  }
  else
  {
    nwk_nlmeNwkFormationCn();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint nwk_formationScanCnfHandler(void)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  uint uVar4;
  uint uVar5;
  byte bVar6;
  zb_buf_t *in_r0;
  uint uVar7;
  tl_zb_addition_neighbor_entry_t *ptVar8;
  u32 uVar9;
  zb_buf_t *pzVar10;
  char cVar11;
  byte bVar12;
  u8 uVar13;
  u8 uVar14;
  nwk_ctx_t *pnVar15;
  undefined2 uVar16;
  byte bVar17;

  if (in_r0->buf[1] == '\0')
  {
    if (in_r0->buf[0] == '\0')
    {
      memcpy(&g_zbNwkCtx, in_r0->buf + 8, 0x10);
      cVar11 = '\x0f';
      uVar7 = 0x800;
      pzVar10 = in_r0;
      while (true)
      {
        if (((g_zbNwkCtx.scanChannels & uVar7) != 0) && (0x3c < pzVar10->buf[8]))
        {
          g_zbNwkCtx.scanChannels = g_zbNwkCtx.scanChannels ^ uVar7;
        }
        cVar11 = cVar11 + -1;
        pzVar10 = (zb_buf_t *)(pzVar10->buf + 1);
        if (cVar11 == '\0')
          break;
        uVar7 = uVar7 << 1;
      }
      uVar7 = g_zbNwkCtx.scanChannels >> 8;
      uVar4 = g_zbNwkCtx.scanChannels >> 0x10;
      uVar5 = g_zbNwkCtx.scanChannels >> 0x18;
      if (g_zbNwkCtx.scanChannels == 0)
      {
        uVar7 = nwk_nlmeNwkFormationCn();
        return uVar7;
      }
      in_r0->buf[0] = (u8)g_zbNwkCtx.scanChannels;
      in_r0->buf[1] = (u8)uVar7;
      in_r0->buf[2] = (u8)uVar4;
      in_r0->buf[3] = (u8)uVar5;
      in_r0->buf[5] = g_zbNwkCtx.scanDuration;
      in_r0->buf[4] = '\x01';
      bVar6 = tl_zbPrimitivePost('\x02', 'U', in_r0);
      return (uint)bVar6;
    }
    goto LAB_00018752;
  }
  if (in_r0->buf[1] != '\x01')
  {
    bVar6 = zb_buf_free(in_r0);
    return (uint)bVar6;
  }
  uVar7 = (uint)g_zbInfo.nwkNib.panId;
  if ((in_r0->buf[0] != 0xea) && (in_r0->buf[0] != '\0'))
    goto LAB_00018752;
  bVar6 = tl_zbAdditionNeighborTableNumGet();
  if (bVar6 != 0)
  {
    bVar12 = 0;
    do
    {
      ptVar8 = tl_zbAdditionNeighborEntryGetFromIdx(bVar12);
      if (ptVar8 != (tl_zb_addition_neighbor_entry_t *)0x0)
      {
        g_zbNwkCtx.formationInfo.energy_detect[ptVar8->logicChannel + 5] =
            g_zbNwkCtx.formationInfo.energy_detect[ptVar8->logicChannel + 5] + '\x01';
      }
      bVar12 = bVar12 + 1;
    } while (bVar12 < bVar6);
  }
  pnVar15 = &g_zbNwkCtx;
  uVar14 = '\0';
  bVar12 = 0xff;
  bVar17 = 0xff;
  uVar13 = '\v';
  do
  {
    if (((g_zbNwkCtx.scanChannels &
          1 << (int)(pnVar15[-0x1ad58].formationInfo.channel_pan_count + 0xf)) != 0) &&
        (bVar1 = (pnVar15->formationInfo).channel_pan_count[0], bVar1 <= bVar17))
    {
      if (bVar1 == bVar17)
      {
        bVar2 = (pnVar15->formationInfo).energy_detect[0];
        if (bVar12 < bVar2)
          goto LAB_00018722;
      }
      else
      {
        bVar2 = (pnVar15->formationInfo).energy_detect[0];
      }
      bVar12 = bVar2;
      bVar17 = bVar1;
      uVar14 = uVar13;
      if (bVar1 == 0)
        goto joined_r0x00018810;
    }
  LAB_00018722:
    uVar13 = uVar13 + '\x01';
    pnVar15 = (nwk_ctx_t *)((pnVar15->formationInfo).energy_detect + 1);
  } while (uVar13 != '\x1b');
  bVar3 = false;
  uVar13 = uVar14;
  goto LAB_00018764;
joined_r0x00018810:
  while (uVar7 == 0xffff)
  {
    uVar9 = drv_u32Rand();
    uVar7 = uVar9 & 0xffff;
  }
  bVar3 = true;
LAB_00018764:
  uVar16 = (undefined2)uVar7;
  if ((byte)(uVar13 - 0xb) < 0x10)
  {
    if (!bVar3)
    {
      do
      {
        if (uVar7 == 0xffff)
        {
          uVar9 = drv_u32Rand();
          uVar7 = uVar9 & 0xffff;
        }
        bVar12 = 0;
        if (bVar6 != 0)
        {
          uVar14 = '\0';
          do
          {
            ptVar8 = tl_zbAdditionNeighborEntryGetFromIdx(uVar14);
            if (((ptVar8 != (tl_zb_addition_neighbor_entry_t *)0x0) &&
                 (ptVar8->logicChannel == uVar13)) &&
                (ptVar8->panId == uVar7))
            {
              uVar7 = uVar7 + 1 & 0xffff;
              break;
            }
            bVar12 = bVar12 + 1;
            uVar14 = uVar14 + '\x01';
          } while (bVar12 < bVar6);
        }
        uVar16 = (undefined2)uVar7;
      } while ((uVar7 == 0xffff) || (bVar6 != bVar12));
    }
    in_r0->buf[4] = (u8)uVar16;
    in_r0->buf[5] = (u8)((ushort)uVar16 >> 8);
    in_r0->buf[6] = uVar13;
    in_r0->buf[10] = '\x01';
    in_r0->buf[0x17] = '\0';
    in_r0->buf[8] = '\x0f';
    in_r0->buf[9] = '\x0f';
    in_r0->buf[0xb] = '\0';
    bVar6 = tl_zbPrimitivePost('\x02', 'Z', in_r0);
    return (uint)bVar6;
  }
LAB_00018752:
  uVar7 = nwk_nlmeNwkFormationCn();
  return uVar7;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkBeaconPayloadUpdate(void)

{
  byte bVar1;
  int iVar2;
  int iVar3;

  memset(&g_zbInfo.macPib.beaconPayload, 0, 0xf);
  g_zbInfo.macPib.beaconPayload._1_1_ = g_zbInfo.nwkNib.stackProfile & 0xf | 0x20;
  g_zbInfo.macPib.beaconPayload._2_1_ =
      g_zbInfo.macPib.beaconPayload._2_1_ & 0x87 | (byte)((g_zbInfo.nwkNib.depth & 0xf) << 3);
  memcpy(g_zbInfo.macPib.beaconPayload.extended_panid, g_zbInfo.nwkNib.extPANId, 8);
  memset(g_zbInfo.macPib.beaconPayload.txoffset, 0xff, 3);
  g_zbInfo.macPib.beaconPayload.nwk_update_id = g_zbInfo.nwkNib.updateId;
  g_zbInfo.macPib.beaconPayload._2_1_ = g_zbInfo.macPib.beaconPayload._2_1_ | 0x7f;
  bVar1 = tl_zbNeighborTableChildEDNumGet();
  if (TL_ZB_CHILD_TABLE_SIZE <= bVar1)
  {
    g_zbInfo.macPib.beaconPayload._2_1_ = g_zbInfo.macPib.beaconPayload._2_1_ & 0x7f;
  }
  if (LONG_UPTIME_THRESHOLD <= g_secondCnt)
  {
    g_zbInfo.macPib.beaconPayload._2_1_ = g_zbInfo.macPib.beaconPayload._2_1_ | 1;
  }
  iVar2 = nwkRoutingTabEntryDstActiveGet();
  iVar3 = nwkVaildNeighborToFwd();
  if ((iVar3 != 0) || (iVar2 != 0))
  {
    g_zbInfo.macPib.beaconPayload._2_1_ = g_zbInfo.macPib.beaconPayload._2_1_ | 2;
  }
  g_zbInfo.macPib.beaconPayloadLen = '\x0f';
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_formationStartCnfHandler(void)

{
  u16 shortAddr;
  char *in_r0;
  int iVar1;
  undefined4 in_lr;
  undefined in_stack_ffffffe8;
  undefined in_stack_ffffffe9;

  if (*in_r0 == '\0')
  {
    g_zbInfo.macPib.rxOnWhenIdle =
        (u8)(((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1c) >> 0x1f);
    g_zbInfo.nwkNib.panId = g_zbInfo.macPib.panId;
    memcpy(g_zbInfo.nwkNib.ieeeAddr, g_zbInfo.macPib.extAddress, 8);
    shortAddr = g_zbInfo.nwkNib.nwkAddr;
    g_zbInfo.macPib.shortAddress._0_1_ = (undefined)g_zbInfo.nwkNib.nwkAddr;
    g_zbInfo.macPib.shortAddress._1_1_ = (undefined)((uint)g_zbInfo.nwkNib.nwkAddr >> 8);
    iVar1 = memcmp(g_zbInfo.nwkNib.extPANId, &g_zero_addr, 8);
    if (iVar1 == 0)
    {
      memcpy(g_zbInfo.nwkNib.extPANId, g_zbInfo.macPib.extAddress, 8);
    }
    tl_zbNwkAddrMapAdd(shortAddr,
                       (addrExt_t)
                           CONCAT44(in_lr, (uint)CONCAT11(in_stack_ffffffe9, in_stack_ffffffe8)),
                       (u16 *)g_zbInfo.macPib.extAddress);
    tl_zbNwkBeaconPayloadUpdate();
  }
  nwk_nlmeNwkFormationCn();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

tl_zb_addition_neighbor_entry_t *tl_zbNwkParentChoose(void)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  void *in_r0;
  int iVar4;
  int in_r1;
  byte idx;
  tl_zb_addition_neighbor_entry_t *m2;
  tl_zb_addition_neighbor_entry_t *ptVar5;

  bVar3 = tl_zbAdditionNeighborTableNumGet();
  m2 = (tl_zb_addition_neighbor_entry_t *)0x0;
  if (bVar3 != 0)
  {
    idx = 0;
    ptVar5 = m2;
    do
    {
      m2 = tl_zbAdditionNeighborEntryGetFromIdx(idx);
      if (((m2 != (tl_zb_addition_neighbor_entry_t *)0x0) &&
           (bVar1 = m2->lqi, NWK_NEIGHBORTBL_ADD_LQITHRESHOLD <= bVar1)) &&
          ((iVar4 = memcmp(in_r0, &g_zero_addr, 8), iVar4 == 0 ||
                                                        (iVar4 = memcmp(in_r0, m2, 8), iVar4 == 0))))
      {
        if (in_r1 == 0)
        {
          bVar2 = m2->field_0x17;
          if ((bVar2 & 1) != 0)
          {
          LAB_00018a30:
            if (((bVar2 & 2) != 0) &&
                ((ptVar5 == (tl_zb_addition_neighbor_entry_t *)0x0 || (ptVar5->lqi < bVar1))))
            {
              ptVar5 = m2;
            }
          }
        }
        else
        {
          if ((m2->shortAddr != g_zbInfo.macPib.coordShortAddress) ||
              (m2->panId != g_zbInfo.macPib.panId))
          {
            bVar2 = m2->field_0x17;
            goto LAB_00018a30;
          }
          if ((m2->field_0x17 & 2) != 0)
            goto LAB_00018a56;
        }
      }
      m2 = ptVar5;
      idx = idx + 1;
      ptVar5 = m2;
    } while (idx < bVar3);
    if (m2 != (tl_zb_addition_neighbor_entry_t *)0x0)
    {
    LAB_00018a56:
      bVar3 = m2->field_0x17;
      if ((bVar3 & 0xf0) == 0x10)
      {
        g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x20;
        g_zbInfo.nwkNib.capabilityInfo =
            (capability_info_t)((byte)g_zbInfo.nwkNib.capabilityInfo & 0xfd);
        bVar3 = m2->field_0x17;
      }
      m2->field_0x17 = bVar3 & 0xfd;
    }
  }
  return m2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbNlmeRejoinRespTimeoutCb(void)

{
  u16 uVar1;
  undefined *arg;
  void *arg_00;
  char cVar2;
  undefined4 uVar3;

  cVar2 = rejoinRespPollCnt + 1;
  if (rejoinRespPollCnt < 3)
  {
    uVar3 = 0;
    rejoinRespPollCnt = cVar2;
    if (g_zbInfo.macPib.rxOnWhenIdle == '\0')
    {
      if ((g_zbNwkCtx.join.pAssocJoinParent != (tl_zb_addition_neighbor_entry_t *)0x0) &&
          (arg = (undefined *)c1(), arg != (undefined *)0x0))
      {
        arg[10] = 2;
        uVar1 = (g_zbNwkCtx.join.pAssocJoinParent)->shortAddr;
        arg[2] = (char)uVar1;
        arg[3] = (char)(uVar1 >> 8);
        uVar1 = g_zbInfo.macPib.panId;
        *arg = (char)g_zbInfo.macPib.panId;
        arg[1] = (char)(uVar1 >> 8);
        tl_zbPrimitivePost('\x02', ']', arg);
      }
    }
  }
  else
  {
    rejoinRespPollCnt = cVar2;
    arg_00 = (void *)c1();
    uVar3 = 0;
    if (arg_00 != (void *)0x0)
    {
      tl_zbTaskPost(nwk_rejoinReq, arg_00);
      rejoinRespPollCnt = '\0';
      rejoinRespTimeoutEvt = 0;
      uVar3 = 0xfffffffe;
    }
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

bool tl_zbNwkJoinAccept_clone_0(void)

{
  zb_nwk_status_t zVar1;
  u16 uVar2;
  u16 *in_r0;
  int iVar3;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  uint in_r1;
  u16 *in_r2;
  uint uVar5;
  uint uVar6;
  byte bVar7;
  int in_r3;
  byte in_stack_00000000;
  nebTbl_t *in_stack_ffffffb4;
  u16 local_28;
  undefined2 local_26;

  local_26 = 0;
  local_28 = 0xfffd;
  bVar7 = in_r3 != 0 &
          ~in_stack_00000000 + in_stack_00000000 + ((undefined *)0xffffffd5 < &stack0xffffffb0);
  if ((bVar7 != 0) && (iVar3 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8), iVar3 == 0))
  {
    return true;
  }
  ptVar4 = tl_zbNeighborTableSearchFromExtAddr(&local_28, (addrExt_t)CONCAT44(in_stack_ffffffb4, in_r2), in_r0);
  if (ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    if (g_zbInfo.nwkNib.maxDepth < g_zbInfo.nwkNib.depth)
    {
      return true;
    }
    if ((in_r1 & 0x80) == 0)
    {
      uVar2 = *in_r2;
    }
    else
    {
      uVar2 = *in_r2;
      if (*in_r2 == 0xffff)
      {
        uVar2 = tl_zbNwkStochasticAddrCal();
      }
    }
    local_28 = uVar2;
    zVar1 = tl_zbNwkAddrMapAdd(local_28, (addrExt_t)CONCAT44(in_stack_ffffffb4, in_r2), in_r0);
    if (zVar1 != NWK_STATUS_SUCCESS)
    {
      return true;
    }
  }
  else if (bVar7 != 0)
  {
    if (((byte)ptVar4->field_0x1e & 1) != -((int)(in_r1 << 0x1c) >> 0x1f))
    {
      return true;
    }
    uVar5 = (byte)ptVar4->field_0x1e & 0xe;
    uVar6 = uVar5 - 2;
    if (uVar6 + ~uVar6 + (uint)(1 < uVar5) != -((int)(in_r1 << 0x1e) >> 0x1f))
    {
      return true;
    }
  }
  bVar7 = (byte)in_r1 & 2;
  bVar7 = (bVar7 + ~bVar7 + '\x01') * '\x02';
  if ((bVar7 & 0xe) == 4)
  {
    iVar3 = 5;
    if (in_stack_00000000 != 0)
    {
      iVar3 = 1;
    }
  }
  else
  {
    if ((bVar7 & 0xe) != 2)
      goto LAB_00018c76;
    iVar3 = 5;
    if (in_stack_00000000 != 0)
    {
      iVar3 = 2;
    }
  }
  bVar7 = (byte)(iVar3 << 4);
LAB_00018c76:
  if ((bVar7 & 0x70) == 0x50)
  {
    FUN_0000162c(NWK_UNAUTH_CHILD_TABLE_LIFE_TIME, 1000);
  }
  ptVar4 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)&stack0xffffffb4, '\x01');
  if (ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    *in_r2 = local_28;
  }
  return ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkSendRejoinReqCmd(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, '\x02');
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[4];
  (in_r0->hdr).handle = in_r3;
  nwk_tx();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkSendRejoinRespCmd(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_stack_00000000;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, '\x04');
  *puVar1 = *in_r2;
  memcpy(puVar1 + 1, in_r2 + 4, 2);
  puVar1[3] = in_r2[6];
  (in_r0->hdr).handle = in_stack_00000000;
  nwk_tx();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_nlmeJoinCnf(void)

{
  u16 uVar1;
  undefined *in_r0;
  char in_r1;

  in_r0[2] = in_r1;
  if (in_r1 == '\0')
  {
    in_r0[3] = g_zbInfo.macPib.phyChannelCur;
    uVar1 = g_zbInfo.nwkNib.nwkAddr;
    *in_r0 = (char)g_zbInfo.nwkNib.nwkAddr;
    in_r0[1] = (char)(uVar1 >> 8);
    memcpy(in_r0 + 4, g_zbInfo.nwkNib.extPANId, 8);
  }
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf;
  tl_zbTaskPost(zdo_nlme_join_confirm, in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_associateJoin(void)

{
  char cVar1;
  undefined2 uVar2;
  undefined *in_r0;
  int iVar3;
  byte bVar4;

  bVar4 = g_zbNwkCtx._47_1_ & 0xf0;
  if ((g_zbNwkCtx._47_1_ & 0xf0) == 0)
  {
    iVar3 = tl_zbNwkParentChoose();
    if (iVar3 == 0)
    {
      nwk_nlmeJoinCnf();
    }
    else
    {
      g_zbNwkCtx.join._0_1_ = (undefined)iVar3;
      g_zbNwkCtx.join._1_1_ = (undefined)((uint)iVar3 >> 8);
      g_zbNwkCtx.join._2_1_ = (undefined)((uint)iVar3 >> 0x10);
      g_zbNwkCtx.join._3_1_ = (undefined)((uint)iVar3 >> 0x18);
      g_zbInfo.macPib.panId._0_1_ = (undefined) * (undefined2 *)(iVar3 + 0x12);
      g_zbInfo.macPib.panId._1_1_ = (undefined)((ushort) * (undefined2 *)(iVar3 + 0x12) >> 8);
      g_zbInfo.nwkNib.parentInfo = bVar4;
      memcpy(g_zbInfo.nwkNib.extPANId, in_r0, 8);
      g_zbInfo.nwkNib.capabilityInfo = *(capability_info_t *)(in_r0 + 0xe);
      g_zbInfo.macPib.rxOnWhenIdle = (u8)(((uint)(byte)in_r0[0xe] << 0x1c) >> 0x1f);
      memset(in_r0, 0, 0x19);
      *in_r0 = *(undefined *)(iVar3 + 0x15);
      uVar2 = *(undefined2 *)(iVar3 + 0x12);
      in_r0[2] = (char)uVar2;
      in_r0[3] = (char)((ushort)uVar2 >> 8);
      *(capability_info_t *)(in_r0 + 0xd) = g_zbInfo.nwkNib.capabilityInfo;
      cVar1 = *(char *)(iVar3 + 0x14);
      in_r0[0xc] = cVar1;
      if (cVar1 == '\x02')
      {
        uVar2 = *(undefined2 *)(iVar3 + 0x10);
        in_r0[4] = (char)uVar2;
        in_r0[5] = (char)((ushort)uVar2 >> 8);
      }
      else if (cVar1 == '\x03')
      {
        memcpy(in_r0 + 4, (void *)(iVar3 + 8), 8);
      }
      tl_zbPrimitivePost('\x02', 'E', in_r0);
    }
  }
  else
  {
    nwk_nlmeJoinCnf();
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_rejoinReq(void)

{
  uint uVar1;
  u8 uVar2;
  bool bVar3;
  int iVar4;
  int iVar5;
  undefined local_58[8];
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  u8 *puStack_3c;
  undefined4 local_38;
  uint uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  undefined local_1e;

  local_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  local_20 = 0;
  local_1e = 0;
  local_58._0_4_ = 0;
  local_58._4_4_ = 0;
  uStack_50 = 0;
  uStack_4c = 0;
  uStack_48 = 0;
  uStack_44 = 0;
  uStack_40 = 0;
  puStack_3c = (u8 *)0x0;
  iVar4 = tl_zbNwkParentChoose();
  if (iVar4 == 0)
  {
    nwk_nlmeJoinCnf();
  }
  else
  {
    g_zbNwkCtx.join._0_1_ = (undefined)iVar4;
    g_zbNwkCtx.join._1_1_ = (undefined)((uint)iVar4 >> 8);
    g_zbNwkCtx.join._2_1_ = (undefined)((uint)iVar4 >> 0x10);
    g_zbNwkCtx.join._3_1_ = (undefined)((uint)iVar4 >> 0x18);
    tl_zbMacChannelSet(*(u8 *)(iVar4 + 0x15));
    g_zbInfo.macPib.panId._0_1_ = *(undefined *)(iVar4 + 0x12);
    g_zbInfo.macPib.panId._1_1_ = *(undefined *)(iVar4 + 0x13);
    iVar5 = 0;
    g_zbInfo.nwkNib.panId._0_1_ = (undefined)g_zbInfo.macPib.panId;
    g_zbInfo.nwkNib.panId._1_1_ = g_zbInfo.macPib.panId._1_1_;
    if ((((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0)) &&
        (bVar3 = ss_keyPreconfigured(), bVar3 != false))
    {
      iVar5 = ~(aps_ib._18_1_ & 1) + (aps_ib._18_1_ & 1) + 1;
    }
    local_38 = CONCAT31(local_38._1_3_, 6);
    uVar1 = (uint)(byte)g_zbInfo.nwkNib.capabilityInfo;
    if (g_zbInfo.nwkNib.addrAlloc == '\x02')
    {
      uVar1 = uVar1 & 0xffffff7f;
    }
    uStack_34 = uStack_34 & 0xffffff00 | uVar1;
    local_58._4_4_ = (uint)((ushort)local_58._4_4_ & 0xfe00);
    local_58._0_4_ = CONCAT22(g_zbInfo.nwkNib.nwkAddr, *(undefined2 *)(iVar4 + 0x10));
    local_58._4_4_ =
        CONCAT13(g_zbInfo.nwkNib.seqNum,
                 CONCAT12(1, (((local_58[5] & 0xfd | (byte)(iVar5 << 1)) & 0xfb | 0x10) & 0xf7) << 8 | 9));
    g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
    memcpy(&uStack_48, g_zbInfo.macPib.extAddress, 8);
    uVar2 = getNwkHdrSize((nwk_hdr_t *)local_58);
    uStack_40._0_2_ = CONCAT11(uVar2, uStack_40._0_1_);
    uStack_40 = uStack_40 & 0xffff0000 | (uint)(ushort)uStack_40;
    tl_zbNwkSendRejoinReqCmd();
  }
  return;
}

void tl_zbMacMlmeAssociateConfirmHandler(void *arg)

{
  ushort shortAddr;
  anon_union_4_2_bfd4ae01_for_join aVar1;
  zb_nwk_status_t zVar2;
  zb_nwk_status_t zVar3;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  nebTbl_t *in_stack_ffffffb4;
  nebTbl_t *in_stack_ffffffb8;

  aVar1.pAssocJoinParent = g_zbNwkCtx.join.pAssocJoinParent;
  if (*(char *)((int)arg + 10) == '\0')
  {
    g_zbInfo.nwkNib.updateId = (g_zbNwkCtx.join.pAssocJoinParent)->nwkUpdateId;
    g_zbInfo.nwkNib.depth =
        (byte)(((uint)(byte)(g_zbNwkCtx.join.pAssocJoinParent)->field_0x16 << 0x1c) >> 0x1c) +
        (((byte)(g_zbNwkCtx.join.pAssocJoinParent)->field_0x16 & 0xf) <
         (uint)g_zbInfo.nwkNib.maxDepth);
    g_zbInfo.nwkNib.panId._0_1_ = (undefined)(g_zbNwkCtx.join.pAssocJoinParent)->panId;
    g_zbInfo.nwkNib.panId._1_1_ = (undefined)((g_zbNwkCtx.join.pAssocJoinParent)->panId >> 8);
    memcpy(g_zbInfo.nwkNib.extPANId, g_zbNwkCtx.join.pAssocJoinParent, 8);
    shortAddr = *(ushort *)((int)arg + 8);
    g_zbInfo.macPib.shortAddress._0_1_ = (undefined)shortAddr;
    g_zbInfo.macPib.shortAddress._1_1_ = (undefined)((uint)shortAddr >> 8);
    g_zbInfo.nwkNib.nwkAddr._0_1_ = (undefined)g_zbInfo.macPib.shortAddress;
    g_zbInfo.nwkNib.nwkAddr._1_1_ = g_zbInfo.macPib.shortAddress._1_1_;
    memcpy(g_zbInfo.nwkNib.ieeeAddr, g_zbInfo.macPib.extAddress, 8);
    g_zbInfo.macPib.coordShortAddress = (aVar1.pAssocJoinParent)->shortAddr;
    memcpy(g_zbInfo.macPib.coordExtAddress, arg, 8);
    zVar2 = tl_zbNwkAddrMapAdd(shortAddr, (addrExt_t)CONCAT44(in_stack_ffffffb8, in_stack_ffffffb4),
                               (u16 *)g_zbInfo.macPib.extAddress);
    zVar3 = tl_zbNwkAddrMapAdd(g_zbInfo.macPib.coordShortAddress,
                               (addrExt_t)CONCAT44(in_stack_ffffffb8, in_stack_ffffffb4),
                               (u16 *)g_zbInfo.macPib.coordExtAddress);
    if (((zVar2 | zVar3) == 0) &&
        (ptVar4 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)&stack0xffffffb4, '\x01'),
         ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0))
    {
      g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf0 | 1;
      nwk_nlmeJoinCnf();
    }
    else
    {
      nwk_nlmeJoinCnf();
    }
  }
  else
  {
    memset(arg, 0, 0x10);
    *(capability_info_t *)((int)arg + 0xe) = g_zbInfo.nwkNib.capabilityInfo;
    memcpy(arg, g_zbInfo.nwkNib.extPANId, 8);
    nwk_associateJoin();
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

void tl_zbMacMlmeAssociateIndicationHandler(void *arg)

{
  int iVar1;
  undefined auStack_28[10];
  undefined2 local_1e;

  memcpy(auStack_28, arg, 8);
  local_1e = 0xfffe;
  iVar1 = tl_zbNwkJoinAccept_clone_0();
  if (iVar1 == 0x20)
  {
    zb_buf_free((zb_buf_t *)arg);
  }
  else
  {
    if (iVar1 == 0)
    {
      g_sysDiags.joinIndication = g_sysDiags.joinIndication + 1;
    }
    *(char *)((int)arg + 10) = (char)iVar1;
    *(undefined *)arg = (undefined)local_1e;
    *(undefined *)((int)arg + 1) = local_1e._1_1_;
    memcpy((void *)((int)arg + 2), auStack_28, 8);
    tl_zbPrimitivePost('\x02', 'H', arg);
  }
  return;
}

void tl_zbMacMlmeCommStatusIndicationHandler(void *arg)

{
  char cVar1;
  byte bVar2;
  byte bVar3;
  u16 uVar4;
  tl_zb_normal_neighbor_entry_t *ptVar5;
  undefined in_stack_ffffffe0;
  undefined7 in_stack_ffffffe1;
  u16 auStack_16[3];

  cVar1 = *(char *)((int)arg + 0x15);
  if (*(char *)((int)arg + 0x13) == '\x03')
  {
    ptVar5 = tl_zbNeighborTableSearchFromExtAddr(auStack_16, (addrExt_t)CONCAT71(in_stack_ffffffe1, in_stack_ffffffe0),
                                                 (u16 *)((int)arg + 0xb));
  }
  else
  {
    ptVar5 = tl_zbNeighborTableSearchFromShortAddr(*(u16 *)((int)arg + 0xb),
                                                   (addrExt_t)CONCAT71(in_stack_ffffffe1, in_stack_ffffffe0),
                                                   (u16 *)&stack0xffffffe0);
  }
  if ((ptVar5 == (tl_zb_normal_neighbor_entry_t *)0x0) ||
      ((*(char *)((int)arg + 0x14) != ' ' && (*(char *)((int)arg + 0x14) != '\0'))))
  {
    zb_buf_free((zb_buf_t *)arg);
  }
  else
  {
    tl_zbNwkBeaconPayloadUpdate();
    tl_zbExtAddrByIdx(ptVar5->addrmapIdx, (addrExt_t)CONCAT71(in_stack_ffffffe1, in_stack_ffffffe0));
    uVar4 = tl_zbshortAddrByIdx(ptVar5->addrmapIdx);
    *(char *)((int)arg + 8) = (char)uVar4;
    *(char *)((int)arg + 9) = (char)((uint)uVar4 >> 8);
    bVar2 = ptVar5->field_0x1e & 0xe;
    bVar3 = bVar2 - 2;
    *(byte *)((int)arg + 10) =
        *(byte *)((int)arg + 10) & 0xfd | (bVar3 + ~bVar3 + (1 < bVar2)) * '\x02';
    *(byte *)((int)arg + 10) =
        *(byte *)((int)arg + 10) & 0xf7 | (byte)(((byte)ptVar5->field_0x1e & 1) << 3);
    if (cVar1 == '\0')
    {
      *(undefined *)((int)arg + 0xb) = 1;
      *(undefined *)((int)arg + 0xc) = 1;
    }
    else
    {
      *(undefined *)((int)arg + 0xb) = 0;
      *(undefined *)((int)arg + 0xc) = 0;
    }
    tl_zbTaskPost(zdo_nlme_join_indication, arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_rejoinScanCnfHandler(void)

{
  zb_buf_t *in_r0;
  u32 uVar1;
  uint uVar2;

  if (in_r0->buf[1] == '\x01')
  {
    if (in_r0->buf[0] == '\0')
    {
      uVar2 = (uint)g_zbInfo.nwkNib.nwkAddr;
      while ((uVar2 == 0 || ((uVar2 & 0xfff8) == 0xfff8)))
      {
        uVar1 = drv_u32Rand();
        g_zbInfo.macPib.shortAddress._0_1_ = (undefined)uVar1;
        g_zbInfo.macPib.shortAddress._1_1_ = (undefined)(uVar1 >> 8);
        g_zbInfo.nwkNib.nwkAddr = (u16)uVar1;
        uVar2 = uVar1 & 0xffff;
      }
      memcpy(g_zbInfo.nwkNib.ieeeAddr, g_zbInfo.macPib.extAddress, 8);
      nwk_rejoinReq();
    }
    else
    {
      nwk_nlmeJoinCnf();
    }
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_rejoinCmdSendCnf(void)

{
  zb_buf_t *in_r0;
  u32 t_ms;

  if ((g_zbNwkCtx._47_1_ & 0xf0) == 0x40)
  {
    if ((in_r0->buf[9] != ' ') && (in_r0->buf[9] != '\0'))
    {
      nwk_rejoinReq();
      return;
    }
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf0 | 1;
    if (rejoinRespTimeoutEvt == (ev_timer_event_t *)0x0)
    {
      t_ms = FUN_00001624((uint)g_zbInfo.macPib.respWaitTime * 0x1400, 1000);
      rejoinRespTimeoutEvt = ev_timer_taskPost(tl_zbNlmeRejoinRespTimeoutCb, (void *)0x0, t_ms);
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint tl_zbNwkRejoinRespCmdHandler(void)

{
  ushort shortAddr;
  anon_union_4_2_bfd4ae01_for_join in;
  byte bVar1;
  zb_nwk_status_t zVar2;
  zb_nwk_status_t zVar3;
  u16 uVar4;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar5;
  int iVar6;
  int in_r1;
  int in_r2;
  uint uVar7;
  nebTbl_t *in_stack_ffffffac;
  nebTbl_t *in_stack_ffffffb0;
  undefined auStack_30[10];
  undefined2 local_26;

  ptVar5 = tl_zbNeighborTableSearchForParent();
  in = g_zbNwkCtx.join;
  if ((g_zbNwkCtx._47_1_ & 0xf0) == 0x40)
  {
    if (((g_zbNwkCtx.join.pAssocJoinParent == (tl_zb_addition_neighbor_entry_t *)0x0) ||
         (rejoinRespTimeoutEvt + ~rejoinRespTimeoutEvt != 0)) ||
        ((g_zbNwkCtx.join.pAssocJoinParent)->shortAddr != *(u16 *)(in_r1 + 2)))
    {
      bVar1 = zb_buf_free(in_r0);
      uVar7 = (uint)bVar1;
    }
    else
    {
      rejoinRespPollCnt = 0;
      ev_timer_taskCancel((ev_timer_event_t **)&rejoinRespTimeoutEvt);
      if ((*(char *)(in_r2 + 6) == '\0') && ((*(ushort *)(in_r2 + 4) & 0xfff8) != 0xfff8))
      {
        memcpy(g_zbInfo.nwkNib.extPANId, in.pAssocJoinParent, 8);
        g_zbInfo.nwkNib.updateId = (in.pAssocJoinParent)->nwkUpdateId;
        g_zbInfo.nwkNib.depth =
            (byte)(((uint)(byte)(in.pAssocJoinParent)->field_0x16 << 0x1c) >> 0x1c) +
            (((byte)(in.pAssocJoinParent)->field_0x16 & 0xf) < (uint)g_zbInfo.nwkNib.maxDepth);
        g_zbInfo.macPib.shortAddress = *(u16 *)(in_r2 + 4);
        g_zbInfo.nwkNib.nwkAddr._0_1_ = (undefined)g_zbInfo.macPib.shortAddress;
        g_zbInfo.nwkNib.nwkAddr._1_1_ = (byte)(g_zbInfo.macPib.shortAddress >> 8);
        memcpy(g_zbInfo.nwkNib.ieeeAddr, g_zbInfo.macPib.extAddress, 8);
        g_zbInfo.macPib.coordShortAddress = *(u16 *)(in_r1 + 2);
        if ((int)((uint) * (byte *)(in_r1 + 5) << 0x1b) < 0)
        {
          memcpy(g_zbInfo.macPib.coordExtAddress, (void *)(in_r1 + 0x10), 8);
        }
        if (ptVar5 != (tl_zb_normal_neighbor_entry_t *)0x0)
        {
          tl_zbExtAddrByIdx(ptVar5->addrmapIdx,
                            (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac));
          uVar4 = tl_zbshortAddrByIdx(ptVar5->addrmapIdx);
          iVar6 = memcmp(auStack_30, (void *)(in_r1 + 0x10), 8);
          if ((iVar6 != 0) || (*(u16 *)(in_r1 + 2) != uVar4))
          {
            tl_zbNeighborTableDelete(ptVar5);
            g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ | 0x7f;
          }
        }
        local_26 = 0;
        zVar2 = tl_zbNwkAddrMapAdd(g_zbInfo.macPib.shortAddress,
                                   (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac),
                                   (u16 *)g_zbInfo.macPib.extAddress);
        zVar3 = tl_zbNwkAddrMapAdd(g_zbInfo.macPib.coordShortAddress,
                                   (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac),
                                   (u16 *)g_zbInfo.macPib.coordExtAddress);
        if (((zVar2 | zVar3) == 0) &&
            (ptVar5 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)&stack0xffffffac, '\x01'),
             ptVar5 != (tl_zb_normal_neighbor_entry_t *)0x0))
        {
          uVar7 = nwk_nlmeJoinCnf();
        }
        else
        {
          uVar7 = nwk_nlmeJoinCnf();
        }
      }
      else
      {
        bVar1 = tl_zbTaskPost(nwk_rejoinReq, in_r0);
        uVar7 = (uint)bVar1;
      }
    }
  }
  else
  {
    bVar1 = zb_buf_free(in_r0);
    uVar7 = (uint)bVar1;
    if (ptVar5 != (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      uVar4 = tl_zbshortAddrByIdx(ptVar5->addrmapIdx);
      uVar7 = (uint)uVar4;
      if (uVar7 != *(ushort *)(in_r1 + 2))
      {
        return uVar7;
      }
    }
    if (*(char *)(in_r2 + 6) == '\0')
    {
      shortAddr = *(ushort *)(in_r2 + 4);
      uVar7 = (uint)shortAddr;
      if ((uVar7 & 0xfff8) != 0xfff8)
      {
        g_zbInfo.nwkNib.nwkAddr._0_1_ = (undefined)shortAddr;
        g_zbInfo.nwkNib.nwkAddr._1_1_ = (byte)(uVar7 >> 8);
        g_zbInfo.macPib.shortAddress = shortAddr & 0xff | (ushort)g_zbInfo.nwkNib.nwkAddr._1_1_ << 8;
        local_26 = 0;
        tl_zbNwkAddrMapAdd(shortAddr, (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac),
                           (u16 *)g_zbInfo.macPib.extAddress);
        zb_info_save((void *)0x0);
        uVar7 = zdo_device_announce_send();
      }
    }
  }
  return uVar7;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

uint tl_zbNwkRejoinReqCmdHandler(void)

{
  u8 uVar1;
  byte bVar2;
  zb_buf_t *in_r0;
  int iVar3;
  int in_r1;
  uint uVar4;
  undefined local_6c[8];
  undefined4 local_64;
  undefined4 uStack_60;
  undefined4 uStack_5c;
  undefined4 uStack_58;
  uint uStack_54;
  u8 *puStack_50;
  undefined4 local_4c;
  uint uStack_48;
  undefined4 uStack_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined2 local_34;
  undefined local_32;
  undefined4 local_30;
  undefined4 uStack_2c;
  undefined2 local_26;

  if ((int)((uint) * (byte *)(in_r1 + 5) << 0x1b) < 0)
  {
    local_26 = *(undefined2 *)(in_r1 + 2);
    memcpy(&local_30, (void *)(in_r1 + 0x10), 8);
    iVar3 = tl_zbNwkJoinAccept_clone_0();
    if (iVar3 != 0x20)
    {
      if (iVar3 == 0)
      {
        g_sysDiags.joinIndication = g_sysDiags.joinIndication + 1;
      }
      uVar4 = (uint) * (byte *)(in_r1 + 5) << 0x1e;
      in_r0->buf[0x28] = (byte)(uVar4 >> 0x1f);
      local_4c = 0;
      uStack_48 = 0;
      uStack_44 = 0;
      uStack_40 = 0;
      uStack_3c = 0;
      uStack_38 = 0;
      local_34 = 0;
      local_32 = 0;
      local_6c._0_4_ = 0;
      local_64 = 0;
      uStack_60 = 0;
      uStack_5c = 0;
      uStack_58 = 0;
      uStack_54 = 0;
      puStack_50 = (u8 *)0x0;
      local_6c._4_4_ = (uVar4 >> 0x1f) << 9;
      local_6c[5] = (byte)(local_6c._4_4_ >> 8) | 0x10;
      local_6c._4_4_ = CONCAT11(local_6c[5], 9) | 0x800;
      memcpy(&uStack_5c, g_zbInfo.macPib.extAddress, 8);
      local_64 = uStack_2c;
      uStack_60 = local_30;
      local_6c._0_4_ = CONCAT22(g_zbInfo.macPib.shortAddress, *(undefined2 *)(in_r1 + 2));
      local_6c._4_4_ = CONCAT13(g_zbInfo.nwkNib.seqNum, CONCAT12(1, local_6c._4_2_));
      g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
      uVar1 = getNwkHdrSize((nwk_hdr_t *)local_6c);
      uStack_54._0_2_ = CONCAT11(uVar1, uStack_54._0_1_);
      uStack_54 = uStack_54 & 0xffff0000 | (uint)(ushort)uStack_54;
      local_4c = CONCAT31(local_4c._1_3_, 7);
      uStack_48._0_3_ = CONCAT12((char)iVar3, local_26);
      uStack_48 = uStack_48 & 0xff000000 | (uint)(uint3)uStack_48;
      uVar4 = tl_zbNwkSendRejoinRespCmd();
      return uVar4;
    }
  }
  bVar2 = zb_buf_free(in_r0);
  return (uint)bVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbMcpsRejoinRespCnfHandler(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  char in_r1;
  byte bVar3;
  byte bVar4;
  undefined4 in_r2;
  undefined in_stack_ffffffd4;
  undefined7 in_stack_ffffffd5;

  if ((in_r1 == '\0') &&
      (ptVar2 = tl_zbNeighborTableSearchFromShortAddr((u16)in_r2, (addrExt_t)CONCAT71(in_stack_ffffffd5, in_stack_ffffffd4),
                                                      (u16 *)&stack0xffffffd4),
       ptVar2 != (tl_zb_normal_neighbor_entry_t *)0x0))
  {
    tl_zbNwkBeaconPayloadUpdate();
    uVar1 = in_r0->buf[0x28];
    bVar3 = ptVar2->field_0x1e & 0xe;
    bVar4 = bVar3 - 2;
    in_r0->buf[10] = in_r0->buf[10] & 0xfd | (bVar4 + ~bVar4 + (1 < bVar3)) * '\x02';
    in_r0->buf[10] = in_r0->buf[10] & 0xf7 | (byte)(((byte)ptVar2->field_0x1e & 1) << 3);
    in_r0->buf[8] = (u8)in_r2;
    in_r0->buf[9] = (u8)((uint)in_r2 >> 8);
    memcpy(in_r0, &stack0xffffffd4, 8);
    in_r0->buf[0xb] = '\x02';
    in_r0->buf[0xc] = uVar1;
    tl_zbTaskPost(zdo_nlme_join_indication, in_r0);
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_directJoinScanCnfHandler(void)

{
  zb_nwk_status_t zVar1;
  u16 uVar2;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  int iVar4;
  nebTbl_t *in_stack_ffffffb8;
  nebTbl_t *in_stack_ffffffbc;
  undefined auStack_24[10];
  undefined2 local_1a;

  if (in_r0->buf[1] == '\x03')
  {
    if (in_r0->buf[0] == '\0')
    {
      ptVar3 = tl_zbNeighborTableSearchForParent();
      if (ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0)
      {
        tl_zbExtAddrByIdx(ptVar3->addrmapIdx,
                          (addrExt_t)CONCAT44(in_stack_ffffffbc, in_stack_ffffffb8));
        uVar2 = tl_zbshortAddrByIdx(ptVar3->addrmapIdx);
        iVar4 = memcmp(auStack_24, g_zbInfo.macPib.coordExtAddress, 8);
        if ((iVar4 != 0) || (g_zbInfo.macPib.coordShortAddress != uVar2))
        {
          tl_zbNeighborTableDelete(ptVar3);
          g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ | 0x7f;
        }
      }
      local_1a = 0;
      zVar1 = tl_zbNwkAddrMapAdd(g_zbInfo.macPib.coordShortAddress,
                                 (addrExt_t)CONCAT44(in_stack_ffffffbc, in_stack_ffffffb8),
                                 (u16 *)g_zbInfo.macPib.coordExtAddress);
      if ((zVar1 == NWK_STATUS_SUCCESS) &&
          (ptVar3 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)&stack0xffffffb8, '\x01'),
           ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0))
      {
        nwk_nlmeJoinCnf();
        return;
      }
      nwk_nlmeJoinCnf();
    }
    else
    {
      nwk_nlmeJoinCnf();
    }
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

void tl_zbMacMlmeOrphanIndicationHandler(void *arg)

{
  tl_zb_normal_neighbor_entry_t *ptVar1;
  undefined in_stack_ffffffe4;
  undefined7 in_stack_ffffffe5;
  undefined local_12;
  undefined uStack_11;

  memcpy(&stack0xffffffe4, arg, 8);
  ptVar1 = tl_zbNeighborTableSearchFromExtAddr((u16 *)&local_12, (addrExt_t)CONCAT71(in_stack_ffffffe5, in_stack_ffffffe4),
                                               (u16 *)&stack0xffffffe4);
  if ((ptVar1 == (tl_zb_normal_neighbor_entry_t *)0x0) || ((ptVar1->field_0x1e & 0x70) != 0x10))
  {
    zb_buf_free((zb_buf_t *)arg);
  }
  else
  {
    *(undefined *)((int)arg + 8) = local_12;
    *(undefined *)((int)arg + 9) = uStack_11;
    memcpy(arg, &stack0xffffffe4, 8);
    *(undefined *)((int)arg + 10) = 1;
    tl_zbPrimitivePost('\x02', 'P', arg);
  }
  return;
}

void tl_zbNwkNlmeJoinRequestHandler(void *arg)

{
  char cVar1;
  byte bVar2;
  undefined4 uVar3;
  undefined uVar4;
  undefined uVar5;
  undefined uVar6;
  undefined uVar7;
  undefined uVar8;

  cVar1 = *(char *)((int)arg + 0xc);
  if (cVar1 == '\x01')
  {
    if ((g_zbNwkCtx._47_1_ & 0xf0) != 0)
      goto LAB_00019b28;
    g_zbInfo.nwkNib.parentInfo = g_zbNwkCtx._47_1_ & 0xf0;
    memcpy(g_zbInfo.nwkNib.extPANId, arg, 8);
    g_zbInfo.nwkNib.capabilityInfo = *(capability_info_t *)((int)arg + 0xe);
    bVar2 = (byte)(((uint) * (byte *)((int)arg + 0xe) << 0x1c) >> 0x18);
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf | 0x50;
    uVar3 = *(undefined4 *)((int)arg + 8);
    uVar7 = (undefined)uVar3;
    uVar4 = (undefined)((uint)uVar3 >> 8);
    uVar5 = (undefined)((uint)uVar3 >> 0x10);
    uVar6 = (undefined)((uint)uVar3 >> 0x18);
    g_zbNwkCtx.scanDuration = *(u8 *)((int)arg + 0xd);
    uVar8 = 3;
  }
  else
  {
    if (cVar1 == '\0')
    {
      nwk_associateJoin();
      return;
    }
    if (cVar1 != '\x02')
    {
      zb_buf_free((zb_buf_t *)arg);
      return;
    }
    if ((g_zbNwkCtx._47_1_ & 0xf0) != 0)
    {
    LAB_00019b28:
      nwk_nlmeJoinCnf();
      return;
    }
    g_zbInfo.nwkNib.parentInfo = g_zbNwkCtx._47_1_ & 0xf0;
    memcpy(g_zbInfo.nwkNib.extPANId, arg, 8);
    g_zbInfo.nwkNib.capabilityInfo = *(capability_info_t *)((int)arg + 0xe);
    bVar2 = (byte)(((uint) * (byte *)((int)arg + 0xe) << 0x1c) >> 0x18);
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf | 0x40;
    uVar3 = *(undefined4 *)((int)arg + 8);
    uVar7 = (undefined)uVar3;
    uVar4 = (undefined)((uint)uVar3 >> 8);
    uVar5 = (undefined)((uint)uVar3 >> 0x10);
    uVar6 = (undefined)((uint)uVar3 >> 0x18);
    g_zbNwkCtx.scanDuration = *(u8 *)((int)arg + 0xd);
    uVar8 = 1;
  }
  g_zbInfo.macPib.rxOnWhenIdle = bVar2 >> 7;
  g_zbNwkCtx.scanChannels._0_1_ = uVar7;
  g_zbNwkCtx.scanChannels._1_1_ = uVar4;
  g_zbNwkCtx.scanChannels._2_1_ = uVar5;
  g_zbNwkCtx.scanChannels._3_1_ = uVar6;
  *(undefined *)((int)arg + 4) = uVar8;
  *(undefined *)arg = uVar7;
  *(undefined *)((int)arg + 1) = uVar4;
  *(undefined *)((int)arg + 2) = uVar5;
  *(undefined *)((int)arg + 3) = uVar6;
  *(u8 *)((int)arg + 5) = g_zbNwkCtx.scanDuration;
  tl_zbPrimitivePost('\x02', 'U', arg);
  return;
}

void tl_zbNwkNlmeDirectJoinRequestHandler(void *arg)

{
  zb_nwk_status_t zVar1;
  int iVar2;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  undefined uVar4;
  nebTbl_t *in_stack_ffffffc0;
  nebTbl_t *in_stack_ffffffc4;
  undefined auStack_1c[10];
  undefined2 local_12;

  memcpy(auStack_1c, arg, 8);
  iVar2 = memcmp(arg, g_zbInfo.macPib.extAddress, 8);
  uVar4 = 0xc1;
  if (iVar2 != 0)
  {
    local_12 = 0;
    zVar1 = tl_zbNwkAddrMapAdd(*(u16 *)((int)arg + 8),
                               (addrExt_t)CONCAT44(in_stack_ffffffc4, in_stack_ffffffc0), (u16 *)arg);
    uVar4 = 199;
    if (zVar1 == NWK_STATUS_SUCCESS)
    {
      ptVar3 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT44(in_stack_ffffffc4, in_stack_ffffffc0));
      uVar4 = 0xc5;
      if (ptVar3 == (tl_zb_normal_neighbor_entry_t *)0x0)
      {
        ptVar3 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)&stack0xffffffc0, '\x01');
        if (ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0)
        {
          *(undefined *)arg = 0;
          *(undefined *)((int)arg + 1) = 0;
          *(undefined *)((int)arg + 2) = 0;
          *(undefined *)((int)arg + 3) = 0;
          *(undefined *)((int)arg + 4) = 0;
          *(undefined *)((int)arg + 5) = 0;
          *(undefined *)((int)arg + 6) = 0;
          *(undefined *)((int)arg + 7) = 0;
          *(undefined *)((int)arg + 8) = 0;
          *(undefined *)((int)arg + 8) = 0;
          memcpy(arg, auStack_1c, 8);
          goto LAB_00019c82;
        }
        uVar4 = 199;
      }
    }
  }
  *(undefined *)arg = 0;
  *(undefined *)((int)arg + 1) = 0;
  *(undefined *)((int)arg + 2) = 0;
  *(undefined *)((int)arg + 3) = 0;
  *(undefined *)((int)arg + 4) = 0;
  *(undefined *)((int)arg + 5) = 0;
  *(undefined *)((int)arg + 6) = 0;
  *(undefined *)((int)arg + 7) = 0;
  *(undefined *)((int)arg + 8) = 0;
  *(undefined *)((int)arg + 8) = uVar4;
LAB_00019c82:
  tl_zbTaskPost(zdo_nlme_direct_join_confirm, arg);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_nlmeLeaveCnf(void)

{
  void *in_r0;
  undefined in_r1;
  void *in_r2;

  *(undefined *)((int)in_r0 + 8) = in_r1;
  memcpy(in_r0, in_r2, 8);
  tl_zbTaskPost(zdo_nlme_leave_confirm_cb, in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkSendLeaveReqCmd(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, '\x02');
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[4];
  (in_r0->hdr).handle = in_r3;
  if (in_r3 == 199)
  {
    nwk_tx();
  }
  else
  {
    nwk_fwdPacket();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkLeaveReqSend(void)

{
  u16 uVar1;
  u8 uVar2;
  bool bVar3;
  uint uVar4;
  nwk_hdr_t *in_r1;

  uVar4 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar3 = ss_keyPreconfigured();
    uVar4 = (uint)(bVar3 != false);
  }
  *(byte *)&in_r1->framecontrol = *(byte *)&in_r1->framecontrol & 0xfc | 1;
  *(byte *)&in_r1->framecontrol = *(byte *)&in_r1->framecontrol & 0xc3 | 8;
  (in_r1->framecontrol).field_0x1 = (in_r1->framecontrol).field_0x1 & 0xfd | (byte)(uVar4 << 1);
  (in_r1->framecontrol).field_0x1 = (in_r1->framecontrol).field_0x1 | 0x10;
  memcpy(in_r1->srcIeeeAddr, g_zbInfo.macPib.extAddress, 8);
  uVar1 = g_zbInfo.nwkNib.nwkAddr;
  *(char *)&in_r1->srcAddr = (char)g_zbInfo.nwkNib.nwkAddr;
  *(char *)((int)&in_r1->srcAddr + 1) = (char)(uVar1 >> 8);
  in_r1->radius = '\x01';
  in_r1->seqNum = g_zbInfo.nwkNib.seqNum;
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar2 = getNwkHdrSize(in_r1);
  in_r1->frameHdrLen = uVar2;
  tl_zbNwkSendLeaveReqCmd();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkLeaveReqStart(void)

{
  ushort in_r1;

  if ((in_r1 & 0xfff8) != 0xfff8)
  {
    zb_address_ieee_by_short(in_r1, (addrExt_t)(ulonglong)in_r1);
  }
  nwkLeaveReqSend();
  return;
}

void tl_zbNwkNlmeLeaveRequestHandler(void *arg)

{
  int iVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  undefined in_stack_ffffffec;
  undefined7 in_stack_ffffffed;

  memcpy(&stack0xffffffec, arg, 8);
  iVar1 = memcmp(arg, &g_zero_addr, 8);
  if ((iVar1 == 0) || (iVar1 = memcmp(arg, g_zbInfo.macPib.extAddress, 8), iVar1 == 0))
  {
    *(byte *)((int)arg + 0xc3) =
        *(byte *)((int)arg + 0xc3) & 0xfb | ('\x01' - (*(char *)((int)arg + 9) == '\0')) * '\x04';
    nwkLeaveReqStart();
  }
  else if ((int)((uint)g_zbNwkCtx._45_1_ << 0x1d) < 0)
  {
    ptVar2 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT71(in_stack_ffffffed, in_stack_ffffffec));
    if (ptVar2 == (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      nwk_nlmeLeaveCnf();
    }
    else if ((ptVar2->field_0x1e & 0x70) == 0x50)
    {
      nwk_nlmeLeaveCnf();
    }
    else
    {
      tl_zbshortAddrByIdx(ptVar2->addrmapIdx);
      nwkLeaveReqStart();
    }
  }
  else
  {
    nwk_nlmeLeaveCnf();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_leaveCmdSendCnf(void)

{
  u8 uVar1;
  ushort in_r1;
  undefined4 in_stack_ffffffe8;
  undefined4 in_stack_ffffffec;

  if (((in_r1 & 0xfff8) != 0xfff8) &&
      (uVar1 = zb_address_ieee_by_short(in_r1, (addrExt_t)CONCAT44(in_stack_ffffffec, in_stack_ffffffe8)),
       uVar1 != '\0'))
  {
    memcpy(&stack0xffffffe8, &g_invalid_addr, 8);
  }
  nwk_nlmeLeaveCnf();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkLeaveReqCmdHandler(void)

{
  byte bVar1;
  u8 uVar2;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  byte bVar4;
  ushort *in_r1;
  int in_r2;
  undefined in_stack_ffffffdc;
  undefined7 in_stack_ffffffdd;

  if ((((int)((uint)g_zbNwkCtx._45_1_ << 0x1d) < 0) &&
       (1 < (int)((uint)in_r0->buf[0x1d] - (uint) * (byte *)((int)in_r1 + 0x19)))) &&
      (uVar2 = tl_zbExtAddrByShortAddr(in_r1[1], (addrExt_t)CONCAT71(in_stack_ffffffdd, in_stack_ffffffdc),
                                       (u16 *)&stack0xffffffdc),
       uVar2 != 0xff))
  {
    ptVar3 = nwk_neTblGetByShortAddr(in_r1[1]);
    bVar1 = *(byte *)(in_r2 + 4);
    bVar4 = (byte)(((uint)bVar1 << 0x1a) >> 0x1f);
    if ((((char)bVar1 < '\0') && (ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0)) &&
        ((ptVar3->field_0x1e & 0x70) == 0))
    {
      in_r0->buf[0] = '\0';
      in_r0->buf[1] = '\0';
      in_r0->buf[2] = '\0';
      in_r0->buf[3] = '\0';
      in_r0->buf[4] = '\0';
      in_r0->buf[5] = '\0';
      in_r0->buf[6] = '\0';
      in_r0->buf[7] = '\0';
      in_r0->buf[9] = bVar4;
      in_r0->buf[8] = '\x01';
      tl_zbTaskPost(tl_zbNwkNlmeLeaveRequestHandler, in_r0);
      return;
    }
    if ((-1 < (int)((uint)bVar1 << 0x19)) || ((*in_r1 & 0xfff8) == 0xfff8))
    {
      in_r0->buf[8] = bVar4;
      memcpy(in_r0, &stack0xffffffdc, 8);
      tl_zbTaskPost(zdo_nlme_leave_indication_cb, in_r0);
      return;
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_nebListDelete(void)

{
  nebTbl_t *pnVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  char in_r0;
  tl_zb_normal_neighbor_entry_t *in_r1;
  tl_zb_normal_neighbor_entry_t *ptVar3;

  if (in_r0 == '\0')
  {
    ptVar2 = g_zb_neighborTbl.activeHead;
    if (in_r1 == g_zb_neighborTbl.activeHead)
    {
      g_zb_neighborTbl.activeHead = in_r1->activeNext;
    }
    else
    {
      do
      {
        ptVar3 = ptVar2;
        ptVar2 = ptVar3->activeNext;
        if (ptVar2 == (tl_zb_normal_neighbor_entry_t *)0x0)
        {
          return;
        }
      } while (in_r1 != ptVar2);
      pnVar1 = in_r1->activeNext;
      *(char *)&ptVar3->activeNext = (char)pnVar1;
      *(char *)((int)&ptVar3->activeNext + 1) = (char)((uint)pnVar1 >> 8);
      *(char *)((int)&ptVar3->activeNext + 2) = (char)((uint)pnVar1 >> 0x10);
      *(char *)((int)&ptVar3->activeNext + 3) = (char)((uint)pnVar1 >> 0x18);
    }
  }
  else
  {
    ptVar2 = g_zb_neighborTbl.freeHead;
    if (g_zb_neighborTbl.freeHead == in_r1)
    {
      g_zb_neighborTbl.freeHead = (g_zb_neighborTbl.freeHead)->freeNext;
    }
    else
    {
      do
      {
        ptVar3 = ptVar2;
        ptVar2 = ptVar3->freeNext;
        if (ptVar2 == (tl_zb_normal_neighbor_entry_t *)0x0)
        {
          return;
        }
      } while (in_r1 != ptVar2);
      pnVar1 = in_r1->freeNext;
      *(char *)&ptVar3->freeNext = (char)pnVar1;
      *(char *)((int)&ptVar3->freeNext + 1) = (char)((uint)pnVar1 >> 8);
      *(char *)((int)&ptVar3->freeNext + 2) = (char)((uint)pnVar1 >> 0x10);
      *(char *)((int)&ptVar3->freeNext + 3) = (char)((uint)pnVar1 >> 0x18);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNeighborTableRst(void)

{
  u32 len;
  uint uVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  int iVar4;
  u16 *puVar5;

  len = neighborTblSizeGet();
  memset(&g_zb_neighborTbl, 0, len);
  g_zb_neighborTbl.activeHead = (tl_zb_normal_neighbor_entry_t *)0x0;
  ptVar2 = g_zb_neighborTbl.neighborTbl;
  g_zb_neighborTbl.freeHead = g_zb_neighborTbl.neighborTbl;
  if (TL_ZB_NEIGHBOR_TABLE_SIZE != '\x01')
  {
    uVar1 = 0;
    ptVar3 = ptVar2;
    do
    {
      ptVar3->field_0x1e = ptVar3->field_0x1e & 0x8f | 0x30;
      ptVar3->field_0x1e = ptVar3->field_0x1e & 0x7f;
      *(undefined *)&ptVar3->activeNext = 0;
      *(undefined *)((int)&ptVar3->activeNext + 1) = 0;
      *(undefined *)((int)&ptVar3->activeNext + 2) = 0;
      *(undefined *)((int)&ptVar3->activeNext + 3) = 0;
      ptVar2 = ptVar3 + 1;
      *(char *)&ptVar3->freeNext = (char)ptVar2;
      *(char *)((int)&ptVar3->freeNext + 1) = (char)((uint)ptVar2 >> 8);
      *(char *)((int)&ptVar3->freeNext + 2) = (char)((uint)ptVar2 >> 0x10);
      *(char *)((int)&ptVar3->freeNext + 3) = (char)((uint)ptVar2 >> 0x18);
      uVar1 = uVar1 + 1;
      ptVar3 = ptVar2;
    } while (uVar1 < TL_ZB_NEIGHBOR_TABLE_SIZE - 1);
  }
  *(undefined *)&ptVar2->freeNext = 0;
  *(undefined *)((int)&ptVar2->freeNext + 1) = 0;
  *(undefined *)((int)&ptVar2->freeNext + 2) = 0;
  *(undefined *)((int)&ptVar2->freeNext + 3) = 0;
  ptVar2->field_0x1e = ptVar2->field_0x1e & 0x7f;
  *(undefined *)&ptVar2->activeNext = 0;
  *(undefined *)((int)&ptVar2->activeNext + 1) = 0;
  *(undefined *)((int)&ptVar2->activeNext + 2) = 0;
  *(undefined *)((int)&ptVar2->activeNext + 3) = 0;
  puVar5 = &g_zb_neighborTbl.additionNeighborTbl[0].shortAddr;
  iVar4 = 0;
  do
  {
    *puVar5 = 0xfffe;
    memset(g_zb_neighborTbl.additionNeighborTbl[iVar4].extAddr, 0xff, 8);
    iVar4 = iVar4 + 1;
    puVar5 = puVar5 + 0xe;
  } while (iVar4 != 6);
  return;
}

u8 tl_zbNeighborTableNumGet(void)

{
  byte bVar1;
  nebTbl_t *pnVar2;

  g_zb_neighborTbl.normalNeighborNum = '\0';
  if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar1 = (g_zb_neighborTbl.activeHead)->field_0x1e;
    pnVar2 = g_zb_neighborTbl.activeHead;
    while ((bVar1 & 0x80) != 0)
    {
      g_zb_neighborTbl.normalNeighborNum = g_zb_neighborTbl.normalNeighborNum + '\x01';
      pnVar2 = pnVar2->activeNext;
      if (pnVar2 == (nebTbl_t *)0x0)
      {
        return g_zb_neighborTbl.normalNeighborNum;
      }
      bVar1 = pnVar2->field_0x1e;
    }
  }
  return g_zb_neighborTbl.normalNeighborNum;
}

u8 tl_zbNeighborTableChildEDNumGet(void)

{
  byte bVar1;
  nebTbl_t *pnVar2;

  g_zb_neighborTbl.childrenNum = '\0';
  if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar1 = (g_zb_neighborTbl.activeHead)->field_0x1e;
    pnVar2 = g_zb_neighborTbl.activeHead;
    while ((bVar1 & 0x80) != 0)
    {
      if (((bVar1 & 0xe) == 4) && (((bVar1 & 0x70) == 0x50 || ((bVar1 & 0x70) == 0x10))))
      {
        g_zb_neighborTbl.childrenNum = g_zb_neighborTbl.childrenNum + '\x01';
      }
      pnVar2 = pnVar2->activeNext;
      if (pnVar2 == (nebTbl_t *)0x0)
      {
        return g_zb_neighborTbl.childrenNum;
      }
      bVar1 = pnVar2->field_0x1e;
    }
  }
  return g_zb_neighborTbl.childrenNum;
}

u8 tl_zbNeighborTableRouterValidNumGet(void)

{
  byte bVar1;
  nebTbl_t *pnVar2;
  u8 uVar3;

  uVar3 = '\0';
  if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar1 = (g_zb_neighborTbl.activeHead)->field_0x1e;
    pnVar2 = g_zb_neighborTbl.activeHead;
    while ((bVar1 & 0x80) != 0)
    {
      if ((((bVar1 & 0xe) == 0) || ((bVar1 & 0xe) == 2)) && (pnVar2->lqi != '\0'))
      {
        uVar3 = uVar3 + '\x01';
      }
      pnVar2 = pnVar2->activeNext;
      if (pnVar2 == (nebTbl_t *)0x0)
      {
        return uVar3;
      }
      bVar1 = pnVar2->field_0x1e;
    }
  }
  return uVar3;
}

// WARNING: Type propagation algorithm not settling

tl_zb_normal_neighbor_entry_t *tl_zbNeighborTableSearchForParent(void)

{
  byte bVar1;
  nebTbl_t *pnVar2;
  tl_zb_normal_neighbor_entry_t *ptVar3;

  ptVar3 = g_zb_neighborTbl.activeHead;
  if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar1 = (g_zb_neighborTbl.activeHead)->field_0x1e;
    pnVar2 = g_zb_neighborTbl.activeHead;
    while ((bVar1 & 0x80) != 0)
    {
      if ((bVar1 & 0x70) == 0)
      {
        return pnVar2;
      }
      pnVar2 = pnVar2->activeNext;
      if (pnVar2 == (nebTbl_t *)0x0)
      {
        return (tl_zb_normal_neighbor_entry_t *)0x0;
      }
      bVar1 = pnVar2->field_0x1e;
    }
    ptVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
  }
  return ptVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nebTbl_t *tl_zbNeighborTabSearchForChildEndDev(void)

{
  byte bVar1;
  int in_r0;
  nebTbl_t *pnVar2;

  pnVar2 = g_zb_neighborTbl.activeHead;
  if (in_r0 != 0)
  {
    pnVar2 = *(tl_zb_normal_neighbor_entry_t **)(in_r0 + 4);
  }
  if (pnVar2 != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar1 = pnVar2->field_0x1e;
    while ((bVar1 & 0x80) != 0)
    {
      if ((bVar1 & 0xe) == 4)
      {
        if ((bVar1 & 0x70) == 0x50)
        {
          return pnVar2;
        }
        if ((bVar1 & 0x70) == 0x10)
        {
          return pnVar2;
        }
      }
      pnVar2 = pnVar2->activeNext;
      if (pnVar2 == (nebTbl_t *)0x0)
      {
        return (tl_zb_normal_neighbor_entry_t *)0x0;
      }
      bVar1 = pnVar2->field_0x1e;
    }
    pnVar2 = (tl_zb_normal_neighbor_entry_t *)0x0;
  }
  return pnVar2;
}

// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention -- yet parameter storage is locked

nebTbl_t *tl_zbNeighborTabSearchForRouter(void)

{
  byte bVar1;
  int in_r0;
  nebTbl_t *pnVar2;

  pnVar2 = g_zb_neighborTbl.activeHead;
  if (in_r0 != 0)
  {
    pnVar2 = *(tl_zb_normal_neighbor_entry_t **)(in_r0 + 4);
  }
  if (pnVar2 != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar1 = pnVar2->field_0x1e;
    while ((bVar1 & 0x80) != 0)
    {
      if ((bVar1 & 0xe) == 2)
      {
        return pnVar2;
      }
      pnVar2 = pnVar2->activeNext;
      if (pnVar2 == (nebTbl_t *)0x0)
      {
        return (tl_zb_normal_neighbor_entry_t *)0x0;
      }
      bVar1 = pnVar2->field_0x1e;
    }
    pnVar2 = (tl_zb_normal_neighbor_entry_t *)0x0;
  }
  return pnVar2;
}

tl_zb_normal_neighbor_entry_t *tl_zbNeighborEntryGetFromIdx(u8 idx)

{
  nebTbl_t *pnVar1;
  uint uVar2;

  pnVar1 = g_zb_neighborTbl.activeHead;
  if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    if (((g_zb_neighborTbl.activeHead)->field_0x1e & 0x80) == 0)
    {
    LAB_0001a53a:
      pnVar1 = (tl_zb_normal_neighbor_entry_t *)0x0;
    }
    else if (idx != 0)
    {
      uVar2 = 0;
      do
      {
        pnVar1 = pnVar1->activeNext;
        if (pnVar1 == (nebTbl_t *)0x0)
        {
          return (tl_zb_normal_neighbor_entry_t *)0x0;
        }
        if ((pnVar1->field_0x1e & 0x80) == 0)
          goto LAB_0001a53a;
        uVar2 = uVar2 + 1;
      } while (uVar2 != idx);
    }
  }
  return pnVar1;
}

tl_zb_normal_neighbor_entry_t *
tl_zbNeighborTableSearchFromExtAddr(u16 *shortAddr, addrExt_t extAddr, u16 *idx)

{
  u16 uVar1;
  u8 uVar2;
  nebTbl_t *pnVar3;
  u16 *in_r2;
  undefined4 unaff_r4;
  undefined4 in_lr;

  uVar2 = tl_zbShortAddrByExtAddr(shortAddr, (addrExt_t)CONCAT44(unaff_r4, in_lr), idx);
  pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
  if ((uVar2 == '\0') &&
      (pnVar3 = g_zb_neighborTbl.activeHead,
       g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0))
  {
    if (((g_zb_neighborTbl.activeHead)->field_0x1e & 0x80) == 0)
    {
    LAB_0001a5a2:
      pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
    }
    else
    {
      uVar1 = (g_zb_neighborTbl.activeHead)->addrmapIdx;
      while ((*in_r2 != uVar1 && (pnVar3 = pnVar3->activeNext, pnVar3 != (nebTbl_t *)0x0)))
      {
        if ((pnVar3->field_0x1e & 0x80) == 0)
          goto LAB_0001a5a2;
        uVar1 = pnVar3->addrmapIdx;
      }
    }
  }
  return pnVar3;
}

tl_zb_normal_neighbor_entry_t *
tl_zbNeighborTableSearchFromShortAddr(u16 shortAddr, addrExt_t extAddr, u16 *idx)

{
  u16 uVar1;
  u8 uVar2;
  nebTbl_t *pnVar3;
  u16 *in_r2;
  undefined4 unaff_r4;
  undefined4 in_lr;

  uVar2 = tl_zbExtAddrByShortAddr(shortAddr, (addrExt_t)CONCAT44(unaff_r4, in_lr), idx);
  pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
  if ((uVar2 == '\0') &&
      (pnVar3 = g_zb_neighborTbl.activeHead,
       g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0))
  {
    if (((g_zb_neighborTbl.activeHead)->field_0x1e & 0x80) == 0)
    {
    LAB_0001a60e:
      pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
    }
    else
    {
      uVar1 = (g_zb_neighborTbl.activeHead)->addrmapIdx;
      while ((*in_r2 != uVar1 && (pnVar3 = pnVar3->activeNext, pnVar3 != (nebTbl_t *)0x0)))
      {
        if ((pnVar3->field_0x1e & 0x80) == 0)
          goto LAB_0001a60e;
        uVar1 = pnVar3->addrmapIdx;
      }
    }
  }
  return pnVar3;
}

tl_zb_normal_neighbor_entry_t *nwk_neTblGetByShortAddr(u16 shortAddr)

{
  u16 uVar1;
  int iVar2;
  nebTbl_t *pnVar3;

  iVar2 = FUNBBBBK();
  pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
  if ((iVar2 == 0) &&
      (pnVar3 = g_zb_neighborTbl.activeHead,
       g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0))
  {
    if (((g_zb_neighborTbl.activeHead)->field_0x1e & 0x80) == 0)
    {
    LAB_0001a686:
      pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
    }
    else
    {
      uVar1 = (g_zb_neighborTbl.activeHead)->addrmapIdx;
      while ((uVar1 != 0 && (pnVar3 = pnVar3->activeNext, pnVar3 != (nebTbl_t *)0x0)))
      {
        if ((pnVar3->field_0x1e & 0x80) == 0)
          goto LAB_0001a686;
        uVar1 = pnVar3->addrmapIdx;
      }
    }
  }
  return pnVar3;
}

tl_zb_normal_neighbor_entry_t *nwk_neTblGetByExtAddr(addrExt_t extAddr)

{
  u16 uVar1;
  int iVar2;
  nebTbl_t *pnVar3;

  iVar2 = tl_idxByExtAddr();
  pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
  if ((iVar2 == 0) &&
      (pnVar3 = g_zb_neighborTbl.activeHead,
       g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0))
  {
    if (((g_zb_neighborTbl.activeHead)->field_0x1e & 0x80) == 0)
    {
    LAB_0001a6fc:
      pnVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
    }
    else
    {
      uVar1 = (g_zb_neighborTbl.activeHead)->addrmapIdx;
      while ((uVar1 != 0 && (pnVar3 = pnVar3->activeNext, pnVar3 != (nebTbl_t *)0x0)))
      {
        if ((pnVar3->field_0x1e & 0x80) == 0)
          goto LAB_0001a6fc;
        uVar1 = pnVar3->addrmapIdx;
      }
    }
  }
  return pnVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

tl_zb_normal_neighbor_entry_t *nwkVaildNeighborToFwd(void)

{
  u16 in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar1;

  ptVar1 = nwk_neTblGetByShortAddr(in_r0);
  if ((ptVar1 != (tl_zb_normal_neighbor_entry_t *)0x0) && ((ptVar1->field_0x1e & 0x7e) != 0x14))
  {
    if (ptVar1->outgoingCost == 0)
    {
      ptVar1 = (tl_zb_normal_neighbor_entry_t *)0x0;
    }
    else
    {
      ptVar1 = (tl_zb_normal_neighbor_entry_t *)((uint)ptVar1 & -(uint)(ptVar1->outgoingCost < NWK_NEIGHBOR_SEND_OUTGOING_THRESHOLD));
    }
  }
  return ptVar1;
}

void tl_zbNeighborTableDelete(tl_zb_normal_neighbor_entry_t *entry)

{
  nebTbl_t *pnVar1;
  int iVar2;
  byte bVar3;
  undefined in_stack_ffffffe8;
  undefined7 in_stack_ffffffe9;

  bVar3 = entry->field_0x1e & 0x70;
  if ((bVar3 == 0x50) || (bVar3 == 0x10))
  {
    g_sysDiags.childMoved = g_sysDiags.childMoved + 1;
  }
  if (g_zb_neighborTbl.normalNeighborNum == '\0')
  {
    sys_exceptionPost(0x124, '3');
  }
  g_sysDiags.neighborRemoved = g_sysDiags.neighborRemoved + 1;
  tl_zbExtAddrByIdx(entry->addrmapIdx, (addrExt_t)CONCAT71(in_stack_ffffffe9, in_stack_ffffffe8));
  iVar2 = aps_bindingTblExis();
  if (iVar2 == 0)
  {
    tl_zbNwkAddrMapDelete(entry->addrmapIdx);
  }
  entry->field_0x1e = entry->field_0x1e & 0x8f | 0x30;
  entry->field_0x1e = entry->field_0x1e & 0x7f;
  entry->transFailure = '\0';
  tl_nebListDelete();
  *(undefined *)&entry->freeNext = g_zb_neighborTbl.freeHead._0_1_;
  *(undefined *)((int)&entry->freeNext + 1) = g_zb_neighborTbl.freeHead._1_1_;
  *(undefined *)((int)&entry->freeNext + 2) = g_zb_neighborTbl.freeHead._2_1_;
  *(undefined *)((int)&entry->freeNext + 3) = g_zb_neighborTbl.freeHead._3_1_;
  g_zb_neighborTbl.normalNeighborNum = '\0';
  if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar3 = (g_zb_neighborTbl.activeHead)->field_0x1e;
    pnVar1 = g_zb_neighborTbl.activeHead;
    while ((bVar3 & 0x80) != 0)
    {
      g_zb_neighborTbl.normalNeighborNum = g_zb_neighborTbl.normalNeighborNum + '\x01';
      pnVar1 = pnVar1->activeNext;
      if (pnVar1 == (nebTbl_t *)0x0)
        break;
      bVar3 = pnVar1->field_0x1e;
    }
  }
  g_zb_neighborTbl.freeHead = entry;
  tl_zbNeighborTableChildEDNumGet();
  return;
}

u8 tl_nwkNeighborDeleteByAddrmapIdx(u16 idx)

{
  u16 uVar1;
  nebTbl_t *entry;

  if ((g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0) &&
      (((g_zb_neighborTbl.activeHead)->field_0x1e & 0x80) != 0))
  {
    uVar1 = (g_zb_neighborTbl.activeHead)->addrmapIdx;
    entry = g_zb_neighborTbl.activeHead;
    while (idx != uVar1)
    {
      entry = entry->activeNext;
      if (entry == (nebTbl_t *)0x0)
      {
        return '\0';
      }
      if ((entry->field_0x1e & 0x80) == 0)
      {
        return '\0';
      }
      uVar1 = entry->addrmapIdx;
    }
    tl_zbNeighborTableDelete(entry);
  }
  return '\0';
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

tl_zb_normal_neighbor_entry_t *tl_zbNeighborTableDeleteAuto(void)

{
  byte bVar1;
  char in_r0;
  int iVar2;
  nebTbl_t *entry;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  bool bVar5;

  ptVar3 = g_zb_neighborTbl.activeHead;
  if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar1 = (g_zb_neighborTbl.activeHead)->field_0x1e;
    if ((bVar1 & 0x80) == 0)
    {
      ptVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
    }
    else
    {
      ptVar4 = (tl_zb_normal_neighbor_entry_t *)0x0;
      ptVar3 = (tl_zb_normal_neighbor_entry_t *)0x0;
      entry = g_zb_neighborTbl.activeHead;
      do
      {
        if (((bVar1 & 0x70) == 0x50) || ((bVar1 & 0x70) == 0x10))
        {
          bVar5 = false;
        }
        else
        {
          bVar5 = (bVar1 & 0x70) != 0;
        }
        tl_zbshortAddrByIdx(entry->addrmapIdx);
        iVar2 = nwkRoutingTabEntryFind();
        if ((iVar2 == 0) && (bVar5))
        {
          if (entry->outgoingCost == '\0')
          {
            if (entry->lqi == 0)
              goto LAB_0001a974;
            if ((ptVar3 == (tl_zb_normal_neighbor_entry_t *)0x0) || (entry->lqi < ptVar3->lqi))
            {
              ptVar3 = entry;
            }
          }
          else if ((in_r0 != '\0') &&
                   ((ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0 || (entry->lqi < ptVar4->lqi))))
          {
            ptVar4 = entry;
          }
        }
        entry = entry->activeNext;
      } while ((entry != (nebTbl_t *)0x0) && (bVar1 = entry->field_0x1e, (bVar1 & 0x80) != 0));
      entry = ptVar3;
      if ((ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0) ||
          (ptVar3 = (tl_zb_normal_neighbor_entry_t *)0x0, entry = ptVar4,
           ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0))
      {
      LAB_0001a974:
        tl_zbNeighborTableDelete(entry);
        ptVar3 = entry;
      }
    }
  }
  return ptVar3;
}

tl_zb_normal_neighbor_entry_t *
tl_zbNeighborTableUpdate(tl_zb_normal_neighbor_entry_t *entry, u8 delete)

{
  u16 uVar1;
  nebTbl_t *pnVar2;
  byte bVar3;
  int iVar4;
  nebTbl_t *pnVar5;

  pnVar5 = (tl_zb_normal_neighbor_entry_t *)0x0;
  if (NWK_NEIGHBORTBL_ADD_LQITHRESHOLD <= entry->lqi)
  {
    if ((g_zb_neighborTbl.activeHead == (tl_zb_normal_neighbor_entry_t *)0x0) ||
        (((g_zb_neighborTbl.activeHead)->field_0x1e & 0x80) == 0))
    {
    LAB_0001aa16:
      if (((entry->field_0x1e & 0xe) == 4) &&
          (bVar3 = tl_zbNeighborTableChildEDNumGet(), TL_ZB_CHILD_TABLE_SIZE <= bVar3))
      {
        return (tl_zb_normal_neighbor_entry_t *)0x0;
      }
      g_zb_neighborTbl.normalNeighborNum = 0;
      if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
      {
        bVar3 = (g_zb_neighborTbl.activeHead)->field_0x1e;
        pnVar5 = g_zb_neighborTbl.activeHead;
        while ((bVar3 & 0x80) != 0)
        {
          g_zb_neighborTbl.normalNeighborNum = g_zb_neighborTbl.normalNeighborNum + 1;
          pnVar5 = pnVar5->activeNext;
          if (pnVar5 == (nebTbl_t *)0x0)
            break;
          bVar3 = pnVar5->field_0x1e;
        }
      }
      if ((TL_ZB_NEIGHBOR_TABLE_SIZE <= g_zb_neighborTbl.normalNeighborNum) &&
          (iVar4 = tl_zbNeighborTableDeleteAuto(), iVar4 == 0))
      {
        return (tl_zb_normal_neighbor_entry_t *)0x0;
      }
      pnVar5 = g_zb_neighborTbl.freeHead;
      if (g_zb_neighborTbl.freeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
      {
        if (((g_zb_neighborTbl.freeHead)->field_0x1e & 0x80) == 0)
        {
          (g_zb_neighborTbl.freeHead)->field_0x1e =
              (g_zb_neighborTbl.freeHead)->field_0x1e & 0x8f | 0x30;
          memcpy(&pnVar5->authTimeout, &entry->authTimeout, 0x1c);
          pnVar5->field_0x1e = pnVar5->field_0x1e | 0x7f;
          tl_nebListDelete();
          *(undefined *)&pnVar5->activeNext = g_zb_neighborTbl.activeHead._0_1_;
          *(undefined *)((int)&pnVar5->activeNext + 1) = g_zb_neighborTbl.activeHead._1_1_;
          *(undefined *)((int)&pnVar5->activeNext + 2) = g_zb_neighborTbl.activeHead._2_1_;
          *(undefined *)((int)&pnVar5->activeNext + 3) = g_zb_neighborTbl.activeHead._3_1_;
          g_zb_neighborTbl.activeHead = pnVar5;
          g_sysDiags.neighborAdded = g_sysDiags.neighborAdded + 1;
          tl_zbNeighborTableChildEDNumGet();
          g_zb_neighborTbl.normalNeighborNum = '\0';
          if (g_zb_neighborTbl.activeHead != (tl_zb_normal_neighbor_entry_t *)0x0)
          {
            bVar3 = (g_zb_neighborTbl.activeHead)->field_0x1e;
            pnVar2 = g_zb_neighborTbl.activeHead;
            while ((bVar3 & 0x80) != 0)
            {
              g_zb_neighborTbl.normalNeighborNum = g_zb_neighborTbl.normalNeighborNum + '\x01';
              pnVar2 = pnVar2->activeNext;
              if (pnVar2 == (nebTbl_t *)0x0)
              {
                return pnVar5;
              }
              bVar3 = pnVar2->field_0x1e;
            }
          }
        }
        else
        {
          pnVar5 = (tl_zb_normal_neighbor_entry_t *)0x0;
        }
      }
    }
    else
    {
      uVar1 = (g_zb_neighborTbl.activeHead)->addrmapIdx;
      pnVar5 = g_zb_neighborTbl.activeHead;
      while (entry->addrmapIdx != uVar1)
      {
        pnVar5 = pnVar5->activeNext;
        if ((pnVar5 == (nebTbl_t *)0x0) || ((pnVar5->field_0x1e & 0x80) == 0))
          goto LAB_0001aa16;
        uVar1 = pnVar5->addrmapIdx;
      }
      memcpy(&pnVar5->authTimeout, &entry->authTimeout, 0x1c);
      pnVar5->field_0x1e = pnVar5->field_0x1e | 0x7f;
    }
  }
  return pnVar5;
}

void tl_zbAdditionNeighborReset(void)

{
  int iVar1;
  u16 *puVar2;

  puVar2 = &g_zb_neighborTbl.additionNeighborTbl[0].shortAddr;
  iVar1 = 0;
  do
  {
    *puVar2 = 0xfffe;
    memset(g_zb_neighborTbl.additionNeighborTbl[iVar1].extAddr, 0xff, 8);
    iVar1 = iVar1 + 1;
    puVar2 = puVar2 + 0xe;
  } while (iVar1 != 6);
  g_zb_neighborTbl.additionNeighborNum = '\0';
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

tl_zb_addition_neighbor_entry_t *AdditionNeighborEntryGetFromExtAddr(void)

{
  void *in_r0;
  int iVar1;
  uint uVar2;
  uint uVar3;

  uVar3 = (uint)g_zb_neighborTbl.additionNeighborNum;
  if (uVar3 != 0)
  {
    uVar2 = 0;
    do
    {
      iVar1 = memcmp((void *)((int)in_r0 + 8),
                     g_zb_neighborTbl.additionNeighborTbl[uVar2 & 0xff].extAddr, 8);
      if ((iVar1 == 0) &&
          (iVar1 = memcmp(in_r0, g_zb_neighborTbl.additionNeighborTbl + (uVar2 & 0xff), 8), iVar1 == 0))
      {
        return g_zb_neighborTbl.additionNeighborTbl + (uVar2 & 0xff);
      }
      uVar2 = uVar2 + 1;
    } while (uVar2 < uVar3);
  }
  return (tl_zb_addition_neighbor_entry_t *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

tl_zb_addition_neighbor_entry_t *AdditionNeighborEntryGetFromShortAddr(void)

{
  u16 uVar1;
  void *in_r0;
  int iVar2;
  uint uVar3;
  uint uVar4;

  uVar4 = (uint)g_zb_neighborTbl.additionNeighborNum;
  if (uVar4 != 0)
  {
    uVar1 = *(u16 *)((int)in_r0 + 0x10);
    uVar3 = 0;
    do
    {
      if ((g_zb_neighborTbl.additionNeighborTbl[uVar3 & 0xff].shortAddr == uVar1) &&
          (iVar2 = memcmp(in_r0, g_zb_neighborTbl.additionNeighborTbl + (uVar3 & 0xff), 8), iVar2 == 0))
      {
        return g_zb_neighborTbl.additionNeighborTbl + (uVar3 & 0xff);
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 < uVar4);
  }
  return (tl_zb_addition_neighbor_entry_t *)0x0;
}

u8 tl_zbAdditionNeighborTableUpdate(tl_zb_addition_neighbor_entry_t *entry)

{
  tl_zb_addition_neighbor_entry_t *out;
  uint uVar1;
  int iVar2;

  if (entry->addrMode == '\x02')
  {
    out = (tl_zb_addition_neighbor_entry_t *)AdditionNeighborEntryGetFromShortAddr();
  LAB_0001aca8:
    if (out != (tl_zb_addition_neighbor_entry_t *)0x0)
      goto LAB_0001acac;
  }
  else if (entry->addrMode == '\x03')
  {
    out = (tl_zb_addition_neighbor_entry_t *)AdditionNeighborEntryGetFromExtAddr();
    goto LAB_0001aca8;
  }
  uVar1 = (uint)g_zb_neighborTbl.additionNeighborNum;
  if (uVar1 < 6)
  {
    g_zb_neighborTbl.additionNeighborNum = g_zb_neighborTbl.additionNeighborNum + '\x01';
    out = g_zb_neighborTbl.additionNeighborTbl + uVar1;
  }
  else
  {
    iVar2 = 0;
    while (out = g_zb_neighborTbl.additionNeighborTbl + iVar2,
           (g_zb_neighborTbl.additionNeighborTbl[iVar2].field_0x16 & 0xf) <=
               (entry->field_0x16 & 0xf))
    {
      iVar2 = iVar2 + 1;
      if (iVar2 == 6)
      {
        return 199;
      }
    }
  }
LAB_0001acac:
  memcpy(out, entry, 0x1c);
  return '\0';
}

u8 tl_zbAdditionNeighborTableNumGet(void)

{
  return g_zb_neighborTbl.additionNeighborNum;
}

tl_zb_addition_neighbor_entry_t *tl_zbAdditionNeighborEntryGetFromIdx(u8 idx)

{
  return g_zb_neighborTbl.additionNeighborTbl + idx;
}

u8 tl_neighborFrameCntReset(void)

{
  byte bVar1;
  u32 *puVar2;
  u32 *puVar3;

  if (TL_ZB_NEIGHBOR_TABLE_SIZE != '\0')
  {
    bVar1 = TL_ZB_NEIGHBOR_TABLE_SIZE - 1;
    puVar2 = &g_zb_neighborTbl.neighborTbl[0].incomingFrameCnt;
    for (puVar3 = &g_zb_neighborTbl.neighborTbl[1].incomingFrameCnt; *puVar2 = 0,
        puVar3 != &g_zb_neighborTbl.neighborTbl[bVar1 + 1].incomingFrameCnt;
         puVar3 = puVar3 + 9)
    {
      puVar2 = puVar3;
    }
  }
  return '\0';
}

// WARNING: Could not reconcile some variable overlaps

void tl_zbNeighborTableInit(void)

{
  nv_sts_t nVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  int iVar3;
  undefined uVar4;
  undefined uVar5;
  undefined2 uVar6;
  u16 *puVar7;
  u32 *puVar8;
  undefined auStack_68[32];
  uint uStack_48;
  u32 local_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  u16 local_38;
  u16 auStack_36[4];
  byte bStack_2e;
  byte bStack_2d;
  ushort local_2c;
  u8 uStack_2a;
  ushort local_26;

  tl_zbNeighborTableRst();
  auStack_68._0_4_ = (nebTbl_t *)0x0;
  auStack_68._4_4_ = (nebTbl_t *)0x0;
  auStack_68._8_4_ = 0;
  auStack_68._12_4_ = 0;
  auStack_68._16_4_ = 0;
  auStack_68._20_4_ = 0;
  auStack_68._24_4_ = 0;
  auStack_68._28_4_ = 0;
  uStack_48 = 0;
  local_2c = 0;
  uStack_2a = '\0';
  nVar1 = nv_flashReadNew('\0', '\x01', 0xff, 0xc, (u8 *)&local_2c);
  if (nVar1 == NV_SUCC)
  {
    iVar3 = 0;
    do
    {
      while (true)
      {
        uVar4 = 0xc;
        uVar5 = 0;
        uVar6 = 0;
        puVar7 = &local_38;
        nVar1 = nv_flashReadByIndex('\x01', '\x02', uStack_2a, (u16)iVar3, 0xc, (u8 *)&local_38);
        if (nVar1 == 0)
          break;
      LAB_0001ad7a:
        iVar3 = iVar3 + 1;
        if ((int)(uint)local_2c < iVar3)
          goto LAB_0001ae2e;
      }
      tl_zbNwkAddrMapAdd(local_38, (addrExt_t)CONCAT44(puVar7, CONCAT22(uVar6, CONCAT11(uVar5, uVar4))),
                         auStack_36);
      auStack_68._20_4_ = auStack_68._20_4_ & 0xffff | (uint)local_26 << 0x10;
      auStack_68._28_3_ =
          CONCAT12(auStack_68[30] & 0x80 | bStack_2d & 1 | (byte)((bStack_2d >> 4 & 7) << 4) |
                       (byte)((bStack_2d >> 1 & 7) << 1),
                   auStack_68._28_2_);
      auStack_68._28_4_ = auStack_68._28_4_ & 0xff000000 | (uint)auStack_68._28_3_;
      auStack_68[30] = (byte)((uint)auStack_68._28_3_ >> 0x10);
      if ((auStack_68[30] & 0xe) == 4)
      {
        auStack_68._12_4_ = 10;
        auStack_68._16_4_ = auStack_68._12_4_;
        if (g_zbInfo.nwkNib.endDevTimeoutDefault != 0)
        {
          auStack_68._12_4_ = 0x3c << (uint)g_zbInfo.nwkNib.endDevTimeoutDefault;
          auStack_68._16_4_ = auStack_68._12_4_;
        }
      }
      uStack_48 = (uint)CONCAT12(NWK_NEIGHBORTBL_ADD_LQITHRESHOLD + '\x01',
                                 (ushort)uStack_48 & 0xff00 | (ushort)bStack_2e);
      auStack_68._28_4_ = auStack_68._28_4_ | 0x7f0000;
      auStack_68._24_4_ = (uint)nVar1;
      ptVar2 = tl_zbNeighborTableUpdate((tl_zb_normal_neighbor_entry_t *)auStack_68, '\0');
      if (ptVar2 == (tl_zb_normal_neighbor_entry_t *)0x0)
        goto LAB_0001ad7a;
      ptVar2->lqi = '\0';
      iVar3 = iVar3 + 1;
    } while (iVar3 <= (int)(uint)local_2c);
  }
LAB_0001ae2e:
  local_44 = 0;
  uStack_40 = 0;
  uStack_3c = 0;
  local_2c = 0;
  uStack_2a = '\0';
  nVar1 = nv_flashReadNew('\0', '\x01', 0xff, 0xc, (u8 *)&local_2c);
  if (nVar1 == NV_SUCC)
  {
    iVar3 = 0;
    do
    {
      while (true)
      {
        uVar4 = 0xc;
        uVar5 = 0;
        uVar6 = 0;
        puVar8 = &local_44;
        nVar1 = nv_flashReadByIndex('\x01', '\v', uStack_2a, (u16)iVar3, 0xc, (u8 *)&local_44);
        if (((nVar1 != NV_SUCC) ||
             (ptVar2 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT44(puVar8, CONCAT22(uVar6, CONCAT11(uVar5, uVar4)))),
              ptVar2 == (tl_zb_normal_neighbor_entry_t *)0x0)) ||
            ((ptVar2->field_0x1e & 0xe) != 4))
          break;
        auStack_68._12_4_ = local_44;
        iVar3 = iVar3 + 1;
        auStack_68._16_4_ = auStack_68._12_4_;
        if ((int)(uint)local_2c < iVar3)
        {
          return;
        }
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 <= (int)(uint)local_2c);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkNebManagePeriodic(void)

{
  byte bVar1;
  int iVar2;
  u32 *puVar3;
  u32 uVar4;
  int iVar5;
  uint uVar6;

  if (TL_ZB_NEIGHBOR_TABLE_SIZE != '\0')
  {
    uVar6 = 0;
    do
    {
      while (bVar1 = g_zb_neighborTbl.neighborTbl[uVar6].field_0x1e, (bVar1 & 0x80) != 0)
      {
        if ((bVar1 & 0x70) == 0x50)
        {
          puVar3 = &g_zb_neighborTbl.neighborTbl[uVar6].authTimeout;
          uVar4 = *puVar3;
        }
        else
        {
          if (((bVar1 & 0x7e) != 0x14) || (g_zb_neighborTbl.neighborTbl[uVar6].devTimeout == 0))
            break;
          puVar3 = &g_zb_neighborTbl.neighborTbl[uVar6].timeoutCnt;
          uVar4 = *puVar3;
        }
        if ((uVar4 != 0) && (*puVar3 = uVar4 - 1, uVar4 - 1 != 0))
          break;
        iVar2 = uVar6 * 0x24;
        iVar5 = iVar2 + 0x84305c;
        tl_zbshortAddrByIdx(g_zb_neighborTbl.neighborTbl[uVar6].addrmapIdx);
        tl_zbExtAddrByIdx(*(u16 *)(iVar5 + 2), (addrExt_t)CONCAT44(iVar5, iVar2));
        nwk_nodeAddrInfoDelete();
        tl_zbNeighborTableDelete((tl_zb_normal_neighbor_entry_t *)((int)&g_zb_neighborTbl.neighborTbl[0].freeNext + iVar2));
        uVar6 = uVar6 + 1 & 0xff;
        if (TL_ZB_NEIGHBOR_TABLE_SIZE <= uVar6)
        {
          return;
        }
      }
      uVar6 = uVar6 + 1 & 0xff;
    } while (uVar6 < TL_ZB_NEIGHBOR_TABLE_SIZE);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_nlmeStartRouterCnf(void)

{
  undefined *in_r0;
  undefined in_r1;

  *in_r0 = in_r1;
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf;
  tl_zbTaskPost(zdo_nlme_start_router_confirm, in_r0);
  return;
}

void tl_zbNwkNlmeStartRouterRequestHandler(void *arg)

{
  byte bVar1;

  bVar1 = g_zbNwkCtx._47_1_ & 0xf0;
  if ((g_zbNwkCtx._47_1_ & 0xf0) == 0)
  {
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf | 0x20;
    // WARNING: Load size is inaccurate
    *(u16 *)((int)arg + 4) = g_zbInfo.macPib.panId;
    *(u8 *)((int)arg + 6) = g_zbInfo.macPib.phyChannelCur;
    *(byte *)((int)arg + 7) = bVar1;
    *(undefined *)((int)arg + 10) = 1;
    *(byte *)((int)arg + 0x17) = bVar1;
    *(undefined *)((int)arg + 8) = *arg;
    *(undefined *)((int)arg + 9) = *(undefined *)((int)arg + 1);
    *(undefined *)((int)arg + 0xb) = *(undefined *)((int)arg + 2);
    tl_zbPrimitivePost('\x02', 'Z', arg);
  }
  else
  {
    nwk_nlmeStartRouterCnf();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_startRouterCnfHandler(void)

{
  u16 shortAddr;
  char *in_r0;
  int iVar1;
  undefined4 in_lr;
  undefined in_stack_ffffffe8;
  undefined in_stack_ffffffe9;

  if (*in_r0 == '\0')
  {
    g_zbInfo.macPib.rxOnWhenIdle =
        (u8)(((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1c) >> 0x1f);
    g_zbInfo.nwkNib.panId = g_zbInfo.macPib.panId;
    memcpy(g_zbInfo.nwkNib.ieeeAddr, g_zbInfo.macPib.extAddress, 8);
    shortAddr = g_zbInfo.nwkNib.nwkAddr;
    g_zbInfo.macPib.shortAddress._0_1_ = (undefined)g_zbInfo.nwkNib.nwkAddr;
    g_zbInfo.macPib.shortAddress._1_1_ = (undefined)((uint)g_zbInfo.nwkNib.nwkAddr >> 8);
    iVar1 = memcmp(g_zbInfo.nwkNib.extPANId, &g_zero_addr, 8);
    if (iVar1 == 0)
    {
      memcpy(g_zbInfo.nwkNib.extPANId, g_zbInfo.macPib.extAddress, 8);
    }
    tl_zbNwkAddrMapAdd(shortAddr,
                       (addrExt_t)
                           CONCAT44(in_lr, (uint)CONCAT11(in_stack_ffffffe9, in_stack_ffffffe8)),
                       (u16 *)g_zbInfo.macPib.extAddress);
    tl_zbNwkBeaconPayloadUpdate();
  }
  nwk_nlmeStartRouterCnf();
  return;
}

void tl_zbNwkNlmeEDScanRequestHandler(void *arg)

{
  undefined4 uVar1;

  // WARNING: Load size is inaccurate
  uVar1 = *arg;
  *(char *)arg = (char)uVar1;
  *(char *)((int)arg + 1) = (char)((uint)uVar1 >> 8);
  *(char *)((int)arg + 2) = (char)((uint)uVar1 >> 0x10);
  *(char *)((int)arg + 3) = (char)((uint)uVar1 >> 0x18);
  *(undefined *)((int)arg + 5) = *(undefined *)((int)arg + 4);
  *(undefined *)((int)arg + 4) = 0;
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf | 0x70;
  tl_zbPrimitivePost('\x02', 'U', arg);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_edScanCnfHandler(void)

{
  void *in_r0;

  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf;
  tl_zbTaskPost(zdo_nlme_ed_scan_confirm, in_r0);
  return;
}

void tl_zbNwkNlmeResetRequestHandler(void *arg)

{
  byte bVar1;

  if (((g_zbNwkCtx._47_1_ & 0xf0) == 0) &&
      (bVar1 = g_zbNwkCtx._45_1_ & 4, (g_zbNwkCtx._45_1_ & 4) == 0))
  {
    // WARNING: Load size is inaccurate
    if (*arg == '\0')
    {
      *(undefined *)arg = 1;
      tl_zbPrimitivePost('\x02', 'Q', arg);
    }
    else
    {
      tl_zbAdditionNeighborReset();
      *(byte *)arg = bVar1;
      tl_zbTaskPost(zdo_reset_confirm_cb, arg);
    }
  }
  else
  {
    *(undefined *)arg = 0;
    tl_zbTaskPost(zdo_reset_confirm_cb, arg);
  }
  return;
}

void tl_zbMacMlmeResetConfirmHandler(void *arg)

{
  undefined uVar1;

  // WARNING: Load size is inaccurate
  uVar1 = *arg;
  tl_zbNwkNibInit();
  tl_zbNeighborTableInit();
  memset(&g_zbNwkCtx, 0, 0x4f);
  g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ | 0x10;
  *(undefined *)arg = uVar1;
  tl_zbTaskPost(zdo_reset_confirm_cb, arg);
  return;
}

void tl_zbMacMlmeSyncLossIndicationHandler(void *arg)

{
  zb_buf_free((zb_buf_t *)arg);
  return;
}

void tl_zbNwkNlmeNwkStatusInd(void *arg, u16 nwkAddr, nwk_statusCode_t status)

{
  *(nwk_statusCode_t *)((int)arg + 2) = status;
  *(u16 *)arg = nwkAddr;
  tl_zbTaskPost(zdo_nlme_status_indication, arg);
  return;
}

void tl_zbMacMlmePollIndicationHandler(void *arg)

{
  u32 uVar1;
  tl_zb_normal_neighbor_entry_t *ptVar2;

  // WARNING: Load size is inaccurate
  if ((((int)((uint)g_zbNwkCtx._45_1_ << 0x1d) < 0) &&
       (-1 < (int)((uint)g_zbInfo.nwkNib.parentInfo << 0x1e))) &&
      (*arg == '\x02'))
  {
    ptVar2 = nwk_neTblGetByShortAddr(*(u16 *)((int)arg + 1));
    if (ptVar2 == (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      if (unknowEndDevAddr_8528 == -2)
      {
        unknowEndDevAddr_8528 = *(u16 *)((int)arg + 1);
        if ((unknowEndDevAddr_8528 & 0xfff8) != 0xfff8)
        {
          zb_address_ieee_by_short(unknowEndDevAddr_8528, (addrExt_t)(ulonglong)unknowEndDevAddr_8528);
        }
        nwkLeaveReqSend();
        return;
      }
      if (unknowEndDevAddr_8528 == *(short *)((int)arg + 1))
      {
        unknowEndDevAddr_8528 = -3;
      }
    }
    else
    {
      uVar1 = ptVar2->devTimeout;
      if (uVar1 != 0)
      {
        *(char *)&ptVar2->timeoutCnt = (char)uVar1;
        *(char *)((int)&ptVar2->timeoutCnt + 1) = (char)(uVar1 >> 8);
        *(char *)((int)&ptVar2->timeoutCnt + 2) = (char)(uVar1 >> 0x10);
        *(char *)((int)&ptVar2->timeoutCnt + 3) = (char)(uVar1 >> 0x18);
        ptVar2->keepaliveRcvd = '\x01';
      }
    }
  }
  zb_buf_free((zb_buf_t *)arg);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbNwkPanidConflictSetPanidCb(void)

{
  u16 uVar1;
  device_type_t dVar2;
  void *arg;
  char cVar3;

  arg = (void *)c1();
  uVar1 = g_zbNwkCtx.new_panid;
  if (arg != (void *)0x0)
  {
    *(char *)((int)arg + 4) = (char)g_zbNwkCtx.new_panid;
    cVar3 = (uVar1 >> 7 & 1) != 0;
    *(char *)((int)arg + 5) = (char)(uVar1 >> 8);
    *(u8 *)((int)arg + 6) = g_zbMacCtx.curChannel;
    *(undefined *)((int)arg + 8) = 0xf;
    dVar2 = af_nodeDevTypeGet();
    *(device_type_t *)((int)arg + 10) = ~dVar2 + dVar2 + cVar3;
    *(undefined *)((int)arg + 9) = 0xf;
    *(undefined *)((int)arg + 0xb) = 0;
    *(undefined *)((int)arg + 0x17) = 0;
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf | 0x60;
    tl_zbPrimitivePost('\x02', 'Z', arg);
    g_sysDiags.panIdModified = g_sysDiags.panIdModified + '\x01';
  }
  panidConflictTimerEvt = 0;
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbNwkPanidConflictDoubleCheck(void)

{
  undefined4 uVar1;
  int iVar2;

  tl_zbMacMlmeBeaconRequestCmdSend();
  iVar2 = (g_panIdConflictDected[12] - 1) * 0x1000000;
  g_panIdConflictDected[12] = (char)((uint)iVar2 >> 0x18);
  if (iVar2 < 1)
  {
    g_panIdConflictDected._0_4_ = 0;
    uVar1 = 0xfffffffe;
  }
  else
  {
    uVar1 = 2000;
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkReportCmdSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;

  puVar1 = (undefined *)
      tl_bufInitalloc(in_r0, (u8)((((uint)(byte)in_r2[0x10] << 0x1b) >> 2) + 0xa000000 >> 0x18));
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[0x10];
  memcpy(puVar1 + 2, in_r2 + 4, 8);
  memcpy(puVar1 + 10, *(void **)(in_r2 + 0xc), ((uint)(byte)in_r2[0x10] << 0x1b) >> 0x1a);
  (in_r0->hdr).handle = in_r3;
  nwk_fwdPacket();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkUpdateCmdSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, '\r');
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[0xe];
  memcpy(puVar1 + 2, in_r2 + 4, 8);
  puVar1[10] = in_r2[0xf];
  memcpy(puVar1 + 0xb, in_r2 + 0xc, 2);
  (in_r0->hdr).handle = in_r3;
  nwk_fwdPacket();
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

uint tl_zbNwkUpdateForPanidConflict(void)

{
  uint uVar1;
  u8 uVar2;
  byte bVar3;
  bool bVar4;
  zb_buf_t *in_r0;
  uint uVar5;
  int iVar6;
  uint in_r1;
  undefined local_58[4];
  undefined4 uStack_54;
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  u8 *puStack_3c;
  undefined4 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  undefined local_1e;

  g_zbNwkCtx.new_panid._0_1_ = (undefined)in_r1;
  g_zbNwkCtx.new_panid._1_1_ = (undefined)(in_r1 >> 8);
  local_58 = (undefined[4])0x0;
  uStack_54 = 0;
  uStack_50 = 0;
  uStack_4c = 0;
  uStack_48 = 0;
  uStack_44 = 0;
  uStack_40 = 0;
  puStack_3c = (u8 *)0x0;
  local_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  local_20 = 0;
  local_1e = 0;
  uVar5 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar4 = ss_keyPreconfigured();
    uVar5 = (uint)bVar4;
  }
  uVar1 = ((ushort)uStack_54 & 0xff00 | 0x1049) & 0xfffff7ff;
  uStack_54._1_1_ = (byte)(uVar1 >> 8);
  uStack_54._0_2_ =
      (nwkFrameCtrl_t)CONCAT11(uStack_54._1_1_ & 0xfd | (byte)(uVar5 << 1), (char)uVar1);
  uStack_54 = uStack_54 & 0xffff0000 | (uint)(ushort)uStack_54._0_2_;
  memcpy(&uStack_48, g_zbInfo.macPib.extAddress, 8);
  local_58 = (undefined[4])CONCAT22(g_zbInfo.nwkNib.nwkAddr, 0xfffe);
  uStack_54 = CONCAT13(g_zbInfo.nwkNib.seqNum,
                       CONCAT12(g_zbInfo.nwkNib.maxDepth << 1, uStack_54._0_2_));
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar2 = getNwkHdrSize((nwk_hdr_t *)local_58);
  uStack_40._0_2_ = CONCAT11(uVar2, uStack_40._0_1_);
  uStack_40 = uStack_40 & 0xffff0000 | (uint)(ushort)uStack_40;
  local_38 = CONCAT31(local_38._1_3_, 10);
  uStack_2c._0_3_ = CONCAT12(1, (short)uStack_2c);
  uStack_2c = uStack_2c & 0xff000000 | (uint)(uint3)uStack_2c;
  memcpy(&uStack_34, g_zbInfo.nwkNib.extPANId, 8);
  uStack_2c._2_2_ =
      (ushort)(uStack_2c >> 0x10) & 0xff |
      (ushort)(((uint)g_zbInfo.nwkNib.updateId << 0x18) >> 0x10);
  uStack_2c = in_r1 & 0xffff | (uint)uStack_2c._2_2_ << 0x10;
  if (((zdoAppIndCbLst == 0) || (*(int *)(zdoAppIndCbLst + 0x14) == 0)) ||
      (iVar6 = tl_zbNwkPanidConflictDetect(), iVar6 == 1))
  {
    uVar5 = nwkUpdateCmdSend();
  }
  else
  {
    bVar3 = zb_buf_free(in_r0);
    uVar5 = (uint)bVar3;
  }
  return uVar5;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbNwkPanidConflictDetect(void)

{
  u16 uVar1;
  int iVar2;
  void *m1;
  code *in_r3;
  undefined4 uVar3;

  uVar1 = (*in_r3)();
  uVar3 = 0;
  if ((g_zbInfo.nwkNib.panId == uVar1) &&
      ((iVar2 = memcmp(m1, &g_zero_addr, 8), iVar2 == 0 ||
                                                 (iVar2 = memcmp(m1, g_zbInfo.nwkNib.extPANId, 8), iVar2 != 0))))
  {
    g_sysDiags.panIdConflictCheck = g_sysDiags.panIdConflictCheck + 1;
    if (g_panIdConflictDected._0_4_ == (ev_timer_event_t *)0x0)
    {
      memcpy(g_panIdConflictDected + 4, m1, 8);
      g_panIdConflictDected[12] = 2;
      g_panIdConflictDected._0_4_ =
          ev_timer_taskPost(tl_zbNwkPanidConflictDoubleCheck, (void *)0x0, 0x14);
      uVar3 = 0;
    }
    else
    {
      iVar2 = memcmp(m1, g_panIdConflictDected + 4, 8);
      uVar3 = 0;
      if (iVar2 == 0)
      {
        ev_timer_taskCancel((ev_timer_event_t **)g_panIdConflictDected);
        uVar3 = 1;
      }
    }
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_zbNwkPanidConflictDetect(void)

{
  u16 in_r0;
  int iVar1;
  void *in_r1;
  undefined4 uVar2;

  uVar2 = 0;
  if ((g_zbInfo.nwkNib.panId == in_r0) &&
      ((iVar1 = memcmp(in_r1, &g_zero_addr, 8), iVar1 == 0 ||
                                                    (iVar1 = memcmp(in_r1, g_zbInfo.nwkNib.extPANId, 8), iVar1 != 0))))
  {
    g_sysDiags.panIdConflictCheck = g_sysDiags.panIdConflictCheck + 1;
    if (g_panIdConflictDected._0_4_ == (ev_timer_event_t *)0x0)
    {
      memcpy(g_panIdConflictDected + 4, in_r1, 8);
      g_panIdConflictDected[12] = 2;
      g_panIdConflictDected._0_4_ =
          ev_timer_taskPost(tl_zbNwkPanidConflictDoubleCheck, (void *)0x0, 0x14);
      uVar2 = 0;
    }
    else
    {
      iVar1 = memcmp(in_r1, g_panIdConflictDected + 4, 8);
      uVar2 = 0;
      if (iVar1 == 0)
      {
        ev_timer_taskCancel((ev_timer_event_t **)g_panIdConflictDected);
        uVar2 = 1;
      }
    }
  }
  return uVar2;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkReportForPanidConflict(void)

{
  u8 uVar1;
  bool bVar2;
  uint uVar3;
  byte bVar4;
  u8 uVar5;
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  u8 *puStack_3c;
  undefined4 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  uint uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  undefined local_1e;

  bVar4 = 0;
  uVar1 = '\0';
  uVar5 = '\0';
  uStack_50 = 0;
  uStack_4c = 0;
  uStack_48 = 0;
  uStack_44 = 0;
  uStack_40 = 0;
  puStack_3c = (u8 *)0x0;
  local_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  local_20 = 0;
  local_1e = 0;
  uVar3 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar2 = ss_keyPreconfigured();
    uVar3 = (uint)(bVar2 != false);
  }
  tl_zbExtAddrByShortAddr(g_zbInfo.nwkNib.managerAddr,
                          (addrExt_t)(CONCAT17(uVar5, CONCAT16(uVar1, CONCAT15(bVar4 & 0xf5 | 0x10 | (byte)(uVar3 << 1),
                                                                               CONCAT14(9, CONCAT22(g_zbInfo.nwkNib.nwkAddr,
                                                                                                    g_zbInfo.nwkNib.managerAddr))))) |
                                      0x4000000000),
                          (u16 *)&uStack_50);
  memcpy(&uStack_48, g_zbInfo.macPib.extAddress, 8);
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar1 = getNwkHdrSize((nwk_hdr_t *)&stack0xffffffa8);
  uStack_40._0_2_ = CONCAT11(uVar1, uStack_40._0_1_);
  uStack_40 = uStack_40 & 0xffff0000 | (uint)(ushort)uStack_40;
  local_38 = CONCAT31(local_38._1_3_, 9);
  uStack_28 = uStack_28 & 0xffffff00 | g_zbNwkCtx._46_1_ & 0xf;
  memcpy(&uStack_34, g_zbInfo.nwkNib.extPANId, 8);
  uStack_2c = 0x847e47;
  nwkReportCmdSend();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkPanidConflictProcess(void)

{
  u32 uVar1;
  uint uVar2;
  uint uVar3;

  if (g_zbInfo.nwkNib.managerAddr == g_zbInfo.nwkNib.nwkAddr)
  {
    do
    {
      while (true)
      {
        uVar1 = drv_u32Rand();
        uVar2 = uVar1 & 0xffff;
        if ((g_zbNwkCtx._46_1_ & 0xf) == 0)
          break;
        if (g_zbNwkCtx.known_panids[0] != uVar2)
        {
          uVar3 = 0;
          do
          {
            uVar3 = uVar3 + 1 & 0xff;
            if ((g_zbNwkCtx._46_1_ & 0xf) <= uVar3)
              goto LAB_0001b89e;
          } while (g_zbNwkCtx.known_panids[uVar3] != uVar2);
        }
      }
    LAB_0001b89e:
    } while (uVar2 == 0);
    g_zbInfo.nwkNib.updateId = g_zbInfo.nwkNib.updateId + '\x01';
    tl_zbNwkUpdateForPanidConflict();
  }
  else
  {
    tl_zbNwkReportForPanidConflict();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint nwkReportCmdHandler(void)

{
  byte *pbVar1;
  byte bVar2;
  zb_buf_t *in_r0;
  u32 uVar3;
  int in_r1;
  uint uVar4;
  uint uVar5;

  if (((int)((uint)g_zbNwkCtx._45_1_ << 0x19) < 0) || ((*(byte *)(in_r1 + 0x10) & 0xe0) != 0))
  {
    bVar2 = zb_buf_free(in_r0);
    uVar4 = (uint)bVar2;
  }
  else
  {
    g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x40;
  LAB_0001b8ee:
    do
    {
      while (true)
      {
        uVar3 = drv_u32Rand();
        uVar4 = uVar3 & 0xffff;
        if ((g_zbNwkCtx._46_1_ & 0xf) == 0)
          break;
        if (g_zbNwkCtx.known_panids[0] != uVar4)
        {
          uVar5 = 0;
          do
          {
            uVar5 = uVar5 + 1 & 0xff;
            if ((g_zbNwkCtx._46_1_ & 0xf) <= uVar5)
              goto LAB_0001b932;
          } while (g_zbNwkCtx.known_panids[uVar5] != uVar4);
        }
      }
    LAB_0001b932:
      if ((*(byte *)(in_r1 + 0x10) & 0x1f) != 0)
      {
        pbVar1 = *(byte **)(in_r1 + 0xc);
        if (uVar4 != (uint)pbVar1[1] * 0x100 + (uint)*pbVar1)
        {
          uVar5 = 0;
          do
          {
            uVar5 = uVar5 + 1 & 0xff;
            if ((*(byte *)(in_r1 + 0x10) & 0x1f) <= uVar5)
              goto LAB_0001b980;
          } while (uVar4 != (uint)pbVar1[uVar5 * 2] + (uint)pbVar1[uVar5 * 2 + 1] * 0x100);
        }
        goto LAB_0001b8ee;
      }
    LAB_0001b980:
    } while (uVar4 == 0);
    g_zbInfo.nwkNib.updateId = g_zbInfo.nwkNib.updateId + '\x01';
    uVar4 = tl_zbNwkUpdateForPanidConflict();
  }
  return uVar4;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkPanidConflictSetPanidStart(void)

{
  if (panidConflictTimerEvt == (ev_timer_event_t *)0x0)
  {
    panidConflictTimerEvt =
        ev_timer_taskPost(tl_zbNwkPanidConflictSetPanidCb, (void *)0x0,
                          g_zbInfo.nwkNib.nwkBroadcastDeliveryTime);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkUpdateCmdHandler(void)

{
  u16 uVar1;
  zb_buf_t *in_r0;
  int iVar2;
  int in_r1;
  int in_r2;

  if ((((-1 < (int)((uint)g_zbNwkCtx._46_1_ << 0x1a)) && ((*(byte *)(in_r2 + 0xe) & 0xe0) == 0)) &&
       (iVar2 = memcmp((void *)(in_r2 + 4), g_zbInfo.nwkNib.extPANId, 8), iVar2 == 0)) &&
      (((uVar1 = zdo_af_get_accept_nwk_update_pan_id(), uVar1 == 0 ||
                                                            (uVar1 = zdo_af_get_accept_nwk_update_pan_id(), uVar1 == 0xffff)) ||
        (uVar1 = zdo_af_get_accept_nwk_update_pan_id(), uVar1 == *(u16 *)(in_r2 + 0xc)))))
  {
    g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ | 0x20;
    g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x40;
    g_zbNwkCtx.new_panid._0_1_ = (undefined) * (undefined2 *)(in_r2 + 0xc);
    g_zbNwkCtx.new_panid._1_1_ = (undefined)((ushort) * (undefined2 *)(in_r2 + 0xc) >> 8);
    tl_zbNwkPanidConflictSetPanidStart();
    if (*(u16 *)(in_r1 + 2) == g_zbInfo.nwkNib.managerAddr)
    {
      g_zbInfo.nwkNib.updateId = *(u8 *)(in_r2 + 0xf);
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void tl_zbNwkNetworkUpdateCmdHandler(void)

{
  zb_buf_t *in_r0;
  int iVar1;
  ushort *in_r1;

  if (((*in_r1 & 0xfff8) == 0xfff8) && (*(char *)(in_r1 + 3) != '\0'))
  {
    nwkBrcTransJitterSet();
    iVar1 = nwkBrcTimerStart();
    if (iVar1 != 0)
    {
      iVar1 = nwkBrcTransEntryFind();
      if (iVar1 != 0)
      {
        nwkBrcTransTabEntryClear();
      }
      zb_buf_free(in_r0);
      return;
    }
  }
  nwkUpdateCmdHandler();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwk_panIdConflictCnfHandler(void)

{
  void *in_r0;

  g_zbInfo.nwkNib.panId = g_zbInfo.macPib.panId;
  tl_zbNwkBeaconPayloadUpdate();
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf;
  g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xbf;
  g_zbNwkCtx._46_1_ = g_zbNwkCtx._46_1_ & 0xd0;
  memset(g_zbNwkCtx.known_panids, 0, 0x10);
  tl_zbNwkNlmeNwkStatusInd(in_r0, g_zbInfo.nwkNib.managerAddr, 0xf);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkTxDataPendTabEntryRst(void)

{
  undefined *in_r0;

  *in_r0 = 0;
  in_r0[1] = 0;
  in_r0[2] = 0;
  in_r0[3] = 0;
  in_r0[4] = 0;
  in_r0[5] = 0;
  in_r0[6] = 0;
  in_r0[7] = 0;
  in_r0[8] = 0;
  in_r0[9] = 0;
  in_r0[10] = 0;
  in_r0[0xb] = 0;
  in_r0[6] = 0xfd;
  in_r0[7] = 0xfe;
  in_r0[4] = 0xfd;
  in_r0[5] = 0xfe;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkTxDataPendTabEntryClear(void)

{
  zb_buf_t *buf;
  zb_buf_t **in_r0;

  if ((in_r0 != (zb_buf_t **)0x0) && ((*(byte *)((int)in_r0 + 0xb) & 0x80) != 0))
  {
    buf = *in_r0;
    nwkTxDataPendTabEntryRst();
    if (buf != (zb_buf_t *)0x0)
    {
      zb_buf_free(buf);
    }
    g_txDataPendTabCnt = g_txDataPendTabCnt + -1;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkTxDataPendTabInit(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    nwkTxDataPendTabEntryRst();
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x10);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *nwkTxDataPendTabEntryFind(void)

{
  short in_r0;
  int iVar1;
  short in_r1;
  char in_r2;
  char *pcVar2;
  char in_r3;
  int iVar3;

  pcVar2 = g_txDataPendTab + 8;
  iVar3 = 0;
  while (true)
  {
    iVar1 = iVar3 * 0xc;
    if ((((*(short *)(g_txDataPendTab + iVar1 + 4) == in_r0) &&
          (*(short *)(g_txDataPendTab + iVar1 + 6) == in_r1)) &&
         (*pcVar2 == in_r2)) &&
        ((pcVar2[1] == in_r3 && ((g_txDataPendTab[iVar1 + 0xb] & 0x80) != 0))))
      break;
    iVar3 = iVar3 + 1;
    pcVar2 = pcVar2 + 0xc;
    if (iVar3 == 0x10)
    {
      return (undefined1 *)0x0;
    }
  }
  return g_txDataPendTab + iVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *nwkTxDataPendTabEntryRtDiscFind(void)

{
  short in_r0;
  int iVar1;
  char in_r1;
  char *pcVar2;
  int iVar3;

  pcVar2 = g_txDataPendTab + 10;
  iVar3 = 0;
  while (true)
  {
    iVar1 = iVar3 * 0xc;
    if (((*(short *)(g_txDataPendTab + iVar1 + 6) == in_r0) && (*pcVar2 == in_r1)) &&
        ((g_txDataPendTab[iVar1 + 0xb] & 0xc0) == 0xc0))
      break;
    iVar3 = iVar3 + 1;
    pcVar2 = pcVar2 + 0xc;
    if (iVar3 == 0x10)
    {
      return (undefined1 *)0x0;
    }
  }
  return g_txDataPendTab + iVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *nwkTxDataPendTabEntryCreate(void)

{
  undefined4 in_r0;
  undefined2 in_r1;
  int iVar1;
  undefined2 in_r2;
  undefined in_r3;
  int iVar2;
  undefined in_stack_00000000;

  iVar2 = 0;
  do
  {
    iVar1 = iVar2 * 0xc;
    if ((g_txDataPendTab[iVar1 + 0xb] & 0x80) == 0)
    {
      *(undefined4 *)(g_txDataPendTab + iVar1) = in_r0;
      *(undefined2 *)(g_txDataPendTab + iVar1 + 4) = in_r1;
      *(undefined2 *)(g_txDataPendTab + iVar1 + 6) = in_r2;
      g_txDataPendTab[iVar1 + 8] = in_r3;
      g_txDataPendTab[iVar1 + 9] = in_stack_00000000;
      g_txDataPendTab[iVar1 + 0xb] = g_txDataPendTab[iVar1 + 0xb] & 0xbf;
      g_txDataPendTab[iVar1 + 0xb] = g_txDataPendTab[iVar1 + 0xb] & 0xc0 | 0x3c;
      g_txDataPendTab[iVar1 + 0xb] = g_txDataPendTab[iVar1 + 0xb] | 0x7f;
      g_txDataPendTabCnt = g_txDataPendTabCnt + '\x01';
      return g_txDataPendTab + iVar1;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0x10);
  return (undefined1 *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void *nwkTxDataCachePacketCopy(void)

{
  byte bVar1;
  void *in_r0;
  void *out;
  int iVar2;
  undefined auStack_3c[5];
  byte bStack_37;
  int iStack_1c;

  out = in_r0;
  if (in_r0 != (void *)0x0)
  {
    out = (void *)c1();
    if (out == (void *)0x0)
    {
      out = (void *)0x0;
    }
    else
    {
      memcpy(out, in_r0, 0xc3);
      *(undefined *)((int)out + 0xc1) = 0xc0;
      memcpy(&iStack_1c, (void *)((int)in_r0 + 1), 4);
      iVar2 = (iStack_1c - ((uint)in_r0 & 0xff) & 0xff) + (int)out;
      *(char *)((int)out + 1) = (char)iVar2;
      *(char *)((int)out + 2) = (char)((uint)iVar2 >> 8);
      *(char *)((int)out + 3) = (char)((uint)iVar2 >> 0x10);
      *(char *)((int)out + 4) = (char)((uint)iVar2 >> 0x18);
      memcpy(auStack_3c, (void *)((int)in_r0 + 5), 0x20);
      bVar1 = *(byte *)((int)in_r0 + 0x21);
      if ((int)((uint)bStack_37 << 0x1d) < 0)
      {
        memcpy((void *)((int)out + 5), auStack_3c, 0x20);
        iVar2 = (int)out + ((uint)bVar1 - ((uint)in_r0 & 0xff) & 0xff);
        *(char *)((int)out + 0x21) = (char)iVar2;
        *(char *)((int)out + 0x22) = (char)((uint)iVar2 >> 8);
        *(char *)((int)out + 0x23) = (char)((uint)iVar2 >> 0x10);
        *(char *)((int)out + 0x24) = (char)((uint)iVar2 >> 0x18);
      }
    }
  }
  return out;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int nwkTxDataPendTabEntryAdd(void)

{
  undefined *in_r0;
  int iVar1;
  zb_buf_t *buf;
  void *in_r1;
  undefined4 in_r2;
  undefined in_r3;

  iVar1 = nwkTxDataPendTabEntryFind();
  if (iVar1 == 0)
  {
    *in_r0 = in_r3;
    in_r0[1] = (char)in_r2;
    in_r0[2] = (char)((uint)in_r2 >> 8);
    in_r0[3] = (char)((uint)in_r2 >> 0x10);
    in_r0[4] = (char)((uint)in_r2 >> 0x18);
    memcpy(in_r0 + 5, in_r1, 0x20);
    buf = (zb_buf_t *)nwkTxDataCachePacketCopy();
    if (buf != (zb_buf_t *)0x0)
    {
      iVar1 = nwkTxDataPendTabEntryCreate();
      if (iVar1 == 0)
      {
        zb_buf_free(buf);
      }
    }
  }
  return iVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwk_permitJoinTimeout(void)

{
  g_zbInfo.macPib.associationPermit = '\0';
  g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xfd;
  permitJoinTimerEvt = 0;
  return 0xfffffffe;
}

void tl_zbNwkNlmePermitJoiningRequestHandler(void *arg)

{
  if (((int)((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1e) < 0) &&
      ((g_zbNwkCtx._45_1_ & 0x84) == 0x84))
  {
    if (permitJoinTimerEvt != (ev_timer_event_t *)0x0)
    {
      ev_timer_taskCancel(&permitJoinTimerEvt);
    }
    // WARNING: Load size is inaccurate
    g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xfd | ('\x01' - (*arg == '\0')) * '\x02';
    // WARNING: Load size is inaccurate
    g_zbInfo.macPib.associationPermit = *arg;
    if (g_zbInfo.macPib.associationPermit != '\0')
    {
      if (g_zbInfo.macPib.associationPermit == 0xff)
      {
        g_zbInfo.macPib.associationPermit = '\x01';
      }
      else
      {
        g_zbInfo.macPib.associationPermit = '\x01';
        // WARNING: Load size is inaccurate
        permitJoinTimerEvt = ev_timer_taskPost(nwk_permitJoinTimeout, (void *)0x0, (uint)*arg * 1000);
      }
    }
    tl_zbNwkBeaconPayloadUpdate();
    *(undefined *)arg = 0;
    tl_zbTaskPost(zdo_nlmePermitJoinCnf, arg);
  }
  else
  {
    *(undefined *)arg = 0xc2;
    tl_zbTaskPost(zdo_nlmePermitJoinCnf, arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkDiscDataPendSend(void)

{
  void **ppvVar1;
  undefined4 uVar2;

  ppvVar1 = (void **)nwkTxDataPendTabEntryRtDiscFind();
  uVar2 = 0xd3;
  if (ppvVar1 != (void **)0x0)
  {
    do
    {
      *(undefined *)((int)*ppvVar1 + 0xc1) = *(undefined *)(ppvVar1 + 2);
      *(byte *)((int)ppvVar1 + 0xb) = *(byte *)((int)ppvVar1 + 0xb) & 0xbf;
      tl_zbTaskPost(nwkMsgSendCb, *ppvVar1);
      *(undefined *)ppvVar1 = 0;
      *(undefined *)((int)ppvVar1 + 1) = 0;
      *(undefined *)((int)ppvVar1 + 2) = 0;
      *(undefined *)((int)ppvVar1 + 3) = 0;
      nwkTxDataPendTabEntryClear();
      ppvVar1 = (void **)nwkTxDataPendTabEntryRtDiscFind();
    } while (ppvVar1 != (void **)0x0);
    uVar2 = 0;
  }
  return uVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkDiscDataPendClear(void)

{
  zb_buf_t **ppzVar1;
  undefined4 uVar2;

  ppzVar1 = (zb_buf_t **)nwkTxDataPendTabEntryRtDiscFind();
  uVar2 = 0xd3;
  if (ppzVar1 != (zb_buf_t **)0x0)
  {
    do
    {
      if (*(byte *)(ppzVar1 + 2) < 0xc0)
      {
        nwkNldeDataCnf();
      }
      else
      {
        zb_buf_free(*ppzVar1);
      }
      *(undefined *)ppzVar1 = 0;
      *(undefined *)((int)ppzVar1 + 1) = 0;
      *(undefined *)((int)ppzVar1 + 2) = 0;
      *(undefined *)((int)ppzVar1 + 3) = 0;
      nwkTxDataPendTabEntryClear();
      ppzVar1 = (zb_buf_t **)nwkTxDataPendTabEntryRtDiscFind();
    } while (ppzVar1 != (zb_buf_t **)0x0);
    uVar2 = 0;
  }
  return uVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteDiscTabEntryRst(void)

{
  void *in_r0;

  memset(in_r0, 0, 0x16);
  *(undefined *)((int)in_r0 + 0xc) = 0xfd;
  *(undefined *)((int)in_r0 + 0xd) = 0xfe;
  *(undefined *)((int)in_r0 + 10) = 0xfd;
  *(undefined *)((int)in_r0 + 0xb) = 0xfe;
  *(undefined *)((int)in_r0 + 8) = 0xfd;
  *(undefined *)((int)in_r0 + 9) = 0xfe;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteDiscTabEntryClear(void)

{
  int *in_r0;

  if ((in_r0 != (int *)0x0) && (*(char *)((int)in_r0 + 0x15) != '\0'))
  {
    if (in_r0[1] != 0)
    {
      ev_timer_taskCancel((ev_timer_event_t **)(in_r0 + 1));
    }
    if (*in_r0 != 0)
    {
      sys_exceptionPost(0x46, '4');
    }
    nwkRouteDiscTabEntryRst();
    g_routeDiscTabCnt = g_routeDiscTabCnt + -1;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteDiscTabInit(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    nwkRouteDiscTabEntryRst();
    iVar1 = iVar1 + 1;
  } while (iVar1 != 10);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *nwkRouteDiscEntryFind(void)

{
  short in_r0;
  char in_r1;
  char *pcVar1;
  int iVar2;

  pcVar1 = g_routeDiscTab + 0x10;
  iVar2 = 0;
  while (((*(short *)(g_routeDiscTab + iVar2 * 0x16 + 8) != in_r0 || (*pcVar1 != in_r1)) ||
          (pcVar1[5] == '\0')))
  {
    iVar2 = iVar2 + 1;
    pcVar1 = pcVar1 + 0x16;
    if (iVar2 == 10)
    {
      return (undefined1 *)0x0;
    }
  }
  return g_routeDiscTab + iVar2 * 0x16;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *nwkRouteDiscEntryDstFind(void)

{
  short in_r0;
  char *pcVar1;
  int iVar2;

  pcVar1 = g_routeDiscTab + 0x15;
  iVar2 = 0;
  while ((*(short *)(g_routeDiscTab + iVar2 * 0x16 + 0xc) != in_r0 || (*pcVar1 == '\0')))
  {
    iVar2 = iVar2 + 1;
    pcVar1 = pcVar1 + 0x16;
    if (iVar2 == 10)
    {
      return (undefined1 *)0x0;
    }
  }
  return g_routeDiscTab + iVar2 * 0x16;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *nwkManyToOneRouteDiscEntryInitFind(void)

{
  int iVar1;
  int iVar2;

  iVar2 = 0;
  while (true)
  {
    iVar1 = iVar2 * 0x16;
    if ((*(short *)(g_routeDiscTab + iVar1 + 0xc) == -4) &&
        (*(u16 *)(g_routeDiscTab + iVar1 + 8) == g_zbInfo.nwkNib.nwkAddr))
      break;
    iVar2 = iVar2 + 1;
    if (iVar2 == 10)
    {
      return (undefined1 *)0x0;
    }
  }
  return g_routeDiscTab + iVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *nwkRouteDiscEntryCreate(void)

{
  undefined2 in_r0;
  undefined2 in_r1;
  undefined2 in_r2;
  undefined in_r3;
  int iVar1;
  char *pcVar2;
  int iVar3;
  undefined in_stack_00000000;
  undefined in_stack_00000004;

  pcVar2 = g_routeDiscTab + 0x15;
  iVar1 = 0;
  do
  {
    iVar3 = iVar1 * 0x16;
    if (*pcVar2 == '\0')
    {
      *(undefined2 *)(g_routeDiscTab + iVar3) = 0;
      *(undefined2 *)(g_routeDiscTab + iVar3 + 2) = 0;
      *(undefined2 *)(g_routeDiscTab + iVar3 + 4) = 0;
      *(undefined2 *)(g_routeDiscTab + iVar3 + 6) = 0;
      *(undefined2 *)(g_routeDiscTab + iVar3 + 8) = in_r0;
      *(undefined2 *)(g_routeDiscTab + iVar3 + 0xc) = in_r1;
      *(undefined2 *)(g_routeDiscTab + iVar3 + 10) = in_r2;
      g_routeDiscTab[iVar3 + 0x10] = in_stack_00000004;
      g_routeDiscTab[iVar3 + 0x11] = in_r3;
      g_routeDiscTab[iVar3 + 0x12] = 0xff;
      g_routeDiscTab[iVar3 + 0x13] = in_stack_00000000;
      *(undefined2 *)(g_routeDiscTab + iVar3 + 0xe) = 10;
      g_routeDiscTab[iVar3 + 0x14] = 0;
      g_routeDiscTab[iVar3 + 0x15] = 1;
      g_routeDiscTabCnt = g_routeDiscTabCnt + '\x01';
      return g_routeDiscTab + iVar3;
    }
    iVar1 = iVar1 + 1;
    pcVar2 = pcVar2 + 0x16;
  } while (iVar1 != 10);
  return (undefined1 *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteReqCmdSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;
  u8 size;

  size = '\x06';
  if ((int)((uint)(byte)in_r2[0xc] << 0x1a) < 0)
  {
    size = '\x0e';
  }
  puVar1 = (undefined *)tl_bufInitalloc(in_r0, size);
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[0xc];
  puVar1[2] = in_r2[0xd];
  memcpy(puVar1 + 3, in_r2 + 0xe, 2);
  puVar1[5] = in_r2[0x10];
  if ((int)((uint)(byte)in_r2[0xc] << 0x1a) < 0)
  {
    memcpy(puVar1 + 6, in_r2 + 4, 8);
  }
  (in_r0->hdr).handle = in_r3;
  nwk_fwdPacket();
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkRouteReqRetry(void)

{
  byte bVar1;
  u8 uVar2;
  zb_buf_t **in_r0;
  void *out;
  undefined4 uVar3;
  undefined auStack_54[32];
  undefined4 local_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined2 local_1c;
  undefined local_1a;

  uVar2 = NWKC_RREQ_RETRIES;
  local_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  local_1c = 0;
  local_1a = 0;
  bVar1 = *(byte *)(in_r0 + 5);
  *(byte *)(in_r0 + 5) = bVar1 + 1;
  if (uVar2 < bVar1)
  {
    if (*in_r0 != (zb_buf_t *)0x0)
    {
      zb_buf_free(*in_r0);
      *(undefined *)in_r0 = 0;
      *(undefined *)((int)in_r0 + 1) = 0;
      *(undefined *)((int)in_r0 + 2) = 0;
      *(undefined *)((int)in_r0 + 3) = 0;
    }
    *(undefined *)(in_r0 + 1) = 0;
    *(undefined *)((int)in_r0 + 5) = 0;
    *(undefined *)((int)in_r0 + 6) = 0;
    *(undefined *)((int)in_r0 + 7) = 0;
    uVar3 = 0xfffffffe;
  }
  else
  {
    uVar3 = 0xfe;
    if ((*in_r0 != (zb_buf_t *)0x0) && (out = (void *)c1(), out != (void *)0x0))
    {
      memcpy(out, *in_r0, 0xc3);
      memcpy(auStack_54, out, 0x20);
      memcpy(&uStack_30, (void *)((int)out + 0x20), 0xd);
      local_34 = CONCAT31(local_34._1_3_, 1);
      uStack_24 = uStack_24 & 0xffffff00 | (uint) * (byte *)((int)in_r0 + 0x11);
      nwkRouteReqCmdSend();
    }
  }
  return uVar3;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkRouteReqInitialRetry(void)

{
  byte bVar1;
  u8 uVar2;
  zb_buf_t **in_r0;
  void *out;
  undefined4 uVar3;
  undefined auStack_54[32];
  undefined4 local_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined2 local_1c;
  undefined local_1a;

  uVar2 = NWKC_INITIAL_RREQ_RETRIES;
  local_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  local_1c = 0;
  local_1a = 0;
  bVar1 = *(byte *)(in_r0 + 5);
  *(byte *)(in_r0 + 5) = bVar1 + 1;
  if (uVar2 < bVar1)
  {
    if (*in_r0 != (zb_buf_t *)0x0)
    {
      zb_buf_free(*in_r0);
      *(undefined *)in_r0 = 0;
      *(undefined *)((int)in_r0 + 1) = 0;
      *(undefined *)((int)in_r0 + 2) = 0;
      *(undefined *)((int)in_r0 + 3) = 0;
    }
    *(undefined *)(in_r0 + 1) = 0;
    *(undefined *)((int)in_r0 + 5) = 0;
    *(undefined *)((int)in_r0 + 6) = 0;
    *(undefined *)((int)in_r0 + 7) = 0;
    uVar3 = 0xfffffffe;
  }
  else
  {
    uVar3 = 0;
    if ((*in_r0 != (zb_buf_t *)0x0) && (out = (void *)c1(), out != (void *)0x0))
    {
      memcpy(out, *in_r0, 0xc3);
      memcpy(auStack_54, out, 0x20);
      memcpy(&uStack_30, (void *)((int)out + 0x20), 0xd);
      local_34 = CONCAT31(local_34._1_3_, 1);
      uStack_24 = uStack_24 & 0xffffff00 | (uint) * (byte *)((int)in_r0 + 0x11);
      nwkRouteReqCmdSend();
    }
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteReplyCmdSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *out;
  char cVar2;
  undefined *in_r2;
  u8 in_r3;
  uint uVar3;

  cVar2 = '\b';
  if ((int)((uint)(byte)in_r2[0x18] << 0x1b) < 0)
  {
    cVar2 = '\x10';
  }
  puVar1 = (undefined *)
      tl_bufInitalloc(in_r0, (char)((int)((uint)(byte)in_r2[0x18] << 0x1a) >> 0x1f) * -8 + cVar2);
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[0x18];
  puVar1[2] = in_r2[0x19];
  memcpy(puVar1 + 3, in_r2 + 0x14, 2);
  memcpy(puVar1 + 5, in_r2 + 0x16, 2);
  puVar1[7] = in_r2[0x1a];
  out = puVar1 + 8;
  uVar3 = (uint)(byte)in_r2[0x18];
  if ((int)(uVar3 << 0x1b) < 0)
  {
    memcpy(out, in_r2 + 4, 8);
    out = puVar1 + 0x10;
    uVar3 = (uint)(byte)in_r2[0x18];
  }
  if ((int)(uVar3 << 0x1a) < 0)
  {
    memcpy(out, in_r2 + 0xc, 8);
  }
  (in_r0->hdr).handle = in_r3;
  nwk_tx();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteRecordCmdSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  undefined *in_r2;
  u8 in_r3;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, (in_r2[8] + '\x01') * '\x02');
  *puVar1 = *in_r2;
  puVar1[1] = in_r2[8];
  memcpy(puVar1 + 2, *(void **)(in_r2 + 4), (uint)(byte)in_r2[8] << 1);
  (in_r0->hdr).handle = in_r3;
  nwk_fwdPacket();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void *nwkRouteDiscCachePacketCopy(void)

{
  void *in_r0;
  void *out;
  void *in_r1;
  void *in_r2;

  out = (void *)c1();
  if (out != (void *)0x0)
  {
    memcpy(out, in_r0, 0xc3);
    memcpy(out, in_r1, 0x20);
    memcpy((void *)((int)out + 0x20), in_r2, 0xd);
    *(undefined *)((int)out + 0xc1) = 0xca;
  }
  return out;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteReqConcentInitiation(void)

{
  u8 uVar1;
  u8 uVar2;
  bool bVar3;
  uint uVar4;
  int iVar5;
  u16 *in_r1;
  int in_r2;
  byte bVar6;
  byte bVar7;
  char cVar8;
  undefined uVar9;
  undefined uVar10;
  u16 uVar11;
  u8 uVar12;
  undefined4 uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  u8 *puStack_3c;
  undefined4 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  uint uStack_2c;
  uint uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  undefined local_1e;

  bVar6 = 0;
  bVar7 = 0;
  uStack_48 = 0;
  uStack_44 = 0;
  uStack_40 = 0;
  puStack_3c = (u8 *)0x0;
  local_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  local_20 = 0;
  local_1e = 0;
  uVar4 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar3 = ss_keyPreconfigured();
    uVar4 = (uint)(bVar3 != false);
  }
  bVar6 = bVar6 & 0xc0 | 9;
  bVar7 = bVar7 & 0xfd | (byte)(uVar4 << 1) | 0x10;
  uVar9 = 0xfb;
  uVar10 = 0xff;
  uVar11 = g_zbInfo.nwkNib.nwkAddr;
  memcpy(&uStack_48, g_zbInfo.macPib.extAddress, 8);
  uVar2 = g_zbInfo.nwkNib.concentratorRadius;
  if (*(char *)(in_r1 + 1) != '\0')
  {
    uVar2 = *(u8 *)((int)in_r1 + 3);
  }
  if (uVar2 == '\0')
  {
    uVar2 = (u8)(((uint)g_zbInfo.nwkNib.maxDepth << 0x19) >> 0x18);
  }
  uVar12 = g_zbInfo.nwkNib.seqNum;
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar1 = getNwkHdrSize((nwk_hdr_t *)&stack0xffffffa8);
  uStack_40._0_2_ = CONCAT11(uVar1, uStack_40._0_1_);
  uStack_40 = uStack_40 & 0xffff0000 | (uint)(ushort)uStack_40;
  local_38 = CONCAT31(local_38._1_3_, 1);
  cVar8 = *(char *)(in_r1 + 1);
  if (cVar8 == '\0')
  {
    uStack_2c = (uint)(byte)((byte)uStack_2c & 0xe7 |
                             (byte)((2 - ((uint) * (byte *)(in_r1 + 2) + ~(uint) * (byte *)(in_r1 + 2) +
                                          1) &
                                     3)
                                    << 3));
  }
  else if (cVar8 == '\x02')
  {
    uVar2 = zb_address_ieee_by_short(*in_r1, (addrExt_t)
                                                 CONCAT17(uVar12, CONCAT16(uVar2, CONCAT15(bVar7, CONCAT14(bVar6, CONCAT22(
                                                                                                                      uVar11, CONCAT11(uVar10, uVar9)))))));
    if (((uVar2 == '\0') && (iVar5 = memcmp(&uStack_34, &g_zero_addr, 8), iVar5 != 0)) &&
        (iVar5 = memcmp(&uStack_34, &g_invalid_addr, 8), iVar5 != 0))
    {
      uStack_2c = (uint)((byte)uStack_2c | 0x20);
    }
    cVar8 = *(char *)(in_r1 + 1);
  }
  uStack_2c = CONCAT22(*(undefined2 *)(in_r2 + 0xc),
                       CONCAT11(*(undefined *)(in_r2 + 0x10),
                                (byte)uStack_2c & 0xbf |
                                    ((cVar8 - 1U) + ~(cVar8 - 1U) + (cVar8 != '\0')) * '@'));
  uStack_28 = uStack_28 & 0xffffff00;
  nwkRouteReqCmdSend();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkConcentDiscTimerCb(void)

{
  zb_buf_t *buf;
  int iVar1;
  undefined4 uVar2;

  if (g_zbInfo.nwkNib.concentratorDiscoveryTime == '\0')
  {
    concentratorDiscoveryTimer = 0;
    uVar2 = 0xfffffffe;
  }
  else
  {
    buf = (zb_buf_t *)c1();
    uVar2 = 0;
    if (buf != (zb_buf_t *)0x0)
    {
      iVar1 = nwkManyToOneRouteDiscEntryInitFind();
      if (iVar1 == 0)
      {
        g_routeReqId = g_routeReqId + '\x01';
        iVar1 = nwkRouteDiscEntryCreate();
        if (iVar1 == 0)
        {
          zb_buf_free(buf);
          return 0;
        }
      }
      else
      {
        *(char *)(iVar1 + 0x10) = g_routeReqId;
        g_routeReqId = g_routeReqId + '\x01';
        *(undefined *)(iVar1 + 0xe) = 10;
        *(undefined *)(iVar1 + 0xf) = 0;
      }
      nwkRouteReqConcentInitiation();
      uVar2 = 0;
    }
  }
  return uVar2;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteReplySend(void)

{
  u8 uVar1;
  bool bVar2;
  uint uVar3;
  char in_r1;
  byte in_r2;
  undefined2 in_stack_00000004;
  nwk_hdr_t local_60;
  undefined4 local_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  ushort local_28;
  undefined local_26;

  local_60._0_4_ = 0;
  local_60._4_4_ = 0;
  local_60.dstIeeeAddr._0_4_ = 0;
  local_60.dstIeeeAddr._4_4_ = 0;
  local_60.srcIeeeAddr._0_4_ = 0;
  local_60.srcIeeeAddr._4_4_ = 0;
  local_60._24_4_ = 0;
  local_60.srcRouteSubFrame.relayList = (u8 *)0x0;
  local_40 = 0;
  uStack_3c = 0;
  uStack_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  local_28 = 0;
  local_26 = 0;
  uVar3 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar2 = ss_keyPreconfigured();
    uVar3 = (uint)(bVar2 != false);
  }
  local_60._0_4_ = CONCAT22(g_zbInfo.nwkNib.nwkAddr, in_stack_00000004);
  if (in_r1 == '\0')
  {
    in_r1 = '\x01';
  }
  local_60._4_4_ =
      CONCAT13(g_zbInfo.nwkNib.seqNum,
               CONCAT12(in_r1, CONCAT11((byte)(local_60._4_4_ >> 8) & 0xfd | (byte)(uVar3 << 1),
                                        (char)local_60._4_4_))) &
          0xffffffc0 |
      9;
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar1 = getNwkHdrSize(&local_60);
  local_60._24_2_ = CONCAT11(uVar1, local_60.mcaseControl);
  local_60._24_4_ = local_60._24_4_ & 0xffff0000 | (uint)local_60._24_2_;
  local_40 = CONCAT31(local_40._1_3_, 2);
  local_28 = local_28 & 0xff | (ushort)in_r2 << 8;
  nwkRouteReplyCmdSend();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteReplySendDelay(void)

{
  int in_r0;
  undefined local_26[2];
  undefined local_24[2];
  undefined local_22[2];

  memcpy(local_22, (void *)(in_r0 + 2), 2);
  memcpy(local_24, (void *)(in_r0 + 4), 2);
  memcpy(local_26, (void *)(in_r0 + 6), 2);
  nwkRouteReplySend();
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 nwkRouteDiscStart(void)

{
  u8 uVar1;
  bool bVar2;
  u16 *in_r0;
  zb_buf_t *buf;
  uint uVar3;
  int iVar4;
  ev_timer_event_t *peVar5;
  char *pcVar6;
  byte bVar7;
  int iVar8;
  char cVar9;
  undefined4 uVar10;
  int iVar11;
  undefined1 *arg;
  undefined4 in_stack_ffffff9c;
  undefined4 in_stack_ffffffa0;
  nwk_hdr_t local_5c;
  undefined4 local_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  uint uStack_30;
  uint uStack_2c;
  undefined4 uStack_28;
  undefined2 local_24;
  undefined local_22;

  g_sysDiags.routeDiscInitiated = g_sysDiags.routeDiscInitiated + 1;
  buf = (zb_buf_t *)c1();
  if (buf == (zb_buf_t *)0x0)
  {
    return 0xd1;
  }
  local_5c._0_4_ = 0;
  local_5c._4_4_ = 0;
  local_5c.dstIeeeAddr._0_4_ = 0;
  local_5c.dstIeeeAddr._4_4_ = 0;
  local_5c.srcIeeeAddr._0_4_ = 0;
  local_5c.srcIeeeAddr._4_4_ = 0;
  local_5c._24_4_ = 0;
  local_5c.srcRouteSubFrame.relayList = (u8 *)0x0;
  local_3c = 0;
  uStack_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  local_24 = 0;
  local_22 = 0;
  if ((*(u8 *)((int)in_r0 + 3) != '\0') ||
      (uVar1 = g_zbInfo.nwkNib.concentratorRadius, *(char *)(in_r0 + 1) != '\0'))
  {
    uVar1 = *(u8 *)((int)in_r0 + 3);
  }
  uVar3 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar2 = ss_keyPreconfigured();
    uVar3 = (uint)(bVar2 != false);
  }
  local_5c.framecontrol =
      (nwkFrameCtrl_t)(CONCAT11((byte)(local_5c._4_4_ >> 8) & 0xfd | (byte)(uVar3 << 1), (char)local_5c._4_4_) &
                           0xffc0 |
                       9);
  local_5c._4_4_ = local_5c._4_4_ & 0xffff0000 | (uint)(ushort)local_5c.framecontrol;
  local_5c._4_4_ = local_5c._4_4_ | 0x1000;
  local_5c._0_4_ = CONCAT22(g_zbInfo.nwkNib.nwkAddr, 0xfffb);
  memcpy(local_5c.srcIeeeAddr, g_zbInfo.macPib.extAddress, 8);
  if (uVar1 == '\0')
  {
    uVar1 = (u8)(((uint)g_zbInfo.nwkNib.maxDepth << 0x19) >> 0x18);
  }
  local_5c._4_4_ = CONCAT13(g_zbInfo.nwkNib.seqNum, CONCAT12(uVar1, (short)local_5c._4_4_));
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar1 = getNwkHdrSize(&local_5c);
  local_5c._24_2_ = CONCAT11(uVar1, local_5c.mcaseControl);
  local_5c._24_4_ = local_5c._24_4_ & 0xffff0000 | (uint)local_5c._24_2_;
  local_3c = CONCAT31(local_3c._1_3_, 1);
  cVar9 = *(char *)(in_r0 + 1);
  if (cVar9 == '\0')
  {
    uStack_30 = uStack_30 & 0xffffff00 |
                (byte)((byte)uStack_30 & 0xe7 |
                       (byte)((2 - ((uint) * (byte *)(in_r0 + 2) + ~(uint) * (byte *)(in_r0 + 2) + 1) & 3) << 3)) &
                    0xffffffbf;
    uStack_2c = uStack_2c & 0xffffff00;
  LAB_0001cad8:
    iVar4 = nwkManyToOneRouteDiscEntryInitFind();
    cVar9 = g_routeReqId;
    if (iVar4 == 0)
    {
      g_routeReqId = g_routeReqId + '\x01';
      iVar4 = nwkRouteDiscEntryCreate();
      if (iVar4 == 0)
        goto LAB_0001cc36;
      cVar9 = *(char *)(iVar4 + 0x10);
    }
    else
    {
      *(char *)(iVar4 + 0x10) = g_routeReqId;
      g_routeReqId = g_routeReqId + '\x01';
      *(undefined *)(iVar4 + 0xe) = 10;
      *(undefined *)(iVar4 + 0xf) = 0;
    }
    uStack_30._0_2_ = CONCAT11(cVar9, (byte)uStack_30);
    uStack_30 = CONCAT22(*(undefined2 *)(iVar4 + 0xc), (undefined2)uStack_30);
    nwkRouteReqCmdSend();
    if (concentratorDiscoveryTimer != (ev_timer_event_t *)0x0)
    {
      ev_timer_taskCancel(&concentratorDiscoveryTimer);
    }
    uVar10 = 0;
    if (g_zbInfo.nwkNib.concentratorDiscoveryTime != 0)
    {
      concentratorDiscoveryTimer =
          ev_timer_taskPost(nwkConcentDiscTimerCb, (void *)(uint) * (byte *)(in_r0 + 2),
                            (uint)g_zbInfo.nwkNib.concentratorDiscoveryTime * 1000);
    }
  }
  else
  {
    if (cVar9 == '\x02')
    {
      uVar1 = zb_address_ieee_by_short(*in_r0, (addrExt_t)CONCAT44(in_stack_ffffffa0, in_stack_ffffff9c));
      if (((uVar1 == '\0') && (iVar4 = memcmp(&uStack_38, &g_zero_addr, 8), iVar4 != 0)) &&
          (iVar4 = memcmp(&uStack_38, &g_invalid_addr, 8), iVar4 != 0))
      {
        uStack_30 = uStack_30 | 0x20;
      }
      cVar9 = *(char *)(in_r0 + 1);
      uStack_30 = uStack_30 & 0xffffff00 |
                  (uint)(byte)((byte)uStack_30 & 0xbf |
                               ((cVar9 - 1U) + ~(cVar9 - 1U) + (cVar9 != '\0')) * '@');
      uStack_2c = uStack_2c & 0xffffff00;
      if (cVar9 == '\0')
        goto LAB_0001cad8;
    }
    else
    {
      uStack_30 = uStack_30 & 0xffffff00 |
                  (uint)(byte)((byte)uStack_30 & 0xbf |
                               ((cVar9 - 1U) + ~(cVar9 - 1U) + (cVar9 != '\0')) * '@');
      uStack_2c = uStack_2c & 0xffffff00;
    }
    iVar4 = nwkRoutingTabEntryDstFind();
    if (iVar4 == 0)
    {
    LAB_0001cb70:
      iVar4 = nwkRoutingTabEntryCreate();
      if (iVar4 == 0)
        goto LAB_0001cc36;
      bVar7 = *(char *)(in_r0 + 1) - 1;
      *(byte *)(iVar4 + 5) =
          *(byte *)(iVar4 + 5) & 0xf7 | (bVar7 + ~bVar7 + (*(char *)(in_r0 + 1) != '\0')) * '\b';
    }
    else
    {
      if ((int)((uint) * (byte *)(iVar4 + 5) << 0x1c) < 0)
      {
        if (*(char *)(in_r0 + 1) != '\x01')
          goto LAB_0001cb70;
      }
      else if (*(char *)(in_r0 + 1) != '\x02')
        goto LAB_0001cb70;
      if ((*(char *)(iVar4 + 4) != '\x04') && (*(char *)(iVar4 + 4) != '\0'))
      {
        *(undefined *)(iVar4 + 4) = 1;
      }
      *(byte *)(iVar4 + 5) = *(byte *)(iVar4 + 5) & 0xf;
    }
    pcVar6 = g_routeDiscTab + 0x15;
    iVar8 = 0;
    do
    {
      iVar11 = iVar8 * 0x16;
      arg = g_txDataPendTab + iVar11 + 0xbf;
      if ((*(u16 *)(g_routeDiscTab + iVar11 + 0xb) == *in_r0) && (*pcVar6 != '\0'))
      {
        if (*(int *)(g_routeDiscTab + iVar11 + 3) != 0)
        {
          zb_buf_free(buf);
          return 0;
        }
        nwkDiscDataPendClear();
        cVar9 = g_routeReqId;
        g_routeDiscTab[iVar11 + 0xf] = g_routeReqId;
        g_routeReqId = g_routeReqId + '\x01';
        g_routeDiscTab[iVar11 + 0xd] = 10;
        g_routeDiscTab[iVar11 + 0xe] = 0;
        g_routeDiscTab[iVar11 + 0x13] = 0;
        g_routeDiscTab[iVar11 + 0x10] = 0;
        g_routeDiscTab[iVar11 + 0x11] = 0xff;
        goto LAB_0001cd2c;
      }
      iVar8 = iVar8 + 1;
      pcVar6 = pcVar6 + 0x16;
    } while (iVar8 != 10);
    g_routeReqId = g_routeReqId + '\x01';
    arg = (undefined1 *)nwkRouteDiscEntryCreate();
    if (arg != (undefined1 *)0x0)
    {
      cVar9 = arg[0x10];
    LAB_0001cd2c:
      uStack_30._0_2_ = CONCAT11(cVar9, (byte)uStack_30);
      uStack_30 = CONCAT22(*(undefined2 *)(arg + 0xc), (undefined2)uStack_30);
      nwkRouteReqCmdSend();
      if (NWKC_INITIAL_RREQ_RETRIES == '\0')
      {
        return 0;
      }
      uVar1 = ev_timer_enough();
      if (uVar1 == '\0')
      {
        return 0;
      }
      iVar4 = nwkRouteDiscCachePacketCopy();
      if (iVar4 == 0)
      {
        return 0;
      }
      *arg = (char)iVar4;
      arg[1] = (char)((uint)iVar4 >> 8);
      arg[2] = (char)((uint)iVar4 >> 0x10);
      arg[3] = (char)((uint)iVar4 >> 0x18);
      peVar5 = ev_timer_taskPost(nwkRouteReqInitialRetry, arg, 0xfe);
      arg[4] = (char)peVar5;
      arg[5] = (char)((uint)peVar5 >> 8);
      arg[6] = (char)((uint)peVar5 >> 0x10);
      arg[7] = (char)((uint)peVar5 >> 0x18);
      return 0;
    }
    if (*(char *)(iVar4 + 4) == '\x01')
    {
      *(undefined *)(iVar4 + 4) = 3;
    }
  LAB_0001cc36:
    zb_buf_free(buf);
    uVar10 = 0xd1;
  }
  return uVar10;
}

void tl_zbNwkNlmeRouteDiscRequestHandler(void *arg)

{
  undefined uVar1;
  aps_group_tbl_ent_t *paVar2;
  undefined uVar3;
  u16 local_18;
  char cStack_16;

  memcpy(&local_18, arg, 5);
  if ((int)((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1e) < 0)
  {
    if (cStack_16 != '\0')
    {
      if ((local_18 & 0xfff8) == 0xfff8)
      {
        uVar3 = 0xc;
        uVar1 = 0xc2;
        goto LAB_0001ce20;
      }
      if (cStack_16 == '\x02')
      {
        if (local_18 == g_zbInfo.nwkNib.nwkAddr)
          goto LAB_0001ce0a;
      }
      else if ((cStack_16 == '\x01') &&
               (paVar2 = aps_group_search_by_addr(local_18), paVar2 != (aps_group_tbl_ent_t *)0x0))
      {
      LAB_0001ce0a:
        uVar3 = 0;
        uVar1 = 0;
        goto LAB_0001ce20;
      }
    LAB_0001ce18:
      uVar1 = nwkRouteDiscStart();
      uVar3 = 0;
      goto LAB_0001ce20;
    }
    if ((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1b) < 0)
      goto LAB_0001ce18;
  }
  uVar3 = 4;
  uVar1 = 0xc2;
LAB_0001ce20:
  *(undefined *)arg = uVar1;
  *(undefined *)((int)arg + 1) = uVar3;
  tl_zbTaskPost(zdo_routeDiscCnf, arg);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int nwkRouteReqDstChk(void)

{
  u16 in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;

  iVar2 = 1;
  if (g_zbInfo.nwkNib.nwkAddr != in_r0)
  {
    ptVar1 = nwk_neTblGetByShortAddr(in_r0);
    iVar2 = 0;
    if (ptVar1 != (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      uVar3 = (byte)ptVar1->field_0x1e & 0x7e;
      uVar4 = uVar3 - 0x14;
      iVar2 = uVar4 + ~uVar4 + (uint)(0x13 < uVar3);
    }
  }
  return iVar2;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 nwkRouteReqCmdHandler(void)

{
  byte bVar1;
  void *out;
  undefined2 uVar2;
  byte bVar3;
  u8 uVar4;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar5;
  void **ppvVar6;
  undefined *arg;
  int iVar7;
  u32 uVar8;
  ev_timer_event_t *peVar9;
  void *in_r1;
  uint uVar10;
  int in_r2;
  byte bVar11;
  undefined *puVar12;
  byte bVar13;
  undefined uStack_34;
  int iStack_2c;
  undefined2 local_26;

  local_26 = *(u16 *)(in_r0->buf + 0x14);
  bVar3 = in_r0->buf[0x27];
  ptVar5 = nwk_neTblGetByShortAddr(local_26);
  if (ptVar5 != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    bVar3 = (byte)((uint)bVar3 + (uint)ptVar5->lqi >> 1);
    ptVar5->lqi = bVar3;
  }
  bVar3 = rf_lqi2cost(bVar3);
  if (NWK_COST_THRESHOLD_ONEHOP < bVar3)
    goto LAB_0001d064;
  bVar11 = g_zbInfo.nwkNib._45_1_ & 2;
  bVar13 = bVar3;
  if ((g_zbInfo.nwkNib._45_1_ & 2) == 0)
  {
    uVar10 = (uint) * (byte *)(in_r2 + 0xc);
  LAB_0001cef4:
    bVar3 = *(char *)(in_r2 + 0x10) + bVar13;
    iStack_2c = 0;
    if ((uVar10 & 0x18) == 0)
      goto LAB_0001d0b8;
  }
  else
  {
    uVar10 = (uint) * (byte *)(in_r2 + 0xc);
    if ((int)(uVar10 << 0x19) < 0)
      goto LAB_0001cef4;
    if (ptVar5 != (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      bVar1 = ptVar5->outgoingCost;
      bVar13 = 7;
      if ((bVar1 != 0) && (bVar13 = bVar3, bVar3 < bVar1))
      {
        bVar13 = bVar1;
      }
      goto LAB_0001cef4;
    }
    if ((*(byte *)(in_r2 + 0xc) & 0x18) != 0)
      goto LAB_0001d064;
    bVar3 = *(char *)(in_r2 + 0x10) + 7;
    bVar13 = 7;
  LAB_0001d0b8:
    iVar7 = nwkRouteReqDstChk();
    if (iVar7 == 0)
    {
      iStack_2c = nwkRoutingTabEntryDstFind();
      if (iStack_2c != 0)
      {
        if ((int)((uint) * (byte *)(iStack_2c + 5) << 0x1c) < 0)
        {
          if ((int)((uint) * (byte *)(in_r2 + 0xc) << 0x19) < 0)
          {
          LAB_0001d0f6:
            if ((*(char *)(iStack_2c + 4) != '\x04') && (*(char *)(iStack_2c + 4) != '\0'))
            {
              *(undefined *)(iStack_2c + 4) = 1;
            }
            *(byte *)(iStack_2c + 5) = *(byte *)(iStack_2c + 5) & 0xf;
            bVar11 = g_zbInfo.nwkNib._45_1_ & 2;
            goto LAB_0001cf08;
          }
        }
        else if (-1 < (int)((uint) * (byte *)(in_r2 + 0xc) << 0x19))
          goto LAB_0001d0f6;
      }
      if (((g_zbNwkCtx._45_1_ & 0x80) == 0) ||
          (iStack_2c = nwkRoutingTabEntryCreate(), iStack_2c == 0))
        goto LAB_0001d064;
      *(byte *)(iStack_2c + 5) =
          *(byte *)(iStack_2c + 5) & 0xf7 |
          (byte)((((uint) * (byte *)(in_r2 + 0xc) << 0x19) >> 0x1f) << 3);
      bVar11 = g_zbInfo.nwkNib._45_1_ & 2;
    }
    else
    {
      bVar11 = g_zbInfo.nwkNib._45_1_ & 2;
      iStack_2c = 0;
    }
  }
LAB_0001cf08:
  puVar12 = (undefined *)0x0;
  if ((bVar11 != 0) && (-1 < (int)((uint) * (byte *)(in_r2 + 0xc) << 0x19)))
  {
    puVar12 = (undefined *)nwkRoutingTabEntryDstFind();
    if ((puVar12 == (undefined *)0x0) &&
        (puVar12 = (undefined *)nwkRoutingTabEntryCreate(), puVar12 == (undefined *)0x0))
    {
      if ((iStack_2c != 0) && (*(char *)(iStack_2c + 4) == '\x01'))
      {
        *(undefined *)(iStack_2c + 4) = 3;
      }
      goto LAB_0001d064;
    }
    puVar12[5] = puVar12[5] & 0xf;
  }
  ppvVar6 = (void **)nwkRouteDiscEntryFind();
  if (ppvVar6 == (void **)0x0)
  {
    arg = (undefined *)nwkRouteDiscEntryCreate();
    if (arg == (undefined *)0x0)
    {
      iVar7 = nwkRouteReqDstChk();
      if (iVar7 == 0)
      {
        if ((iStack_2c != 0) && (*(char *)(iStack_2c + 4) == '\x01'))
        {
          *(undefined *)(iStack_2c + 4) = 3;
        }
        if ((puVar12 != (undefined *)0x0) && (puVar12[4] == '\x01'))
        {
          puVar12[4] = 3;
        }
        goto LAB_0001d064;
      }
    }
    else
    {
      iVar7 = nwkRouteReqDstChk();
      if ((((iVar7 == 0) && (*(char *)((int)in_r1 + 6) != '\0')) &&
           (uVar4 = ev_timer_enough(), uVar4 != '\0')) &&
          (iVar7 = nwkRouteDiscCachePacketCopy(), iVar7 != 0))
      {
        uVar8 = drv_u32Rand();
        uVar10 = uVar8 & 0x7f;
        uStack_34 = (undefined)iVar7;
        *arg = uStack_34;
        arg[1] = (char)((uint)iVar7 >> 8);
        arg[2] = (char)((uint)iVar7 >> 0x10);
        arg[3] = (char)((uint)iVar7 >> 0x18);
        if (uVar10 < 2)
        {
          uVar10 = 2;
        }
        peVar9 = ev_timer_taskPost(nwkRouteReqRetry, arg, (uVar10 << 0x10) >> 0xf);
        arg[4] = (char)peVar9;
        arg[5] = (char)((uint)peVar9 >> 8);
        arg[6] = (char)((uint)peVar9 >> 0x10);
        arg[7] = (char)((uint)peVar9 >> 0x18);
      }
    }
  }
  else
  {
    if (*(byte *)((int)ppvVar6 + 0x11) <= bVar3)
      goto LAB_0001d064;
    *(byte *)((int)ppvVar6 + 0x13) = bVar13;
    *(byte *)((int)ppvVar6 + 0x11) = bVar3;
    *(undefined *)((int)ppvVar6 + 10) = (undefined)local_26;
    *(undefined *)((int)ppvVar6 + 0xb) = local_26._1_1_;
    out = *ppvVar6;
    if (out != (void *)0x0)
    {
      memcpy(out, in_r1, 0x20);
      memcpy((void *)((int)out + 0x20), (void *)(in_r2 + 4), 0xd);
    }
  }
  if (puVar12 != (undefined *)0x0)
  {
    uVar2 = *(undefined2 *)((int)in_r1 + 2);
    *puVar12 = (char)uVar2;
    puVar12[1] = (char)((ushort)uVar2 >> 8);
    puVar12[2] = (undefined)local_26;
    puVar12[3] = local_26._1_1_;
    puVar12[4] = 0;
    if ((*(byte *)(in_r2 + 0xc) & 0x18) != 0)
    {
      puVar12[5] = puVar12[5] | 2;
      puVar12[5] = puVar12[5] | 4;
      bVar11 = *(byte *)(in_r2 + 0xc) & 0x18;
      bVar3 = bVar11 - 0x10;
      puVar12[5] = puVar12[5] & 0xfe | bVar3 + ~bVar3 + (0xf < bVar11);
    }
  }
  iVar7 = nwkRouteReqDstChk();
  if (iVar7 != 0)
  {
    in_r0->buf[0] = g_zbInfo.nwkNib.maxDepth << 1;
    in_r0->buf[1] = *(u8 *)(in_r2 + 0xd);
    memcpy(in_r0->buf + 2, (void *)((int)in_r1 + 2), 2);
    memcpy(in_r0->buf + 4, (void *)(in_r2 + 0xe), 2);
    memcpy(in_r0->buf + 6, &local_26, 2);
    in_r0->buf[8] = bVar13;
    uVar4 = tl_zbTaskPost(nwkRouteReplySendDelay, in_r0);
    return uVar4;
  }
LAB_0001d064:
  uVar4 = zb_buf_free(in_r0);
  return uVar4;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteReplyCmdHandler(void)

{
  u16 shortAddr;
  undefined2 uVar1;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar2;
  int iVar3;
  int iVar4;
  undefined uVar5;
  int in_r1;
  byte bVar6;
  int in_r2;
  undefined uVar7;
  char cVar8;
  bool bVar9;

  shortAddr = *(u16 *)(in_r0->buf + 0x14);
  bVar6 = in_r0->buf[0x27];
  ptVar2 = nwk_neTblGetByShortAddr(shortAddr);
  if (ptVar2 != (tl_zb_normal_neighbor_entry_t *)0x0)
  {
    ptVar2->lqi = (u8)((int)((uint)bVar6 + (uint)ptVar2->lqi) >> 1);
  }
  iVar3 = nwkRoutingTabEntryDstFind();
  if (iVar3 == 0)
  {
  LAB_0001d3a6:
    zb_buf_free(in_r0);
  }
  else
  {
    uVar5 = (undefined)shortAddr;
    uVar7 = (undefined)(shortAddr >> 8);
    if (*(u16 *)(in_r2 + 0x14) == g_zbInfo.nwkNib.nwkAddr)
    {
      zb_buf_free(in_r0);
      iVar4 = nwkRouteDiscEntryFind();
      if (iVar4 == 0)
      {
        if (*(char *)(iVar3 + 4) == '\x04')
        {
          return;
        }
        if (*(char *)(iVar3 + 4) == '\0')
        {
          return;
        }
        *(undefined *)(iVar3 + 4) = 2;
        return;
      }
      cVar8 = *(char *)(iVar3 + 4);
      if (cVar8 == '\x01')
      {
        *(char *)(iVar3 + 4) = (char)((((uint) * (byte *)(iVar3 + 5) << 0x1c) >> 0x1f) << 2);
        *(undefined *)(iVar3 + 2) = uVar5;
        *(undefined *)(iVar3 + 3) = uVar7;
        *(undefined *)(iVar3 + 6) = *(undefined *)(in_r2 + 0x1a);
        *(undefined *)(iVar4 + 0x12) = *(undefined *)(in_r2 + 0x1a);
        cVar8 = *(char *)(iVar3 + 4);
        bVar9 = true;
      }
      else
      {
        if ((cVar8 != '\x04') && (cVar8 != '\0'))
        {
          return;
        }
        bVar6 = *(byte *)(in_r2 + 0x1a);
        bVar9 = false;
        if (bVar6 < *(byte *)(iVar4 + 0x12))
        {
          bVar9 = *(u16 *)(iVar3 + 2) != shortAddr;
          if (bVar9)
          {
            *(undefined *)(iVar3 + 2) = uVar5;
            *(undefined *)(iVar3 + 3) = uVar7;
            bVar6 = *(byte *)(in_r2 + 0x1a);
          }
          *(byte *)(iVar4 + 0x12) = bVar6;
          *(undefined *)(iVar3 + 6) = *(undefined *)(in_r2 + 0x1a);
          cVar8 = *(char *)(iVar3 + 4);
        }
      }
      if (cVar8 == '\0')
      {
        nwkDiscDataPendSend();
      }
    }
    else
    {
      iVar4 = nwkRouteDiscEntryFind();
      if ((iVar4 == 0) || (*(byte *)(iVar4 + 0x12) < *(byte *)(in_r2 + 0x1a)))
        goto LAB_0001d3a6;
      if (*(char *)(iVar3 + 4) == '\x01')
      {
        *(char *)(iVar3 + 4) = (char)((((uint) * (byte *)(iVar3 + 5) << 0x1c) >> 0x1f) << 2);
      }
      bVar9 = *(u16 *)(iVar3 + 2) != shortAddr;
      if (bVar9)
      {
        *(undefined *)(iVar3 + 2) = uVar5;
        *(undefined *)(iVar3 + 3) = uVar7;
      }
      *(undefined *)(iVar4 + 0x12) = *(undefined *)(in_r2 + 0x1a);
    }
    if ((bVar9) && ((int)((uint) * (byte *)(iVar3 + 5) << 0x1c) < 0))
    {
      if (*(u16 *)(in_r2 + 0x14) == g_zbInfo.nwkNib.nwkAddr)
      {
        *(undefined *)(iVar4 + 0xe) = 1;
        *(undefined *)(iVar4 + 0xf) = 0;
      }
      else
      {
        *(undefined *)(iVar4 + 0xe) = 10;
        *(undefined *)(iVar4 + 0xf) = 0;
      }
    }
    if (*(u16 *)(in_r2 + 0x14) != g_zbInfo.nwkNib.nwkAddr)
    {
      in_r0->buf[0] = *(u8 *)(in_r1 + 6);
      in_r0->buf[1] = *(u8 *)(in_r2 + 0x19);
      memcpy(in_r0->buf + 2, (void *)(in_r2 + 0x14), 2);
      memcpy(in_r0->buf + 4, (void *)(in_r2 + 0x16), 2);
      memcpy(in_r0->buf + 6, (void *)(iVar4 + 10), 2);
      in_r0->buf[8] = *(char *)(iVar4 + 0x13) + *(char *)(iVar4 + 0x12);
      tl_zbTaskPost(nwkRouteReplySendDelay, in_r0);
      if ((((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1e) < 0) &&
           (iVar3 = nwkRoutingTabEntryFind(), iVar3 == 0)) &&
          (iVar3 = nwkRoutingTabEntryCreate(), iVar3 != 0))
      {
        uVar1 = *(undefined2 *)(iVar4 + 10);
        *(char *)(iVar3 + 2) = (char)uVar1;
        *(char *)(iVar3 + 3) = (char)((ushort)uVar1 >> 8);
        *(undefined *)(iVar3 + 4) = 0;
      }
    }
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteRecordInitiation(void)

{
  byte bVar1;
  u8 uVar2;
  u8 uVar3;
  bool bVar4;
  u16 in_r0;
  int iVar5;
  uint uVar6;
  u16 in_r1;
  byte bVar7;
  undefined uVar8;
  undefined uVar9;
  u16 uVar10;
  byte bVar11;
  u8 uVar12;
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  uint uStack_40;
  u8 *puStack_3c;
  undefined4 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined2 local_20;
  undefined local_1e;

  iVar5 = c1();
  if (iVar5 != 0)
  {
    uVar8 = 0;
    uVar9 = 0;
    uVar10 = 0;
    bVar11 = 0;
    bVar1 = 0;
    uVar3 = '\0';
    uVar12 = '\0';
    uStack_50 = 0;
    uStack_4c = 0;
    uStack_48 = 0;
    uStack_44 = 0;
    uStack_40 = 0;
    puStack_3c = (u8 *)0x0;
    local_38 = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    uStack_2c = 0;
    uStack_28 = 0;
    uStack_24 = 0;
    local_20 = 0;
    local_1e = 0;
    uVar6 = 0;
    if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
    {
      bVar4 = ss_keyPreconfigured();
      uVar6 = (uint)(bVar4 != false);
    }
    bVar7 = bVar11 & 0xc0 | 9;
    bVar1 = bVar1 & 0xfd | (byte)(uVar6 << 1);
    uVar2 = tl_zbExtAddrByShortAddr(in_r0, (addrExt_t)(CONCAT17(uVar12, CONCAT16(uVar3, CONCAT15(bVar1, CONCAT14(bVar11, CONCAT22(uVar10, CONCAT11(uVar9, uVar8)))))) & 0xffffffc0ffffffff | 0x900000000), (u16 *)&uStack_48);
    if (uVar2 == '\0')
    {
      bVar1 = bVar1 | 0x10;
    }
    tl_zbExtAddrByShortAddr(in_r1, (addrExt_t)CONCAT17(uVar12, CONCAT16(uVar3, CONCAT15(bVar1, CONCAT14(bVar7, CONCAT22(uVar10, CONCAT11(uVar9, uVar8)))))), (u16 *)&uStack_50);
    g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
    uVar3 = getNwkHdrSize((nwk_hdr_t *)&stack0xffffffa8);
    uStack_40._0_2_ = CONCAT11(uVar3, uStack_40._0_1_);
    uStack_40 = uStack_40 & 0xffff0000 | (uint)(ushort)uStack_40;
    local_38 = CONCAT31(local_38._1_3_, 5);
    if (g_zbInfo.nwkNib.nwkAddr == in_r0)
    {
      uStack_30 = (uint)uStack_30._1_3_ << 8;
    }
    else
    {
      uStack_30 = CONCAT31(uStack_30._1_3_, 1);
      uStack_34 = 0x8479f6;
    }
    nwkRouteRecordCmdSend();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteRecordCmdHandler(void)

{
  zb_buf_t *in_r0;
  u16 *in_r1;
  int in_r2;

  if (*in_r1 == g_zbInfo.nwkNib.nwkAddr)
  {
    if ((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1b) < 0)
    {
      nwkRouteRecTabEntryCreat();
    }
  }
  else if (((uint) * (byte *)(in_r2 + 8) < (uint)g_zbInfo.nwkNib.maxSourceRoute) &&
           (*(char *)(in_r1 + 3) != '\0'))
  {
    memcpy((void *)(*(int *)(in_r2 + 4) + (uint) * (byte *)(in_r2 + 8) * 2), &g_zbInfo.nwkNib.nwkAddr, 2);
    *(char *)(in_r2 + 8) = *(char *)(in_r2 + 8) + '\x01';
    nwkRouteRecordCmdSend();
    return;
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkTxDataRouteDiscStart(void)

{
  nwkRouteDiscStart();
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteDiscStatusCodeSend(void)

{
  u8 uVar1;
  bool bVar2;
  void *in_r0;
  uint uVar3;
  undefined2 in_r1;
  undefined2 in_r2;
  undefined in_r3;
  undefined local_5c[4];
  undefined4 uStack_58;
  undefined4 uStack_54;
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  uint uStack_44;
  u8 *puStack_40;
  undefined local_3c[7];
  undefined uStack_35;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined2 local_24;
  undefined local_22;

  local_5c = (undefined[4])0x0;
  uStack_58 = 0;
  uStack_54 = 0;
  uStack_50 = 0;
  uStack_4c = 0;
  uStack_48 = 0;
  uStack_44 = 0;
  puStack_40 = (u8 *)0x0;
  local_3c._0_4_ = 0;
  stack0xffffffc8 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  local_24 = 0;
  local_22 = 0;
  uVar3 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar2 = ss_keyPreconfigured();
    uVar3 = (uint)bVar2;
  }
  uStack_58 = uStack_58 & 0xffff0000 |
              (ushort)((ushort)(byte)(uStack_58._1_1_ & 0xfd | (byte)(uVar3 << 1)) << 8 |
                       (byte)uStack_58 & 0xc0 | 1 | 0x1008) &
                  0xfffff7ff;
  memcpy(&uStack_4c, g_zbInfo.macPib.extAddress, 8);
  local_5c = (undefined[4])CONCAT22(g_zbInfo.nwkNib.nwkAddr, in_r1);
  uStack_58 = CONCAT13(g_zbInfo.nwkNib.seqNum,
                       CONCAT12(g_zbInfo.nwkNib.maxDepth << 1, uStack_58._0_2_));
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar1 = getNwkHdrSize((nwk_hdr_t *)local_5c);
  uStack_44._0_2_ = CONCAT11(uVar1, uStack_44._0_1_);
  uStack_44 = uStack_44 & 0xffff0000 | (uint)(ushort)uStack_44;
  local_3c._0_4_ = CONCAT31(local_3c._1_3_, 3);
  stack0xffffffc8 = CONCAT22(CONCAT11(uStack_35, in_r3), in_r2);
  tl_zbNwkSendNwkStatusCmd(in_r0, (nwk_hdr_t *)local_5c, (nwkCmd_t *)local_3c, 0xc9);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteDiscPeriodic(void)

{
  char cVar1;
  int iVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  int iVar6;

  if (g_routeDiscTabCnt != '\0')
  {
    iVar6 = 0x847f34;
    iVar5 = 0;
    do
    {
      while (*(char *)(iVar6 + 5) != '\0')
      {
        if (((*(short *)(g_routeDiscTab + iVar5 * 0x16 + 0xe) != 0) &&
             (sVar3 = *(short *)(g_routeDiscTab + iVar5 * 0x16 + 0xe) + -1,
              *(short *)(g_routeDiscTab + iVar5 * 0x16 + 0xe) = sVar3, sVar3 != 0)) ||
            (iVar4 = iVar5 * 0x16, *(int *)(g_routeDiscTab + iVar4) != 0))
          break;
        if ((*(ushort *)(g_routeDiscTab + iVar4 + 0xc) & 0xfff8) != 0xfff8)
        {
          iVar2 = nwkRoutingTabEntryDstFind();
          if (iVar2 != 0)
          {
            cVar1 = *(char *)(iVar2 + 4);
            if (cVar1 == '\x01')
            {
              *(undefined *)(iVar2 + 4) = 2;
            }
            else if (cVar1 == '\x04')
            {
              if (((*(u16 *)(g_routeDiscTab + iVar4 + 8) == g_zbInfo.nwkNib.nwkAddr) &&
                   (iVar4 = nwkDiscDataPendSend(), iVar4 != 0)) &&
                  (iVar4 = c1(), iVar4 != 0))
              {
                nwkRouteDiscStatusCodeSend();
              }
            }
            else if (cVar1 == '\0')
            {
              nwkDiscDataPendSend();
            }
          }
          nwkDiscDataPendClear();
        }
        nwkRouteDiscTabEntryClear();
        iVar5 = iVar5 + 1;
        iVar6 = iVar6 + 0x16;
        if (iVar5 == 10)
        {
          return;
        }
      }
      iVar5 = iVar5 + 1;
      iVar6 = iVar6 + 0x16;
    } while (iVar5 != 10);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRoutingTabEntryClear(void)

{
  undefined *in_r0;

  in_r0[5] = 0;
  in_r0[6] = 0;
  in_r0[7] = 0;
  *in_r0 = 0xfd;
  in_r0[1] = 0xfe;
  in_r0[2] = 0xfd;
  in_r0[3] = 0xfe;
  in_r0[4] = 3;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRoutingTabInit(void)

{
  uint uVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  uint uVar5;
  u8 *puVar6;

  if (ROUTING_TABLE_SIZE != 0)
  {
    uVar3 = 0;
    do
    {
      nwkRoutingTabEntryClear();
      uVar3 = uVar3 + 1;
    } while (uVar3 < ROUTING_TABLE_SIZE);
  }
  uVar1 = (uint)NWK_ROUTE_RECORD_TABLE_SIZE;
  if (uVar1 != 0)
  {
    uVar4 = (uint)g_zbInfo.nwkNib.maxSourceRoute;
    puVar6 = &g_routeRecTab[0].forgetCnt;
    uVar5 = 0;
    do
    {
      g_brcTransTab[uVar5 + 0xb].used = 0xfd;
      *(undefined *)&g_routeRecTab[uVar5].nwkAddr = 0xfe;
      if (uVar4 != 0)
      {
        uVar2 = 0;
        do
        {
          *(undefined *)((int)g_routeRecTab[uVar5].path + uVar2 * 2 + -1) = 0xfd;
          *(undefined *)(g_routeRecTab[uVar5].path + uVar2) = 0xfe;
          uVar2 = uVar2 + 1;
        } while ((uVar2 & 0xff) < uVar4);
      }
      *(byte *)((int)g_routeRecTab[uVar5].path + 0xf) =
          *(byte *)((int)g_routeRecTab[uVar5].path + 0xf) & 0x80;
      *(byte *)((int)g_routeRecTab[uVar5].path + 0xf) =
          *(byte *)((int)g_routeRecTab[uVar5].path + 0xf) & 0x7f;
      *puVar6 = '\0';
      uVar5 = uVar5 + 1;
      puVar6 = puVar6 + 0x14;
    } while ((uVar5 & 0xffff) < uVar1);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routingTabEntry_t *nwkRoutingTabEntryDstActiveGet(void)

{
  u16 in_r0;
  uint uVar1;
  u8 *puVar2;
  uint uVar3;

  if (ROUTING_TABLE_SIZE != 0)
  {
    puVar2 = &g_routingTab[0].status;
    uVar3 = 0;
    uVar1 = 0;
    do
    {
      if ((*puVar2 == '\0') && (g_routingTab[uVar3].dstAddr == in_r0))
      {
        return g_routingTab + (uVar1 >> 0x10);
      }
      uVar3 = uVar3 + 1;
      puVar2 = puVar2 + 8;
      uVar1 = uVar3 * 0x10000;
    } while ((uVar3 & 0xffff) < (uint)ROUTING_TABLE_SIZE);
  }
  return (nwk_routingTabEntry_t *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routingTabEntry_t *nwkRoutingTabEntryFind(void)

{
  u16 in_r0;
  u8 *puVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;

  if (ROUTING_TABLE_SIZE != 0)
  {
    puVar1 = &g_routingTab[0].status;
    uVar4 = 0;
    uVar3 = 0;
    do
    {
      if (((g_routingTab[uVar4].dstAddr == in_r0) || (g_routingTab[uVar4].nextHopAddr == in_r0)) &&
          ((uVar2 = (uint)*puVar1, (uVar2 - 4) + ~(uVar2 - 4) + (uint)(3 < uVar2) != 0 || (uVar2 < 2))))
      {
        return g_routingTab + (uVar3 >> 0x10);
      }
      uVar4 = uVar4 + 1;
      puVar1 = puVar1 + 8;
      uVar3 = uVar4 * 0x10000;
    } while ((uVar4 & 0xffff) < (uint)ROUTING_TABLE_SIZE);
  }
  return (nwk_routingTabEntry_t *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routingTabEntry_t *nwkRoutingTabEntryDstFind(void)

{
  u16 in_r0;
  nwk_routingTabEntry_t *pnVar1;
  int iVar2;
  uint uVar3;

  pnVar1 = (nwk_routingTabEntry_t *)0x0;
  if (ROUTING_TABLE_SIZE != 0)
  {
    if (g_routingTab[0].dstAddr == in_r0)
    {
      uVar3 = 0;
    }
    else
    {
      iVar2 = 0;
      uVar3 = 0;
      do
      {
        uVar3 = uVar3 + 1 & 0xffff;
        if (ROUTING_TABLE_SIZE <= uVar3)
        {
          return (nwk_routingTabEntry_t *)0x0;
        }
        iVar2 = iVar2 + 1;
      } while (g_routingTab[iVar2].dstAddr != in_r0);
    }
    pnVar1 = g_routingTab + uVar3;
  }
  return pnVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routingTabEntry_t *nwkRoutingTabEntryCreate(void)

{
  u8 uVar1;
  undefined uVar2;
  undefined4 in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  u8 *puVar4;
  int iVar5;
  uint uVar6;
  undefined uVar7;
  ushort uVar8;
  uint uVar9;
  nwk_routingTabEntry_t *pnVar10;
  int iVar11;
  uint uVar12;

  uVar2 = (undefined)((uint)in_r0 >> 8);
  if (ROUTING_TABLE_SIZE == 0)
  {
    return (nwk_routingTabEntry_t *)0x0;
  }
  pnVar10 = g_routingTab;
  uVar7 = (undefined)in_r0;
  if ((byte)(g_routingTab[0].status - 2) < 2)
  {
    iVar11 = 0;
  }
  else
  {
    puVar4 = &g_routingTab[1].status;
    iVar5 = 0;
    uVar8 = 0;
    do
    {
      uVar8 = uVar8 + 1;
      if (ROUTING_TABLE_SIZE <= uVar8)
      {
        uVar12 = 0;
        goto LAB_0001daaa;
      }
      iVar5 = iVar5 + 1;
      iVar11 = iVar5 * 8;
      pnVar10 = g_routingTab + iVar5;
      uVar1 = *puVar4;
      puVar4 = puVar4 + 8;
    } while (1 < (byte)(uVar1 - 2));
  }
  nwkRoutingTabEntryClear();
  *(undefined *)((int)&g_routingTab[0].dstAddr + iVar11) = uVar7;
  *(undefined *)((int)&g_routingTab[0].dstAddr + iVar11 + 1) = uVar2;
  (&g_routingTab[0].status)[iVar11] = '\x01';
  return pnVar10;
LAB_0001daaa:
  ptVar3 = nwk_neTblGetByShortAddr(g_routingTab[uVar12].dstAddr);
  if (((ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0) && (ptVar3->outgoingCost != 0)) &&
      (ptVar3->outgoingCost < NWK_NEIGHBOR_SEND_OUTGOING_THRESHOLD))
  {
    nwkRoutingTabEntryClear();
    *(undefined *)&g_routingTab[uVar12].dstAddr = uVar7;
    goto LAB_0001db0e;
  }
  uVar12 = uVar12 + 1 & 0xffff;
  uVar9 = (uint)ROUTING_TABLE_SIZE;
  if (uVar9 <= uVar12)
  {
    uVar12 = 0;
    if (uVar9 != 0)
    {
      puVar4 = &g_routingTab[0].forgetCnt;
      uVar6 = 0;
      do
      {
        if (g_routingTab[uVar12].forgetCnt < *puVar4)
        {
          uVar12 = uVar6;
        }
        uVar6 = uVar6 + 1 & 0xffff;
        puVar4 = puVar4 + 8;
      } while (uVar6 < uVar9);
    }
    nwkRoutingTabEntryClear();
    *(undefined *)&g_routingTab[uVar12].dstAddr = uVar7;
  LAB_0001db0e:
    *(undefined *)((int)&g_routingTab[0].dstAddr + uVar12 * 8 + 1) = uVar2;
    (&g_routingTab[0].status)[uVar12 * 8] = '\x01';
    return (nwk_routingTabEntry_t *)(&g_routingTab[0].dstAddr + uVar12 * 4);
  }
  goto LAB_0001daaa;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routeRecordTabEntry_t *nwkRouteRecTabEntryFind(void)

{
  u16 in_r0;
  uint uVar1;
  uint uVar2;

  if (NWK_ROUTE_RECORD_TABLE_SIZE != 0)
  {
    uVar2 = 0;
    uVar1 = 0;
    do
    {
      if (((char)g_routeRecTab[uVar2].field_0x12 < '\0') && (g_routeRecTab[uVar2].nwkAddr == in_r0))
      {
        return g_routeRecTab + (uVar1 >> 0x10);
      }
      uVar2 = uVar2 + 1;
      uVar1 = uVar2 * 0x10000;
    } while ((uVar2 & 0xffff) < (uint)NWK_ROUTE_RECORD_TABLE_SIZE);
  }
  return (nwk_routeRecordTabEntry_t *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routeRecordTabEntry_t *nwkRouteRecTabEntryAddNew(void)

{
  undefined4 in_r0;
  int in_r1;
  uint uVar1;
  int iVar2;
  nwk_routeRecordTabEntry_t *pnVar3;

  pnVar3 = (nwk_routeRecordTabEntry_t *)0x0;
  if (NWK_ROUTE_RECORD_TABLE_SIZE != 0)
  {
    if (g_routeRecTab[0]._18_1_ < '\0')
    {
      iVar2 = 0;
      uVar1 = 0;
      do
      {
        uVar1 = uVar1 + 1 & 0xffff;
        if (NWK_ROUTE_RECORD_TABLE_SIZE <= uVar1)
        {
          return (nwk_routeRecordTabEntry_t *)0x0;
        }
        iVar2 = iVar2 + 1;
      } while ((char)g_routeRecTab[iVar2].field_0x12 < '\0');
    }
    else
    {
      uVar1 = 0;
    }
    pnVar3 = g_routeRecTab + uVar1;
    *(char *)&g_routeRecTab[uVar1].nwkAddr = (char)in_r0;
    *(char *)((int)&g_routeRecTab[uVar1].nwkAddr + 1) = (char)((uint)in_r0 >> 8);
    g_routeRecTab[uVar1].field_0x12 =
        g_routeRecTab[uVar1].field_0x12 & 0x80 | *(byte *)(in_r1 + 8) & 0x7f;
    g_routeRecTab[uVar1].forgetCnt = '\0';
    memcpy(g_routeRecTab[uVar1].path, *(void **)(in_r1 + 4), (uint) * (byte *)(in_r1 + 8) << 1);
    g_routeRecTab[uVar1].field_0x12 = g_routeRecTab[uVar1].field_0x12 | 0x7f;
  }
  return pnVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routeRecordTabEntry_t *nwkRouteRecTabEntryCreat(void)

{
  uint in_r0;
  int in_r1;
  uint uVar1;
  u8 *puVar2;
  uint uVar3;
  nwk_routeRecordTabEntry_t *pnVar4;
  nwk_routeRecordTabEntry_t *pnVar5;
  int iVar6;
  undefined *puVar7;

  pnVar5 = (nwk_routeRecordTabEntry_t *)0x0;
  if ((NWK_ROUTE_RECORD_TABLE_SIZE != 0) && (*(byte *)(in_r1 + 8) <= g_zbInfo.nwkNib.maxSourceRoute))
  {
    uVar3 = 0;
    uVar1 = 0;
    do
    {
      uVar1 = uVar1 >> 0x10;
      if (((char)g_routeRecTab[uVar3].field_0x12 < '\0') &&
          ((in_r0 & 0xffff) == (uint)g_routeRecTab[uVar3].nwkAddr))
      {
        g_routeRecTab[uVar1].field_0x12 =
            g_routeRecTab[uVar1].field_0x12 & 0x80 | *(byte *)(in_r1 + 8) & 0x7f;
        g_routeRecTab[uVar1].forgetCnt = '\0';
        memcpy(g_routeRecTab[uVar1].path, *(void **)(in_r1 + 4), (uint) * (byte *)(in_r1 + 8) << 1);
        return g_routeRecTab + uVar1;
      }
      uVar3 = uVar3 + 1;
      uVar1 = uVar3 * 0x10000;
    } while ((uVar3 & 0xffff) < (uint)NWK_ROUTE_RECORD_TABLE_SIZE);
    pnVar5 = (nwk_routeRecordTabEntry_t *)nwkRouteRecTabEntryAddNew();
    if (pnVar5 == (nwk_routeRecordTabEntry_t *)0x0)
    {
      pnVar4 = (nwk_routeRecordTabEntry_t *)0x0;
      if ((nwk_routeRecordTabEntry_t *)(uint)NWK_ROUTE_RECORD_TABLE_SIZE ==
          (nwk_routeRecordTabEntry_t *)0x0)
      {
        pnVar5 = (nwk_routeRecordTabEntry_t *)0x0;
        iVar6 = 0;
      }
      else
      {
        puVar2 = &g_routeRecTab[0].forgetCnt;
        iVar6 = 0;
        do
        {
          if (*(byte *)((int)g_routeRecTab[0].path +
                        (int)((int)pnVar5->path + iVar6 + -2) * 4 + 0x11) < *puVar2)
          {
            iVar6 = (int)pnVar4 << 2;
            pnVar5 = pnVar4;
          }
          pnVar4 = (nwk_routeRecordTabEntry_t *)((uint)((int)&pnVar4->nwkAddr + 1) & 0xffff);
          puVar2 = puVar2 + 0x14;
        } while (pnVar4 < (nwk_routeRecordTabEntry_t *)(uint)NWK_ROUTE_RECORD_TABLE_SIZE);
      }
      puVar7 = (undefined *)((int)pnVar5->path + iVar6 + -2);
      pnVar5 = (nwk_routeRecordTabEntry_t *)(g_routeRecTab[0].path + (int)puVar7 * 2 + -1);
      *(char *)(g_routeRecTab[0].path + (int)puVar7 * 2 + -1) = (char)in_r0;
      *(char *)((int)g_routeRecTab[0].path + (int)puVar7 * 4 + -1) = (char)((in_r0 & 0xffff) >> 8);
      *(byte *)(g_routeRecTab[0].path + (int)puVar7 * 2 + 8) =
          *(byte *)(g_routeRecTab[0].path + (int)puVar7 * 2 + 8) & 0x80 |
          *(byte *)(in_r1 + 8) & 0x7f;
      *(undefined *)((int)g_routeRecTab[0].path + (int)puVar7 * 4 + 0x11) = 0;
      memcpy(g_routeRecTab[0].path + (int)puVar7 * 2, *(void **)(in_r1 + 4),
             (uint) * (byte *)(in_r1 + 8) << 1);
      *(byte *)(g_routeRecTab[0].path + (int)puVar7 * 2 + 8) =
          *(byte *)(g_routeRecTab[0].path + (int)puVar7 * 2 + 8) | 0x7f;
    }
  }
  return pnVar5;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteRecTabEntryDstDel(void)

{
  byte bVar1;
  u16 in_r0;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;

  uVar2 = (uint)NWK_ROUTE_RECORD_TABLE_SIZE;
  if (uVar2 != 0)
  {
    uVar3 = (uint)g_zbInfo.nwkNib.maxSourceRoute;
    uVar5 = 0;
    do
    {
      bVar1 = g_routeRecTab[uVar5].field_0x12;
      if ((char)bVar1 < '\0')
      {
        if (g_routeRecTab[uVar5].nwkAddr != in_r0)
        {
          if ((bVar1 & 0x7f) == 0)
            goto LAB_0001de54;
          if (in_r0 != g_routeRecTab[uVar5].path[0])
          {
            uVar4 = 0;
            do
            {
              uVar4 = uVar4 + 1 & 0xff;
              if ((bVar1 & 0x7f) <= uVar4)
                goto LAB_0001de54;
            } while (in_r0 != g_routeRecTab[uVar5].path[uVar4]);
          }
        }
        *(undefined *)&g_routeRecTab[uVar5].nwkAddr = 0xfd;
        *(undefined *)((int)&g_routeRecTab[uVar5].nwkAddr + 1) = 0xfe;
        if (uVar3 != 0)
        {
          uVar4 = 0;
          do
          {
            *(undefined *)(g_routeRecTab[uVar5].path + uVar4) = 0xfd;
            *(undefined *)((int)g_routeRecTab[uVar5].path + uVar4 * 2 + 1) = 0xfe;
            uVar4 = uVar4 + 1;
          } while ((uVar4 & 0xff) < uVar3);
        }
        g_routeRecTab[uVar5].field_0x12 = g_routeRecTab[uVar5].field_0x12 & 0x80;
        g_routeRecTab[uVar5].field_0x12 = g_routeRecTab[uVar5].field_0x12 & 0x7f;
        g_routeRecTab[uVar5].forgetCnt = '\0';
      }
    LAB_0001de54:
      uVar5 = uVar5 + 1 & 0xffff;
    } while (uVar5 < uVar2);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nwk_routingTabEntry_t *nwkRoutingTabGetNextHop(void)

{
  u16 *in_r0;
  nwk_routingTabEntry_t *pnVar1;
  int iVar2;
  uint uVar3;

  pnVar1 = (nwk_routingTabEntry_t *)0x0;
  if (ROUTING_TABLE_SIZE != 0)
  {
    if (*in_r0 == g_routingTab[0].dstAddr)
    {
      uVar3 = 0;
    }
    else
    {
      iVar2 = 0;
      uVar3 = 0;
      do
      {
        uVar3 = uVar3 + 1 & 0xffff;
        if (ROUTING_TABLE_SIZE <= uVar3)
          goto LAB_0001df28;
        iVar2 = iVar2 + 1;
      } while (*in_r0 != g_routingTab[iVar2].dstAddr);
    }
    if (g_routingTab[uVar3].nextHopAddr == 0xfffe)
    {
    LAB_0001df28:
      pnVar1 = (nwk_routingTabEntry_t *)0x0;
    }
    else if ((g_routingTab[uVar3].status == '\x04') ||
             (pnVar1 = (nwk_routingTabEntry_t *)0x0, g_routingTab[uVar3].status == '\0'))
    {
      pnVar1 = g_routingTab + uVar3;
      g_routingTab[uVar3].status = '\0';
    }
  }
  return pnVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRoutingTabEntryDstDel(void)

{
  u16 in_r0;
  uint uVar1;

  if (ROUTING_TABLE_SIZE != 0)
  {
    uVar1 = 0;
    do
    {
      while ((g_routingTab[uVar1].dstAddr == in_r0 || (g_routingTab[uVar1].nextHopAddr == in_r0)))
      {
        nwkRoutingTabEntryClear();
        uVar1 = uVar1 + 1 & 0xffff;
        if (ROUTING_TABLE_SIZE <= uVar1)
        {
          return;
        }
      }
      uVar1 = uVar1 + 1 & 0xffff;
    } while (uVar1 < ROUTING_TABLE_SIZE);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteRepair(void)

{
  uint uVar1;
  u8 uVar2;
  bool bVar3;
  void *in_r0;
  uint uVar4;
  undefined2 in_r1;
  undefined2 in_r2;
  undefined in_r3;
  undefined local_54[4];
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  undefined4 uStack_44;
  undefined4 uStack_40;
  uint uStack_3c;
  u8 *puStack_38;
  undefined local_34[8];
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined4 uStack_20;
  undefined2 local_1c;
  undefined local_1a;

  local_54 = (undefined[4])0x0;
  uStack_50 = 0;
  uStack_4c = 0;
  uStack_48 = 0;
  uStack_44 = 0;
  uStack_40 = 0;
  uStack_3c = 0;
  puStack_38 = (u8 *)0x0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  local_1c = 0;
  local_1a = 0;
  local_34._0_4_ = 3;
  local_34._4_4_ = (uint)CONCAT12(in_r3, in_r2);
  uVar4 = 0;
  if (((int)((uint)ss_ib._62_1_ << 0x1c) < 0) && ((ss_ib._62_1_ & 7) != 0))
  {
    bVar3 = ss_keyPreconfigured();
    uVar4 = (uint)bVar3;
  }
  uVar1 = (ushort)((ushort)uStack_50 & 0xff00 | (ushort)uStack_50 & 0xc0 | 1 | 0x1008) & 0xfffff7ff;
  uStack_50._1_1_ = (byte)(uVar1 >> 8);
  uStack_50._0_2_ =
      (nwkFrameCtrl_t)CONCAT11(uStack_50._1_1_ & 0xfd | (byte)(uVar4 << 1), (char)uVar1);
  uStack_50 = uStack_50 & 0xffff0000 | (uint)(ushort)uStack_50._0_2_;
  memcpy(&uStack_44, g_zbInfo.macPib.extAddress, 8);
  local_54 = (undefined[4])CONCAT22(g_zbInfo.nwkNib.nwkAddr, in_r1);
  uStack_50 = CONCAT13(g_zbInfo.nwkNib.seqNum,
                       CONCAT12(g_zbInfo.nwkNib.maxDepth << 1, uStack_50._0_2_));
  g_zbInfo.nwkNib.seqNum = g_zbInfo.nwkNib.seqNum + '\x01';
  uVar2 = getNwkHdrSize((nwk_hdr_t *)local_54);
  uStack_3c._0_2_ = CONCAT11(uVar2, uStack_3c._0_1_);
  uStack_3c = uStack_3c & 0xffff0000 | (uint)(ushort)uStack_3c;
  tl_zbNwkSendNwkStatusCmd(in_r0, (nwk_hdr_t *)local_54, (nwkCmd_t *)local_34, 0xc9);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRouteMaintenance(void)

{
  u16 *in_r0;
  int iVar1;
  undefined4 in_r1;
  u8 *puVar2;
  uint uVar3;
  uint uVar4;

  if ((int)((uint) * (byte *)((int)in_r0 + 5) << 0x1d) < 0)
  {
    nwkRouteRecTabEntryDstDel();
  }
  else if (ROUTING_TABLE_SIZE != 0)
  {
    puVar2 = &g_routingTab[0].status;
    uVar3 = 0;
    uVar4 = 0;
    do
    {
      if ((*puVar2 == '\0') && (*in_r0 == g_routingTab[uVar3].dstAddr))
      {
        g_routingTab[uVar4 >> 0x10].status = '\x03';
        if ((int)((uint)(byte)g_routingTab[uVar4 >> 0x10].field_0x5 << 0x1e) < 0)
        {
          g_zbNwkCtx.manyToOneRepair.senderAddr._0_1_ = (undefined)in_r0[1];
          g_zbNwkCtx.manyToOneRepair.senderAddr._1_1_ = (undefined)((uint)in_r0[1] >> 8);
          g_zbNwkCtx.manyToOneRepair.lastSendFailAddr._0_1_ = (undefined)in_r1;
          g_zbNwkCtx.manyToOneRepair.lastSendFailAddr._1_1_ = (char)((uint)in_r1 >> 8);
        }
        iVar1 = c1();
        if (iVar1 == 0)
        {
          return;
        }
        nwkRouteRepair();
        return;
      }
      uVar3 = uVar3 + 1;
      puVar2 = puVar2 + 8;
      uVar4 = uVar3 * 0x10000;
    } while ((uVar3 & 0xffff) < (uint)ROUTING_TABLE_SIZE);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkSrcRouteRequiredClear(void)

{
  u16 in_r0;
  int iVar1;
  uint uVar2;

  if (ROUTING_TABLE_SIZE != 0)
  {
    if (in_r0 == g_routingTab[0].dstAddr)
    {
      uVar2 = 0;
    }
    else
    {
      iVar1 = 0;
      uVar2 = 0;
      do
      {
        uVar2 = uVar2 + 1 & 0xffff;
        if (ROUTING_TABLE_SIZE <= uVar2)
        {
          return;
        }
        iVar1 = iVar1 + 1;
      } while (in_r0 != g_routingTab[iVar1].dstAddr);
    }
    if (-1 < (int)((uint)(byte)g_routingTab[uVar2].field_0x5 << 0x1f))
    {
      g_routingTab[uVar2].field_0x5 = g_routingTab[uVar2].field_0x5 & 0xfb;
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u16 nwkSrcRouteReplayNextHop(void)

{
  u16 *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar1;
  byte bVar2;
  int iVar3;
  u16 uVar4;

  if ((in_r0[1] == g_zbInfo.nwkNib.nwkAddr) || (-1 < (int)((uint) * (byte *)((int)in_r0 + 5) << 0x1d)))
  {
    uVar4 = 0xfffe;
  }
  else
  {
    if (*(char *)((int)in_r0 + 0x1b) == '\0')
    {
      uVar4 = *in_r0;
    }
    else
    {
      ptVar1 = nwk_neTblGetByShortAddr(*in_r0);
      if ((ptVar1 == (tl_zb_normal_neighbor_entry_t *)0x0) || ((ptVar1->field_0x1e & 0x7e) != 0x14))
      {
        bVar2 = *(char *)((int)in_r0 + 0x1b) - 1;
        *(byte *)((int)in_r0 + 0x1b) = bVar2;
        iVar3 = (uint)bVar2 * 2;
        uVar4 = (ushort) * (byte *)(*(int *)(in_r0 + 0xe) + iVar3 + 1) * 0x100 +
                (ushort) * (byte *)(*(int *)(in_r0 + 0xe) + iVar3);
      }
      else
      {
        uVar4 = *in_r0;
      }
    }
    nwkSrcRouteRequiredClear();
  }
  return uVar4;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

byte nwkSourceRoutePacketRelayFilter(void)

{
  byte bVar1;
  u16 *in_r0;
  int iVar2;

  bVar1 = 0xc1;
  if (((in_r0[1] != g_zbInfo.nwkNib.nwkAddr) && (bVar1 = 0, g_zbInfo.nwkNib.nwkAddr != *in_r0)) &&
      (*(char *)(in_r0 + 0xd) != '\0'))
  {
    iVar2 = (uint) * (byte *)((int)in_r0 + 0x1b) * 2;
    bVar1 = ~(g_zbInfo.nwkNib.nwkAddr !=
              (u16)((ushort) * (byte *)(*(int *)(in_r0 + 0xe) + iVar2 + 1) * 0x100 +
                    (ushort) * (byte *)(*(int *)(in_r0 + 0xe) + iVar2))) &
            0xc1;
  }
  return bVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void nwkRoutingTabPeriodic(void)

{
  u8 *puVar1;
  u8 *puVar2;
  uint uVar3;
  short sVar4;
  uint uVar5;

  uVar5 = (uint)ROUTING_TABLE_SIZE;
  if (uVar5 != 0)
  {
    sVar4 = 0;
    puVar2 = &g_routingTab[0].status;
    do
    {
      if (*puVar2 == '\0')
      {
        sVar4 = sVar4 + 1;
      }
      puVar2 = puVar2 + 8;
    } while (puVar2 != &g_routingTab[1].status + ((uVar5 - 1) * 0x10000 >> 0xd));
    if (sVar4 != 0)
    {
      uVar3 = 0;
      puVar2 = &g_routingTab[0].status;
      puVar1 = &g_routingTab[1].status;
      while (true)
      {
        if (((*puVar2 == '\0') && (-1 < (int)((uint)(byte)g_routingTab[uVar3].field_0x5 << 0x1e))) && (puVar2[3] != 0xff))
        {
          puVar2[3] = puVar2[3] + '\x01';
        }
        uVar3 = uVar3 + 1;
        if (uVar5 <= (uVar3 & 0xffff))
          break;
        puVar2 = puVar1;
        puVar1 = puVar1 + 8;
      }
    }
  }
  uVar5 = (uint)NWK_ROUTE_RECORD_TABLE_SIZE;
  if (uVar5 != 0)
  {
    uVar3 = 0;
    sVar4 = 0;
    do
    {
      if ((char)g_routeRecTab[uVar3].field_0x12 < '\0')
      {
        sVar4 = sVar4 + 1;
      }
      uVar3 = uVar3 + 1;
    } while ((uVar3 & 0xffff) < uVar5);
    if (sVar4 != 0)
    {
      puVar2 = &g_routeRecTab[0].forgetCnt;
      uVar3 = 0;
      do
      {
        if (((char)g_routeRecTab[uVar3].field_0x12 < '\0') && (*puVar2 != 0xff))
        {
          *puVar2 = *puVar2 + '\x01';
        }
        uVar3 = uVar3 + 1;
        puVar2 = puVar2 + 0x14;
      } while ((uVar3 & 0xffff) < uVar5);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint ss_apsEnAuxHdrFill(void)

{
  byte *in_r0;
  byte *out;
  char *in_r1;
  int in_r2;

  out = in_r0 + 5;
  in_r0[1] = (byte)ss_ib.outgoingFrameCounter;
  in_r0[2] = (byte)(ss_ib.outgoingFrameCounter >> 8);
  in_r0[3] = (byte)(ss_ib.outgoingFrameCounter >> 0x10);
  in_r0[4] = (byte)(ss_ib.outgoingFrameCounter >> 0x18);
  ss_ib.outgoingFrameCounter = ss_ib.outgoingFrameCounter + 1;
  *in_r0 = *in_r0 & 0xf8 | 5;
  if (in_r1 == (char *)0x0)
  {
    if (in_r2 << 0x1b < 0)
    {
      *in_r0 = *in_r0 | 0x20;
      memcpy(out, g_zbInfo.macPib.extAddress, 8);
      out = in_r0 + 0xd;
    }
  }
  else
  {
    *in_r0 = *in_r0 | 0x20;
    memcpy(out, g_zbInfo.macPib.extAddress, 8);
    out = in_r0 + 0xd;
    if (*in_r1 == '\x05')
    {
      if (in_r1[1] == '\x01')
      {
        *in_r0 = *in_r0 & 0xe7 | 0x10;
      }
      else
      {
        *in_r0 = *in_r0 | 0x18;
      }
      goto LAB_0001e438;
    }
  }
  *in_r0 = *in_r0 & 0xe7;
LAB_0001e438:
  return (int)out - (int)in_r0 & 0xff;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 ss_apsSecureFrame(void)

{
  uint uVar1;
  byte bVar2;
  undefined *in_r0;
  int iVar3;
  byte in_r1;
  byte *pbVar4;
  uint in_r2;
  ss_dev_pair_set_t *in_r3;
  uint uVar5;
  uint uVar6;
  byte bVar7;
  undefined4 in_stack_ffffff80;
  undefined4 in_stack_ffffff84;
  undefined auStack_78[36];
  undefined4 uStack_54;
  undefined4 uStack_50;
  undefined4 uStack_4c;
  undefined4 uStack_48;
  uint local_44;
  int iStack_40;
  undefined4 uStack_3c;
  undefined2 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  uint uStack_2c;
  undefined uStack_28;
  undefined local_25;

  local_44 = 0;
  iStack_40 = 0;
  uStack_3c = 0;
  local_38 = 0;
  uStack_54 = 0;
  uStack_50 = 0;
  uStack_4c = 0;
  uStack_48 = 0;
  pbVar4 = *(byte **)(in_r0 + 0x10);
  *pbVar4 = *pbVar4 & 0xdf | 0x20;
  pbVar4 = pbVar4 + (in_r2 & 0xff);
  memcpy(&local_44, pbVar4, (uint)in_r1 - (in_r2 & 0xff));
  uVar1 = local_44 & 0x18;
  uVar6 = local_44 & 0x18;
  bVar7 = 7 < uVar6;
  if (uVar6 != 8)
  {
    bVar2 = ss_devKeyPairFind((addrExt_t)CONCAT44(in_stack_ffffff84, in_stack_ffffff80), in_r3);
    uVar5 = ~(~(uint)bVar2 + (uint)bVar2 + (uint)bVar7) & (uint)auStack_78;
    if ((ss_ib.tcLinkKeyType == '\0') && ((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0))
    {
      if ((uVar5 == 0) || (*(char *)(uVar5 + 0x19) != '\0'))
        goto LAB_0001e5bc;
    }
    else if (uVar5 == 0)
    {
      ss_securityModeIsDistributed();
    }
    if (uVar1 != 0)
    {
      local_25 = 0;
      if (uVar6 == 0x18)
      {
        local_25 = 2;
      }
      ss_keyHash();
    }
  }
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = iStack_40 << 0x18 | local_44 >> 8;
  local_44 = local_44 & 0xfffffff8 | 5;
  uStack_28 = (undefined)local_44;
  memcpy(&uStack_34, g_zbInfo.macPib.extAddress, 8);
  iVar3 = ss_ccmEncryption();
  if (iVar3 != 0)
  {
    in_r0[0x14] = (char)iVar3 + in_r1;
    *pbVar4 = *pbVar4 & 0xf8;
    return 0;
  }
LAB_0001e5bc:
  in_r0[2] = 0xad;
  *in_r0 = (char)*(undefined2 *)(in_r0 + 8);
  in_r0[1] = (char)((ushort) * (undefined2 *)(in_r0 + 8) >> 8);
  tl_zbTaskPost(zdo_nlme_status_indication, in_r0);
  return 1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int ss_apsDecryptFrame(void)

{
  undefined uVar1;
  bool bVar2;
  u8 uVar3;
  byte bVar4;
  bool bVar5;
  int *in_r0;
  int iVar6;
  tl_zb_normal_neighbor_entry_t *ptVar7;
  int iVar8;
  int iVar9;
  uint uVar10;
  ss_preconfiguredKey_e sVar11;
  byte bVar12;
  uint uVar13;
  byte *in;
  u8 *m1;
  byte bVar14;
  undefined4 in_stack_ffffff60;
  undefined4 in_stack_ffffff64;
  u8 *puStack_98;
  byte *pbStack_94;
  u8 *puStack_90;
  uint uStack_8c;
  undefined auStack_7c[52];
  undefined auStack_48[35];
  undefined local_25;

  bVar12 = g_zbDefaultLinkKeyEn;
  in = (byte *)(*in_r0 + (uint) * (byte *)(in_r0 + 5));
  memcpy(auStack_48 + 0x18, in, 5);
  bVar4 = *in;
  if (((uint)auStack_48[28] << 0x18 | auStack_48._24_4_ >> 8) == 0xffffffff)
  {
    return 1;
  }
  uVar10 = auStack_48._24_4_ & 0x18;
  if (uVar10 == 8)
  {
    return 1;
  }
  uVar3 = tl_zbExtAddrByShortAddr(*(u16 *)(in_r0 + 6), (addrExt_t)CONCAT44(in_stack_ffffff64, in_stack_ffffff60),
                                  (u16 *)(ss_dev_pair_set_t *)auStack_48);
  if ((uVar3 == 0xff) && ((int)((uint)aps_ib._18_1_ << 0x1e) < 0))
  {
    return 1;
  }
  pbStack_94 = in + 5;
  if ((int)((uint)bVar4 << 0x1a) < 0)
  {
    memcpy((ss_dev_pair_set_t *)auStack_48, pbStack_94, 8);
    pbStack_94 = in + 0xd;
  }
  bVar14 = 0;
  bVar4 = ss_devKeyPairFind((addrExt_t)CONCAT44(in_stack_ffffff64, in_stack_ffffff60),
                            (ss_dev_pair_set_t *)auStack_48);
  uVar13 = (uint)auStack_7c & ~(~(uint)bVar4 + (uint)bVar4 + (uint)bVar14);
  if (((ss_ib.tcLinkKeyType == '\0') && ((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0)) &&
      ((uVar13 == 0 || (*(char *)(uVar13 + 0x19) != '\0'))))
  {
    iVar6 = 0x44;
    iVar8 = 0x45;
    uVar1 = (undefined)g_sysDiags.apsUnauthorizedKey;
  LAB_0001e8d6:
    iVar9 = CONCAT11(*(undefined *)((int)&g_sysDiags.numberOfResets + iVar8), uVar1) + 1;
    *(char *)((int)&g_sysDiags.numberOfResets + iVar6) = (char)iVar9;
    *(char *)((int)&g_sysDiags.numberOfResets + iVar8) = (char)((uint)iVar9 >> 8);
    iVar6 = 1;
  }
  else
  {
    puStack_98 = ss_ib.tcLinkKey;
    bVar2 = false;
    if (uVar10 == 0x10)
    {
      ptVar7 = tl_zbNeighborTableSearchFromShortAddr(*(u16 *)(in_r0 + 6),
                                                     (addrExt_t)CONCAT44(in_stack_ffffff64, in_stack_ffffff60),
                                                     (u16 *)(auStack_48 + 0x10));
      if (((ptVar7 != (tl_zb_normal_neighbor_entry_t *)0x0) && ((ptVar7->field_0x1e & 0xe) != 0)) &&
          (iVar6 = memcmp(auStack_48 + 0x10, (ss_dev_pair_set_t *)auStack_48, 8), iVar6 == 0))
      {
        puStack_98 = ss_ib.distibuteLinkKey;
        bVar2 = true;
      }
    }
    if (uVar13 != 0)
    {
      puStack_98 = (u8 *)(uVar13 + 8);
    }
    uVar10 = ((uint) * (byte *)in_r0 + (uint) * (byte *)(in_r0 + 1)) - ((uint)pbStack_94 & 0xff) & 0xff;
    *in = *in & 0xf8 | 5;
    bVar5 = zb_isDeviceFactoryNew();
    puStack_90 = (u8 *)0x0;
    if (((bVar5 != false) && ((auStack_48._24_4_ & 0x18) == 0x10)) &&
        (puStack_90 = ev_buf_allocate((u16)uVar10), puStack_90 != (u8 *)0x0))
    {
      memcpy(puStack_90, pbStack_94, uVar10);
    }
    if (uVar13 == 0)
    {
      uStack_8c = (uint)auStack_48[28] << 0x18 | auStack_48._24_4_ >> 8;
    }
    else if (*(char *)(uVar13 + 0x19) == '\0')
    {
      uStack_8c = (uint)auStack_48[28] << 0x18 | auStack_48._24_4_ >> 8;
      if (uStack_8c < *(uint *)(uVar13 + 0x20))
      {
        iVar6 = 0x42;
        iVar8 = 0x43;
        uVar1 = (undefined)g_sysDiags.apsFCFailure;
        goto LAB_0001e8d6;
      }
      iVar6 = uStack_8c + 1;
      *(char *)(uVar13 + 0x20) = (char)iVar6;
      *(char *)(uVar13 + 0x21) = (char)((uint)iVar6 >> 8);
      *(char *)(uVar13 + 0x22) = (char)((uint)iVar6 >> 0x10);
      *(char *)(uVar13 + 0x23) = (char)((uint)iVar6 >> 0x18);
    }
    else
    {
      uStack_8c = (uint)auStack_48[28] << 0x18 | auStack_48._24_4_ >> 8;
    }
    local_25 = 0;
    if ((auStack_48._24_4_ & 0x18) != 0)
    {
      if ((auStack_48._24_4_ & 0x18) == 0x18)
      {
        local_25 = 2;
      }
      ss_keyHash();
    }
    auStack_48._8_4_ = uStack_8c;
    auStack_48._24_4_ = auStack_48._24_4_ & 0xfffffff8 | 5;
    auStack_48[12] = auStack_48[24];
    iVar6 = ss_ccmDecryption();
    bVar5 = zb_isDeviceFactoryNew();
    if ((bVar5 != false) && ((auStack_48._24_4_ & 0x18) == 0x10))
    {
      if (iVar6 == 0)
      {
      LAB_0001ea64:
        if (bVar2)
        {
          iVar6 = 0;
          ss_ib.distibuteLinkKey = puStack_98;
        }
        else
        {
          bVar4 = 0;
          uVar10 = memcmp(puStack_98, tcLinkKeyCentralDefault, 0x10);
          iVar6 = ~uVar10 + uVar10 + (uint)bVar4;
          ss_ib.tcLinkKeyType = (u8)iVar6;
          if (iVar6 == 0)
          {
            sVar11 = SS_PRECONFIGURED_UNIQUELLINKKEY;
            ss_ib.tcLinkKey = puStack_98;
          }
          else
          {
            ss_ib.tcLinkKey = tcLinkKeyCentralDefault;
            sVar11 = SS_PRECONFIGURED_GLOBALLINKKEY;
          }
          ss_ib.preConfiguredKeyType = sVar11 | ss_ib.preConfiguredKeyType;
          iVar6 = 0;
        }
      }
      else if ((puStack_90 != (u8 *)0x0) && (m1 = puStack_98, bVar12 != 0))
      {
        do
        {
          if ((bVar12 & 1) == 0)
          {
            if (((bVar12 & 2) == 0) || (!bVar2))
              break;
            puStack_98 = linkKeyDistributedCertification;
            bVar12 = 0;
          LAB_0001e9f0:
            local_25 = 0;
            ss_keyHash();
            memcpy(pbStack_94, puStack_90, uVar10);
            iVar6 = ss_ccmDecryption();
            m1 = puStack_98;
            if (iVar6 == 0)
              goto LAB_0001ea64;
          }
          else
          {
            if (bVar2)
            {
              bVar12 = bVar12 & 0xfe;
              puStack_98 = linkKeyDistributedMaster;
            }
            else
            {
              bVar12 = 0;
              puStack_98 = tcLinkKeyCentralDefault;
            }
            iVar8 = memcmp(m1, puStack_98, 0x10);
            if (iVar8 != 0)
              goto LAB_0001e9f0;
          }
        } while (bVar12 != 0);
      }
    }
    if (puStack_90 != (u8 *)0x0)
    {
      ev_buf_free(puStack_90);
    }
    if (iVar6 == 0)
    {
      *(byte *)(in_r0 + 1) =
          ((*(byte *)(in_r0 + 1) - 4) + (char)in) - (char)((uint)pbStack_94 & 0xff);
      pbStack_94 = pbStack_94 + (*in_r0 - (int)in);
      *(byte *)in_r0 = (byte)pbStack_94;
      *(byte *)((int)in_r0 + 1) = (byte)((uint)pbStack_94 >> 8);
      *(byte *)((int)in_r0 + 2) = (byte)((uint)pbStack_94 >> 0x10);
      *(byte *)((int)in_r0 + 3) = (byte)((uint)pbStack_94 >> 0x18);
    }
    else
    {
      g_sysDiags.apsDecryptFailures = g_sysDiags.apsDecryptFailures + 1;
    }
  }
  return iVar6;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsmeUpdateDevReqSend(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, '\f');
  *puVar1 = 6;
  memcpy(puVar1 + 1, in_r0->buf + 8, 8);
  puVar1[9] = in_r0->buf[0x10];
  puVar1[10] = in_r0->buf[0x11];
  puVar1[0xb] = in_r0->buf[0x12];
  aps_cmd_send();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 updateDeviceSendAgain(void)

{
  ss_apsmeUpdateDevReqSend();
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *ss_tcKeyPairFind(void)

{
  void *in_r0;
  int iVar1;
  int iVar2;
  char *pcVar3;

  pcVar3 = g_ssTcKeyPair + 0x1a;
  iVar2 = 0;
  while ((*pcVar3 == '\0' || (iVar1 = memcmp(g_ssTcKeyPair + iVar2 * 0x28, in_r0, 8), iVar1 != 0)))
  {
    iVar2 = iVar2 + 1;
    pcVar3 = pcVar3 + 0x28;
    if (iVar2 == 10)
    {
      return (undefined1 *)0x0;
    }
  }
  return g_ssTcKeyPair + iVar2 * 0x28;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_tcKeyPairClear(void)

{
  void *in_r0;

  memset(in_r0, 0, 0x28);
  return;
}

void ss_devKeyPairSave(ss_dev_pair_set_t *keyPair)

{
  nv_sts_t nVar1;

  nVar1 = nv_flashWriteNew('\0', 7, '\b', 0x24, keyPair->device_address);
  if (nVar1 == NV_SUCC)
  {
    ss_ib.devKeyPairNum = ss_ib.devKeyPairNum + 1;
  }
  return;
}

u8 ss_devKeyPairFind(addrExt_t extAddr, ss_dev_pair_set_t *keyPair)

{
  nv_sts_t nVar1;
  nv_sts_t nVar2;
  int iVar3;
  u8 *in_r1;
  u8 uVar4;
  int iVar5;
  u8 *puVar6;
  undefined auStack_4c[36];
  ushort local_28;
  u8 uStack_26;

  local_28 = 0;
  uStack_26 = '\0';
  nVar1 = nv_flashReadNew('\0', '\a', 0xff, 0x24, (u8 *)&local_28);
  if (nVar1 == NV_SUCC)
  {
    iVar5 = 0;
    puVar6 = (u8 *)0x0;
    nVar1 = NV_ITEM_NOT_FOUND;
    do
    {
      nVar2 = nv_flashReadByIndex('\a', '\b', uStack_26, (u16)iVar5, 0x24, in_r1);
      if (nVar2 != NV_ITEM_NOT_FOUND)
      {
        if ((puVar6 == (u8 *)0x0) && (in_r1[0x19] == '\x01'))
        {
          memcpy(auStack_4c, in_r1, 0x24);
          nVar1 = NV_SUCC;
          puVar6 = in_r1;
        }
        else if (in_r1[0x19] == '\0')
        {
          uVar4 = in_r1[0x18];
          if (uVar4 == '\x01')
          {
            iVar3 = memcmp(keyPair, in_r1, 8);
            if (iVar3 != 0)
              goto LAB_0001ec72;
            memcpy(auStack_4c, in_r1, 0x24);
            uVar4 = in_r1[0x18];
            nVar1 = NV_SUCC;
          }
          if ((uVar4 == '\x02') && (iVar3 = memcmp(keyPair, in_r1, 8), iVar3 == 0))
          {
            return '\0';
          }
        }
      }
    LAB_0001ec72:
      iVar5 = iVar5 + 1;
    } while (iVar5 <= (int)(uint)local_28);
    memcpy(in_r1, auStack_4c, 0x24);
  }
  return nVar1;
}

u8 ss_devKeyPairDelete(addrExt_t extAddr)

{
  nv_sts_t nVar1;
  void *in_r0;
  int iVar2;
  int iVar3;
  u8 auStack_48[36];
  ushort local_24;
  u8 uStack_22;

  local_24 = 0;
  uStack_22 = '\0';
  nVar1 = nv_flashReadNew('\0', '\a', 0xff, 0x24, (u8 *)&local_24);
  if (nVar1 == NV_SUCC)
  {
    iVar3 = 0;
    do
    {
      nVar1 = nv_flashReadByIndex('\a', '\b', uStack_22, (u16)iVar3, 0x24, auStack_48);
      if ((nVar1 == NV_SUCC) && (iVar2 = memcmp(in_r0, auStack_48, 8), iVar2 == 0))
      {
        nv_itemDeleteByIndex('\a', '\b', uStack_22, (u16)iVar3);
        ss_ib.devKeyPairNum = ss_ib.devKeyPairNum - 1;
        return '\0';
      }
      iVar3 = iVar3 + 1;
    } while (iVar3 <= (int)(uint)local_24);
    nVar1 = NV_ITEM_NOT_FOUND;
  }
  return nVar1;
}

u16 ss_devKeyPairInfoGet(void)

{
  nv_sts_t nVar1;
  int iVar2;
  u8 auStack_40[36];
  ushort local_1c;
  u8 uStack_1a;

  local_1c = 0;
  uStack_1a = '\0';
  ss_ib.devKeyPairNum = 0;
  nVar1 = nv_flashReadNew('\0', '\a', 0xff, 0x24, (u8 *)&local_1c);
  if (nVar1 == NV_SUCC)
  {
    iVar2 = 0;
    do
    {
      nVar1 = nv_flashReadByIndex('\a', '\b', uStack_1a, (u16)iVar2, 0x24, auStack_40);
      if (nVar1 == NV_SUCC)
      {
        ss_ib.devKeyPairNum = ss_ib.devKeyPairNum + 1;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 <= (int)(uint)local_1c);
  }
  return ss_ib.devKeyPairNum;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsmeRequestKeyReq(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  u8 uVar2;
  undefined uVar3;
  uint uStack_24;
  undefined4 uStack_20;
  uint uStack_1c;
  undefined local_18;

  if ((ss_ib.tcPolicy.updateTCLKrequired == '\0') || (1 < (byte)(in_r0->buf[0x10] - 2)))
  {
    zb_buf_free(in_r0);
  }
  else
  {
    if (in_r0->buf[0x11] == '\x02')
    {
      uVar2 = '\n';
      uVar3 = 10;
    }
    else
    {
      uVar2 = '\x02';
      uVar3 = 2;
    }
    puVar1 = (undefined *)tl_bufInitalloc(in_r0, uVar2);
    *puVar1 = 8;
    puVar1[1] = in_r0->buf[0x11];
    if (in_r0->buf[0x11] == '\x02')
    {
      memcpy(puVar1 + 2, in_r0->buf + 8, 8);
    }
    uStack_24 = 0;
    uStack_20 = 0;
    local_18 = 0;
    uVar2 = in_r0->buf[0x10];
    uStack_1c = (uint)CONCAT11(uVar3, uVar2);
    if (uVar2 == '\x02')
    {
      uStack_24 = (uint) * (ushort *)in_r0->buf;
    }
    else if (uVar2 == '\x03')
    {
      memcpy(&uStack_24, in_r0, 8);
    }
    uStack_1c = CONCAT13(1, CONCAT12(1, (undefined2)uStack_1c));
    aps_cmd_send();
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsmeSwitchKeyReq(void)

{
  zb_buf_t *in_r0;
  undefined *puVar1;
  int iVar2;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  undefined local_14;

  puVar1 = (undefined *)tl_bufInitalloc(in_r0, '\x02');
  *puVar1 = 9;
  puVar1[1] = in_r0->buf[8];
  uStack_20 = 0;
  uStack_1c = 0;
  local_14 = 0;
  uStack_18 = 0x200;
  iVar2 = memcmp(in_r0, &g_invalid_addr, 8);
  if (iVar2 == 0)
  {
    uStack_18 = CONCAT31(uStack_18._1_3_, 2);
    uStack_20 = CONCAT22(uStack_20._2_2_, 0xfffe);
  }
  else
  {
    uStack_18 = CONCAT31(uStack_18._1_3_, 3);
    memcpy(&uStack_20, in_r0, 8);
  }
  uStack_18 = CONCAT13(1, CONCAT12('\x01' - ((uStack_20 & 0xfff8) == 0xfff8), (undefined2)uStack_18));
  aps_cmd_send();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsmeUpdateDevReq(void)

{
  zb_buf_t *in_r0;
  void *out;

  if (ss_ib.tcLinkKeyType == '\0')
  {
    ss_apsmeUpdateDevReqSend();
  }
  else if (ss_ib.tcLinkKeyType == '\x01')
  {
    if ((-1 < (int)((uint)aps_ib._18_1_ << 0x1d)) && (out = (void *)c1(), out != (void *)0x0))
    {
      memcpy(out, in_r0, 0x13);
      ev_timer_taskPost(updateDeviceSendAgain, out, 0x14);
    }
    ss_apsmeUpdateDevReqSend();
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsmeTransportKeyReq(void)

{
  u8 uVar1;
  char cVar2;
  bool bVar3;
  zb_buf_t *in_r0;
  int iVar4;
  undefined *puVar5;
  undefined *out;
  char cVar6;
  undefined uVar7;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  undefined local_24;

  iVar4 = memcmp(in_r0, &g_zero_addr, 8);
  if ((iVar4 == 0) && (in_r0->buf[8] != '\x01'))
  {
    zb_buf_free(in_r0);
    return;
  }
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  local_24 = 0;
  puVar5 = (undefined *)tl_bufInitalloc(in_r0, '\'');
  *puVar5 = 5;
  puVar5[1] = in_r0->buf[8];
  memcpy(puVar5 + 2, in_r0->buf + 9, 0x10);
  out = puVar5 + 0x12;
  uStack_28 = CONCAT13(1, (uint3)uStack_28);
  iVar4 = memcmp(in_r0, &g_zero_addr, 8);
  cVar2 = (char)puVar5;
  if (iVar4 == 0)
  {
    uStack_28 = CONCAT31(uStack_28._1_3_, 2);
    uStack_30 = CONCAT22(uStack_30._2_2_, 0xfffe);
    iVar4 = memcmp(in_r0, &g_zero_addr, 8);
  }
  else
  {
    uStack_28 = CONCAT31(uStack_28._1_3_, 3);
    if (in_r0->buf[0x19] == '\0')
    {
      memcpy(&uStack_30, in_r0, 8);
    }
    else
    {
      memcpy(puVar5 + -0x17, in_r0, 8);
      memcpy(&uStack_30, in_r0->buf + 0x1b, 8);
    }
    iVar4 = memcmp(in_r0, &g_zero_addr, 8);
  }
  if ((iVar4 == 0) || (in_r0->buf[0x19] != '\0'))
  {
    uVar7 = 0;
    uVar1 = in_r0->buf[0x24];
  }
  else
  {
    uVar7 = 1;
    uVar1 = in_r0->buf[0x24];
  }
  if ((uVar1 == '\0') && (in_r0->buf[0x19] == '\0'))
  {
    uStack_28 = uStack_28 & 0xffffff;
    uVar1 = in_r0->buf[8];
  }
  else
  {
    uVar1 = in_r0->buf[8];
  }
  if (uVar1 == '\x01')
  {
    puVar5[0x12] = in_r0->buf[0x1a];
    memcpy(puVar5 + 0x13, in_r0, 8);
    bVar3 = ss_securityModeIsDistributed();
    if (bVar3 == false)
    {
      memcpy(puVar5 + 0x1b, g_zbInfo.macPib.extAddress, 8);
    }
    else
    {
      memcpy(puVar5 + 0x1b, ss_ib.trust_center_address, 8);
    }
    cVar6 = cVar2 + '#';
  }
  else if (uVar1 == '\x04')
  {
    memcpy(out, in_r0, 8);
    memcpy(puVar5 + 0x1a, g_zbInfo.macPib.extAddress, 8);
    cVar6 = cVar2 + '\"';
  }
  else
  {
    if (uVar1 == '\x03')
    {
      memcpy(out, in_r0->buf + 0x1b, 8);
      puVar5[0x1a] = in_r0->buf[0x23];
      out = puVar5 + 0x1b;
    }
    cVar6 = (char)out;
  }
  uStack_28._0_3_ = CONCAT12(uVar7, CONCAT11(cVar6 - cVar2, (undefined)uStack_28));
  uStack_28 = uStack_28 & 0xff000000 | (uint)(uint3)uStack_28;
  aps_cmd_send();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsUpdateDeviceCmdHandle(void)

{
  byte bVar1;
  u16 shortAddr;
  u8 uVar2;
  zb_buf_t *in_r0;
  int iVar3;
  undefined in_stack_ffffffb4;
  undefined7 in_stack_ffffffb5;
  char cStack_33;
  undefined uStack_28;
  undefined auStack_27[8];
  byte bStack_1f;
  byte bStack_1e;
  u8 uStack_1d;

  shortAddr = *(u16 *)(in_r0->buf + 0x14);
  bVar1 = in_r0->buf[0x1f];
  memcpy(&uStack_28, *(void **)(in_r0->buf + 0xc), 0xc);
  iVar3 = (uint)bStack_1e * 0x100 + (uint)bStack_1f;
  in_r0->buf[0x10] = (u8)iVar3;
  in_r0->buf[0x11] = (u8)((uint)iVar3 >> 8);
  memcpy(in_r0->buf + 8, auStack_27, 8);
  in_r0->buf[0x12] = uStack_1d;
  uVar2 = tl_zbExtAddrByShortAddr(shortAddr, (addrExt_t)CONCAT71(in_stack_ffffffb5, in_stack_ffffffb4), (u16 *)in_r0);
  if (uVar2 == 0xff)
  {
  LAB_0001f1f6:
    zb_buf_free(in_r0);
  }
  else
  {
    uVar2 = ss_devKeyPairFind((addrExt_t)CONCAT71(in_stack_ffffffb5, in_stack_ffffffb4),
                              (ss_dev_pair_set_t *)in_r0);
    if (uVar2 == '\0')
    {
      if ((bVar1 == 0) && (cStack_33 == '\0'))
        goto LAB_0001f1f6;
    }
    else if ((ss_ib.tcLinkKeyType == '\0') && ((bVar1 & 1) == 0))
      goto LAB_0001f1f6;
    tl_zbTaskPost(ss_zdoUpdateDeviceIndHandle, in_r0);
    if (g_gpDeviceAnnounceCheckCb != ll_reset)
    {
      FUNDDDDA();
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 FUNDDDDA(void)

{
  bool bVar1;
  int iVar2;
  uint extraout_r1;
  code *in_r3;
  undefined4 uVar3;

  iVar2 = (*in_r3)();
  uVar3 = 0xa3;
  if (((((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) && (uVar3 = 0xaa, (extraout_r1 & 0xff) == 4)) && (bVar1 = ss_securityModeIsDistributed(), bVar1 == false)) &&
      ((uVar3 = 0xad, iVar2 != 0 && (uVar3 = 0, *(char *)(iVar2 + 0x18) == '\0'))))
  {
    uVar3 = 0xad;
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 ss_apsVerifyKeyCmdValid(void)

{
  bool bVar1;
  int in_r0;
  char in_r1;
  undefined4 uVar2;

  uVar2 = 0xa3;
  if (((((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) && (uVar2 = 0xaa, in_r1 == '\x04')) &&
       (bVar1 = ss_securityModeIsDistributed(), bVar1 == false)) &&
      ((uVar2 = 0xad, in_r0 != 0 && (uVar2 = 0, *(char *)(in_r0 + 0x18) == '\0'))))
  {
    uVar2 = 0xad;
  }
  return uVar2;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsVerifyKeyCmdHandle(void)

{
  zb_buf_t *in_r0;
  ss_dev_pair_set_t *keyPair;
  int iVar1;
  undefined *puVar2;
  int iVar3;
  undefined in_stack_ffffff9c;
  undefined in_stack_ffffff9d;
  undefined6 in_stack_ffffff9e;
  undefined auStack_5a[18];
  undefined4 uStack_48;
  undefined *puStack_44;
  uint uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined local_34;
  undefined auStack_30[19];
  undefined local_1d;

  if ((*(ushort *)(in_r0->buf + 2) & 0xfff8) != 0xfff8)
  {
    memcpy(&stack0xffffff9c, *(void **)(in_r0->buf + 0xc), 0x1a);
    keyPair = (ss_dev_pair_set_t *)ss_tcKeyPairFind();
    if (keyPair != (ss_dev_pair_set_t *)0x0)
    {
      iVar1 = ss_apsVerifyKeyCmdValid();
      if (iVar1 == 0)
      {
        local_1d = 3;
        ss_keyHash();
        iVar3 = memcmp(auStack_30, auStack_5a, 0x10);
        if (iVar3 == 0)
        {
          keyPair->keyAttr = SS_VERIFIED_KEY;
          ss_devKeyPairDelete((addrExt_t)
                                  CONCAT62(in_stack_ffffff9e,
                                           CONCAT11(in_stack_ffffff9d, in_stack_ffffff9c)));
          ss_devKeyPairSave(keyPair);
        }
        else
        {
          iVar1 = 0xad;
        }
      }
      ss_tcKeyPairClear();
      uStack_48 = 0;
      puStack_44 = (undefined *)0x0;
      uStack_40 = 0;
      uStack_3c = 0;
      local_34 = 0;
      uStack_38 = 0xb00;
      puVar2 = (undefined *)tl_bufInitalloc(in_r0, '\v');
      *puVar2 = 0x10;
      puVar2[1] = (char)iVar1;
      puVar2[2] = in_stack_ffffff9d;
      memcpy(puVar2 + 3, &stack0xffffff9e, 8);
      uStack_38 = CONCAT31(uStack_38._1_3_, 2);
      if (iVar1 == 0)
      {
        uStack_38._0_3_ = CONCAT12(1, (undefined2)uStack_38);
      }
      uStack_38 = CONCAT13(1, (undefined3)uStack_38);
      uStack_40 = uStack_40 & 0xffff0000 | (uint) * (ushort *)(in_r0->buf + 0x14);
      local_34 = 1;
      puStack_44 = puVar2;
      aps_cmd_send();
      return;
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_apsRequestKeyCmdHandle(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;
  undefined1 *out;
  undefined4 uVar2;
  undefined *puVar3;
  char *pcVar4;
  int iVar5;
  undefined4 in_stack_ffffffb8;
  undefined4 in_stack_ffffffbc;
  u16 auStack_30[6];

  if (((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) &&
      (*(char *)(*(int *)(in_r0->buf + 0xc) + 1) == '\x04'))
  {
    uVar1 = tl_zbExtAddrByShortAddr(*(u16 *)(in_r0->buf + 0x14),
                                    (addrExt_t)CONCAT44(in_stack_ffffffbc, in_stack_ffffffb8), auStack_30);
    if ((uVar1 == '\0') &&
        ((ss_ib.tcPolicy.allowTCLKrequest == '\x01' &&
          ((int)(uint)ss_ib.devKeyPairNum < (int)(TL_ZB_NWK_ADDR_MAP_SIZE - 1)))))
    {
      out = (undefined1 *)ss_tcKeyPairFind();
      if (out != (undefined1 *)0x0)
      {
      LAB_0001f3f6:
        memcpy(out, auStack_30, 8);
        drv_generateRandomData(out + 8, '\x10');
        out[0x19] = 0;
        out[0x18] = 1;
        out[0x20] = 0;
        out[0x21] = 0;
        out[0x22] = 0;
        out[0x23] = 0;
        out[0x1c] = 0;
        out[0x1d] = 0;
        out[0x1e] = 0;
        out[0x1f] = 0;
        uVar2 = FUN_0000162c(ss_ib.ssTimeoutPeriod, 1000);
        out[0x24] = (char)uVar2;
        out[0x25] = (char)((uint)uVar2 >> 8);
        out[0x26] = (char)((uint)uVar2 >> 0x10);
        out[0x27] = (char)((uint)uVar2 >> 0x18);
        puVar3 = (undefined *)tl_bufInitalloc(in_r0, '\'');
        *puVar3 = 5;
        puVar3[1] = 4;
        memcpy(puVar3 + 2, out + 8, 0x10);
        memcpy(puVar3 + 0x12, auStack_30, 8);
        memcpy(puVar3 + 0x1a, g_zbInfo.macPib.extAddress, 8);
        aps_cmd_send();
        return;
      }
      pcVar4 = g_ssTcKeyPair + 0x1a;
      iVar5 = 0;
      do
      {
        out = g_ssTcKeyPair + iVar5 * 0x28;
        if (*pcVar4 == '\0')
        {
          g_ssTcKeyPair[iVar5 * 0x28 + 0x1a] = 1;
          goto LAB_0001f3f6;
        }
        iVar5 = iVar5 + 1;
        pcVar4 = pcVar4 + 0x28;
      } while (iVar5 != 10);
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 ss_nwkSecureFrame(void)

{
  int in_r0;
  int iVar1;
  byte in_r1;
  uint uVar2;
  byte *pbVar3;
  undefined4 uStack_4c;
  uint local_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  short local_38;
  undefined auStack_34[8];
  u32 uStack_2c;
  undefined uStack_28;

  uStack_3c = 0;
  uStack_2c = ss_ib.outgoingFrameCounter;
  local_44 = CONCAT31((undefined3)ss_ib.outgoingFrameCounter, 0x28);
  uStack_40 = ss_ib.outgoingFrameCounter >> 0x18;
  ss_ib.outgoingFrameCounter = ss_ib.outgoingFrameCounter + 1;
  local_38 = (ushort)ss_ib.activeKeySeqNum << 8;
  memcpy((void *)((int)&uStack_40 + 1), g_zbInfo.macPib.extAddress, 8);
  local_44 = local_44 & 0xfffffff8 | 5;
  uVar2 = in_r1 - 0xe & 0xff;
  memcpy((void *)(*(int *)(in_r0 + 0x15) + uVar2), &local_44, 0xe);
  iVar1 = ss_zdoGetNwkKeyBySeqNum();
  uStack_4c = 1;
  if (iVar1 != 0)
  {
    uStack_28 = (undefined)local_44;
    memcpy(auStack_34, (void *)((int)&uStack_40 + 1), 8);
    iVar1 = ss_ccmEncryption();
    if (iVar1 != 0)
    {
      *(byte *)(in_r0 + 0x14) = (char)iVar1 + in_r1;
      pbVar3 = (byte *)(*(int *)(in_r0 + 0x15) + uVar2);
      *pbVar3 = *pbVar3 & 0xf8;
      uStack_4c = 0;
      if (((((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) &&
            (0x80000000 < ss_ib.outgoingFrameCounter)) &&
           (zdoAppIndCbLst != 0)) &&
          ((*(int *)(zdoAppIndCbLst + 0x24) != 0 && (-1 < (int)((uint)zdo_mgmt_nwk_flag << 0x1e)))))
      {
        FUNEEEEA();
      }
    }
  }
  return uStack_4c;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 FUNEEEEA(void)

{
  byte bVar1;
  ushort uVar2;
  u8 uVar3;
  zb_buf_t *buf;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  int iVar5;
  int extraout_r1;
  byte *in;
  code *in_r2;
  uint extraout_r2;
  uint uVar6;
  int extraout_r3;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint in_stack_00000004;
  undefined4 in_stack_ffffffa4;
  undefined4 in_stack_ffffffa8;
  uint local_48;
  byte bStack_44;
  u16 auStack_43[4];
  byte bStack_3b;
  undefined auStack_38[8];
  uint uStack_30;
  undefined local_2c;
  ushort local_28[2];

  buf = (zb_buf_t *)(*in_r2)();
  uVar8 = extraout_r1 * 0x1000000 + 0xf2000000U >> 0x18;
  in = (byte *)(extraout_r3 + uVar8);
  *in = *in & 0xf8 | 5;
  memcpy(&local_48, in, 0xe);
  uVar7 = ((extraout_r2 & 0xff) - 0xf) - uVar8;
  uVar2 = *(ushort *)(buf->buf + 0x14);
  uVar6 = uVar7 & 0xff;
  if ((int)(uVar7 * 0x1000000) >> 0x18 < 4)
  {
  LAB_0001f7ee:
    g_sysDiags.nwkDecryptFailures = g_sysDiags.nwkDecryptFailures + 1;
    zb_buf_free(buf);
  }
  else
  {
    ptVar4 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT44(in_stack_ffffffa8, in_stack_ffffffa4));
    if (((ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0) || (ss_ib.activeKeySeqNum != bStack_3b)) || ((ptVar4->incomingFrameCnt <= ((uint)bStack_44 << 0x18 | local_48 >> 8) &&
                                                                                                        (ptVar4->incomingFrameCnt != 0xffffffff))))
    {
      iVar5 = ss_zdoGetNwkKeyBySeqNum();
      if ((iVar5 != 0) && (ss_ib.activeKeySeqNum <= bStack_3b))
      {
        memcpy(auStack_38, auStack_43, 8);
        uStack_30 = (uint)bStack_44 << 0x18 | local_48 >> 8;
        local_2c = (undefined)local_48;
        iVar9 = extraout_r3 + uVar8 + 0xe;
        iVar5 = ss_ccmDecryption();
        if (iVar5 == 0)
        {
          uVar3 = tl_zbShortAddrByExtAddr(local_28, (addrExt_t)CONCAT44(iVar9, uVar6), auStack_43);
          if (((uVar3 == '\0') && (uVar2 != local_28[0])) && (local_28[0] < 0xfff7))
          {
            T_DBG_decFrameCnt = T_DBG_decFrameCnt + '\x01';
            zb_buf_free(buf);
            return 1;
          }
          if ((((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) &&
               (0x80000000 < ((uint)bStack_44 << 0x18 | local_48 >> 8))) &&
              ((zdoAppIndCbLst != 0 &&
                ((*(int *)(zdoAppIndCbLst + 0x24) != 0 &&
                  (-1 < (int)((uint)zdo_mgmt_nwk_flag << 0x1e)))))))
          {
            tl_cryHashFunction();
          }
          if (ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0)
          {
            ptVar4->age = '\0';
            *(char *)&ptVar4->incomingFrameCnt = (char)(local_48 >> 8);
            *(char *)((int)&ptVar4->incomingFrameCnt + 1) = (char)(local_48 >> 0x10);
            *(char *)((int)&ptVar4->incomingFrameCnt + 2) = (char)(local_48 >> 0x18);
            *(byte *)((int)&ptVar4->incomingFrameCnt + 3) = bStack_44;
            ptVar4->lqi = (u8)((int)((uint)ptVar4->lqi + (in_stack_00000004 & 0xff)) >> 1);
            bVar1 = ptVar4->field_0x1e;
            if ((bVar1 & 0x70) == 0x50)
            {
              if ((bVar1 & 0xe) == 2)
              {
                ptVar4->field_0x1e = bVar1 & 0x8f | 0x20;
              }
              else if ((bVar1 & 0xe) == 4)
              {
                ptVar4->field_0x1e = bVar1 & 0x8f | 0x10;
                ss_zdoChildTableStore();
              }
            }
          }
          if (ss_ib.activeKeySeqNum == bStack_3b)
          {
            return 0;
          }
          if ((int)((uint)zdo_mgmt_nwk_flag << 0x1d) < 0)
          {
            return 0;
          }
          ss_zdoNwkKeySwitch();
          return 0;
        }
        goto LAB_0001f7ee;
      }
      uVar3 = '\x12';
    }
    else
    {
      g_sysDiags.nwkFCFailure = g_sysDiags.nwkFCFailure + 1;
      uVar3 = '\x11';
    }
    buf->buf[2] = uVar3;
    buf->buf[0] = (u8)uVar2;
    buf->buf[1] = (u8)(uVar2 >> 8);
    tl_zbTaskPost(zdo_nlme_status_indication, buf);
  }
  return 1;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 ss_nwkDecryptFrame(void)

{
  byte bVar1;
  ushort uVar2;
  u8 uVar3;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  int iVar5;
  int in_r1;
  byte *in;
  uint in_r2;
  uint uVar6;
  int in_r3;
  uint uVar7;
  uint uVar8;
  int iVar9;
  uint in_stack_00000004;
  undefined4 in_stack_ffffffa4;
  undefined4 in_stack_ffffffa8;
  uint local_48;
  byte bStack_44;
  u16 auStack_43[4];
  byte bStack_3b;
  undefined auStack_38[8];
  uint uStack_30;
  undefined local_2c;
  ushort local_28[2];

  uVar8 = in_r1 * 0x1000000 + 0xf2000000U >> 0x18;
  in = (byte *)(in_r3 + uVar8);
  *in = *in & 0xf8 | 5;
  memcpy(&local_48, in, 0xe);
  uVar7 = ((in_r2 & 0xff) - 0xf) - uVar8;
  uVar2 = *(ushort *)(in_r0->buf + 0x14);
  uVar6 = uVar7 & 0xff;
  if ((int)(uVar7 * 0x1000000) >> 0x18 < 4)
  {
  LAB_0001f7ee:
    g_sysDiags.nwkDecryptFailures = g_sysDiags.nwkDecryptFailures + 1;
    zb_buf_free(in_r0);
  }
  else
  {
    ptVar4 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT44(in_stack_ffffffa8, in_stack_ffffffa4));
    if (((ptVar4 == (tl_zb_normal_neighbor_entry_t *)0x0) || (ss_ib.activeKeySeqNum != bStack_3b)) || ((ptVar4->incomingFrameCnt <= ((uint)bStack_44 << 0x18 | local_48 >> 8) &&
                                                                                                        (ptVar4->incomingFrameCnt != 0xffffffff))))
    {
      iVar5 = ss_zdoGetNwkKeyBySeqNum();
      if ((iVar5 != 0) && (ss_ib.activeKeySeqNum <= bStack_3b))
      {
        memcpy(auStack_38, auStack_43, 8);
        uStack_30 = (uint)bStack_44 << 0x18 | local_48 >> 8;
        local_2c = (undefined)local_48;
        iVar9 = in_r3 + uVar8 + 0xe;
        iVar5 = ss_ccmDecryption();
        if (iVar5 == 0)
        {
          uVar3 = tl_zbShortAddrByExtAddr(local_28, (addrExt_t)CONCAT44(iVar9, uVar6), auStack_43);
          if (((uVar3 == '\0') && (uVar2 != local_28[0])) && (local_28[0] < 0xfff7))
          {
            T_DBG_decFrameCnt = T_DBG_decFrameCnt + '\x01';
            zb_buf_free(in_r0);
            return 1;
          }
          if ((((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0) &&
               (0x80000000 < ((uint)bStack_44 << 0x18 | local_48 >> 8))) &&
              ((zdoAppIndCbLst != 0 &&
                ((*(int *)(zdoAppIndCbLst + 0x24) != 0 &&
                  (-1 < (int)((uint)zdo_mgmt_nwk_flag << 0x1e)))))))
          {
            tl_cryHashFunction();
          }
          if (ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0)
          {
            ptVar4->age = '\0';
            *(char *)&ptVar4->incomingFrameCnt = (char)(local_48 >> 8);
            *(char *)((int)&ptVar4->incomingFrameCnt + 1) = (char)(local_48 >> 0x10);
            *(char *)((int)&ptVar4->incomingFrameCnt + 2) = (char)(local_48 >> 0x18);
            *(byte *)((int)&ptVar4->incomingFrameCnt + 3) = bStack_44;
            ptVar4->lqi = (u8)((int)((uint)ptVar4->lqi + (in_stack_00000004 & 0xff)) >> 1);
            bVar1 = ptVar4->field_0x1e;
            if ((bVar1 & 0x70) == 0x50)
            {
              if ((bVar1 & 0xe) == 2)
              {
                ptVar4->field_0x1e = bVar1 & 0x8f | 0x20;
              }
              else if ((bVar1 & 0xe) == 4)
              {
                ptVar4->field_0x1e = bVar1 & 0x8f | 0x10;
                ss_zdoChildTableStore();
              }
            }
          }
          if (ss_ib.activeKeySeqNum == bStack_3b)
          {
            return 0;
          }
          if ((int)((uint)zdo_mgmt_nwk_flag << 0x1d) < 0)
          {
            return 0;
          }
          ss_zdoNwkKeySwitch();
          return 0;
        }
        goto LAB_0001f7ee;
      }
      uVar3 = '\x12';
    }
    else
    {
      g_sysDiags.nwkFCFailure = g_sysDiags.nwkFCFailure + 1;
      uVar3 = '\x11';
    }
    in_r0->buf[2] = uVar3;
    in_r0->buf[0] = (u8)uVar2;
    in_r0->buf[1] = (u8)(uVar2 >> 8);
    tl_zbTaskPost(zdo_nlme_status_indication, in_r0);
  }
  return 1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 tl_cryHashFunction(void)

{
  int iVar1;
  uint extraout_r1;
  uchar *Key;
  code *in_r3;
  uint uVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  byte abStack_28[16];

  iVar1 = (*in_r3)();
  uVar5 = extraout_r1 & 0xff;
  memset(Key, 0, 0x10);
  uVar2 = 0;
  uVar4 = 0;
  while (uVar4 < uVar5)
  {
    while (true)
    {
      abStack_28[uVar2] = *(byte *)(iVar1 + uVar4);
      uVar2 = uVar2 + 1;
      uVar4 = uVar4 + 1;
      if (uVar2 < 0x10)
        break;
      aes_encrypt(Key, abStack_28, Key);
      iVar3 = 0;
      do
      {
        Key[iVar3] = Key[iVar3] ^ abStack_28[iVar3];
        iVar3 = iVar3 + 1;
      } while (iVar3 != 0x10);
      uVar2 = 0;
      if (uVar5 <= uVar4)
        goto LAB_0001f9a2;
    }
  }
LAB_0001f9a2:
  abStack_28[uVar2] = 0x80;
  while (uVar2 = uVar2 + 1, uVar2 != 0xe)
  {
    if (0xf < uVar2)
    {
      aes_encrypt(Key, abStack_28, Key);
      iVar1 = 0;
      do
      {
        Key[iVar1] = Key[iVar1] ^ abStack_28[iVar1];
        iVar1 = iVar1 + 1;
      } while (iVar1 != 0x10);
      abStack_28[0] = 0;
      uVar2 = 1;
    }
    abStack_28[uVar2] = 0;
  }
  abStack_28[14] = (byte)((uVar5 << 3) >> 8);
  abStack_28[15] = (byte)(uVar5 << 3);
  aes_encrypt(Key, abStack_28, Key);
  iVar1 = 0;
  do
  {
    Key[iVar1] = Key[iVar1] ^ abStack_28[iVar1];
    iVar1 = iVar1 + 1;
  } while (iVar1 != 0x10);
  return 0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_ttlMAC(void)

{
  uint in_r0;
  u8 *pBuf;
  int in_r1;
  int in_r2;
  int iVar1;
  uint uVar2;
  byte local_3c[16];
  undefined auStack_2c[16];

  uVar2 = in_r0 & 0xff;
  if (uVar2 < 0x71)
  {
    pBuf = ev_buf_allocate(0x80);
    if (pBuf == (u8 *)0x0)
    {
      sys_exceptionPost(0x9e, '\x02');
    }
    else
    {
      iVar1 = 0;
      do
      {
        local_3c[iVar1] = *(byte *)(in_r2 + iVar1) ^ 0x5c;
        iVar1 = iVar1 + 1;
      } while (iVar1 != 0x10);
      iVar1 = 0;
      do
      {
        pBuf[iVar1] = *(byte *)(in_r2 + iVar1) ^ 0x36;
        iVar1 = iVar1 + 1;
      } while (iVar1 != 0x10);
      if (uVar2 != 0)
      {
        iVar1 = 0;
        do
        {
          pBuf[iVar1 + 0x10] = *(u8 *)(in_r1 + iVar1);
          iVar1 = iVar1 + 1;
        } while (iVar1 < (int)uVar2);
      }
      (*(code *)&tl_cryHashFunction)(pBuf, uVar2 + 0x10 & 0xff, auStack_2c);
      (*(code *)&tl_cryHashFunction)(local_3c, 0x20);
      ev_buf_free(pBuf);
    }
  }
  else
  {
    sys_exceptionPost(0x8c, '\x04');
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 ss_keyHash(void)

{
  ss_ttlMAC();
  return 0;
}

u8 aes_ccmAuthTran(u8 M, u8 *key, u8 *iv, u8 *mStr, u16 mStrLen, u8 *aStr, u8 aStrLen, u8 *result)

{
  u8 uVar1;
  u8 *pBuf;
  uint uVar2;
  uint length;
  uint uVar3;
  uint length_00;
  int iVar4;
  uint uVar5;
  int iVar6;
  u16 uVar7;
  uint uStack_54;
  undefined4 local_44;
  undefined4 uStack_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  byte local_34[16];

  length_00 = (uint)mStrLen;
  uVar5 = ((M - 2) * 0x10000000 >> 0x1d) << 3 | 1 | (uint)(aStrLen != '\0') * 0x40;
  local_34[0] = (byte)uVar5;
  memcpy(local_34 + 1, iv, 0xd);
  uVar2 = aStrLen + 2;
  uVar7 = mStrLen;
  pBuf = ev_buf_allocate((u16)uVar2);
  uVar7._1_1_ = (byte)(uVar7 >> 8);
  uVar7._0_1_ = (byte)uVar7;
  uVar1 = 0xff;
  if (pBuf != (u8 *)0x0)
  {
    *pBuf = '\0';
    pBuf[1] = aStrLen;
    memcpy(pBuf + 2, aStr, (uint)aStrLen);
    uVar7._1_1_ = (byte)(uVar7 >> 8);
    uVar7._0_1_ = (byte)uVar7;
    length = uVar2 & 0xff;
    local_44 = 0;
    uStack_40 = 0;
    uStack_3c = 0;
    uStack_38 = 0;
    uVar3 = length;
    if ((uVar2 & 0xf) != 0)
    {
      uVar3 = (uVar2 & 0xf0) + 0x10 & 0xff;
    }
    uVar3 = uVar3 + (mStrLen & 0xff);
    if ((mStrLen & 0xf) != 0)
    {
      uVar3 = (uVar3 & 0xf0) + 0x10;
    }
    local_44._0_1_ = 0;
    uStack_54 = 0;
    iVar6 = 0;
    while (true)
    {
      iVar4 = 0;
      while (true)
      {
        *(byte *)((int)&local_44 + iVar4) = (byte)local_44 ^ (byte)uVar5;
        iVar4 = iVar4 + 1;
        if (iVar4 == 0x10)
          break;
        local_44._0_1_ = *(byte *)((int)&local_44 + iVar4);
        uVar5 = (uint)local_34[iVar4];
      }
      aes_encrypt(key, (uchar *)&local_44, (uchar *)&local_44);
      uVar7._1_1_ = (byte)(uVar7 >> 8);
      uVar7._0_1_ = (byte)uVar7;
      if (length < 0x10)
      {
        if ((length - 2 & 0xff) < 0xf)
        {
          memcpy(local_34, pBuf + iVar6, length);
          uVar7._1_1_ = (byte)(uVar7 >> 8);
          uVar7._0_1_ = (byte)uVar7;
          memset(local_34 + length, 0, 0x10 - length);
          uVar7._1_1_ = (byte)(uVar7 >> 8);
          uVar7._0_1_ = (byte)uVar7;
          uStack_54 = 0;
          length = 0;
        }
        else if (length_00 < 0x10)
        {
          memcpy(local_34, mStr + uStack_54 * 0x10, length_00);
          uVar7._1_1_ = (byte)(uVar7 >> 8);
          uVar7._0_1_ = (byte)uVar7;
          memset(local_34 + length_00, 0, 0x10 - length_00);
          uVar7._1_1_ = (byte)(uVar7 >> 8);
          uVar7._0_1_ = (byte)uVar7;
          length = 0;
        }
        else
        {
          memcpy(local_34, mStr + uStack_54 * 0x10, 0x10);
          uVar7._1_1_ = (byte)(uVar7 >> 8);
          uVar7._0_1_ = (byte)uVar7;
          uStack_54 = uStack_54 + 1 & 0xff;
          length_00 = length_00 - 0x11 & 0xffff;
          length = 0;
        }
      }
      else
      {
        memcpy(local_34, pBuf + iVar6, 0x10);
        uVar7._1_1_ = (byte)(uVar7 >> 8);
        uVar7._0_1_ = (byte)uVar7;
        length = length - 0x11 & 0xff;
      }
      if ((uVar3 & 0xff) + 0x10 <= iVar6 + 0x10U)
        break;
      iVar6 = iVar6 + 0x10;
      uVar5 = (uint)local_34[0];
    }
    memcpy(result, &local_44, (uint)M);
    uVar7._1_1_ = (byte)(uVar7 >> 8);
    uVar7._0_1_ = (byte)uVar7;
    ev_buf_free(pBuf);
    uVar7._1_1_ = (byte)(uVar7 >> 8);
    uVar7._0_1_ = (byte)uVar7;
    uVar1 = '\0';
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 aes_ccmBaseTran(void)

{
  uint in_r0;
  uchar *in_r1;
  void *in_r2;
  byte *pbVar1;
  int in_r3;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint in_stack_00000000;
  int in_stack_0000000c;
  char in_stack_00000010;
  byte local_48[16];
  byte local_38;
  undefined auStack_37[13];
  undefined uStack_2a;
  undefined uStack_29;
  undefined local_28;

  uVar5 = in_stack_00000000 & 0xffff;
  local_28 = 1;
  local_38 = 1;
  memcpy(auStack_37, in_r2, 0xd);
  uStack_29 = 0;
  uStack_2a = 0;
  aes_encrypt(in_r1, &local_38, local_48);
  if ((in_r0 & 0xff) != 0)
  {
    uVar2 = 0;
    do
    {
      *(byte *)(in_stack_0000000c + uVar2) = *(byte *)(in_stack_0000000c + uVar2) ^ local_48[uVar2];
      uVar2 = uVar2 + 1;
    } while ((uVar2 & 0xffff) < (in_r0 & 0xff));
  }
  uStack_2a = 0;
  uStack_29 = 1;
  if ((in_stack_00000010 != '\x01') || (uVar5 != 0))
  {
    if ((in_stack_00000000 & 0xf) != 0)
    {
      in_stack_00000000 = (in_stack_00000000 & 0xf0) + 0x10;
    }
    if ((in_stack_00000000 & 0xff) != 0)
    {
      uVar2 = 1;
      uVar6 = 0;
      do
      {
        aes_encrypt(in_r1, &local_38, local_48);
        pbVar1 = local_48;
        uVar3 = uVar6;
        do
        {
          if ((int)uVar5 <= (int)uVar3)
            break;
          *(byte *)(in_r3 + uVar3) = *(byte *)(in_r3 + uVar3) ^ *pbVar1;
          uVar3 = uVar3 + 1;
          pbVar1 = pbVar1 + 1;
        } while (&local_38 != pbVar1);
        iVar4 = (uVar2 + 1) * 0x10000;
        uVar2 = uVar2 + 1 & 0xffff;
        uStack_2a = (undefined)((uint)iVar4 >> 0x18);
        uStack_29 = (undefined)((uint)iVar4 >> 0x10);
        uVar6 = uVar6 + 0x10 & 0xffff;
      } while (uVar6 < (in_stack_00000000 & 0xff));
    }
  }
  return 0;
}

u8 aes_ccmEncTran(u8 M, u8 *key, u8 *iv, u8 *mStr, u16 mStrLen, u8 *aStr, u8 aStrLen, u8 *result)

{
  u8 uVar1;

  uVar1 = aes_ccmBaseTran();
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint ss_ccmEncryption(void)

{
  u8 uVar1;
  u8 *in_r0;
  u8 *in_r1;
  u8 in_r2;
  u8 *in_r3;
  uint uVar2;
  uint uVar3;
  uint in_stack_00000000;
  u8 *in_stack_00000004;
  u8 auStack_24[4];

  uVar3 = in_stack_00000000 & 0xff;
  uVar1 = aes_ccmAuthTran('\x04', in_r0, in_r1, in_stack_00000004, (u16)uVar3, in_r3, in_r2, auStack_24);
  uVar2 = 0;
  if (uVar1 == '\0')
  {
    aes_ccmEncTran('\x04', in_r0, in_r1, in_stack_00000004, (u16)uVar3, in_r3, in_r2, auStack_24);
    memcpy(in_stack_00000004 + uVar3, auStack_24, 4);
    uVar2 = uVar3 + 4 & 0xff;
  }
  return uVar2;
}

u8 aes_ccmDecTran(u8 micLen, u8 *key, u8 *iv, u8 *mStr, u16 mStrLen, u8 *aStr, u8 aStrLen, u8 *mic)

{
  u8 uVar1;

  uVar1 = aes_ccmBaseTran();
  return uVar1;
}

u8 aes_ccmDecAuthTran(u8 micLen, u8 *key, u8 *iv, u8 *mStr, u16 mStrLen, u8 *aStr, u8 aStrLen, u8 *mic)

{
  u8 *puVar1;
  int iVar2;
  u8 uVar3;
  byte bVar4;
  u8 uVar5;
  int iVar6;
  u8 local_20;
  u8 auStack_1f[19];

  uVar3 = aes_ccmAuthTran(micLen, key, iv, mStr, mStrLen, aStr, aStrLen, &local_20);
  uVar5 = 0xff;
  if (((uVar3 == '\0') && (uVar5 = '\0', micLen != '\0')) && (uVar5 = 0xff, *mic == local_20))
  {
    iVar6 = 0;
    bVar4 = 0;
    do
    {
      bVar4 = bVar4 + 1;
      if (micLen <= bVar4)
      {
        return '\0';
      }
      iVar2 = iVar6 + 1;
      puVar1 = auStack_1f + iVar6;
      iVar6 = iVar6 + 1;
    } while (mic[iVar2] == *puVar1);
    uVar5 = 0xff;
  }
  return uVar5;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 ss_ccmDecryption(void)

{
  u8 uVar1;
  u8 *in_r0;
  u8 *in_r1;
  u8 in_r2;
  u8 *in_r3;
  int iVar2;
  uint in_stack_00000000;
  u8 *in_stack_00000004;
  ushort mStrLen;

  iVar2 = (in_stack_00000000 & 0xff) - 4;
  mStrLen = (ushort)iVar2 & 0xff;
  aes_ccmDecTran('\x04', in_r0, in_r1, in_stack_00000004, mStrLen, in_r3, in_r2, in_stack_00000004 + iVar2);
  uVar1 = aes_ccmDecAuthTran('\x04', in_r0, in_r1, in_stack_00000004, mStrLen, in_r3, in_r2,
                             in_stack_00000004 + iVar2);
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zb_tcTransportKeyTimerCb(void)

{
  void *in_r0;

  tl_zbTaskPost(ss_apsmeTransportKeyReq, in_r0);
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int tcSwitchKeyTimerCb(void)

{
  u8 uVar1;
  ss_apsmeSwitchKeyReq_t sStack_14;

  memcpy(&sStack_14, &g_invalid_addr, 8);
  sStack_14.keySeqNum = ss_ib.activeKeySeqNum + '\x01';
  uVar1 = zb_apsmeSwitchKeyReq(&sStack_14);
  return -(uint)(uVar1 == '\0');
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_zdoTcInit(void)

{
  g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x10;
  memcpy(ss_ib.trust_center_address, g_zbInfo.macPib.extAddress, 8);
  aps_ib._18_1_ = aps_ib._18_1_ | 2;
  return;
}

bool ss_securityModeIsDistributed(void)

{
  int iVar1;
  char in_tmpCY;

  iVar1 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8);
  return (bool)((byte)iVar1 + ~(byte)iVar1 + in_tmpCY);
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_zdoChildTableStore(void)

{
  u16 uVar1;
  int in_r0;
  u8 *arg;
  undefined4 unaff_r4;
  undefined4 in_lr;

  arg = ev_buf_allocate(0xc);
  if (arg != (u8 *)0x0)
  {
    uVar1 = tl_zbshortAddrByIdx(*(u16 *)(in_r0 + 0x16));
    *arg = (u8)uVar1;
    arg[1] = (u8)((uint)uVar1 >> 8);
    tl_zbExtAddrByIdx(*(u16 *)(in_r0 + 0x16), (addrExt_t)CONCAT44(unaff_r4, in_lr));
    arg[0xb] = arg[0xb] & 0x8f | (byte)((*(byte *)(in_r0 + 0x1e) >> 4 & 7) << 4);
    arg[0xb] = arg[0xb] & 0xfe | *(byte *)(in_r0 + 0x1e) & 1;
    arg[0xb] = arg[0xb] & 0xf1 | (byte)((*(byte *)(in_r0 + 0x1e) >> 1 & 7) << 1);
    arg[10] = *(u8 *)(in_r0 + 0x20);
    tl_zbTaskPost(nwk_nodeAddrInfoStore, arg);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_zdoChildAuthStart(void)

{
  byte bVar1;
  u8 uVar2;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar3;
  int iVar4;
  uint uVar5;
  undefined in_stack_ffffff94;
  undefined7 in_stack_ffffff95;
  char cStack_54;
  char cStack_53;
  undefined4 local_48;
  undefined4 uStack_44;
  undefined local_40[34];
  u8 uStack_1e;

  memcpy(&local_48, in_r0, 0x15);
  uVar5 = 1;
  local_40[12] = local_40[12] | (local_40[11] != '\0') * '\x02';
  if (((local_40[12] != 0) && (uVar5 = 0, local_40[12] != 3)) && (uVar5 = 0xff, local_40[12] == 2))
  {
    uVar5 = 3;
  }
  ptVar3 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT71(in_stack_ffffff95, in_stack_ffffff94));
  if ((ss_ib._62_1_ & 7) == 0)
  {
    if ((ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0) &&
        (bVar1 = ptVar3->field_0x1e, (bVar1 & 0x70) == 0x50))
    {
      if ((bVar1 & 0xe) == 4)
      {
        ptVar3->field_0x1e = bVar1 & 0x8f | 0x10;
        ss_zdoChildTableStore();
      }
      else
      {
        ptVar3->field_0x1e = bVar1 & 0x8f | 0x20;
      }
    }
  }
  else
  {
    if (((uVar5 == 0) && (ptVar3 != (tl_zb_normal_neighbor_entry_t *)0x0)) &&
        ((ptVar3->field_0x1e & 0x70) == 0x10))
    {
      ss_zdoChildTableStore();
    }
    if ((int)((uint)g_zbNwkCtx._45_1_ << 0x1b) < 0)
    {
      if (uVar5 != 0)
      {
        uVar2 = ss_devKeyPairFind((addrExt_t)CONCAT71(in_stack_ffffff95, in_stack_ffffff94),
                                  (ss_dev_pair_set_t *)local_40);
        if (uVar5 == 3)
        {
          if ((ss_ib.tcPolicy.allowRejoins == '\0') &&
              ((uVar2 != '\0' ||
                ((cStack_53 == '\x01' &&
                  (iVar4 = memcmp(tcLinkKeyCentralDefault, ss_ib.tcLinkKey, 0x10), iVar4 == 0))))))
            goto LAB_0002007c;
        }
        else if ((((uVar2 == '\0') && (uVar5 == 1)) && (cStack_53 == '\0')) && (cStack_54 == '\x02'))
        {
          ss_devKeyPairDelete((addrExt_t)CONCAT71(in_stack_ffffff95, in_stack_ffffff94));
        }
        memcpy(in_r0, (ss_dev_pair_set_t *)local_40, 8);
        in_r0->buf[8] = '\x01';
        if ((int)((uint)ss_ib.preConfiguredKeyType << 0x1d) < 0)
        {
          memset(in_r0->buf + 9, 0, 0x10);
          in_r0->buf[0x1a] = '\0';
        }
        else
        {
          memcpy(in_r0->buf + 9, ss_ib.nwkSecurMaterialSet + (((uint)ss_ib._62_1_ << 0x1a) >> 0x1e),
                 0x10);
          in_r0->buf[0x1a] = ss_ib.activeKeySeqNum;
        }
        in_r0->buf[0x19] = local_40[10];
        if (local_40[10] != '\0')
        {
          memcpy(in_r0->buf + 0x1b, &local_48, 8);
        }
        in_r0->buf[0x24] = '\0';
        if ((zdoAppIndCbLst != 0) && (*(int *)(zdoAppIndCbLst + 0x20) != 0))
        {
          local_40._16_4_ = uStack_44;
          local_40._20_4_ = local_48;
          local_40._24_4_ = local_40._4_4_;
          local_40._28_4_ = local_40._0_4_;
          local_40._32_2_ = local_40._8_2_;
          uStack_1e = (u8)uVar5;
          iVar4 = ss_tcSwitchKeyTimerStart();
          if (iVar4 == 0)
            goto LAB_0002007c;
        }
      LAB_000201d8:
        tl_zbTaskPost(ss_apsmeTransportKeyReq, in_r0);
        return;
      }
    }
    else
    {
      iVar4 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8);
      if (iVar4 != 0)
      {
        in_r0->buf[0x12] = (u8)uVar5;
        memcpy(in_r0, ss_ib.trust_center_address, 8);
        in_r0->buf[0x10] = local_40[8];
        in_r0->buf[0x11] = local_40[9];
        memcpy(in_r0->buf + 8, (ss_dev_pair_set_t *)local_40, 8);
        tl_zbTaskPost(ss_apsmeUpdateDevReq, in_r0);
        return;
      }
      if ((uVar5 != 0) && ((uVar5 - 3) + ~(uVar5 - 3) + (uint)(2 < uVar5) == 0))
      {
        memcpy(in_r0, (ss_dev_pair_set_t *)local_40, 8);
        in_r0->buf[8] = '\x01';
        if ((int)((uint)ss_ib.preConfiguredKeyType << 0x1d) < 0)
        {
          memset(in_r0->buf + 9, 0, 0x10);
          in_r0->buf[0x1a] = '\0';
        }
        else
        {
          memcpy(in_r0->buf + 9, ss_ib.nwkSecurMaterialSet + (((uint)ss_ib._62_1_ << 0x1a) >> 0x1e),
                 0x10);
          in_r0->buf[0x1a] = ss_ib.activeKeySeqNum;
        }
        in_r0->buf[0x19] = '\0';
        in_r0->buf[0x24] = '\0';
        goto LAB_000201d8;
      }
    }
  }
LAB_0002007c:
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_tcSwitchKeyTimerStart(void)

{
  code *unaff_r8;

  (*unaff_r8)();
  if ((int)((uint)zdo_mgmt_nwk_flag << 0x1e) < 0)
  {
    ev_timer_taskPost(tcSwitchKeyTimerCb, (void *)0x0, 3000);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_tcTransportKeyTimerStart(void)

{
  void *in_r0;
  uint uVar1;

  zdo_mgmt_nwk_flag = zdo_mgmt_nwk_flag | 2;
  uVar1 = (((uint)ss_ib._62_1_ << 0x1a) >> 0x1e) + 1 & 1;
  memcpy(ss_ib.nwkSecurMaterialSet + uVar1, (void *)((int)in_r0 + 9), 0x10);
  ss_ib.nwkSecurMaterialSet[uVar1].keySeqNum = *(u8 *)((int)in_r0 + 0x1a);
  ss_ib.nwkSecurMaterialSet[uVar1].keyType = *(u8 *)((int)in_r0 + 8);
  ev_timer_taskPost(zb_tcTransportKeyTimerCb, in_r0, 1000);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_zdoNwkKeySwitch(void)

{
  u8 in_r0;
  int iVar1;

  if (ss_ib.nwkSecurMaterialSet[0].keySeqNum == in_r0)
  {
    iVar1 = 0;
  }
  else
  {
    iVar1 = 1;
    if (ss_ib.nwkSecurMaterialSet[1].keySeqNum != in_r0)
    {
      return;
    }
  }
  if (ss_ib.activeKeySeqNum != in_r0)
  {
    ss_ib._62_1_ = ss_ib._62_1_ & 0xcf | (byte)(iVar1 << 4);
    if (0x80000000 < ss_ib.outgoingFrameCounter)
    {
      ss_ib.outgoingFrameCounter = 0;
    }
    ss_ib.activeKeySeqNum = in_r0;
    tl_neighborFrameCntReset();
    nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter);
    zdo_ssInfoSaveToFlash();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_tcSwitchKey(void)

{
  ss_zdoNwkKeySwitch();
  if ((zdo_mgmt_nwk_flag & 2) != 0)
  {
    zdo_mgmt_nwk_flag = zdo_mgmt_nwk_flag & 0xfd;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_zdoUpdateDeviceIndHandle(void)

{
  u8 uVar1;
  bool bVar2;
  zb_buf_t *in_r0;
  int iVar3;
  undefined in_stack_ffffffd8;
  undefined7 in_stack_ffffffd9;
  u16 local_12;

  uVar1 = in_r0->buf[0x12];
  if (uVar1 == '\x02')
  {
    iVar3 = tl_idxByExtAddr();
    if ((iVar3 != 0xff) || (iVar3 = FUNBBBBK(), iVar3 != 0xff))
    {
      tl_zbExtAddrByIdx(local_12, (addrExt_t)CONCAT71(in_stack_ffffffd9, in_stack_ffffffd8));
      if ((zdoAppIndCbLst != 0) && (*(int *)(zdoAppIndCbLst + 0xc) != 0))
      {
        ss_zdoNwkKeyConfigure();
      }
      tl_zbshortAddrByIdx(local_12);
      nwkRoutingTabEntryDstDel();
      tl_zbExtAddrByIdx(local_12, (addrExt_t)CONCAT71(in_stack_ffffffd9, in_stack_ffffffd8));
      tl_zbshortAddrByIdx(local_12);
      nwkRouteRecTabEntryDstDel();
      ss_devKeyPairDelete((addrExt_t)CONCAT71(in_stack_ffffffd9, in_stack_ffffffd8));
      aps_bindingTblEntryDelByDstExtAddr();
      tl_nwkNeighborDeleteByAddrmapIdx(local_12);
      tl_zbNwkAddrMapDelete(local_12);
    }
  }
  else if (uVar1 != '\0')
  {
    if (uVar1 == '\x03')
    {
      bVar2 = ss_securityModeIsDistributed();
      if (bVar2 == false)
        goto LAB_000204a8;
    }
    else if ((uVar1 == '\x01') && (ss_ib.tcPolicy.allowJoins != '\0'))
    {
    LAB_000204a8:
      tl_zbNwkAddrMapAdd(*(u16 *)(in_r0->buf + 0x10),
                         (addrExt_t)CONCAT71(in_stack_ffffffd9, in_stack_ffffffd8),
                         (u16 *)(in_r0->buf + 8));
      in_r0->buf[0x12] = '\x01';
      in_r0->buf[0x13] = '\0';
      in_r0->buf[0x14] = '\0';
      ss_zdoChildAuthStart();
      return;
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ss_zdoNwkKeyConfigure(void)

{
  void *in;
  uint extraout_r1;
  u8 extraout_r2;
  code *in_r3;
  uint uVar1;

  in = (void *)(*in_r3)();
  uVar1 = extraout_r1 & 0xff;
  if (uVar1 < 2)
  {
    memcpy(ss_ib.nwkSecurMaterialSet + uVar1, in, 0x10);
    ss_ib.nwkSecurMaterialSet[uVar1].keySeqNum = (u8)extraout_r1;
    ss_ib.nwkSecurMaterialSet[uVar1].keyType = extraout_r2;
  }
  else
  {
    sys_exceptionPost(0x1e9, '@');
  }
  return;
}

void ss_zdoUseKey(byte param_1)

{
  if (param_1 < 2)
  {
    ss_ib._62_1_ = ss_ib._62_1_ & 0xcf | (byte)((param_1 & 3) << 4);
    ss_ib.activeKeySeqNum = param_1;
  }
  else
  {
    sys_exceptionPost(0x201, '@');
  }
  return;
}

bool ss_keyPreconfigured(void)

{
  char cVar1;
  ss_material_set_t *psVar2;

  psVar2 = ss_ib.nwkSecurMaterialSet + (((uint)ss_ib._62_1_ << 0x1a) >> 0x1e);
  cVar1 = '\0';
  do
  {
    if (psVar2->key[0] != '\0')
      break;
    cVar1 = cVar1 + '\x01';
    psVar2 = (ss_material_set_t *)(psVar2->key + 1);
  } while (cVar1 != '\x10');
  return (bool)('\x01' - (cVar1 == '\x10'));
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int ss_zdoGetNwkKeyBySeqNum(void)

{
  u8 in_r0;
  int iVar1;
  uint uVar2;

  uVar2 = ((uint)ss_ib._62_1_ << 0x1a) >> 0x1e;
  if ((ss_ib.nwkSecurMaterialSet[uVar2].keySeqNum == in_r0) ||
      (uVar2 = uVar2 + 1 & 1, ss_ib.nwkSecurMaterialSet[uVar2].keySeqNum == in_r0))
  {
    iVar1 = uVar2 * 0x12 + 0x842170;
  }
  else
  {
    iVar1 = 0;
  }
  return iVar1;
}

void zdo_ssInfoUpdate(void)

{
  if ((((ss_ib.outgoingFrameCounter & 0x3ff) == 0) && (g_zbInfo.bdbAttr.nodeIsOnANetwork != '\0')) && (g_bdbCtx.state == '\0'))
  {
    ss_ib.outgoingFrameCounter = ss_ib.outgoingFrameCounter + 1;
    nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter);
  }
  return;
}

void ss_zdoInit(bool enSecurity)

{
  byte bVar1;
  nv_sts_t nVar2;
  u8 uVar3;
  int iVar4;
  undefined in_stack_ffffffe8;
  undefined uVar5;
  undefined in_stack_ffffffe9;
  undefined uVar6;
  undefined in_stack_ffffffea;
  undefined uVar7;
  undefined in_stack_ffffffeb;
  undefined uVar8;
  undefined4 in_stack_ffffffec;

  if (((int)((uint)g_zbNwkCtx._45_1_ << 0x1f) < 0) || (uVar3 = zdo_ssInfoInit(), uVar3 != '\0'))
  {
    if (enSecurity)
    {
      ss_ib._62_1_ = ss_ib._62_1_ & 0xf8 | 0xd;
      ss_ib.preConfiguredKeyType = SS_PRECONFIGURED_NOKEY;
      ss_ib.devKeyPairNum._0_1_ = 0;
      ss_ib.devKeyPairNum._1_1_ = 0;
    }
    else
    {
      ss_ib._62_1_ = ss_ib._62_1_ & 0xf8;
    }
  }
  else
  {
    aps_ib._18_1_ = aps_ib._18_1_ | 2;
    tl_neighborFrameCntReset();
    ss_devKeyPairInfoGet();
    iVar4 = memcmp(ss_ib.trust_center_address, &g_zero_addr, 8);
    if ((iVar4 != 0) && (iVar4 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8), iVar4 != 0))
    {
      tl_zbNwkAddrMapAdd(0, (addrExt_t)CONCAT44(in_stack_ffffffec, CONCAT13(in_stack_ffffffeb, CONCAT12(in_stack_ffffffea, CONCAT11(in_stack_ffffffe9, in_stack_ffffffe8)))), (u16 *)ss_ib.trust_center_address);
    }
  }
  ss_ib.ssTimeoutPeriod._0_1_ = 0x87;
  ss_ib.ssTimeoutPeriod._1_1_ = 0x13;
  ss_ib.ssTimeoutPeriod._2_1_ = 0;
  ss_ib.ssTimeoutPeriod._3_1_ = 0;
  bVar1 = af_nodeDescStackRevisionGet();
  ss_ib.tcPolicy.allowRejoins = bVar1 < 0x15;
  ss_ib.tcPolicy.allowJoins = '\x01';
  uVar5 = 0;
  uVar6 = 0;
  uVar7 = 0;
  uVar8 = 0;
  nVar2 = nv_nwkFrameCountFromFlash((u32 *)&stack0xffffffe8);
  ss_ib.outgoingFrameCounter._0_1_ = uVar5;
  ss_ib.outgoingFrameCounter._1_1_ = uVar6;
  ss_ib.outgoingFrameCounter._2_1_ = uVar7;
  ss_ib.outgoingFrameCounter._3_1_ = uVar8;
  if (nVar2 != NV_SUCC)
  {
    ss_ib.outgoingFrameCounter._0_1_ = 0;
    ss_ib.outgoingFrameCounter._1_1_ = 0;
    ss_ib.outgoingFrameCounter._2_1_ = 0;
    ss_ib.outgoingFrameCounter._3_1_ = 0;
  }
  return;
}

void ss_securityModeSet(ss_securityMode_e m)

{
  int iVar1;

  if ((int)((uint)aps_ib._18_1_ << 0x1e) < 0)
  {
    iVar1 = memcmp(ss_ib.trust_center_address, &g_zero_addr, 8);
    if ((iVar1 != 0) && (iVar1 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8), iVar1 != 0))
    {
      sys_exceptionPost(0x268, '3');
    }
  }
  if (m == SS_SEMODE_CENTRALIZED)
  {
    ss_ib.tcPolicy.updateTCLKrequired = '\x01';
    ss_ib.trust_center_address[0] = '\0';
    ss_ib.trust_center_address[1] = '\0';
    ss_ib.trust_center_address[2] = '\0';
    ss_ib.trust_center_address[3] = '\0';
    ss_ib.trust_center_address[4] = '\0';
    ss_ib.trust_center_address[5] = '\0';
    ss_ib.trust_center_address[6] = '\0';
    ss_ib.trust_center_address[7] = '\0';
  }
  else if (m == 1)
  {
    ss_ib.tcPolicy.updateTCLKrequired = '\0';
    memcpy(ss_ib.trust_center_address, &g_invalid_addr, 8);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_get_counter_value(void)

{
  aps_counter_value = aps_counter_value + '\x01';
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

byte aps_get_handle(void)

{
  byte bVar1;

  bVar1 = aps_handle;
  aps_handle = aps_handle + 1;
  return bVar1 & 0x3f;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_command_handle(void)

{
  char cVar1;
  zb_buf_t *in_r0;

  if (*(u16 *)(in_r0->buf + 0x14) != g_zbInfo.macPib.shortAddress)
  {
    cVar1 = **(char **)(in_r0->buf + 0xc);
    if (cVar1 == '\b')
    {
      ss_apsRequestKeyCmdHandle();
      return;
    }
    if (cVar1 == '\x0f')
    {
      ss_apsVerifyKeyCmdHandle();
      return;
    }
    if (cVar1 == '\x06')
    {
      ss_apsUpdateDeviceCmdHandle();
      return;
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint aps_hdr_parse(void)

{
  byte bVar1;
  byte *in_r0;
  int iVar2;
  byte *pbVar3;
  void *in_r1;
  byte *pbVar4;
  uint uVar5;
  uint uVar6;

  memset(in_r1, 0, 0xf);
  bVar1 = *in_r0;
  uVar6 = (uint)bVar1;
  *(byte *)((int)in_r1 + 1) = bVar1;
  uVar5 = uVar6 & 3;
  if (uVar5 == 3)
  {
    iVar2 = (uint)in_r0[2] * 0x100 + (uint)in_r0[1];
    *(char *)((int)in_r1 + 8) = (char)iVar2;
    *(char *)((int)in_r1 + 9) = (char)((uint)iVar2 >> 8);
    iVar2 = (uint)in_r0[4] * 0x100 + (uint)in_r0[3];
    *(char *)((int)in_r1 + 10) = (char)iVar2;
    *(char *)((int)in_r1 + 0xb) = (char)((uint)iVar2 >> 8);
    pbVar3 = in_r0 + 5;
  }
  else if (((int)(uVar6 << 0x1b) < 0) || (uVar5 == 1))
  {
    *(byte *)((int)in_r1 + 2) = in_r0[1];
    pbVar3 = in_r0 + 2;
  }
  else
  {
    if (((uVar6 & 0xc) == 8) || ((bVar1 & 0xc) == 0))
    {
      *(byte *)((int)in_r1 + 6) = in_r0[1];
      pbVar4 = in_r0 + 2;
    }
    else
    {
      iVar2 = (uint)in_r0[2] * 0x100 + (uint)in_r0[1];
      *(char *)((int)in_r1 + 6) = (char)iVar2;
      *(char *)((int)in_r1 + 7) = (char)((uint)iVar2 >> 8);
      pbVar4 = in_r0 + 3;
    }
    iVar2 = (uint)pbVar4[1] * 0x100 + (uint)*pbVar4;
    *(char *)((int)in_r1 + 8) = (char)iVar2;
    *(char *)((int)in_r1 + 9) = (char)((uint)iVar2 >> 8);
    iVar2 = (uint)pbVar4[3] * 0x100 + (uint)pbVar4[2];
    *(char *)((int)in_r1 + 10) = (char)iVar2;
    *(char *)((int)in_r1 + 0xb) = (char)((uint)iVar2 >> 8);
    *(byte *)((int)in_r1 + 3) = pbVar4[4];
    *(byte *)((int)in_r1 + 2) = pbVar4[5];
    pbVar3 = pbVar4 + 6;
    if ((int)(uVar6 * 0x1000000) < 0)
    {
      *(byte *)((int)in_r1 + 0xc) = pbVar4[6];
      *(byte *)((int)in_r1 + 0xd) = pbVar4[7];
      pbVar3 = pbVar4 + 8;
      if (uVar5 == 2)
      {
        *(byte *)((int)in_r1 + 0xe) = pbVar4[8];
        pbVar3 = pbVar4 + 9;
      }
    }
  }
  return (int)pbVar3 - (int)in_r0 & 0xff;
}

void aps_init(void)

{
  u32 uVar1;

  uVar1 = drv_u32Rand();
  aps_handle = 0;
  aps_counter_value = (char)uVar1;
  aps_me_init();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void endDevTimeoutReq(void)

{
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_indPrimBuild(void)

{
  byte bVar1;
  byte bVar2;
  undefined uVar3;
  undefined uVar4;
  ushort uVar5;
  ushort uVar6;
  ushort uVar7;
  undefined *in_r0;
  int iVar8;
  undefined uStack_54;
  undefined uStack_50;
  undefined uStack_4c;
  int iStack_48;
  byte bStack_44;
  char cStack_42;
  undefined uStack_41;
  undefined uStack_40;
  undefined uStack_3f;
  undefined uStack_38;
  undefined uStack_37;
  undefined auStack_34[6];
  undefined uStack_2e;
  undefined uStack_2d;

  memcpy(&iStack_48, in_r0, 0x12);
  memcpy(auStack_34, in_r0 + 0x14, 0xf);
  bVar1 = in_r0[0x14];
  bVar2 = in_r0[0x15];
  uVar3 = in_r0[0x16];
  uVar4 = in_r0[0x17];
  uVar5 = *(ushort *)(in_r0 + 0x18);
  uVar6 = *(ushort *)(in_r0 + 0x1c);
  uVar7 = *(ushort *)(in_r0 + 0x1e);
  memset(in_r0, 0, 0x23);
  uStack_50 = (undefined)uVar6;
  in_r0[8] = uStack_50;
  in_r0[9] = (char)((uint)uVar6 >> 8);
  uStack_4c = (undefined)uVar7;
  in_r0[6] = uStack_4c;
  in_r0[7] = (char)((uint)uVar7 >> 8);
  in_r0[5] = uVar4;
  in_r0[1] = uStack_2e;
  uStack_54 = (undefined)uVar5;
  in_r0[0x14] = uStack_54;
  in_r0[0x15] = (char)((uint)uVar5 >> 8);
  in_r0[4] = 2;
  in_r0[0x1c] = uStack_38;
  in_r0[0x1d] = uStack_37;
  in_r0[0x22] = uVar3;
  in_r0[0x20] = uStack_41;
  in_r0[0x21] = in_r0[0xc2];
  if ((bVar2 & 0xc) == 0xc)
  {
    in_r0[2] = uStack_2e;
    in_r0[3] = uStack_2d;
    *in_r0 = 1;
  }
  else
  {
    in_r0[2] = uStack_40;
    in_r0[3] = uStack_3f;
    *in_r0 = 2;
  }
  iStack_48 = iStack_48 + (uint)bVar1;
  in_r0[0xc] = (char)iStack_48;
  in_r0[0xd] = (char)((uint)iStack_48 >> 8);
  in_r0[0xe] = (char)((uint)iStack_48 >> 0x10);
  in_r0[0xf] = (char)((uint)iStack_48 >> 0x18);
  iVar8 = (uint)bStack_44 - (uint)bVar1;
  in_r0[10] = (char)iVar8;
  in_r0[0xb] = (char)((uint)iVar8 >> 8);
  if ((int)((uint)bVar2 << 0x1a) < 0)
  {
    in_r0[0x1f] = in_r0[0x1f] | 1;
  }
  if (cStack_42 != '\0')
  {
    in_r0[0x1f] = in_r0[0x1f] | 2;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_txCacheAsNoShortAddr(void)

{
  void *in_r0;
  u8 *in_r1;
  zdo_nwk_addr_req_t zStack_18;

  memcpy(&zStack_18, in_r0, 8);
  zStack_18.req_type = ZDO_ADDR_REQ_SINGLE_REQ;
  zStack_18.start_index = '\0';
  zb_zdoNwkAddrReq(0xfffc, &zStack_18, in_r1, aps_nwk_addr_req_cb);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void apsDataFragmentRcvWinClear(void)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  byte *pbVar4;
  int iVar5;

  if (g_apsDataFragmentRcvWin[89] != '\0')
  {
    if (g_apsDataFragmentRcvWin._0_4_ != 0)
    {
      ev_timer_taskCancel((ev_timer_event_t **)g_apsDataFragmentRcvWin);
    }
    g_apsDataFragmentRcvWin._4_4_ = 0;
    pbVar4 = g_apsDataFragmentRcvWin + 0x28;
    iVar5 = 0;
    do
    {
      if (((g_apsDataFragmentRcvWin[iVar5 * 0x24 + 0x2b] & 0x7f) != 0) &&
          (uVar1 = (uint)*pbVar4, uVar1 != 0))
      {
        uVar2 = 0;
        do
        {
          iVar3 = (uVar2 + iVar5 * 9 + 2) * 4;
          if (*(zb_buf_t **)(g_apsDataFragmentRcvWin + iVar3) != (zb_buf_t *)0x0)
          {
            zb_buf_free(*(zb_buf_t **)(g_apsDataFragmentRcvWin + iVar3));
            *(undefined4 *)(g_apsDataFragmentRcvWin + iVar3) = 0;
            uVar1 = (uint)*pbVar4;
          }
          uVar2 = uVar2 + 1 & 0xff;
        } while (uVar2 < uVar1);
      }
      iVar5 = iVar5 + 1;
      pbVar4 = pbVar4 + 0x24;
    } while (iVar5 != 2);
    memset(g_apsDataFragmentRcvWin, 0, 0x5a);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void apsRcvingWindowHandling(void)

{
  void *out;
  void *in_r0;
  uint uVar1;
  int iVar2;
  void *in;
  int iVar3;
  uint uVar4;

  out = g_apsDataFragmentRcvWin._4_4_;
  if ((*(byte *)((int)in_r0 + 0x23) & 0x7f) == 2)
  {
    if (g_apsDataFragmentRcvWin._4_4_ == (void *)0x0)
    {
      sys_exceptionPost(0x1bd, 'R');
    }
    else
    {
      uVar4 = 0;
      if (*(char *)((int)in_r0 + 0x20) != '\0')
      {
        do
        {
          iVar3 = uVar4 * 4;
          if (CONCAT13(*(undefined *)((int)in_r0 + iVar3 + 3),
                       CONCAT12(*(undefined *)((int)in_r0 + iVar3 + 2),
                                CONCAT11(*(undefined *)((int)in_r0 + iVar3 + 1),
                                         *(undefined *)((int)in_r0 + iVar3)))) != 0)
          {
            aps_indPrimBuild();
            in = (void *)CONCAT13(*(undefined *)((int)in_r0 + iVar3 + 3),
                                  CONCAT12(*(undefined *)((int)in_r0 + iVar3 + 2),
                                           CONCAT11(*(undefined *)((int)in_r0 + iVar3 + 1),
                                                    *(undefined *)((int)in_r0 + iVar3))));
            uVar1 = (uint) * (byte *)((int)in_r0 + 0x21);
            if (uVar1 == 0)
            {
              g_apsDataFragmentRcvWin._80_2_ = *(ushort *)((int)in + 10);
              memcpy(out, in, 0x23);
              uVar1 = (uint) * (byte *)((int)in_r0 + 0x21);
            }
            memcpy((void *)((int)out + (uVar1 + uVar4) * (uint)g_apsDataFragmentRcvWin._80_2_ + 0x25), *(void **)((int)in + 0xc), (uint) * (ushort *)((int)in + 10));
            iVar2 = (uint) * (ushort *)((int)in + 10) + (uint) * (ushort *)((int)out + 0x23);
            *(char *)((int)out + 0x23) = (char)iVar2;
            *(char *)((int)out + 0x24) = (char)((uint)iVar2 >> 8);
            zb_buf_free((zb_buf_t *)
                            CONCAT13(*(undefined *)((int)in_r0 + iVar3 + 3),
                                     CONCAT12(*(undefined *)((int)in_r0 + iVar3 + 2),
                                              CONCAT11(*(undefined *)((int)in_r0 + iVar3 + 1),
                                                       *(undefined *)((int)in_r0 + iVar3)))));
            *(undefined *)((int)in_r0 + iVar3) = 0;
            *(undefined *)((int)in_r0 + iVar3 + 1) = 0;
            *(undefined *)((int)in_r0 + iVar3 + 2) = 0;
            *(undefined *)((int)in_r0 + iVar3 + 3) = 0;
            g_apsDataFragmentRcvWin[86] = g_apsDataFragmentRcvWin[86] + 1;
          }
          uVar4 = uVar4 + 1 & 0xff;
        } while (uVar4 < *(byte *)((int)in_r0 + 0x20));
      }
      memset(in_r0, 0, 0x24);
      if (g_apsDataFragmentRcvWin[85] < g_apsDataFragmentRcvWin[86])
      {
        sys_exceptionPost(0x1dc, 'R');
      }
      if (g_apsDataFragmentRcvWin[86] == g_apsDataFragmentRcvWin[85])
      {
        tl_zbTaskPost(af_aps_data_fragment_entry, out);
        apsDataFragmentRcvWinClear();
      }
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 aps_ack_send(void)

{
  byte bVar1;
  undefined2 uVar2;
  u8 uVar3;
  int in_r0;
  zb_buf_t *p;
  int iVar4;
  byte *pbVar5;
  byte *out;
  byte in_r1;
  byte bVar6;
  uint length;
  u8 uVar7;
  byte *pbVar9;
  u8 uVar10;
  char cVar11;
  byte bVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  u8 uVar8;

  p = (zb_buf_t *)c1();
  if (p == (zb_buf_t *)0x0)
  {
    return 0xb9;
  }
  uVar13 = 0;
  uVar14 = 0;
  bVar1 = *(byte *)(in_r0 + 0x15);
  if ((bVar1 & 3) == 1)
  {
    pbVar5 = (byte *)tl_bufInitalloc(p, '\x02');
    *pbVar5 = 0x12;
    pbVar9 = pbVar5 + 1;
    uVar3 = '\x02';
    length = 0;
    *pbVar9 = *(byte *)(in_r0 + 0x16);
    out = pbVar5 + 2;
    cVar11 = *(char *)(in_r0 + 0x15);
  }
  else
  {
    if ((int)((uint)bVar1 * 0x1000000) < 0)
    {
      bVar6 = 0x82;
      bVar12 = 0x82;
      cVar11 = '\v';
      uVar3 = '\v';
    }
    else
    {
      bVar12 = 2;
      bVar6 = 2;
      cVar11 = '\b';
      uVar3 = '\b';
    }
    length = 0;
    if ((bVar1 & 0x20) != 0)
    {
      bVar6 = bVar12 | 0x20;
      length = ss_apsEnAuxHdrFill();
      uVar3 = cVar11 + (char)length;
    }
    pbVar5 = (byte *)tl_bufInitalloc(p, uVar3);
    *pbVar5 = bVar6;
    pbVar5[1] = *(byte *)(in_r0 + 0x17);
    pbVar5[2] = *(byte *)(in_r0 + 0x1c);
    pbVar5[3] = *(byte *)(in_r0 + 0x1d);
    pbVar5[4] = *(byte *)(in_r0 + 0x1e);
    pbVar5[5] = *(byte *)(in_r0 + 0x1f);
    pbVar5[6] = *(byte *)(in_r0 + 0x1a);
    pbVar9 = pbVar5 + 7;
    *pbVar9 = *(byte *)(in_r0 + 0x16);
    out = pbVar5 + 8;
    cVar11 = *(char *)(in_r0 + 0x15);
  }
  if (cVar11 < '\0')
  {
    pbVar9[1] = 2;
    out[1] = *(byte *)(in_r0 + 0x21);
    out[2] = in_r1;
    out = out + 3;
  }
  uVar7 = (u8)((uint)pbVar5 >> 8);
  uVar8 = (u8)((uint)pbVar5 >> 0x10);
  uVar10 = (u8)((uint)pbVar5 >> 0x18);
  if (length == 0)
  {
    memset(p, 0, 0x1a);
    p->buf[10] = '\0';
    p->buf[0xb] = '\x02';
    p->buf[0xd] = '\x01';
    uVar2 = *(undefined2 *)(in_r0 + 0x18);
    p->buf[8] = (u8)uVar2;
    p->buf[9] = (u8)((ushort)uVar2 >> 8);
    p->buf[0xe] = '\x01';
    p->buf[0xf] = 'K';
    p->buf[0x14] = uVar3;
    p->buf[0x10] = (u8)pbVar5;
    p->buf[0x11] = uVar7;
    p->buf[0x12] = uVar8;
    p->buf[0x13] = uVar10;
  }
  else
  {
    memcpy(out, &stack0xffffffc4, length);
    memset(p, 0, 0x1a);
    p->buf[0xb] = '\x02';
    p->buf[0xd] = '\x01';
    uVar2 = *(undefined2 *)(in_r0 + 0x18);
    p->buf[8] = (u8)uVar2;
    p->buf[9] = (u8)((ushort)uVar2 >> 8);
    p->buf[0xe] = '\x01';
    p->buf[0xf] = 'K';
    p->buf[0x14] = uVar3;
    p->buf[0x10] = (u8)pbVar5;
    p->buf[0x11] = uVar7;
    p->buf[0x12] = uVar8;
    p->buf[0x13] = uVar10;
    uVar3 = zb_address_ieee_by_short(*(u16 *)(in_r0 + 0x18), (addrExt_t)CONCAT44(uVar14, uVar13));
    if (uVar3 != '\0')
    {
      zb_buf_free(p);
      return 0xad;
    }
    iVar4 = ss_apsSecureFrame();
    if (iVar4 != 0)
    {
      return 0xad;
    }
  }
  tl_zbPrimitivePost('\x03', 'p', p);
  return 0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_conf(void)

{
  u8 uVar1;
  byte bVar2;
  ushort *in_r0;
  u8 *dest;
  undefined4 in_lr;
  char cVar3;
  undefined uVar4;
  u16 in_stack_ffffffea;

  bVar2 = *(byte *)(in_r0 + 8);
  if (bVar2 < 0x40)
  {
    dest = ev_buf_allocate(0x14);
    if (dest != (u8 *)0x0)
    {
      memset(dest, 0, 0x14);
      memcpy(dest, in_r0, 0x14);
      tl_zbTaskPost(af_dataCnfHandler, dest);
    }
  }
  else
  {
    cVar3 = *(char *)((int)in_r0 + 0xb);
    if (cVar3 == '\0')
    {
      if (bVar2 == 0x49)
      {
        uVar4 = 0;
        uVar1 = tl_zbShortAddrByExtAddr((u16 *)&stack0xffffffea,
                                        (addrExt_t)((ulonglong)CONCAT42(in_lr, in_stack_ffffffea) << 0x10),
                                        (u16 *)g_zbInfo.macPib.extAddress);
        if ((uVar1 == '\0') && (in_stack_ffffffea != g_zbInfo.macPib.shortAddress))
        {
          tl_zbNwkAddrMapAdd(g_zbInfo.macPib.shortAddress,
                             (addrExt_t)
                                 CONCAT44(in_lr, CONCAT22(in_stack_ffffffea, CONCAT11(uVar4, cVar3))),
                             (u16 *)g_zbInfo.macPib.extAddress);
          zb_info_save((void *)0x0);
        }
        bVar2 = af_nodeDescStackRevisionGet();
        if (bVar2 < 0x15)
        {
          bVar2 = *(byte *)(in_r0 + 8);
        }
        else
        {
          tl_zbTaskPost(endDevTimeoutReq, (void *)0x0);
          bVar2 = *(byte *)(in_r0 + 8);
        }
      }
      else if (((bVar2 == 0x41) || (bVar2 == 0x4a)) && (*(char *)(in_r0 + 4) == '\x02'))
      {
        if ((*in_r0 & 0xfff8) == 0xfff8)
        {
          (*(code *)&ss_tcSwitchKeyTimerStart)();
          bVar2 = *(byte *)(in_r0 + 8);
        }
      }
      if (bVar2 == 0x45)
      {
        ss_tcSwitchKey();
      }
    }
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_txCacheConfirm(void)

{
  zb_buf_t *buf;
  u8 *puVar1;
  void *in_r0;
  int in_r1;
  u32 t_ms;
  byte bVar2;
  void *pvVar3;
  uint uVar4;
  undefined4 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  uint uStack_28;

  puVar1 = g_apsDataFragmentTransWin._32_4_;
  local_38 = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  if (*(char *)((int)in_r0 + 0x16) == '\0')
  {
    uStack_28 = (uint) * (ushort *)((int)in_r0 + 0xf);
    uStack_30._0_3_ = (uint3) * (byte *)((int)in_r0 + 0xe) << 0x10;
    uStack_30._1_3_ = (uint3)((uint)(in_r1 << 0x18) >> 8) | (uint3)uStack_30 >> 8;
    uStack_30 = CONCAT31(uStack_30._1_3_, *(undefined *)((int)in_r0 + 0xc));
    memcpy(&local_38, in_r0, 8);
    uStack_30._0_2_ = CONCAT11(*(undefined *)((int)in_r0 + 0xd), (undefined)uStack_30);
    uStack_30 = uStack_30 & 0xffff0000 | (uint)(ushort)uStack_30;
    uStack_28 = uStack_28 & 0xffff | (uint) * (ushort *)((int)in_r0 + 0x18) << 0x10;
    aps_conf();
    if (*(zb_buf_t **)((int)in_r0 + 8) != (zb_buf_t *)0x0)
    {
      zb_buf_free(*(zb_buf_t **)((int)in_r0 + 8));
    }
    memset(in_r0, 0, 0x1c);
    g_apsTxCacheNum = g_apsTxCacheNum + -1;
  }
  else
  {
    T_DBG_fgmtCnf._0_1_ = (char)T_DBG_fgmtCnf + '\x01';
    bVar2 = *(byte *)((int)in_r0 + 0x12) & 0xf0;
    if ((((bVar2 == 0x30) || (bVar2 == 0x40)) || (bVar2 == 0x10)) || (bVar2 == 0x20))
    {
      T_DBG_fgmtCnf._1_1_ = T_DBG_fgmtCnf._1_1_ + '\x01';
      if ((in_r1 != 0) ||
          ((int)((g_apsDataFragmentTransWin._40_4_ >> 0x10 & 0xff) - 1) <=
           (int)(g_apsDataFragmentTransWin._40_4_ >> 0x18)))
      {
        uStack_28 = (uint) * (ushort *)(g_apsDataFragmentTransWin._32_4_ + 0xe);
        uStack_30._0_3_ = (uint3)g_apsDataFragmentTransWin._32_4_[8] << 0x10;
        uStack_30._1_3_ = (uint3)((uint)(in_r1 << 0x18) >> 8) | (uint3)uStack_30 >> 8;
        uStack_30 = CONCAT31(uStack_30._1_3_, g_apsDataFragmentTransWin._32_4_[0xc]);
        memcpy(&local_38, g_apsDataFragmentTransWin._32_4_ + 0x10, 8);
        uStack_30._0_2_ = CONCAT11(puVar1[0x18], (undefined)uStack_30);
        uStack_30 = uStack_30 & 0xffff0000 | (uint)(ushort)uStack_30;
        uStack_28 = uStack_28 & 0xffff | (uint) * (ushort *)(puVar1 + 6) << 0x10;
        aps_conf();
        if (g_apsDataFragmentTransWin[47] != '\0')
        {
          if (g_apsDataFragmentTransWin._32_4_ != (u8 *)0x0)
          {
            ev_buf_free(g_apsDataFragmentTransWin._32_4_);
          }
          if (g_apsDataFragmentTransWin[44] != '\0')
          {
            uVar4 = 0;
            do
            {
              pvVar3 = *(void **)(g_apsDataFragmentTransWin + uVar4 * 4);
              if (pvVar3 != (void *)0x0)
              {
                if (*(zb_buf_t **)((int)pvVar3 + 8) != (zb_buf_t *)0x0)
                {
                  zb_buf_free(*(zb_buf_t **)((int)pvVar3 + 8));
                }
                memset(pvVar3, 0, 0x1c);
                g_apsTxCacheNum = g_apsTxCacheNum + -1;
              }
              uVar4 = uVar4 + 1 & 0xff;
            } while (uVar4 < (g_apsDataFragmentTransWin._44_4_ & 0xff));
          }
          g_apsDataFragmentTransWin._0_4_ = 0;
          g_apsDataFragmentTransWin._4_4_ = 0;
          g_apsDataFragmentTransWin._8_4_ = 0;
          g_apsDataFragmentTransWin._12_4_ = 0;
          g_apsDataFragmentTransWin._16_4_ = 0;
          g_apsDataFragmentTransWin._20_4_ = 0;
          g_apsDataFragmentTransWin._24_4_ = 0;
          g_apsDataFragmentTransWin._28_4_ = 0;
          g_apsDataFragmentTransWin._32_4_ = (u8 *)0x0;
          g_apsDataFragmentTransWin._36_4_ = 0;
          g_apsDataFragmentTransWin._40_4_ = 0;
          g_apsDataFragmentTransWin._44_4_ = 0;
        }
        T_DBG_fgmtCnf._2_1_ = T_DBG_fgmtCnf._2_1_ + '\x01';
        return;
      }
      if (aps_ib.aps_max_window_size <= g_apsDataFragmentTransWin[44])
      {
        if (g_apsDataFragmentTransWin[44] != 0)
        {
          uVar4 = 0;
          do
          {
            pvVar3 = *(void **)(g_apsDataFragmentTransWin + uVar4 * 4);
            buf = *(zb_buf_t **)((int)pvVar3 + 8);
            if (buf != (zb_buf_t *)0x0)
            {
              zb_buf_free(buf);
            }
            memset(pvVar3, 0, 0x1c);
            g_apsTxCacheNum = g_apsTxCacheNum + -1;
            *(undefined4 *)(g_apsDataFragmentTransWin + uVar4 * 4) = 0;
            uVar4 = uVar4 + 1 & 0xff;
          } while (uVar4 < (g_apsDataFragmentTransWin._44_4_ & 0xff));
        }
        g_apsDataFragmentTransWin._44_4_ = g_apsDataFragmentTransWin._44_4_ & 0xff000000 | 0xff00;
        g_apsDataFragmentTransWin[46] = '\0';
      }
      T_DBG_fgmtCnf._3_1_ = T_DBG_fgmtCnf._3_1_ + '\x01';
    }
    if (g_apsDataFragmentTransWin[46] == '\0')
    {
      g_apsDataFragmentTransWin._40_4_ =
          g_apsDataFragmentTransWin._40_4_ & 0xffffff |
          (uint)(byte)(g_apsDataFragmentTransWin[43] + 1) << 0x18;
    }
    t_ms = 100;
    if (aps_ib.aps_interframe_delay != 0)
    {
      t_ms = (uint)aps_ib.aps_interframe_delay;
    }
    ev_timer_taskPost(aps_data_fragment_delay, (void *)0x0, t_ms);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 apsTxDataSendStart(void)

{
  void *in;
  int in_r0;
  void *out;
  undefined4 uVar1;
  int iVar2;

  in = *(void **)(in_r0 + 8);
  out = (void *)c1();
  if (out == (void *)0x0)
  {
    aps_txCacheConfirm();
    uVar1 = 1;
  }
  else
  {
    memcpy(out, in, 0xc3);
    iVar2 = (int)out + ((uint) * (byte *)((int)in + 0x10) - (int)in & 0xff);
    *(char *)((int)out + 0x10) = (char)iVar2;
    *(char *)((int)out + 0x11) = (char)((uint)iVar2 >> 8);
    *(char *)((int)out + 0x12) = (char)((uint)iVar2 >> 0x10);
    *(char *)((int)out + 0x13) = (char)((uint)iVar2 >> 0x18);
    if ((int)((uint) * (byte *)(in_r0 + 0x12) << 0x1c) < 0)
    {
      tl_zbNwkInterPanDataReq();
      uVar1 = 0;
    }
    else
    {
      tl_zbPrimitivePost('\x03', 'p', out);
      uVar1 = 0;
    }
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int aps_duplicate_check(void)

{
  int iVar1;
  byte in_r1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  ushort local_16;

  iVar1 = tl_addrByShort();
  iVar2 = 0;
  if (iVar1 == 0)
  {
    uVar5 = (uint)local_16;
    if ((g_nwkAddrMap.addrMap[uVar5].field_0x13 & 0xe) != 0)
    {
      uVar3 = (uint)g_nwkAddrMap.addrMap[uVar5].aps_dup_cnt;
      uVar4 = uVar3 - in_r1;
      iVar2 = uVar4 + ~uVar4 + (uint)(in_r1 <= uVar3);
    }
    g_nwkAddrMap.addrMap[uVar5].aps_dup_cnt = in_r1;
    g_nwkAddrMap.addrMap[uVar5].field_0x13 =
        g_nwkAddrMap.addrMap[uVar5].field_0x13 & 0xf1 |
        (byte)(((uint)APS_ACK_EXPIRY * (uint)APS_MAX_FRAME_RETRIES + 1 & 7) << 1);
    apsDupliateCheckFlag = 1;
  }
  return iVar2;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_interPanDataIndCb(void)

{
  int iVar1;
  u16 clusterID;
  byte bVar2;
  u8 uVar3;
  zb_buf_t *buf;
  int iVar4;
  af_endpoint_descriptor_t *paVar5;
  code *in_r3;
  byte bVar6;
  uint local_40;
  uint uStack_3c;
  undefined4 uStack_38;
  int iStack_34;
  undefined4 uStack_30;
  uint uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  ushort local_20;
  undefined local_1e;

  buf = (zb_buf_t *)(*in_r3)();
  iVar1 = *(int *)(buf->buf + 4);
  bVar2 = buf->buf[0x1d];
  dstPanID = *(undefined2 *)(buf->buf + 0x10);
  local_40 = 0;
  uStack_38 = 0;
  iStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  local_1e = 0;
  local_20 = (ushort)buf->buf[0x27];
  uStack_3c = (uint)buf->buf[0x1c];
  if (buf->buf[0x1c] == 3)
  {
    memcpy(&uStack_2c, buf->buf + 0x14, 8);
  }
  else
  {
    uStack_2c = (uint) * (ushort *)(buf->buf + 0x14);
  }
  if (buf->buf[0x26] == '\x02')
  {
    local_40 = local_40 & 0xffff | (uint) * (ushort *)(buf->buf + 0x1e) << 0x10;
  }
  iVar4 = aps_hdr_parse();
  buf->buf[0x14] = (u8)iVar4;
  clusterID = *(u16 *)(buf->buf + 0x1c);
  uStack_3c = uStack_3c & 0xffff | (uint) * (ushort *)(buf->buf + 0x1e) << 0x10;
  iStack_34 = iVar1 + 2 + iVar4;
  uStack_38 = CONCAT22((bVar2 - 2 & 0xff) - (short)iVar4, clusterID);
  paVar5 = af_epDescriptorGet();
  bVar2 = af_availableEpNumGet();
  if (bVar2 != 0)
  {
    bVar6 = 0;
    do
    {
      uVar3 = af_clsuterIdMatched(clusterID, paVar5->correspond_simple_desc);
      if (uVar3 != '\0')
      {
        local_40._0_2_ = CONCAT11(paVar5->ep, (undefined)local_40);
        local_40 = local_40 & 0xffff0000 | (uint)(ushort)local_40;
        if (bVar6 < bVar2)
        {
          memcpy(buf, &local_40, 0x23);
          tl_zbTaskPost(af_aps_data_entry, buf);
          return;
        }
        break;
      }
      bVar6 = bVar6 + 1;
      paVar5 = paVar5 + 1;
    } while (bVar6 < bVar2);
  }
  zb_buf_free(buf);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void apsTxEventPost(void)

{
  byte bVar1;
  char cVar2;
  int in_r0;
  int iVar3;
  char in_r1;

  bVar1 = *(byte *)(in_r0 + 0x12);
  switch (bVar1 >> 4)
  {
  case 0:
    if ((int)((uint)bVar1 << 0x1e) < 0)
    {
      *(byte *)(in_r0 + 0x12) = bVar1 & 0xf | 0x10;
      return;
    }
  LAB_00021ca0:
    iVar3 = apsTxDataSendStart();
    if (iVar3 == 0)
    {
      *(byte *)(in_r0 + 0x12) = *(byte *)(in_r0 + 0x12) & 0xf | 0x20;
    }
    return;
  case 1:
    if (in_r1 == '\0')
      goto LAB_00021ca0;
    break;
  case 2:
  case 3:
  case 4:
    if (in_r1 == '\x01')
    {
      if (((int)((uint)bVar1 << 0x1d) < 0) &&
          (cVar2 = *(char *)(in_r0 + 0x13), *(char *)(in_r0 + 0x13) = cVar2 + -1, cVar2 != '\0'))
      {
        iVar3 = apsTxDataSendStart();
        if (iVar3 == 0)
        {
          *(u8 *)(in_r0 + 0x14) = APS_ACK_EXPIRY;
          *(byte *)(in_r0 + 0x12) = *(byte *)(in_r0 + 0x12) & 0xf | 0x40;
          return;
        }
        return;
      }
      goto switchD_00021c5a_caseD_5;
    }
    if (in_r1 == '\x02')
    {
      *(byte *)(in_r0 + 0x12) = bVar1 & 0xf | 0x30;
      return;
    }
    break;
  case 5:
    goto switchD_00021c5a_caseD_5;
  default:
    return;
  }
  if (in_r1 != '\x03')
  {
    return;
  }
switchD_00021c5a_caseD_5:
  aps_txCacheConfirm();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void apsDataFragmentReSend(void)

{
  int iVar1;
  uint uVar2;

  if ((g_apsDataFragmentTransWin[47] != '\0') &&
      (iVar1 = 0x2e, g_apsDataFragmentTransWin[46] != '\0'))
  {
    uVar2 = 0;
    if (g_apsDataFragmentTransWin[45] == 0xff)
    {
    LAB_00021d38:
      g_apsDataFragmentTransWin[iVar1] = (char)uVar2;
    }
    else
    {
      do
      {
        if (((int)(uint)g_apsDataFragmentTransWin[45] >> uVar2 & 1U) == 0)
        {
          iVar1 = *(int *)(g_apsDataFragmentTransWin + uVar2 * 4);
          *(byte *)(iVar1 + 0x12) = *(byte *)(iVar1 + 0x12) & 0xf;
          *(u8 *)(iVar1 + 0x14) = APS_ACK_EXPIRY;
          *(u8 *)(iVar1 + 0x13) = APS_MAX_FRAME_RETRIES;
          apsTxEventPost();
          iVar1 = 0x2d;
          uVar2 = 1 << uVar2 | (uint)g_apsDataFragmentTransWin[45];
          goto LAB_00021d38;
        }
        uVar2 = uVar2 + 1;
      } while (uVar2 != 8);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 apsHandleIsExit(void)

{
  u8 in_r0;
  int iVar1;
  aps_tx_cache_list_t *paVar2;

  if (APS_TX_CACHE_TABLE_SIZE != 0)
  {
    iVar1 = 0;
    paVar2 = aps_txCache_tbl;
    while (true)
    {
      if (((paVar2->field_0x12 & 1) != 0) && (paVar2->handler == in_r0))
      {
        return 1;
      }
      iVar1 = iVar1 + 1;
      if ((int)(uint)APS_TX_CACHE_TABLE_SIZE <= iVar1)
        break;
      paVar2 = paVar2 + 1;
    }
  }
  return 0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

aps_tx_cache_list_t *apsTxDataPost(void)

{
  byte bVar1;
  undefined2 uVar2;
  aps_tx_cache_list_t *paVar3;
  u8 uVar4;
  u8 uVar5;
  uint in_r0;
  int iVar6;
  uint in_r1;
  aps_tx_cache_list_t *dest;
  uint in_r2;
  undefined4 in_r3;
  aps_tx_cache_list_t *paVar7;
  int iVar8;
  uint uVar9;
  void *in_stack_00000000;
  undefined local_34;

  uVar9 = (uint)APS_TX_CACHE_TABLE_SIZE;
  if (uVar9 == 0)
  {
  LAB_000221b4:
    *(undefined *)((int)in_stack_00000000 + 0xb) = 0xb9;
    dest = (aps_tx_cache_list_t *)0x0;
  }
  else
  {
    iVar8 = 0;
    dest = aps_txCache_tbl;
    paVar7 = dest;
    while (true)
    {
      bVar1 = paVar7->field_0x12;
      if ((bVar1 & 1) != 0)
      {
        iVar6 = memcmp(paVar7, in_stack_00000000, 8);
        if ((iVar6 == 0) && ((bVar1 & 0xf0) == 0x10))
        {
          *(undefined *)((int)in_stack_00000000 + 0xb) = 0xb2;
          return (aps_tx_cache_list_t *)0x0;
        }
        if (*(u8 *)((int)in_stack_00000000 + 0x10) == paVar7->handler)
        {
          *(undefined *)((int)in_stack_00000000 + 0xb) = 0xb1;
          return (aps_tx_cache_list_t *)0x0;
        }
      }
      iVar8 = iVar8 + 1;
      if ((int)uVar9 <= iVar8)
        break;
      paVar7 = paVar7 + 1;
    }
    if ((int)((uint)aps_txCache_tbl[0]._18_1_ << 0x1f) < 0)
    {
      iVar8 = 0;
      paVar7 = dest;
      do
      {
        iVar8 = iVar8 + 1;
        if ((int)uVar9 <= iVar8)
          goto LAB_000221b4;
        dest = paVar7 + 1;
        paVar3 = paVar7 + 1;
        paVar7 = dest;
      } while ((paVar3->field_0x12 & 1) != 0);
    }
    memset(dest, 0, 0x1c);
    dest->field_0x12 = dest->field_0x12 | 1;
    dest->dstAddrMode = *(u8 *)((int)in_stack_00000000 + 8);
    memcpy(dest, in_stack_00000000, 8);
    dest->dstEndpoint = *(u8 *)((int)in_stack_00000000 + 9);
    dest->ep = *(u8 *)((int)in_stack_00000000 + 10);
    dest->handler = *(u8 *)((int)in_stack_00000000 + 0x10);
    dest->apsCount = *(u8 *)((int)in_stack_00000000 + 0x11);
    uVar2 = *(undefined2 *)((int)in_stack_00000000 + 0x12);
    *(char *)&dest->clusterId = (char)uVar2;
    *(char *)((int)&dest->clusterId + 1) = (char)((ushort)uVar2 >> 8);
    local_34 = (undefined)in_r3;
    *(undefined *)&dest->payload = local_34;
    *(char *)((int)&dest->payload + 1) = (char)((uint)in_r3 >> 8);
    *(char *)((int)&dest->payload + 2) = (char)((uint)in_r3 >> 0x10);
    *(char *)((int)&dest->payload + 3) = (char)((uint)in_r3 >> 0x18);
    dest->field_0x12 = dest->field_0x12 & 0xf;
    dest->field_0x12 = dest->field_0x12 & 0xfb | (byte)((in_r0 & 1) << 2);
    dest->field_0x12 = dest->field_0x12 & 0xfd | (byte)((in_r1 & 1) << 1);
    uVar5 = APS_MAX_FRAME_RETRIES;
    dest->retries = APS_MAX_FRAME_RETRIES;
    dest->field_0x12 = dest->field_0x12 & 0xf7 | (byte)((in_r2 & 1) << 3);
    uVar4 = APS_ACK_EXPIRY;
    dest->apsAddrWaitTimeout = (uVar5 + '\x01') * APS_ACK_EXPIRY;
    dest->apsAckWaitTimeOut = uVar4;
    g_apsTxCacheNum = g_apsTxCacheNum + '\x01';
  }
  return dest;
}

// WARNING: Removing unreachable block (RAM,0x00022594)
// WARNING: Removing unreachable block (RAM,0x00022612)
// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_data_request(void)

{
  u8 uVar1;
  u8 uVar2;
  byte bVar3;
  byte bVar4;
  bool bVar5;
  u8 uVar6;
  zb_buf_t *in_r0;
  addrExt_t *pauVar7;
  uint length;
  uint uVar8;
  uint uVar9;
  int iVar10;
  undefined *puVar11;
  u8 *puVar12;
  uint uVar13;
  undefined4 in_stack_ffffff80;
  undefined4 in_stack_ffffff84;
  undefined4 uStack_64;
  undefined4 uStack_60;
  uint uStack_5c;
  uint uStack_58;
  int iStack_54;
  uint uStack_50;
  u8 uStack_4c;
  byte bStack_4b;
  uint local_48;
  undefined4 uStack_44;
  uint uStack_40;
  undefined4 uStack_3c;
  u8 uStack_38;
  u8 uStack_37;
  undefined2 uStack_36;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;

  uVar1 = in_r0->buf[0x1d];
  uVar2 = in_r0->buf[0x1e];
  local_48 = 0;
  uStack_44 = 0;
  uStack_3c = 0;
  uStack_38 = in_r0->buf[0xe];
  uStack_37 = in_r0->buf[0xf];
  bVar3 = in_r0->buf[8];
  uStack_40 = (uint)bVar3 << 0x10;
  bVar4 = in_r0->buf[0xc];
  uStack_40 = uStack_40 | bVar4;
  uStack_36 = *(undefined2 *)(in_r0->buf + 6);
  if (bVar4 == 1)
  {
  LAB_00022338:
    local_48 = (uint) * (ushort *)(in_r0->buf + 0x10);
  LAB_00022342:
    bVar3 = in_r0->buf[10];
    uVar9 = (uint)bVar3;
    uStack_64 = 0;
    uStack_60 = 0;
    iStack_54 = 0;
    uStack_50 = (uint) * (uint3 *)(in_r0->buf + 0x19) << 8;
    uStack_4c = in_r0->buf[0x1c];
    uStack_5c = CONCAT13(2, (uint3)in_r0->buf[0xb] << 0x10);
    uStack_58 = (((uint)g_zbNwkCtx._46_1_ << 0x1b) >> 0x1f) << 8;
    bStack_4b = (byte)((uVar9 << 0x1a) >> 0x1f);
    if (bVar4 == 1)
    {
      if ((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1c) < 0)
      {
        uStack_5c = CONCAT22(CONCAT11(1, in_r0->buf[0xb]), *(undefined2 *)(in_r0->buf + 0x10));
        in_r0->buf[0x18] = 0xff;
        uStack_58 = uStack_58 | aps_ib.aps_nonmember_radius;
        uVar13 = 8;
      }
      else
      {
        uStack_5c = uStack_5c | GROUP_MESSAGE_SEND_ADDRESS;
        uVar9 = uVar9 & 0xfffffffb;
        uVar13 = 0xc;
      }
      bVar4 = (byte)uVar9;
      uVar9 = uVar9 & 0xfe;
      in_r0->buf[10] = bVar4 & 0xfe;
    LAB_0002239c:
      if ((char)bVar3 < '\0')
      {
        uVar13 = uVar13 | 3;
        uVar8 = uVar9 & 0xfb;
        in_r0->buf[10] = (byte)uVar9 & 0xfb;
        bVar5 = false;
        if (in_r0->buf[0xc] == '\x03')
        {
          uStack_5c = uStack_5c & 0xffffff | 0x3000000;
          memcpy(&uStack_64, in_r0->buf + 0x10, 8);
        }
      }
      else
      {
        uVar8 = (uint)in_r0->buf[10];
        bVar5 = false;
      }
    }
    else
    {
      if (bVar4 == 2)
      {
        uVar13 = 0;
        if ((*(ushort *)(in_r0->buf + 0x10) & 0xfff8) == 0xfff8)
        {
          in_r0->buf[10] = bVar3 & 0xfa;
          uVar13 = 8;
          uVar9 = (uint)in_r0->buf[10];
        }
        uStack_5c = uStack_5c | *(ushort *)(in_r0->buf + 0x10);
        goto LAB_0002239c;
      }
      if (((char)bVar3 < '\0') || (bVar4 != 3))
      {
        uVar13 = 0;
        goto LAB_0002239c;
      }
      uVar6 = tl_zbShortAddrByExtAddr((u16 *)&uStack_5c, (addrExt_t)CONCAT44(in_stack_ffffff84, in_stack_ffffff80),
                                      (u16 *)(in_r0->buf + 0x10));
      if ((uVar6 == 0xff) || (bVar5 = false, (uStack_5c & 0xfff8) == 0xfff8))
      {
        memcpy(&uStack_64, in_r0->buf + 0x10, 8);
        (in_r0->hdr).handle = in_r0->buf[0xe];
        (in_r0->hdr).id = in_r0->buf[8];
        bVar5 = true;
      }
      uVar8 = (uint)in_r0->buf[10];
      uVar13 = 0;
    }
    if ((int)(uVar8 << 0x1d) < 0)
    {
      uVar13 = uVar13 | 0x40;
    }
    if ((int)(uVar8 << 0x1c) < 0)
    {
      uVar13 = 0x7f;
    }
    if ((char)bVar3 < '\0')
    {
      iVar10 = *(int *)in_r0->buf;
      *(char *)(iVar10 + -5) = (char)uVar13;
      *(u8 *)(iVar10 + -4) = in_r0->buf[6];
      *(u8 *)(iVar10 + -3) = in_r0->buf[7];
      *(u8 *)(iVar10 + -2) = in_r0->buf[4];
      *(u8 *)(iVar10 + -1) = in_r0->buf[5];
      uVar8 = 0xfffffffa;
      uVar9 = 5;
    }
    else
    {
      uVar9 = (uVar13 & 0xc) - 0xc;
      iVar10 = ~uVar9 + uVar9 + (uint)(0xb < (uVar13 & 0xc));
      uVar9 = iVar10 + 8;
      if ((int)(uVar8 << 0x1f) < 0)
      {
        uVar13 = uVar13 & 0xdf | 0x20;
        uStack_34 = 0;
        uStack_30 = 0;
        uStack_2c = 0;
        local_28 = 0;
        length = ss_apsEnAuxHdrFill();
        uVar9 = uVar9 + length & 0xff;
      }
      else
      {
        length = 0;
      }
      uVar8 = ~uVar9;
      puVar11 = (undefined *)(*(int *)in_r0->buf + uVar8);
      *puVar11 = (char)uVar13;
      if (iVar10 == 0)
      {
        puVar11[1] = in_r0->buf[0x18];
        puVar12 = puVar11 + 2;
      }
      else
      {
        puVar11[1] = in_r0->buf[0x10];
        puVar11[2] = in_r0->buf[0x11];
        puVar12 = puVar11 + 3;
      }
      *puVar12 = in_r0->buf[6];
      puVar12[1] = in_r0->buf[7];
      puVar12[2] = in_r0->buf[4];
      puVar12[3] = in_r0->buf[5];
      puVar12[4] = in_r0->buf[8];
      if (in_r0->buf[0x19] == '\0')
      {
        uVar6 = in_r0->buf[0xf];
      }
      else
      {
        uVar6 = in_r0->buf[0x1c];
      }
      puVar12[5] = uVar6;
      if (length != 0)
      {
        memcpy(puVar12 + 6, &uStack_34, length);
      }
    }
    uStack_58 = CONCAT13(in_r0->buf[0xe], CONCAT12(in_r0->buf[0xd], (undefined2)uStack_58));
    uStack_50 = uStack_50 & 0xffffff00 | (uint)(byte)(in_r0->buf[9] + (char)uVar9);
    iStack_54 = *(int *)in_r0->buf + uVar8;
    (in_r0->hdr).handle = in_r0->buf[0xe];
    memcpy(in_r0, &uStack_64, 0x1a);
    if ((int)(uVar13 << 0x1a) < 0)
    {
      if ((uVar13 & 0xc) == 0)
      {
        if (!bVar5)
        {
          pauVar7 = tl_zbExtAddrPtrByShortAddr((u16)uStack_5c);
          if (pauVar7 == (addrExt_t *)0x0)
            goto LAB_000224d4;
        }
        iVar10 = ss_apsSecureFrame();
        if (iVar10 != 1)
          goto LAB_0002248a;
      }
    LAB_000224d4:
      if (uVar1 == '\0')
      {
        uStack_40 = CONCAT13(0xad, (undefined3)uStack_40);
        aps_conf();
        return;
      }
    }
    else
    {
    LAB_0002248a:
      iVar10 = apsTxDataPost();
      if (iVar10 != 0)
      {
        if (uVar1 != '\0')
        {
          *(u8 *)(iVar10 + 0x16) = uVar1;
          *(u8 *)(iVar10 + 0x17) = uVar2;
          *(int *)(g_apsDataFragmentTransWin + (uint)g_apsDataFragmentTransWin[44] * 4) = iVar10;
          g_apsDataFragmentTransWin[44] = g_apsDataFragmentTransWin[44] + 1;
        }
        apsTxEventPost();
        if (!bVar5)
        {
          return;
        }
        aps_txCacheAsNoShortAddr();
        return;
      }
      if (uVar1 == '\0')
        goto LAB_00022326;
    }
    tl_zbTaskPost(aps_data_fragment, (void *)0x0);
  }
  else
  {
    if (bVar4 == 2)
    {
      uStack_40._0_2_ = CONCAT11(in_r0->buf[0x18], 2);
      uStack_40 = (uint)CONCAT12(bVar3, (undefined2)uStack_40);
      goto LAB_00022338;
    }
    if (bVar4 == 3)
    {
      uStack_40._0_2_ = CONCAT11(in_r0->buf[0x18], 3);
      uStack_40 = (uint)CONCAT12(bVar3, (undefined2)uStack_40);
      memcpy(&local_48, in_r0->buf + 0x10, 8);
      goto LAB_00022342;
    }
    if (uVar1 != '\0')
    {
      sys_exceptionPost(0x591, 'P');
    }
    puVar12 = ev_buf_allocate((u16)((uint)APS_BINDING_TABLE_SIZE * 0xa0000 + 0x80000 >> 0x10));
    if (puVar12 == (u8 *)0x0)
    {
      uStack_40 = CONCAT13(0xb9, (undefined3)uStack_40);
    }
    else
    {
      iVar10 = aps_search_dst_from_bind_tbl();
      uStack_40 = uStack_40 & 0xffffff | iVar10 << 0x18;
      if (iVar10 == 0)
      {
        *puVar12 = (u8)in_r0;
        puVar12[1] = (u8)((uint)in_r0 >> 8);
        puVar12[2] = (u8)((uint)in_r0 >> 0x10);
        puVar12[3] = (u8)((uint)in_r0 >> 0x18);
        ev_timer_taskPost(bindingTxBack, puVar12, 1);
        return;
      }
      ev_buf_free(puVar12);
    }
  LAB_00022326:
    aps_conf();
    zb_buf_free(in_r0);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 bindingTxBack(void)

{
  byte bVar1;
  char cVar2;
  undefined2 uVar3;
  undefined uVar4;
  zb_buf_t **in_r0;
  undefined4 *out;
  undefined4 uVar5;
  int iVar6;
  ushort uVar7;
  int iVar8;
  uint local_3c;
  undefined4 uStack_38;
  uint uStack_34;
  undefined4 uStack_30;
  int iStack_2c;
  uint uStack_28;
  int iStack_24;
  int iStack_20;
  undefined2 local_1c;
  undefined local_1a;

  out = (undefined4 *)c1();
  if (out != (undefined4 *)0x0)
  {
    memcpy(out, *in_r0, 0xc3);
    iVar8 = (int)out + (*(int *)(*in_r0)->buf - (int)*in_r0);
    *(char *)out = (char)iVar8;
    *(char *)((int)out + 1) = (char)((uint)iVar8 >> 8);
    *(char *)((int)out + 2) = (char)((uint)iVar8 >> 0x10);
    *(char *)((int)out + 3) = (char)((uint)iVar8 >> 0x18);
    bVar1 = *(byte *)(in_r0 + 1);
    iVar8 = (uint)bVar1 * 10;
    cVar2 = *(char *)((int)in_r0 + iVar8 + 0x11);
    *(char *)(out + 3) = cVar2;
    if (cVar2 == '\x03')
    {
      *(undefined *)(out + 6) = *(undefined *)((int)in_r0 + iVar8 + 0x10);
      memcpy(out + 4, (void *)((int)in_r0 + iVar8 + 8), 8);
    }
    else if (cVar2 == '\x01')
    {
      uVar3 = *(undefined2 *)((int)in_r0 + iVar8 + 8);
      *(char *)(out + 4) = (char)uVar3;
      *(char *)((int)out + 0x11) = (char)((ushort)uVar3 >> 8);
    }
    cVar2 = *(char *)(in_r0 + 1);
    *(byte *)(in_r0 + 1) = cVar2 + 1U;
    if (1 < (byte)(cVar2 + 1U))
    {
      uVar4 = aps_get_counter_value();
      *(undefined *)((int)out + 0xf) = uVar4;
      do
      {
        uVar4 = aps_get_handle();
        iVar8 = apsHandleIsExit();
      } while (iVar8 != 0);
      *(undefined *)((int)out + 0xe) = uVar4;
    }
    iVar8 = (uint)bVar1 * 10;
    if ((*(char *)((int)in_r0 + iVar8 + 0x11) == '\x03') &&
        (iVar6 = memcmp((void *)((int)in_r0 + iVar8 + 8), g_zbInfo.macPib.extAddress, 8), iVar6 == 0))
    {
      local_1c = 0;
      local_3c = (uint)CONCAT21(g_zbInfo.nwkNib.nwkAddr, *(undefined *)((int)in_r0 + iVar8 + 0x10))
                     << 8 |
                 2;
      uVar7 = g_zbInfo.nwkNib.nwkAddr;
      if (*(char *)((int)out + 0x19) != '\0')
      {
        uVar7 = *(ushort *)((int)out + 0x1a);
      }
      uStack_28 = (uint)uVar7;
      uStack_38 = CONCAT22(*(undefined2 *)(out + 1), CONCAT11(*(undefined *)(out + 2), 2));
      uStack_34 = (uint)CONCAT12(*(undefined *)((int)out + 9), *(undefined2 *)((int)out + 6));
      uStack_30 = *out;
      local_1a = *(undefined *)((int)out + 0xf);
      iStack_2c = iVar6;
      iStack_24 = iVar6;
      iStack_20 = iVar6;
      memcpy(out, &local_3c, 0x23);
      tl_zbTaskPost(af_aps_data_entry, out);
    }
    else
    {
      aps_data_request();
    }
    uVar5 = 100;
    if (*(byte *)((int)in_r0 + 5) <= *(byte *)(in_r0 + 1))
    {
      zb_buf_free(*in_r0);
      ev_buf_free((u8 *)in_r0);
      uVar5 = 0xfffffffe;
    }
    return uVar5;
  }
  return 100;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void apsAckPeriodic(void)

{
  byte bVar1;
  int iVar2;
  int iVar3;
  s8 *psVar4;

  if (APS_TX_CACHE_TABLE_SIZE != '\0')
  {
    psVar4 = &aps_txCache_tbl[0].apsAddrWaitTimeout;
    iVar3 = 0;
    do
    {
      while (((int)((uint)(byte)aps_txCache_tbl[iVar3].field_0x12 << 0x1f) >> 0x1f) * -0x1000000 !=
             0)
      {
        bVar1 = (byte)aps_txCache_tbl[iVar3].field_0x12 >> 4;
        if (bVar1 != 3)
        {
          if ((bVar1 == 1) &&
              (iVar2 = ((byte)*psVar4 - 1) * 0x1000000, *psVar4 = (byte)((uint)iVar2 >> 0x18),
               iVar2 < 1))
          {
            apsTxEventPost();
          }
          break;
        }
        iVar2 = ((byte)psVar4[-1] - 1) * 0x1000000;
        psVar4[-1] = (byte)((uint)iVar2 >> 0x18);
        if (0 < iVar2)
          break;
        apsTxEventPost();
        iVar3 = iVar3 + 1;
        psVar4 = psVar4 + 0x1c;
        if ((int)(uint)APS_TX_CACHE_TABLE_SIZE <= iVar3)
        {
          return;
        }
      }
      iVar3 = iVar3 + 1;
      psVar4 = psVar4 + 0x1c;
    } while (iVar3 < (int)(uint)APS_TX_CACHE_TABLE_SIZE);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_cmd_send(void)

{
  byte bVar1;
  char cVar2;
  zb_buf_t *buf;
  zb_buf_t *pzVar3;
  undefined2 uVar4;
  undefined uVar5;
  u8 uVar6;
  bool bVar7;
  zb_buf_t **in_r0;
  uint uVar8;
  int iVar9;
  addrExt_t *pauVar10;
  int iVar11;
  byte in_r1;
  uint uVar12;
  uint uVar13;
  byte bVar14;
  undefined *puVar15;
  uint uVar16;
  uint uVar17;
  void *out;
  undefined4 in_stack_ffffffa0;
  uint uStack_58;
  byte bStack_54;
  u8 uStack_50;
  uint local_4c;
  undefined4 uStack_48;
  uint uStack_44;
  undefined4 uStack_40;
  uint uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined2 local_2c;
  undefined local_28;
  undefined uStack_27;

  buf = *in_r0;
  uVar5 = aps_get_counter_value();
  local_4c = 0;
  uStack_48 = 0;
  uStack_40 = 0;
  uStack_3c = (uint)CONCAT11(uVar5, in_r1);
  bVar1 = *(byte *)(in_r0 + 4);
  uStack_44 = (uint)bVar1;
  if (bVar1 == 2)
  {
    local_4c = (uint) * (ushort *)(in_r0 + 2);
  LAB_00022a1a:
    bStack_54 = (byte)(((uint)g_zbNwkCtx._46_1_ << 0x1b) >> 0x1f);
    uVar12 = (uint) * (byte *)(in_r0 + 1);
    uVar8 = (uint) * (byte *)((int)in_r0 + 5);
    uVar13 = (uint) * (byte *)((int)in_r0 + 6);
    pzVar3 = in_r0[1];
    uVar16 = (uint) * (byte *)((int)in_r0 + 7);
    uVar6 = '\0';
    uStack_50 = '\0';
    if ((pzVar3->buf[0] == '\x05') && (pzVar3->buf[1] == '\x01'))
    {
      bVar7 = ss_securityModeIsDistributed();
      uStack_50 = uVar6;
      if (((bVar7 == false) && (in_r1 != 0x48)) &&
          ((*(char *)(in_r0 + 4) != '\x02' || ((*(ushort *)(in_r0 + 2) & 0xfff8) != 0xfff8))))
      {
        uStack_50 = '\x01';
      }
      bStack_54 = 0;
      uVar12 = (uint) * (byte *)(in_r0 + 1);
      uVar8 = (uint) * (byte *)((int)in_r0 + 5);
      uVar13 = (uint) * (byte *)((int)in_r0 + 6);
      uVar16 = (uint) * (byte *)((int)in_r0 + 7);
    }
    local_28 = 1;
    if (*(char *)(in_r0 + 5) != '\0')
    {
      local_28 = 0x41;
    }
    uStack_38 = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    local_2c = 0;
    uVar17 = in_r1 - 0x49;
    iVar9 = ~uVar17 + uVar17;
    uStack_27 = uVar5;
    if ((iVar9 == 0) && (*(char *)((int)in_r0 + 0x12) == '\0'))
    {
      uVar17 = 0xfffffffd;
      uStack_58 = 2;
    }
    else
    {
      iVar11 = ss_apsEnAuxHdrFill();
      uStack_58 = iVar11 + 2U & 0xff;
      uVar17 = ~uStack_58;
      uVar12 = (uint) * (byte *)(in_r0 + 1);
      uVar8 = (uint) * (byte *)((int)in_r0 + 5);
      uVar13 = (uint) * (byte *)((int)in_r0 + 6);
      uVar16 = (uint) * (byte *)((int)in_r0 + 7);
    }
    out = (void *)((uVar8 << 8 | uVar12 | uVar13 << 0x10 | uVar16 << 0x18) + uVar17);
    memcpy(out, &local_28, 2);
    memset(buf, 0, 0x1a);
    buf->buf[10] = uStack_50;
    buf->buf[0xd] = bStack_54;
    buf->buf[0xe] = *(u8 *)((int)in_r0 + 0x13);
    buf->buf[0xf] = in_r1;
    buf->buf[0x14] = *(char *)((int)in_r0 + 0x11) + (char)uStack_58;
    buf->buf[0x10] = (u8)out;
    buf->buf[0x11] = (u8)((uint)out >> 8);
    buf->buf[0x12] = (u8)((uint)out >> 0x10);
    buf->buf[0x13] = (u8)((uint)out >> 0x18);
    if ((iVar9 == 0) && (*(char *)((int)in_r0 + 0x12) == '\0'))
    {
    LAB_00022af8:
      buf->buf[0xb] = '\x02';
      cVar2 = *(char *)(in_r0 + 4);
    }
    else
    {
      if (2 < uStack_58)
      {
        memcpy((void *)((int)out + 2), &uStack_38, uStack_58 - 2);
      }
      if (((iVar9 == 0) && (*(char *)(in_r0 + 4) != '\x03')) &&
          (pauVar10 = tl_zbExtAddrPtrByShortAddr(*(u16 *)(in_r0 + 2)), pauVar10 == (addrExt_t *)0x0))
      {
        bVar14 = 0xad;
        goto LAB_000229f4;
      }
      iVar11 = ss_apsSecureFrame();
      if (iVar11 == 1)
      {
        uStack_44 = CONCAT13(0xad, (undefined3)uStack_44);
        aps_conf();
        return;
      }
      if (iVar9 == 0)
        goto LAB_00022af8;
      iVar9 = *(int *)(buf->buf + 0x10);
      puVar15 = (undefined *)(iVar9 + -0xb);
      buf->buf[0x10] = (u8)puVar15;
      buf->buf[0x11] = (u8)((uint)puVar15 >> 8);
      buf->buf[0x12] = (u8)((uint)puVar15 >> 0x10);
      buf->buf[0x13] = (u8)((uint)puVar15 >> 0x18);
      buf->buf[0x14] = buf->buf[0x14] + '\v';
      *puVar15 = local_28;
      *(undefined *)(iVar9 + -10) = uStack_27;
      *(undefined *)(iVar9 + -9) = 0xe;
      buf->buf[0xb] = '\x02';
      cVar2 = *(char *)(in_r0 + 4);
    }
    if (cVar2 == '\x02')
    {
      uVar4 = *(undefined2 *)(in_r0 + 2);
      buf->buf[8] = (u8)uVar4;
      buf->buf[9] = (u8)((ushort)uVar4 >> 8);
      bVar7 = false;
    }
    else
    {
      uVar6 = tl_zbShortAddrByExtAddr((u16 *)(buf->buf + 8), (addrExt_t)CONCAT44(uVar16, in_stack_ffffffa0),
                                      (u16 *)(in_r0 + 2));
      if (uVar6 == 0xff)
      {
        memcpy(buf, in_r0 + 2, 8);
        bVar7 = true;
      }
      else
      {
        bVar7 = false;
      }
    }
    iVar9 = apsTxDataPost();
    if (iVar9 != 0)
    {
      apsTxEventPost();
      if (!bVar7)
      {
        return;
      }
      aps_txCacheAsNoShortAddr();
      return;
    }
  }
  else
  {
    memcpy(&local_4c, in_r0 + 2, 8);
    bVar14 = 0xa6;
    if ((byte)(bVar1 - 2) < 2)
      goto LAB_00022a1a;
  LAB_000229f4:
    uStack_44 = uStack_44 & 0xffffff | (uint)bVar14 << 0x18;
  }
  aps_conf();
  zb_buf_free(buf);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 apsDataRequest(void)

{
  undefined uVar1;
  void *in_r0;
  zb_buf_t *p;
  undefined4 uVar2;
  void *out;
  int iVar3;
  void *in_r1;
  byte in_r2;

  p = (zb_buf_t *)c1();
  uVar2 = 0x39;
  if (p != (zb_buf_t *)0x0)
  {
    memset(p, 0, 0x1f);
    out = tl_bufInitalloc(p, in_r2);
    if ((uint)((int)out - (int)p) < 0x27)
    {
      zb_buf_free(p);
      sys_exceptionPost(0x6fc, 'P');
      uVar2 = 6;
    }
    else
    {
      if ((*(short *)((int)in_r0 + 4) == 0) && (*(short *)((int)in_r0 + 6) == 0x13))
      {
        *(undefined *)((int)in_r0 + 0xe) = 0x49;
      }
      else
      {
        do
        {
          uVar1 = aps_get_handle();
          iVar3 = apsHandleIsExit();
        } while (iVar3 != 0);
        *(undefined *)((int)in_r0 + 0xe) = uVar1;
      }
      memcpy(out, in_r1, (uint)in_r2);
      memcpy(p, in_r0, 0x1f);
      p->buf[0] = (u8)out;
      p->buf[1] = (u8)((uint)out >> 8);
      p->buf[2] = (u8)((uint)out >> 0x10);
      p->buf[3] = (u8)((uint)out >> 0x18);
      p->buf[9] = in_r2;
      tl_zbTaskPost(aps_data_request, p);
      uVar2 = 0;
    }
  }
  return uVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 apsDataFragmentRequest(void)

{
  u8 uVar1;
  char cVar2;
  void *in_r0;
  u8 *dest;
  int iVar3;
  undefined4 in_r1;
  undefined2 in_r2;
  undefined4 uVar4;

  uVar4 = 0x39;
  if (((g_apsDataFragmentTransWin[47] == '\0') && (g_apsDataFragmentTransWin._32_4_ == (u8 *)0x0)) && (dest = ev_buf_allocate(0x1f), dest != (u8 *)0x0))
  {
    memset(dest, 0, 0x1f);
    memcpy(dest, in_r0, 0x1f);
    uVar1 = aps_ib.aps_fragment_payload_size;
    g_apsDataFragmentTransWin[47] = '\x01';
    g_apsDataFragmentTransWin[46] = 0;
    g_apsDataFragmentTransWin[45] = 0xff;
    g_apsDataFragmentTransWin._32_4_ = dest;
    g_apsDataFragmentTransWin._36_4_ = in_r1;
    g_apsDataFragmentTransWin._40_2_ = in_r2;
    iVar3 = FUNAAAAB();
    cVar2 = FUN_00001624(in_r2, uVar1);
    g_apsDataFragmentTransWin[42] = ('\x01' - (iVar3 == 0)) + cVar2;
    g_apsDataFragmentTransWin[43] = 0;
    tl_zbTaskPost(aps_data_fragment, (void *)0x0);
    uVar4 = 0;
  }
  return uVar4;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_bindingTabInit(void)

{
  aps_binding_entry_t *dest;

  dest = bindTblEntryGet();
  memset(dest, 0, (uint)APS_BINDING_TABLE_SIZE * 0xe);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

nv_sts_t aps_oldBindingTblRecover(void)

{
  byte bVar1;
  byte bVar2;
  nv_sts_t nVar3;
  nv_sts_t nVar4;
  aps_binding_entry_t *buf;
  byte *buf_00;
  int iVar5;
  aps_binding_entry_t *paVar6;
  uint uVar7;
  byte *pbVar8;
  ushort uVar9;
  ushort uVar10;
  uint uVar11;
  int iVar12;
  undefined uVar13;
  undefined uVar14;
  undefined2 uVar15;
  ushort *in_stack_ffffffb4;
  ushort uStack_38;
  u16 auStack_36[5];
  ushort local_2c;
  u8 uStack_2a;
  ushort uStack_28;
  ushort local_26;

  buf = bindTblEntryGet();
  local_26 = 0;
  nVar3 = nv_flashSingleItemSizeGet('\x02', '\x06', &local_26);
  if (nVar3 != NV_SUCC)
  {
    return nVar3;
  }
  if ((uint)APS_OLD_BINDING_TBL_SIZE_MAX < (uint)local_26)
  {
    return NV_SUCC;
  }
  uVar7 = local_26 - 4;
  if (uVar7 < 0x16)
  {
    return NV_SUCC;
  }
  iVar12 = 1;
  if (uVar7 == 0x16)
  {
    APS_BINDING_TABLE_SIZE_V1 = 1;
  }
  else
  {
    do
    {
      iVar5 = iVar12 + 1;
      uVar11 = (iVar12 + 0xb) * iVar5 * 2;
      if (uVar7 < uVar11)
      {
        return NV_SUCC;
      }
      iVar12 = iVar5;
    } while (uVar11 - uVar7 != 0);
    APS_BINDING_TABLE_SIZE_V1 = (byte)iVar5;
  }
  buf_00 = ev_buf_allocate(local_26);
  if (buf_00 == (byte *)0x0)
  {
    return NV_SUCC;
  }
  nVar3 = nv_flashReadNew('\x01', '\x02', '\x06', local_26, buf_00);
  if (nVar3 != NV_SUCC)
    goto LAB_00023008;
  local_2c = 0;
  uStack_2a = '\0';
  uVar13 = SUB41(&local_2c, 0);
  uVar14 = (undefined)((uint)&local_2c >> 8);
  uVar15 = (undefined2)((uint)&local_2c >> 0x10);
  uStack_28 = local_2c;
  nVar4 = nv_flashReadNew('\0', '\x01', 0xff, 10, (u8 *)&local_2c);
  if (nVar4 == NV_SUCC)
  {
    iVar12 = 0;
    do
    {
      uVar13 = 10;
      uVar14 = 0;
      uVar15 = 0;
      in_stack_ffffffb4 = &uStack_38;
      nVar4 = nv_flashReadByIndex('\x01', '\x03', uStack_2a, (u16)iVar12, 10, (u8 *)in_stack_ffffffb4);
      if (nVar4 != NV_ITEM_NOT_FOUND)
      {
        iVar5 = tl_idxByExtAddr();
        if (iVar5 != 0)
        {
          tl_zbNwkAddrMapAdd(0xffff, (addrExt_t)CONCAT44(in_stack_ffffffb4, CONCAT22(uVar15, CONCAT11(uVar14, uVar13))), auStack_36);
          tl_addrMappingForBind('\x01', uStack_28);
        }
        uVar7 = (uint)APS_BINDING_TABLE_SIZE_V1;
        if (uVar7 != 0)
        {
          iVar5 = 0;
          pbVar8 = buf_00;
          do
          {
            if (((int)(uint)uStack_38 >> iVar5 & 1U) != 0)
            {
              *(ushort *)(pbVar8 + 0x14) = uStack_28;
            }
            iVar5 = iVar5 + 1;
            pbVar8 = pbVar8 + 0x14;
          } while (iVar5 < (int)uVar7);
        }
      }
      iVar12 = iVar12 + 1;
    } while (iVar12 <= (int)(uint)local_2c);
  }
  if (buf_00[2] == 0)
  {
    bindTblEntryGet();
  LAB_000230be:
    uVar9 = (ushort)APS_BINDING_TABLE_SIZE;
  }
  else
  {
    iVar12 = tl_idxByExtAddr();
    if (iVar12 != 0)
    {
      tl_zbNwkAddrMapAdd(g_zbInfo.nwkNib.nwkAddr,
                         (addrExt_t)
                             CONCAT44(in_stack_ffffffb4, CONCAT22(uVar15, CONCAT11(uVar14, uVar13))),
                         (u16 *)g_zbInfo.nwkNib.ieeeAddr);
      tl_addrMappingForBind('\x01', uStack_28);
    }
    uVar7 = (uint)APS_BINDING_TABLE_SIZE_V1;
    if ((uVar7 != 0) && (bVar1 = *buf_00, bVar1 != 0))
    {
      iVar5 = 0;
      iVar12 = 0;
      pbVar8 = buf_00;
      do
      {
        if (pbVar8[0xd] == 1)
        {
          *(ushort *)(pbVar8 + 10) = uStack_28;
          iVar12 = iVar12 + 1;
        }
        iVar5 = iVar5 + 1;
      } while ((iVar5 < (int)uVar7) && (pbVar8 = pbVar8 + 0x14, iVar12 < (int)(uint)bVar1));
    }
    bVar1 = buf_00[2];
    paVar6 = bindTblEntryGet();
    if (bVar1 == 0)
      goto LAB_000230be;
    pbVar8 = buf_00 + 0xa4;
    iVar12 = 0;
    uVar10 = 0;
    do
    {
      uVar11 = (uint)*pbVar8;
      uVar7 = (uint)pbVar8[1];
      if ((uVar11 < APS_BINDING_TABLE_SIZE_V1) && (uVar7 < APS_BINDING_TABLE_SIZE_V1))
      {
        paVar6->used = '\x01';
        paVar6->srcEp = buf_00[uVar11 * 0x14 + 0xc];
        bVar2 = (byte)((ushort) * (undefined2 *)(buf_00 + uVar11 * 0x14 + 8) >> 8);
        *(byte *)&paVar6->clusterId = (byte) * (undefined2 *)(buf_00 + uVar11 * 0x14 + 8) | bVar2;
        *(byte *)((int)&paVar6->clusterId + 1) = bVar2;
        if (buf_00[uVar7 * 0x14 + 0x10] == 1)
        {
          paVar6->dstAddrMode = '\x03';
          iVar5 = (uVar7 + 1) * 0x14;
          tl_zbExtAddrByIdx(*(u16 *)(buf_00 + iVar5),
                            (addrExt_t)
                                CONCAT44(in_stack_ffffffb4, CONCAT22(uVar15, CONCAT11(uVar14, uVar13))));
          (paVar6->field_3).dstExtAddrInfo.dstEp = buf_00[iVar5 + 2];
        }
        else
        {
          paVar6->dstAddrMode = '\x01';
          iVar5 = (uVar7 + 1) * 0x14;
          (paVar6->field_3).dstExtAddrInfo.extAddr[0] = buf_00[iVar5];
          (paVar6->field_3).dstExtAddrInfo.extAddr[1] = buf_00[iVar5 + 1];
        }
        uVar10 = uVar10 + 1 & 0xff;
        uVar9 = (ushort)APS_BINDING_TABLE_SIZE;
        if (uVar9 <= uVar10)
          goto LAB_000230c2;
        paVar6 = paVar6 + 1;
      }
      iVar12 = iVar12 + 1;
      pbVar8 = pbVar8 + 2;
    } while (iVar12 < (int)(uint)bVar1);
    uVar9 = (ushort)APS_BINDING_TABLE_SIZE;
  }
LAB_000230c2:
  nv_flashWriteNew('\x01', 2, 0x80, uVar9 * 0xe, (u8 *)buf);
  nv_flashSingleItemRemove('\x02', '\x06', local_26);
  nVar4 = nv_flashReadNew('\0', '\x01', 0xff, 10, (u8 *)&local_2c);
  if (nVar4 == NV_SUCC)
  {
    iVar12 = 0;
    do
    {
      nVar4 = nv_flashReadByIndex('\x01', '\x03', uStack_2a, (u16)iVar12, 10, (u8 *)&uStack_38);
      if (nVar4 != NV_ITEM_NOT_FOUND)
      {
        nv_itemDeleteByIndex('\x01', '\x03', uStack_2a, (u16)iVar12);
      }
      iVar12 = iVar12 + 1;
    } while (iVar12 <= (int)(uint)local_2c);
  }
LAB_00023008:
  ev_buf_free(buf_00);
  return nVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_bindingTblNvInit(void)

{
  nv_sts_t nVar1;
  aps_binding_entry_t *buf;

  buf = bindTblEntryGet();
  nv_itemLengthCheckAdd(0x80, (ushort)APS_BINDING_TABLE_SIZE * 0xe);
  nVar1 = nv_flashReadNew('\x01', '\x02', 0x80, 0xe, (u8 *)buf);
  if (nVar1 != NV_SUCC)
  {
    aps_oldBindingTblRecover();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_bindingTblEntryGet(void)

{
  bindTblEntryGet();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

char aps_bindingTblEntryNum(void)

{
  char cVar1;
  aps_binding_entry_t *paVar2;
  int iVar3;

  paVar2 = bindTblEntryGet();
  cVar1 = '\0';
  if (APS_BINDING_TABLE_SIZE != 0)
  {
    iVar3 = 0;
    while (true)
    {
      if (paVar2->used == '\x01')
      {
        cVar1 = cVar1 + '\x01';
      }
      if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar3 + 1)
        break;
      iVar3 = iVar3 + 1;
      paVar2 = paVar2 + 1;
    }
  }
  return cVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 aps_bindingTblExis(void)

{
  void *in_r0;
  aps_binding_entry_t *paVar1;
  int iVar2;
  int iVar3;
  uint uVar4;

  paVar1 = bindTblEntryGet();
  uVar4 = (uint)APS_BINDING_TABLE_SIZE;
  if (uVar4 != 0)
  {
    iVar3 = 0;
    while (true)
    {
      if (((paVar1->used == '\x01') && (paVar1->dstAddrMode == '\x03')) &&
          (iVar2 = memcmp(&paVar1->field_3, in_r0, 8), iVar2 == 0))
      {
        return 1;
      }
      iVar3 = iVar3 + 1;
      if ((int)uVar4 <= iVar3)
        break;
      paVar1 = paVar1 + 1;
    }
  }
  return 0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

aps_binding_entry_t *aps_bindingTblMatch(void)

{
  u16 in_r0;
  aps_binding_entry_t *paVar1;
  uint uVar2;
  u8 in_r1;
  u8 in_r2;
  uint uVar3;
  void *in_r3;
  uint uVar4;
  int iVar5;
  ushort local_26;

  local_26 = 0xfffe;
  paVar1 = bindTblEntryGet();
  if (APS_BINDING_TABLE_SIZE == '\0')
  {
    return (aps_binding_entry_t *)0x0;
  }
  iVar5 = 0;
  do
  {
    if ((((paVar1->used != '\0') && (paVar1->clusterId == in_r0)) && (paVar1->srcEp == in_r1)) &&
        (paVar1->dstAddrMode == in_r2))
    {
      if (in_r2 == '\x03')
      {
        uVar2 = memcmp(&paVar1->field_3, in_r3, 8);
        uVar3 = (uint)(paVar1->field_3).dstExtAddrInfo.dstEp;
        uVar4 = uVar3 - *(byte *)((int)in_r3 + 8);
        uVar2 = uVar2 + ~uVar2 + (uint)CARRY4(uVar4, ~uVar4) &
                uVar4 + ~uVar4 + (uint)(*(byte *)((int)in_r3 + 8) <= uVar3);
      }
      else
      {
        if (in_r2 != '\x01')
          goto LAB_0002339e;
        memcpy(&local_26, in_r3, 2);
        uVar2 = (uint)local_26 - (uint)(paVar1->field_3).groupAddr;
        uVar2 = uVar2 + ~uVar2 + (uint)((uint)(paVar1->field_3).groupAddr <= (uint)local_26) & 1;
      }
      if (uVar2 != 0)
      {
        return paVar1;
      }
    }
  LAB_0002339e:
    iVar5 = iVar5 + 1;
    if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar5)
    {
      return (aps_binding_entry_t *)0x0;
    }
    paVar1 = paVar1 + 1;
  } while (true);
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 aps_bindingTblEntryAdd(void)

{
  aps_binding_entry_t *paVar1;
  undefined4 in_r0;
  aps_binding_entry_t *paVar2;
  undefined4 uVar3;
  u8 in_r1;
  u8 in_r2;
  u8 *in_r3;
  int iVar4;
  aps_binding_entry_t *paVar5;

  paVar2 = bindTblEntryGet();
  uVar3 = 0;
  if (APS_BINDING_TABLE_SIZE != 0)
  {
    if (paVar2->used != '\0')
    {
      iVar4 = 0;
      paVar5 = paVar2;
      do
      {
        iVar4 = iVar4 + 1;
        if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar4)
        {
          return 0;
        }
        paVar2 = paVar5 + 1;
        paVar1 = paVar5 + 1;
        paVar5 = paVar2;
      } while (paVar1->used != '\0');
    }
    paVar2->used = '\x01';
    *(char *)&paVar2->clusterId = (char)in_r0;
    *(char *)((int)&paVar2->clusterId + 1) = (char)((uint)in_r0 >> 8);
    paVar2->srcEp = in_r1;
    paVar2->dstAddrMode = in_r2;
    if (in_r2 == '\x03')
    {
      memcpy(&paVar2->field_3, in_r3, 8);
      (paVar2->field_3).dstExtAddrInfo.dstEp = in_r3[8];
      uVar3 = 1;
    }
    else
    {
      uVar3 = 0;
      if (in_r2 == '\x01')
      {
        (paVar2->field_3).dstExtAddrInfo.extAddr[0] = *in_r3;
        (paVar2->field_3).dstExtAddrInfo.extAddr[1] = in_r3[1];
        uVar3 = 1;
      }
    }
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void aps_bindingTblEntryDel(void)

{
  void *in_r0;
  int iVar1;
  aps_binding_entry_t *paVar2;
  uint uVar3;

  iVar1 = aps_bindingTblEntryNum();
  paVar2 = bindTblEntryGet();
  if (in_r0 != (void *)0x0)
  {
    *(undefined *)((int)in_r0 + 0xd) = 0;
    uVar3 = ((int)in_r0 - (int)paVar2 >> 1) * -0x49249249 & 0xff;
    iVar1 = iVar1 + -1;
    if ((int)uVar3 < iVar1)
    {
      memcpy(in_r0, (void *)((int)in_r0 + 0xe), (iVar1 - uVar3) * 0xe);
    }
    paVar2[iVar1].used = '\0';
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

aps_binding_entry_t *aps_bindingTblEntryDelByDstExtAddr(void)

{
  bool bVar1;
  byte bVar2;
  void *in_r0;
  aps_binding_entry_t *paVar3;
  aps_binding_entry_t *paVar4;
  int iVar5;

  paVar3 = bindTblEntryGet();
  if (APS_BINDING_TABLE_SIZE == '\0')
  {
    return paVar3;
  }
  iVar5 = 0;
  bVar1 = false;
  paVar4 = paVar3;
  do
  {
    if (((paVar4->used == '\x01') && (paVar4->dstAddrMode == '\x03')) &&
        (paVar3 = (aps_binding_entry_t *)memcmp(&paVar4->field_3, in_r0, 8),
         paVar3 == (aps_binding_entry_t *)0x0))
    {
      paVar3 = (aps_binding_entry_t *)aps_bindingTblEntryDel();
      bVar1 = true;
      if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar5 + 1)
        goto LAB_00023548;
    }
    else if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar5 + 1)
    {
    LAB_00023548:
      if (!bVar1)
      {
        return paVar3;
      }
      bVar2 = tl_zbTaskPost(aps_bindingTblSave2Flash, (void *)0x0);
      return (aps_binding_entry_t *)(uint)bVar2;
    }
    iVar5 = iVar5 + 1;
    paVar4 = paVar4 + 1;
  } while (true);
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 aps_search_dst_from_bind_tbl(void)

{
  u16 uVar1;
  int in_r0;
  aps_binding_entry_t *paVar2;
  undefined4 uVar3;
  int in_r1;
  char cVar4;
  int iVar5;
  undefined *out;

  paVar2 = bindTblEntryGet();
  uVar3 = 0xa8;
  if (APS_BINDING_TABLE_SIZE == '\0')
  {
    return 0xa8;
  }
  out = (undefined *)(in_r1 + 8);
  iVar5 = 0;
  cVar4 = '\0';
  do
  {
    if (((paVar2->used == '\x01') && (paVar2->srcEp == *(u8 *)(in_r0 + 8))) &&
        (paVar2->clusterId == *(u16 *)(in_r0 + 6)))
    {
      out[9] = paVar2->dstAddrMode;
      if (paVar2->dstAddrMode == '\x03')
      {
        out[8] = (paVar2->field_3).dstExtAddrInfo.dstEp;
        memcpy(out, &paVar2->field_3, 8);
      }
      else
      {
        uVar1 = (paVar2->field_3).groupAddr;
        *out = (char)uVar1;
        out[1] = (char)(uVar1 >> 8);
      }
      out = out + 10;
      cVar4 = cVar4 + '\x01';
      *(undefined *)(in_r1 + 4) = 0;
      *(char *)(in_r1 + 5) = cVar4;
      uVar3 = 0;
      if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar5 + 1)
      {
        return 0;
      }
    }
    else if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar5 + 1)
    {
      return uVar3;
    }
    iVar5 = iVar5 + 1;
    paVar2 = paVar2 + 1;
  } while (true);
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 aps_me_bind_req(void)

{
  uint uVar1;
  int iVar2;
  undefined4 uVar3;

  uVar1 = aps_bindingTblEntryNum();
  uVar3 = 0xae;
  if (APS_BINDING_TABLE_SIZE != uVar1)
  {
    iVar2 = aps_bindingTblMatch();
    uVar3 = 0;
    if (iVar2 == 0)
    {
      iVar2 = aps_bindingTblEntryAdd();
      uVar3 = 0xa6;
      if (iVar2 != 0)
      {
        tl_zbTaskPost(aps_bindingTblSave2Flash, (void *)0x0);
        uVar3 = 0;
      }
    }
  }
  return uVar3;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 aps_me_unbind_req(void)

{
  int iVar1;
  undefined4 uVar2;

  iVar1 = aps_bindingTblMatch();
  uVar2 = 0xa4;
  if (iVar1 != 0)
  {
    aps_bindingTblEntryDel();
    tl_zbTaskPost(aps_bindingTblSave2Flash, (void *)0x0);
    uVar2 = 0;
  }
  return uVar2;
}

void aps_me_init(void)

{
  u8 uVar1;
  int iVar2;

  uVar1 = aps_groupTblNvInit();
  if (uVar1 == '\0')
  {
    aps_init_group_num_set();
    iVar2 = aps_bindingTblNvInit();
  }
  else
  {
    aps_groupTblReset();
    iVar2 = aps_bindingTblNvInit();
  }
  if (iVar2 != 0)
  {
    aps_bindingTabInit();
  }
  aps_ib.aps_designated_coordinator = '\0';
  aps_ib.aps_channel_mask = 0x7fff800;
  aps_ib.aps_use_ext_panid._0_4_ = 0;
  aps_ib.aps_use_ext_panid._4_4_ = 0;
  aps_ib.aps_nonmember_radius = '\x02';
  aps_ib.aps_interframe_delay = APS_INTERFRAME_DELAY;
  aps_ib.aps_max_window_size = APS_MAX_WINDOW_SIZE;
  if (APS_MAX_WINDOW_SIZE == '\0')
  {
    aps_ib.aps_max_window_size = '\x01';
  }
  aps_ib.aps_fragment_payload_size = APS_FRAGMEMT_PAYLOAD_SIZE;
  aps_ib._18_1_ = aps_ib._18_1_ & 0xf5 | 1;
  return;
}

void zdo_zdpCbTblRegister(zdo_appIndCb_t *cbTbl)

{
  zdoAppIndCbLst = cbTbl;
  return;
}

u16 zdo_af_get_accept_nwk_update_pan_id(void)

{
  return zdo_cfg_attributes.config_accept_nwk_update_pan_id;
}

u8 zdo_af_get_accept_nwk_update_channel(void)

{
  return zdo_cfg_attributes.config_accept_nwk_update_channel;
}

bool zdo_af_get_mgmtLeave_use_aps_sec(void)

{
  return (bool)zdo_cfg_attributes.config_mgmt_leave_use_aps_sec;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 zdo_af_get_scan_attempts(void)

{
  return zdo_cfg_attributes.config_nwk_scan_attempts;
}

u16 zdo_af_get_nwk_time_btwn_scans(void)

{
  return zdo_cfg_attributes.config_nwk_time_btwn_scans;
}

u8 zdo_channel_page2num(u32 chp)

{
  u8 uVar1;
  int iVar2;

  iVar2 = 0;
  uVar1 = '\v';
  do
  {
    if ((chp >> iVar2 + 0xb & 1) != 0)
    {
      return uVar1;
    }
    uVar1 = uVar1 + '\x01';
    iVar2 = iVar2 + 1;
  } while (uVar1 != '\x1b');
  return '\x1b';
}

void zdo_init(void)

{
  zdp_init();
  memcpy(&zdo_cfg_attributes, &zdoCfgAttrDefault, 0x18);
  return;
}

undefined4 zdo_nlmeNwkDiscReq(void)

{
  undefined *arg;
  undefined4 uVar1;

  arg = (undefined *)c1();
  uVar1 = 0x8a;
  if (arg != (undefined *)0x0)
  {
    g_zdo_nwk_manager[37] = 3;
    *arg = g_zdo_nwk_manager[24];
    arg[1] = g_zdo_nwk_manager[25];
    arg[2] = g_zdo_nwk_manager[26];
    arg[3] = g_zdo_nwk_manager[27];
    arg[4] = g_zdo_nwk_manager[33];
    tl_zbPrimitivePost('\x03', 's', arg);
    uVar1 = 0;
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_nwkDiscReqTimerCb(void)

{
  int iVar1;
  undefined4 uVar2;

  iVar1 = zdo_nlmeNwkDiscReq();
  uVar2 = 0;
  if (iVar1 == 0)
  {
    g_zdo_nwk_manager._0_4_ = 0;
    uVar2 = 0xfffffffe;
  }
  return uVar2;
}

void zdo_nlme_start_router_req(undefined *param_1)

{
  *param_1 = 0xf;
  param_1[1] = 0xf;
  param_1[2] = 0;
  g_zdo_nwk_manager[37] = 2;
  tl_zbPrimitivePost('\x03', 'y', param_1);
  return;
}

void zdo_nlme_edScan(undefined *param_1)

{
  *param_1 = g_zdo_nwk_manager[24];
  param_1[1] = g_zdo_nwk_manager[25];
  param_1[2] = g_zdo_nwk_manager[26];
  param_1[3] = g_zdo_nwk_manager[27];
  param_1[4] = g_zdo_nwk_manager[33];
  tl_zbPrimitivePost('\x03', '{', param_1);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_manyToOneRouteDisc(void)

{
  undefined *in_r0;

  in_r0[3] = 0;
  in_r0[4] = 0;
  in_r0[2] = 0;
  *in_r0 = 0xfb;
  in_r0[1] = 0xfe;
  in_r0[3] = g_zbInfo.nwkNib.concentratorRadius;
  in_r0[4] = (byte)NWK_ROUTE_RECORD_TABLE_SIZE + ~(byte)NWK_ROUTE_RECORD_TABLE_SIZE +
             ((undefined *)0xfffffffe < in_r0 + 3);
  tl_zbPrimitivePost('\x03', 0x8f, in_r0);
  return;
}

void zdo_startDeviceCnf(undefined *param_1, int param_2)

{
  u16 uVar1;

  param_1[1] = 0;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  param_1[5] = 0;
  *param_1 = (char)param_2;
  if (param_2 == 0)
  {
    param_1[1] = g_zbInfo.macPib.phyChannelCur;
    uVar1 = g_zbInfo.macPib.panId;
    param_1[2] = (char)g_zbInfo.macPib.panId;
    param_1[3] = (char)(uVar1 >> 8);
    uVar1 = g_zbInfo.macPib.shortAddress;
    param_1[4] = (char)g_zbInfo.macPib.shortAddress;
    param_1[5] = (char)(uVar1 >> 8);
  }
  g_zdo_nwk_manager[37] = 0;
  tl_zbTaskPost(zdo_startup_complete, param_1);
  return;
}

void zdo_startup_complete(zb_buf_t *param_1)

{
  if (param_1->buf[0] == '\0')
  {
    g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ | 0x14;
    ss_zdoTcInit();
    g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xfe;
    tl_zbNwkLinkStatusStart();
  }
  else
  {
    if ((int)((uint)g_zbNwkCtx._45_1_ << 0x1f) < 0)
    {
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xdb;
    }
    tl_zbNwkLinkStatusStop();
  }
  g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf0;
  tl_zbAdditionNeighborReset();
  if ((zdoAppIndCbLst != (int *)0x0) && (*zdoAppIndCbLst != 0))
  {
    FFFFFFF();
  }
  zb_buf_free(param_1);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 FFFFFFF(void)

{
  u8 uVar1;
  void *out;
  undefined4 uVar2;
  int iVar3;
  code *in_r3;

  (*in_r3)();
  out = (void *)c1();
  uVar2 = 0x8a;
  if (out != (void *)0x0)
  {
    g_zdo_nwk_manager[37] = 5;
    tl_zbAdditionNeighborReset();
    uVar1 = af_nodeMacCapabilityGet();
    *(undefined *)((int)out + 0xc) = 2;
    *(undefined *)((int)out + 8) = g_zdo_nwk_manager[24];
    *(undefined *)((int)out + 9) = g_zdo_nwk_manager[25];
    *(undefined *)((int)out + 10) = g_zdo_nwk_manager[26];
    *(undefined *)((int)out + 0xb) = g_zdo_nwk_manager[27];
    *(undefined *)((int)out + 0xd) = g_zdo_nwk_manager[33];
    *(u8 *)((int)out + 0xe) = uVar1;
    iVar3 = memcmp(aps_ib.aps_use_ext_panid, &g_zero_addr, 8);
    if (iVar3 == 0)
    {
      memcpy(out, g_zbInfo.nwkNib.extPANId, 8);
    }
    else
    {
      memcpy(out, aps_ib.aps_use_ext_panid, 8);
    }
    *(byte *)((int)out + 0xf) = aps_ib._18_1_ & 1 ^ 1;
    tl_zbPrimitivePost('\x03', '}', out);
    uVar2 = 0;
  }
  return uVar2;
}

undefined4 zdo_nwkRejoinReqSend(void)

{
  u8 uVar1;
  void *out;
  undefined4 uVar2;
  int iVar3;

  out = (void *)c1();
  uVar2 = 0x8a;
  if (out != (void *)0x0)
  {
    g_zdo_nwk_manager[37] = 5;
    tl_zbAdditionNeighborReset();
    uVar1 = af_nodeMacCapabilityGet();
    *(undefined *)((int)out + 0xc) = 2;
    *(undefined *)((int)out + 8) = g_zdo_nwk_manager[24];
    *(undefined *)((int)out + 9) = g_zdo_nwk_manager[25];
    *(undefined *)((int)out + 10) = g_zdo_nwk_manager[26];
    *(undefined *)((int)out + 0xb) = g_zdo_nwk_manager[27];
    *(undefined *)((int)out + 0xd) = g_zdo_nwk_manager[33];
    *(u8 *)((int)out + 0xe) = uVar1;
    iVar3 = memcmp(aps_ib.aps_use_ext_panid, &g_zero_addr, 8);
    if (iVar3 == 0)
    {
      memcpy(out, g_zbInfo.nwkNib.extPANId, 8);
    }
    else
    {
      memcpy(out, aps_ib.aps_use_ext_panid, 8);
    }
    *(byte *)((int)out + 0xf) = aps_ib._18_1_ & 1 ^ 1;
    tl_zbPrimitivePost('\x03', '}', out);
    uVar2 = 0;
  }
  return uVar2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_auth_check_timer_cb(void)

{
  undefined4 in_r0;

  tl_zbNwkAddrMapInit();
  tl_zbNeighborTableInit();
  zdo_startDeviceCnf(in_r0, 0x8d);
  g_zdo_nwk_manager._20_4_ = 0;
  g_zdo_nwk_manager._4_4_ = 0;
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_reset_confirm_cb(void)

{
  zb_buf_t *in_r0;

  if ((zdoAppIndCbLst != 0) && (*(int *)(zdoAppIndCbLst + 4) != 0))
  {
    zdo_nlmeEdScanReq();
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_nlmeEdScanReq(void)

{
  undefined4 uVar1;
  int iVar2;
  undefined extraout_r1;
  uint extraout_r2;
  code *in_r3;

  uVar1 = (*in_r3)();
  if (((extraout_r2 & 0xff) != 0) && (g_zdo_nwk_manager[37] == '\0'))
  {
    iVar2 = c1();
    if (iVar2 == 0)
    {
      return 0x8a;
    }
    g_zdo_nwk_manager[37] = 7;
    g_zdo_nwk_manager[35] = (undefined)extraout_r2;
    g_zdo_nwk_manager._24_4_ = uVar1;
    g_zdo_nwk_manager[33] = extraout_r1;
    zdo_nlme_edScan(iVar2);
    return 0;
  }
  return 0x80;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_ed_scan_confirm(void)

{
  zb_buf_t *in_r0;

  if (g_zdo_nwk_manager[37] == '\a')
  {
    g_zdo_nwk_manager[35] = g_zdo_nwk_manager[35] + -1;
    if (g_zdo_nwk_manager[35] != '\0')
    {
      zdo_nlme_edScan(in_r0);
      return;
    }
    g_zdo_nwk_manager[37] = g_zdo_nwk_manager[35];
    if ((zdo_mgmt_nwk_flag & 1) != 0)
    {
      zdo_mgmt_nwk_flag = zdo_mgmt_nwk_flag & 0xfe;
      tl_zbTaskPost(zdo_nwkUpdateNotifyRespSend, in_r0);
      return;
    }
  }
  zb_buf_free(in_r0);
  return;
}

void FUN_00023b08(undefined4 param_1, zb_buf_t *param_2, int param_3, int param_4)

{
  char cVar1;
  char in_ZR;

  if (in_ZR != '\0')
  {
    cVar1 = *(char *)(param_4 + 0x23) + -1;
    *(char *)(param_4 + 0x23) = cVar1;
    if (cVar1 != '\0')
    {
      zdo_nlme_edScan(param_2);
      return;
    }
    *(undefined *)(param_4 + param_3) = 0;
    if ((zdo_mgmt_nwk_flag & 1) != 0)
    {
      zdo_mgmt_nwk_flag = zdo_mgmt_nwk_flag & 0xfe;
      tl_zbTaskPost(zdo_nwkUpdateNotifyRespSend, param_2);
      return;
    }
  }
  zb_buf_free(param_2);
  return;
}

void zdo_nlmeForgetDev(addrExt_t nodeIeeeAddr, bool rejoin)

{
  u8 uVar1;
  u16 uVar2;
  tl_zb_normal_neighbor_entry_t *entry;
  char in_r1;
  undefined in_stack_ffffffdc;
  undefined in_stack_ffffffdd;
  undefined6 in_stack_ffffffde;
  u16 local_16[3];

  local_16[0] = 0xfffe;
  if (in_r1 == '\0')
  {
    ss_devKeyPairDelete((addrExt_t)
                            CONCAT62(in_stack_ffffffde, CONCAT11(in_stack_ffffffdd, in_stack_ffffffdc)));
  }
  uVar1 = tl_zbShortAddrByExtAddr(local_16, (addrExt_t)CONCAT62(in_stack_ffffffde, CONCAT11(in_stack_ffffffdd, in_stack_ffffffdc)),
                                  (u16 *)(uint)rejoin);
  if (uVar1 == '\0')
  {
    if (in_r1 == '\0')
    {
      aps_bindingTblEntryDelByDstExtAddr();
    }
    nwkRoutingTabEntryDstDel();
    nwkRouteRecTabEntryDstDel();
    entry = nwk_neTblGetByExtAddr((addrExt_t)
                                      CONCAT62(in_stack_ffffffde, CONCAT11(in_stack_ffffffdd, in_stack_ffffffdc)));
    if (entry == (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      tl_zbNwkAddrMapDelete(0);
    }
    else
    {
      uVar2 = tl_zbshortAddrByIdx(entry->addrmapIdx);
      tl_zbExtAddrByIdx(entry->addrmapIdx, (addrExt_t)CONCAT62(in_stack_ffffffde, uVar2));
      nwk_nodeAddrInfoDelete();
      tl_zbNeighborTableDelete(entry);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_leave_indication_cb(void)

{
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar1;
  int iVar2;
  undefined in_stack_ffffffd8;
  undefined7 in_stack_ffffffd9;
  char cStack_20;
  u8 local_1a;
  u8 uStack_19;

  memcpy(&stack0xffffffd8, in_r0, 9);
  ptVar1 = tl_zbNeighborTableSearchFromExtAddr((u16 *)&local_1a, (addrExt_t)CONCAT71(in_stack_ffffffd9, in_stack_ffffffd8),
                                               (u16 *)&stack0xffffffd8);
  if (((ptVar1 != (tl_zb_normal_neighbor_entry_t *)0x0) &&
       (-1 < (int)((uint)g_zbNwkCtx._45_1_ << 0x1b))) &&
      (cStack_20 == '\0'))
  {
    iVar2 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8);
    if ((iVar2 != 0) && ((ptVar1->field_0x1e & 0x70) == 0x10))
    {
      in_r0->buf[0x12] = '\x02';
      memcpy(in_r0, ss_ib.trust_center_address, 8);
      in_r0->buf[0x10] = local_1a;
      in_r0->buf[0x11] = uStack_19;
      memcpy(in_r0->buf + 8, &stack0xffffffd8, 8);
      tl_zbTaskPost(ss_apsmeUpdateDevReq, in_r0);
      goto LAB_00023c2a;
    }
  }
  zb_buf_free(in_r0);
LAB_00023c2a:
  zdo_nlmeForgetDev((addrExt_t)CONCAT71(in_stack_ffffffd9, in_stack_ffffffd8),
                    SUB41(&stack0xffffffd8, 0));
  if ((zdoAppIndCbLst != 0) && (*(int *)(zdoAppIndCbLst + 0xc) != 0))
  {
    zdo_nlmeLeaveReq();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_nlmeLeaveReq(void)

{
  void *in;
  void *out;
  undefined4 uVar1;
  code *in_r3;

  in = (void *)(*in_r3)();
  out = (void *)c1();
  uVar1 = 0x8a;
  if (out != (void *)0x0)
  {
    memcpy(out, in, 10);
    tl_zbPrimitivePost('\x03', 0x82, out);
    uVar1 = 0;
  }
  return uVar1;
}

undefined4 zdo_nlmePermitJoinReq(undefined param_1)

{
  undefined *arg;
  undefined4 uVar1;

  arg = (undefined *)c1();
  uVar1 = 0x8a;
  if (arg != (undefined *)0x0)
  {
    *arg = param_1;
    tl_zbPrimitivePost('\x03', 'w', arg);
    uVar1 = 0;
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 zdo_nlmePermitJoinCnf(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;

  uVar1 = zb_buf_free(in_r0);
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 zdo_routeDiscCnf(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;

  uVar1 = zb_buf_free(in_r0);
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_status_indication(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;

  uVar1 = in_r0->buf[2];
  if ((byte)(uVar1 - 0xb) < 2)
  {
    if ((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1b) < 0)
    {
      if (uVar1 == '\v')
      {
        nwkRouteRecTabEntryDstDel();
      }
      tl_zbTaskPost(zdo_manyToOneRouteDisc, in_r0);
      return;
    }
  }
  else
  {
    if (uVar1 == '\r')
    {
      tl_zbNwkStatusAddrConflictInd(in_r0);
      return;
    }
    if (uVar1 == '\x0f')
    {
      zb_buf_free(in_r0);
      zb_info_save((void *)0x0);
      return;
    }
  }
  zb_buf_free(in_r0);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 zdo_nlme_direct_join_confirm(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;

  uVar1 = zb_buf_free(in_r0);
  return uVar1;
}

zdo_status_t zdo_nwkRouterStart(void)

{
  zdo_status_t zVar1;
  int iVar2;

  zVar1 = ZDO_INVALID_REQUEST;
  if (g_zdo_nwk_manager[37] == '\0')
  {
    iVar2 = c1();
    zVar1 = ZDO_INSUFFICIENT_SPACE;
    if (iVar2 != 0)
    {
      g_zbInfo.nwkNib.capabilityInfo = (capability_info_t)af_nodeMacCapabilityGet();
      zdo_nlme_start_router_req(iVar2);
      zVar1 = ZDO_SUCCESS;
    }
  }
  return zVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_start_router_confirm(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;
  void *arg;

  uVar1 = in_r0->buf[0];
  if (g_zdo_nwk_manager[37] == '\x02')
  {
    zdo_startDeviceCnf(in_r0, uVar1);
    if (uVar1 == '\0')
    {
      if (((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1b) < 0) &&
          (arg = (void *)c1(), arg != (void *)0x0))
      {
        tl_zbTaskPost(zdo_manyToOneRouteDisc, arg);
      }
    }
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

zdo_status_t zdo_nwkFormationStart(u32 scanChannels, u8 scanDuration)

{
  zdo_status_t zVar1;
  undefined *arg;
  int iVar2;

  zVar1 = ZDO_INVALID_REQUEST;
  if (g_zdo_nwk_manager[37] == '\0')
  {
    arg = (undefined *)c1();
    zVar1 = ZDO_INSUFFICIENT_SPACE;
    if (arg != (undefined *)0x0)
    {
      arg[6] = 0;
      *arg = (char)scanChannels;
      arg[1] = (char)(scanChannels >> 8);
      arg[2] = (char)(scanChannels >> 0x10);
      arg[3] = (char)(scanChannels >> 0x18);
      arg[8] = scanDuration;
      arg[9] = 0xf;
      arg[10] = 0xf;
      arg[7] = 0;
      g_zdo_nwk_manager[37] = '\x01';
      g_zdo_nwk_manager._24_4_ = scanChannels;
      g_zdo_nwk_manager[33] = scanDuration;
      g_zbInfo.nwkNib.capabilityInfo = (capability_info_t)af_nodeMacCapabilityGet();
      iVar2 = memcmp(aps_ib.aps_use_ext_panid, &g_zero_addr, 8);
      if (iVar2 != 0)
      {
        memcpy(g_zbInfo.nwkNib.extPANId, aps_ib.aps_use_ext_panid, 8);
      }
      tl_zbAdditionNeighborReset();
      tl_zbPrimitivePost('\x03', 'u', arg);
      zVar1 = ZDO_SUCCESS;
    }
  }
  return zVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_network_formation_confirm(void)

{
  u8 uVar1;
  zb_buf_t *in_r0;
  void *arg;

  uVar1 = in_r0->buf[0];
  if (g_zdo_nwk_manager[37] == '\x01')
  {
    zdo_startDeviceCnf(in_r0, uVar1);
    if (uVar1 == '\0')
    {
      if (((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1b) < 0) &&
          (arg = (void *)c1(), arg != (void *)0x0))
      {
        tl_zbTaskPost(zdo_manyToOneRouteDisc, arg);
      }
    }
  }
  else
  {
    zb_buf_free(in_r0);
  }
  return;
}

void zdo_nwkAuthTimeoutStart(zb_buf_t *param_1)

{
  if (g_zdo_nwk_manager._4_4_ == (ev_timer_event_t *)0x0)
  {
    g_zdo_nwk_manager._20_4_ = param_1;
    g_zdo_nwk_manager._4_4_ =
        ev_timer_taskPost(zdo_auth_check_timer_cb, param_1, TRANSPORT_NETWORK_KEY_WAIT_TIME);
  }
  else
  {
    zb_buf_free(param_1);
  }
  return;
}

zdo_status_t zdo_nwkRejoinStart(u32 scanChannels, u8 scanDuration)

{
  zdo_status_t zVar1;
  int iVar2;

  zVar1 = ZDO_INVALID_REQUEST;
  if (g_zdo_nwk_manager[37] == '\0')
  {
    iVar2 = memcmp(aps_ib.aps_use_ext_panid, &g_zero_addr, 8);
    if ((iVar2 != 0) || (iVar2 = memcmp(g_zbInfo.nwkNib.extPANId, &g_zero_addr, 8), iVar2 != 0))
    {
      g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xfb;
      g_zdo_nwk_manager._24_4_ = scanChannels;
      g_zdo_nwk_manager[33] = scanDuration;
      zVar1 = zdo_nwkRejoinReqSend();
    }
  }
  return zVar1;
}

undefined4 zdo_selfLeaveProcessCb(int param_1)

{
  int extraout_r0;

  g_zbNwkCtx._45_1_ = g_zbNwkCtx._45_1_ & 0xfb;
  g_zdo_nwk_manager[36] = 0;
  if (param_1 != 0)
  {
    zdo_nwkRejoinStart(1 << (uint)g_zbInfo.macPib.phyChannelCur,
                       zdo_cfg_attributes.config_nwk_scan_duration);
    return 0xfffffffe;
  }
  nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter);
  nv_resetToFactoryNew();
  zb_reset();
  if (zdoTouchLinkCb == (int *)0x0)
  {
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf0;
  }
  else
  {
    if (zdoTouchLinkCb[1] == 0)
    {
      g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf0;
    }
    else
    {
      zdo_nwkRejoinWithBackOffStop();
      g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf0;
      if (zdoTouchLinkCb == (int *)0x0)
        goto LAB_0002403c;
    }
    if ((*zdoTouchLinkCb != 0) && (zdo_nwkRejoinWithBackOffStop(), extraout_r0 != 0))
    {
      return 0xfffffffe;
    }
  }
LAB_0002403c:
  if ((zdoAppIndCbLst != 0) && (*(int *)(zdoAppIndCbLst + 0x10) != 0))
  {
    zdo_nwkRejoinWithBackOffStop();
  }
  return 0xfffffffe;
}

void zdo_nwkRejoinWithBackOffStop(void)

{
  code *in_r3;

  (*in_r3)();
  if (g_zdo_nwk_manager._12_4_ != 0)
  {
    ev_timer_taskCancel((ev_timer_event_t **)(g_zdo_nwk_manager + 0xc));
  }
  g_zdo_nwk_manager[32] = 0;
  g_zdo_nwk_manager._30_2_ = 0;
  g_zdo_nwk_manager._28_2_ = 0;
  return;
}

void zdo_nwkRejoinWithBackOffStop(void)

{
  if (g_zdo_nwk_manager._12_4_ != 0)
  {
    ev_timer_taskCancel((ev_timer_event_t **)(g_zdo_nwk_manager + 0xc));
  }
  g_zdo_nwk_manager[32] = 0;
  g_zdo_nwk_manager._30_2_ = 0;
  g_zdo_nwk_manager._28_2_ = 0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_leave_confirm_cb(void)

{
  byte bVar1;
  zb_buf_t *in_r0;
  int iVar2;
  undefined auStack_1c[16];

  memcpy(auStack_1c, in_r0, 9);
  bVar1 = (in_r0->hdr).field_0x3;
  zb_buf_free(in_r0);
  iVar2 = memcmp(auStack_1c, &g_zero_addr, 8);
  if ((iVar2 == 0) || (iVar2 = memcmp(auStack_1c, g_zbInfo.macPib.extAddress, 8), iVar2 == 0))
  {
    zdo_nwkRejoinWithBackOffStop();
    g_zbNwkCtx._47_1_ = g_zbNwkCtx._47_1_ & 0xf0 | 2;
    tl_zbNwkLinkStatusStop();
    iVar2 = FUN_0000162c(g_zbInfo.nwkNib.passiveAckTimeout, 1000);
    ev_timer_taskPost(zdo_selfLeaveProcessCb, (void *)(((uint)bVar1 << 0x1d) >> 0x1f), iVar2 << 2);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_join_confirm(void)

{
  zb_buf_t *in_r0;
  u8 uVar1;

  if (g_zdo_nwk_manager[37] == '\x05')
  {
    uVar1 = in_r0->buf[2];
    (in_r0->hdr).field_0x3 = (in_r0->hdr).field_0x3 | 0x20;
    if (uVar1 == '\0')
    {
      zdo_nwkRejoinWithBackOffStop();
      if ((-1 < (int)((uint)aps_ib._18_1_ << 0x1e)) && ((ss_ib._62_1_ & 7) != 0))
      {
      LAB_00024208:
        zdo_nwkAuthTimeoutStart(in_r0);
        FUN_00024188();
        return;
      }
    LAB_000241fe:
      zdo_startDeviceCnf(in_r0, 0);
      FUN_00024188();
      return;
    }
    if (g_zdo_nwk_manager._12_4_ != 0)
    {
      g_zdo_nwk_manager[37] = 0;
      zb_buf_free(in_r0);
      return;
    }
  }
  else if (g_zdo_nwk_manager[37] == '\x06')
  {
    uVar1 = '\0';
    if (in_r0->buf[2] != '\0')
    {
      uVar1 = '`';
    }
  }
  else
  {
    if (g_zdo_nwk_manager[37] != '\x04')
    {
      zb_buf_free(in_r0);
      return;
    }
    uVar1 = in_r0->buf[2];
    if (uVar1 == '\0')
    {
      if ((-1 < (int)((uint)aps_ib._18_1_ << 0x1e)) && ((ss_ib._62_1_ & 7) != 0))
        goto LAB_00024208;
      if ((int)((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1e) < 0)
      {
        zdo_nlme_start_router_req(in_r0);
        FUN_00024188();
        return;
      }
      goto LAB_000241fe;
    }
  }
  zdo_startDeviceCnf(in_r0, uVar1);
  return;
}

void FUN_00024188(void)

{
  return;
}

void FUN_000241a0(void)

{
  undefined4 unaff_r4;
  char in_ZR;

  if (in_ZR == '\0')
  {
    zdo_nwkAuthTimeoutStart(unaff_r4);
    FUN_00024188();
    return;
  }
  if ((int)((uint)(byte)g_zbInfo.nwkNib.capabilityInfo << 0x1e) < 0)
  {
    zdo_nlme_start_router_req(unaff_r4);
    FUN_00024188();
    return;
  }
  zdo_startDeviceCnf(unaff_r4, 0);
  FUN_00024188();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_join_indication(void)

{
  void *in_r0;
  undefined4 local_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  undefined4 uStack_18;
  uint uStack_14;
  undefined uStack_10;

  local_24 = 0;
  uStack_20 = 0;
  uStack_1c = 0;
  uStack_18 = 0;
  uStack_14 = (uint) * (ushort *)((int)in_r0 + 8);
  uStack_14 = uStack_14 | (uint) * (byte *)((int)in_r0 + 0xb) << 0x18;
  uStack_10 = *(undefined *)((int)in_r0 + 0xc);
  memcpy(&uStack_1c, in_r0, 8);
  memcpy(in_r0, &local_24, 0x15);
  ss_zdoChildAuthStart();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_nlme_network_discovery_confirm_cb(void)

{
  byte bVar1;
  u16 uVar2;
  zb_buf_t *in_r0;
  byte bVar3;

  zb_buf_free(in_r0);
  if (g_zdo_nwk_manager[37] == '\x03')
  {
    g_zdo_nwk_manager[37] = '\0';
    if (g_zdo_nwk_manager._16_4_ == 0)
    {
      g_zdo_nwk_manager[34] = '\0';
    }
    else
    {
      bVar3 = g_zdo_nwk_manager[34] + 1;
      g_zdo_nwk_manager[34] = bVar3;
      bVar1 = zdo_af_get_scan_attempts();
      if (bVar3 < bVar1)
      {
        uVar2 = zdo_af_get_nwk_time_btwn_scans();
        g_zdo_nwk_manager._0_4_ = ev_timer_taskPost(zdo_nwkDiscReqTimerCb, (void *)0x0, (uint)uVar2);
        FUN_00024274();
        return;
      }
      g_zdo_nwk_manager[34] = '\0';
      if (g_zdo_nwk_manager._16_4_ != 0)
      {
        zdoMgmtLeaveCmdProcessCb();
        FUN_00024274();
        return;
      }
    }
  }
  return;
}

void FUN_00024274(void)

{
  return;
}

void FUN_00024288(void)

{
  byte bVar1;
  u16 uVar2;
  ev_timer_event_t *peVar3;
  ev_timer_event_t **unaff_r4;
  int unaff_r5;
  undefined unaff_r6;
  uint unaff_r7;

  *(char *)((int)unaff_r4 + unaff_r5) = (char)(unaff_r7 >> 0x18);
  bVar1 = zdo_af_get_scan_attempts();
  if (unaff_r7 >> 0x18 < (uint)bVar1)
  {
    uVar2 = zdo_af_get_nwk_time_btwn_scans();
    peVar3 = ev_timer_taskPost(zdo_nwkDiscReqTimerCb, (void *)0x0, (uint)uVar2);
    *unaff_r4 = peVar3;
    FUN_00024274();
    return;
  }
  peVar3 = unaff_r4[4];
  *(undefined *)((int)unaff_r4 + unaff_r5) = unaff_r6;
  if (peVar3 != (ev_timer_event_t *)0x0)
  {
    zdoMgmtLeaveCmdProcessCb();
    FUN_00024274();
    return;
  }
  return;
}

undefined4 zdoMgmtLeaveCmdProcessCb(void)

{
  void *arg;
  code *in_r3;

  arg = (void *)(*in_r3)();
  tl_zbPrimitivePost('\x03', 0x82, arg);
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_change_channel_cb(void)

{
  u8 in_r0;

  tl_zbMacChannelSet(in_r0);
  g_zbInfo.nwkNib.txTotal._0_1_ = 0;
  g_zbInfo.nwkNib.txTotal._1_1_ = 0;
  g_zbInfo.nwkNib.txFail._0_1_ = 0;
  g_zbInfo.nwkNib.txFail._1_1_ = 0;
  g_zbInfo.macPib.phyChannelCur = in_r0;
  tl_zbTaskPost(zb_info_save, (void *)0x0);
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_cluster_list_match_process_clone_1(void)

{
  uint in_r0;
  uint uVar1;
  uint uVar2;
  int in_r1;
  uint in_r2;
  byte *in_r3;
  uint uVar3;
  uint uVar4;

  if (in_r0 != 0)
  {
    uVar4 = 0;
    do
    {
      while (true)
      {
        uVar1 = (uVar4 << 0x19) >> 0x18;
        if (in_r2 != 0)
          break;
      LAB_00024380:
        uVar4 = uVar4 + 1 & 0xff;
        if (in_r0 <= uVar4)
        {
          return;
        }
      }
      uVar1 = (uint) * (byte *)(in_r1 + uVar1) + (uint) * (byte *)(in_r1 + uVar1 + 1) * 0x100;
      if (((uint)in_r3[1] * 0x100 + (uint)*in_r3) * 0x10000 + uVar1 * -0x10000 != 0)
      {
        uVar3 = 0;
        uVar2 = 2;
        while (uVar3 = uVar3 + 1 & 0xff, uVar3 < in_r2)
        {
          if ((uVar1 & 0xffff) == ((uint)in_r3[uVar2] + (uint)in_r3[uVar2 + 1] * 0x100 & 0xffff))
            goto LAB_00024394;
          uVar2 = uVar2 + 2 & 0xff;
        }
        goto LAB_00024380;
      }
    LAB_00024394:
      *(short *)(ed_binding_ctx + (ed_binding_ctx[48] + 8) * 2) = (short)(uVar1 * 0x10000 >> 0x10);
      ed_binding_ctx[48] = ed_binding_ctx[48] + 1;
      uVar4 = uVar4 + 1 & 0xff;
    } while (uVar4 < in_r0);
  }
  return;
}

void zdp_cb_process(u16 tsn, void *buf)

{
  char *pcVar1;
  int iVar2;
  int iVar3;

  pcVar1 = zdp_cbl + 7;
  iVar2 = 0;
  while ((*pcVar1 == '\0' || (iVar3 = iVar2 * 8, *(u16 *)(zdp_cbl + iVar3 + 4) != tsn)))
  {
    iVar2 = iVar2 + 1;
    pcVar1 = pcVar1 + 8;
    if (iVar2 == 4)
    {
      return;
    }
  }
  if (*(int *)(zdp_cbl + iVar3) != 0)
  {
    _zdo_send_req();
  }
  zdp_cbl[iVar3 + 7] = 0;
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void _zdo_send_req(void)

{
  u16 clusterId;
  u8 **ppuVar1;
  ushort uVar2;
  uint uVar3;
  u8 *puVar4;
  code *in_r3;
  int iVar5;
  uint uStack_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined2 uStack_1c;
  u8 uStack_19;

  ppuVar1 = (u8 **)(*in_r3)();
  uStack_19 = '\0';
  clusterId = *(u16 *)(ppuVar1 + 4);
  uStack_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  uStack_1c = 4;
  if (*(char *)((int)ppuVar1 + 0x13) == '\0')
  {
    uStack_20 = 0x20000;
    uStack_2c = (uint) * (ushort *)(ppuVar1 + 2);
  }
  else if (*(char *)((int)ppuVar1 + 0x13) == '\x01')
  {
    uStack_20 = 0x20000;
    memcpy((epInfo_t *)&uStack_2c, ppuVar1 + 2, 8);
  }
  if (clusterId == 0x13)
  {
    puVar4 = *ppuVar1;
    uVar2 = (ushort)puVar4[2] * 0x100 + (ushort)puVar4[1];
    if (g_zbInfo.nwkNib.nwkAddr != uVar2)
    {
      uStack_24 = uStack_24 & 0xffff | (uint)uVar2 << 0x10;
      uStack_20 = CONCAT22((short)((uint)uStack_20 >> 0x10), 1);
    }
  }
  else
  {
    puVar4 = *ppuVar1;
  }
  af_dataSend('\0', (epInfo_t *)&uStack_2c, clusterId, (ushort) * (byte *)((int)ppuVar1 + 0x12), puVar4,
              &uStack_19);
  puVar4 = ppuVar1[5];
  if (puVar4 != (u8 *)0x0)
  {
    uVar3 = (uint)zdpCblWptr;
    zdpCblWptr = zdpCblWptr + 1;
    iVar5 = (uVar3 & 3) * 8;
    *(ushort *)(zdp_cbl + iVar5 + 4) = (ushort) * (byte *)(ppuVar1 + 6);
    *(u8 **)(zdp_cbl + iVar5) = puVar4;
    zdp_cbl[iVar5 + 6] = 1;
    zdp_cbl[iVar5 + 7] = 1;
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_send_req(zdo_zdp_req_t *req)

{
  u16 clusterId;
  zdo_callback p_Var1;
  ushort uVar2;
  uint uVar3;
  u8 *cmdPld;
  int iVar4;
  uint local_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined2 local_1c;
  u8 local_19;

  local_19 = '\0';
  clusterId = req->cluster_id;
  local_2c = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  uStack_20 = 0;
  local_1c = 4;
  if (req->dst_addr_mode == SHORT_ADDR_MODE)
  {
    uStack_20 = 0x20000;
    local_2c = (uint)(req->field_2).dst_nwk_addr;
  }
  else if (req->dst_addr_mode == EXT_ADDR_MODE)
  {
    uStack_20 = 0x20000;
    memcpy((epInfo_t *)&local_2c, &req->field_2, 8);
  }
  if (clusterId == 0x13)
  {
    cmdPld = req->zdu;
    uVar2 = (ushort)cmdPld[2] * 0x100 + (ushort)cmdPld[1];
    if (g_zbInfo.nwkNib.nwkAddr != uVar2)
    {
      uStack_24 = uStack_24 & 0xffff | (uint)uVar2 << 0x10;
      uStack_20 = CONCAT22((short)((uint)uStack_20 >> 0x10), 1);
    }
  }
  else
  {
    cmdPld = req->zdu;
  }
  af_dataSend('\0', (epInfo_t *)&local_2c, clusterId, (ushort)req->zduLen, cmdPld, &local_19);
  p_Var1 = req->zdoRspReceivedIndCb;
  if (p_Var1 != ll_reset)
  {
    uVar3 = (uint)zdpCblWptr;
    zdpCblWptr = zdpCblWptr + 1;
    iVar4 = (uVar3 & 3) * 8;
    *(ushort *)(zdp_cbl + iVar4 + 4) = (ushort)req->zdpSeqNum;
    *(zdo_callback *)(zdp_cbl + iVar4) = p_Var1;
    zdp_cbl[iVar4 + 6] = 1;
    zdp_cbl[iVar4 + 7] = 1;
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_end_device_bind_resp_send(void)

{
  zb_buf_t *in_r0;
  u8 in_r1;
  u8 in_r2;
  ushort in_r3;
  undefined local_38[12];
  undefined4 uStack_2c;
  uint uStack_28;
  zdo_callback p_Stack_24;
  u8 local_20;

  local_38._0_4_ = (u8 *)0x0;
  local_38._4_4_ = (zb_buf_t *)0x0;
  local_38._8_4_ = 0;
  uStack_2c = 0;
  p_Stack_24 = ll_reset;
  local_20 = '\0';
  uStack_28 = 0x20000;
  local_38._0_4_ = (u8 *)tl_bufInitalloc(in_r0, '\x02');
  *local_38._0_4_ = in_r2;
  local_38._0_4_[1] = in_r1;
  p_Stack_24 = ll_reset;
  uStack_28 = (uint)((uint3)uStack_28 & 0xff0000 | 0x8020);
  local_38._8_4_ = local_38._8_4_ & 0xffff0000 | (uint)in_r3;
  local_38._4_4_ = in_r0;
  zdo_send_req((zdo_zdp_req_t *)local_38);
  zb_buf_free(local_38._4_4_);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_end_device_bind_timeout_cb(void)

{
  zdo_end_device_bind_resp_send();
  ed_binding_ctx._0_4_ = 0;
  ed_binding_ctx._4_4_ = 0;
  ed_binding_ctx._8_4_ = 0;
  ed_binding_ctx._12_4_ = 0;
  ed_binding_ctx._16_4_ = 0;
  ed_binding_ctx._20_4_ = 0;
  ed_binding_ctx._24_4_ = 0;
  ed_binding_ctx._28_4_ = 0;
  ed_binding_ctx._32_4_ = 0;
  ed_binding_ctx._36_4_ = 0;
  ed_binding_ctx._40_4_ = 0;
  ed_binding_ctx._44_4_ = 0;
  ed_binding_ctx._48_2_ = 0;
  zdo_bind_timer_event = 0;
  return 0xfffffffe;
}

// WARNING: Could not reconcile some variable overlaps

undefined4 zdo_ieeeAddrReqDelayCb(zb_buf_t *param_1)

{
  u8 uVar1;
  byte bVar2;
  byte bVar3;
  device_type_t dVar4;
  byte bVar5;
  u16 uVar6;
  tl_zb_normal_neighbor_entry_t *ptVar7;
  u8 *puVar8;
  int iVar9;
  u8 size;
  uint uVar10;
  uint uVar11;
  char cVar12;
  u8 *puVar13;
  u8 uVar14;
  undefined4 in_stack_ffffffac;
  uint uVar15;
  undefined4 in_stack_ffffffb0;
  uint uVar16;
  undefined auStack_4c[12];
  undefined4 uStack_40;
  uint uStack_3c;
  zdo_callback p_Stack_38;
  u8 local_34;
  u16 auStack_30[6];
  uint extraout_r0;

  puVar8 = *(u8 **)(param_1->buf + 0xc);
  uVar1 = *puVar8;
  uVar6 = *(u16 *)(puVar8 + 1);
  bVar2 = puVar8[3];
  bVar3 = puVar8[4];
  uVar10 = (uint)bVar3;
  auStack_4c._0_4_ = (u8 *)0x0;
  auStack_4c._4_4_ = (zb_buf_t *)0x0;
  auStack_4c._8_4_ = 0;
  uStack_40 = 0;
  uStack_3c = 0;
  p_Stack_38 = ll_reset;
  local_34 = '\0';
  memcpy(auStack_30, &g_invalid_addr, 8);
  ptVar7 = nwk_neTblGetByShortAddr(uVar6);
  if ((g_zbInfo.nwkNib.nwkAddr == uVar6) ||
      ((ptVar7 != (tl_zb_normal_neighbor_entry_t *)0x0 && ((ptVar7->field_0x1e & 0xe) == 4))))
  {
    if (1 < bVar2)
    {
      uVar14 = 0x80;
      if ((*(ushort *)(param_1->buf + 2) & 0xfff8) == 0xfff8)
        goto LAB_00024754;
    LAB_0002471e:
      tl_zbExtAddrByShortAddr(uVar6, (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac), auStack_30);
      size = '\x1a';
      uVar15 = 0;
      uVar16 = 0;
      goto LAB_00024674;
    }
    uVar14 = '\0';
    if (bVar2 != 0)
      goto LAB_0002473e;
  LAB_00024666:
    if (uVar14 == '\0')
    {
      tl_zbExtAddrByShortAddr(uVar6, (addrExt_t)CONCAT44(in_stack_ffffffb0, in_stack_ffffffac), auStack_30);
      size = '\x1a';
      uVar15 = 0;
      uVar16 = 0;
      goto LAB_00024674;
    }
  }
  else
  {
    uVar14 = 0x81;
    if ((*(ushort *)(param_1->buf + 2) & 0xfff8) == 0xfff8)
    {
    LAB_00024754:
      zb_buf_free(param_1);
      return 0xfffffffe;
    }
    if (bVar2 == 0)
      goto LAB_00024666;
  LAB_0002473e:
    if (bVar2 != 1)
      goto LAB_0002471e;
    if (uVar14 != '\0')
    {
      size = '\x1a';
      uVar15 = 0;
      uVar16 = 0;
      goto LAB_00024674;
    }
    memcpy(auStack_30, g_zbInfo.macPib.extAddress, 8);
    uVar6 = g_zbInfo.macPib.shortAddress;
    dVar4 = af_nodeDevTypeGet();
    if ((dVar4 == DEVICE_TYPE_COORDINATOR) ||
        (dVar4 = af_nodeDevTypeGet(), dVar4 == DEVICE_TYPE_ROUTER))
    {
      bVar5 = tl_zbNeighborTableChildEDNumGet();
      extraout_r0 = (uint)bVar5;
      uVar16 = extraout_r0;
      if (extraout_r0 == 0)
      {
        size = '\x1a';
        uVar15 = 0;
      }
      else if (uVar10 < extraout_r0)
      {
        uVar15 = extraout_r0 - uVar10 & 0xff;
        if (uVar15 * 2 < 0x1f)
        {
          size = (char)(uVar15 * 2) + '\x1a';
        }
        else
        {
          size = '9';
          uVar15 = 0xf;
        }
      }
      else
      {
        size = '\x1a';
        uVar15 = 0;
      }
      goto LAB_00024674;
    }
  }
  size = '\x1a';
  uVar15 = 0;
  uVar16 = 0;
LAB_00024674:
  puVar8 = (u8 *)tl_bufInitalloc(param_1, size);
  *puVar8 = uVar1;
  puVar8[1] = uVar14;
  auStack_4c._0_4_ = puVar8;
  memcpy(puVar8 + 2, auStack_30, 8);
  puVar8[10] = (u8)uVar6;
  puVar8[0xb] = (u8)(uVar6 >> 8);
  cVar12 = (char)puVar8 + '\f';
  dVar4 = af_nodeDevTypeGet();
  if ((((dVar4 == DEVICE_TYPE_COORDINATOR) ||
        (dVar4 = af_nodeDevTypeGet(), dVar4 == DEVICE_TYPE_ROUTER)) &&
       (uVar14 == '\0')) &&
      (bVar2 == 1))
  {
    if (uVar16 == 0)
    {
      puVar8[0xc] = '\0';
      cVar12 = (char)puVar8 + '\r';
    }
    else
    {
      puVar8[0xd] = bVar3;
      puVar13 = puVar8 + 0xe;
      iVar9 = tl_zbNeighborTabSearchForChildEndDev();
      uVar16 = 0;
      if (iVar9 != 0)
      {
        uVar11 = 0;
        do
        {
          uVar11 = uVar11 + 1 & 0xff;
          if (uVar10 <= uVar11)
          {
            uVar6 = tl_zbshortAddrByIdx(*(u16 *)(iVar9 + 0x16));
            *puVar13 = (u8)uVar6;
            uVar6 = tl_zbshortAddrByIdx(*(u16 *)(iVar9 + 0x16));
            puVar13[1] = (u8)((uint)uVar6 >> 8);
            puVar13 = puVar13 + 2;
            uVar16 = uVar16 + 1 & 0xff;
          }
        } while ((uVar16 < uVar15) && (iVar9 = tl_zbNeighborTabSearchForChildEndDev(), iVar9 != 0));
      }
      cVar12 = (char)puVar13;
      puVar8[0xc] = (u8)uVar16;
    }
  }
  p_Stack_38 = ll_reset;
  uStack_3c = (uint)CONCAT12(cVar12 - (char)auStack_4c._0_4_, 0x8001);
  auStack_4c._8_4_ = auStack_4c._8_4_ & 0xffff0000 | (uint) * (ushort *)(param_1->buf + 0x14);
  auStack_4c._4_4_ = param_1;
  zdo_send_req((zdo_zdp_req_t *)auStack_4c);
  zb_buf_free(auStack_4c._4_4_);
  return 0xfffffffe;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_nwkAddrReqDelayCb(void)

{
  device_type_t dVar1;
  byte bVar2;
  u16 uVar3;
  zb_buf_t *in_r0;
  tl_zb_normal_neighbor_entry_t *ptVar4;
  int iVar5;
  undefined *puVar6;
  u8 size;
  uint uVar7;
  undefined *puVar8;
  char cVar9;
  undefined uVar10;
  uint in_stack_ffffffa4;
  uint uVar11;
  u8 *puVar12;
  undefined4 local_3c;
  undefined4 uStack_38;
  byte bStack_34;
  byte bStack_33;
  undefined4 local_30;
  undefined4 uStack_2c;
  u16 local_26;
  uint extraout_r0;

  uVar10 = **(undefined **)(in_r0->buf + 0xc);
  memcpy(&local_3c, *(undefined **)(in_r0->buf + 0xc) + 1, 10);
  puVar12 = (u8 *)0x0;
  local_26 = 0xfffe;
  ptVar4 = nwk_neTblGetByExtAddr((addrExt_t)(ulonglong)in_stack_ffffffa4);
  iVar5 = memcmp(&local_3c, g_zbInfo.macPib.extAddress, 8);
  if ((iVar5 == 0) ||
      ((ptVar4 != (tl_zb_normal_neighbor_entry_t *)0x0 && ((ptVar4->field_0x1e & 0xe) == 4))))
  {
    if (bStack_34 < 2)
    {
      cVar9 = '\0';
      goto LAB_000248f0;
    }
    if ((*(ushort *)(in_r0->buf + 2) & 0xfff8) == 0xfff8)
      goto LAB_00024ad4;
    cVar9 = -0x80;
  }
  else
  {
    if ((*(ushort *)(in_r0->buf + 2) & 0xfff8) == 0xfff8)
    {
    LAB_00024ad4:
      zb_buf_free(in_r0);
      return 0xfffffffe;
    }
    cVar9 = -0x7f;
  LAB_000248f0:
    local_30 = uStack_38;
    uStack_2c = local_3c;
    if (bStack_34 == 0)
    {
      if (cVar9 == '\0')
      {
        tl_zbShortAddrByExtAddr(&local_26, (addrExt_t)CONCAT44(puVar12, in_stack_ffffffa4), (u16 *)&local_3c);
        size = '\x1a';
        uVar7 = 0;
        uVar11 = 0;
      }
      else
      {
        size = '\x1a';
        uVar7 = 0;
        uVar11 = 0;
      }
      goto LAB_00024910;
    }
  }
  uStack_2c = local_3c;
  local_30 = uStack_38;
  if (bStack_34 == 1)
  {
    if (cVar9 == '\0')
    {
      memcpy(&local_30, g_zbInfo.macPib.extAddress, 8);
      local_26 = g_zbInfo.macPib.shortAddress;
      dVar1 = af_nodeDevTypeGet();
      if ((dVar1 == DEVICE_TYPE_COORDINATOR) ||
          (dVar1 = af_nodeDevTypeGet(), dVar1 == DEVICE_TYPE_ROUTER))
      {
        bVar2 = tl_zbNeighborTableChildEDNumGet();
        extraout_r0 = (uint)bVar2;
        uVar11 = extraout_r0;
        if (extraout_r0 == 0)
        {
          size = '\x1a';
          uVar7 = 0;
        }
        else if (bStack_33 < extraout_r0)
        {
          uVar7 = extraout_r0 - bStack_33 & 0xff;
          if (uVar7 * 2 < 0x1f)
          {
            size = (char)(uVar7 * 2) + '\x1a';
          }
          else
          {
            size = '9';
            uVar7 = 0xf;
          }
        }
        else
        {
          size = '\x1a';
          uVar7 = 0;
        }
      }
      else
      {
        size = '\x1a';
        uVar7 = 0;
        uVar11 = 0;
      }
    }
    else
    {
      size = '\x1a';
      uVar7 = 0;
      uVar11 = 0;
    }
  }
  else
  {
    tl_zbShortAddrByExtAddr(&local_26, (addrExt_t)CONCAT44(puVar12, in_stack_ffffffa4), (u16 *)&local_3c);
    size = '\x1a';
    uVar7 = 0;
    uVar11 = 0;
  }
LAB_00024910:
  puVar6 = (undefined *)tl_bufInitalloc(in_r0, size);
  *puVar6 = uVar10;
  puVar6[1] = cVar9;
  memcpy(puVar6 + 2, &local_30, 8);
  puVar6[10] = (char)local_26;
  puVar6[0xb] = (char)(local_26 >> 8);
  dVar1 = af_nodeDevTypeGet();
  if ((((dVar1 == DEVICE_TYPE_COORDINATOR) ||
        (dVar1 = af_nodeDevTypeGet(), dVar1 == DEVICE_TYPE_ROUTER)) &&
       (cVar9 == '\0')) &&
      (bStack_34 == 1))
  {
    if (uVar11 == 0)
    {
      puVar6[0xc] = 0;
    }
    else
    {
      puVar6[0xd] = bStack_33;
      puVar8 = puVar6 + 0xe;
      iVar5 = tl_zbNeighborTabSearchForChildEndDev();
      uVar11 = 0;
      uVar10 = 0;
      if (iVar5 != 0)
      {
        bVar2 = 0;
        do
        {
          bVar2 = bVar2 + 1;
          if (bStack_33 <= bVar2)
          {
            uVar3 = tl_zbshortAddrByIdx(*(u16 *)(iVar5 + 0x16));
            *puVar8 = (char)uVar3;
            uVar3 = tl_zbshortAddrByIdx(*(u16 *)(iVar5 + 0x16));
            puVar8[1] = (char)((uint)uVar3 >> 8);
            puVar8 = puVar8 + 2;
            uVar11 = uVar11 + 1 & 0xff;
          }
          uVar10 = (undefined)uVar11;
        } while ((uVar11 < uVar7) && (iVar5 = tl_zbNeighborTabSearchForChildEndDev(), iVar5 != 0));
      }
      puVar6[0xc] = uVar10;
    }
  }
  zdo_send_req((zdo_zdp_req_t *)&stack0xffffffa8);
  zb_buf_free(in_r0);
  return 0xfffffffe;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_parentAnnounceIndicateDelay(void)

{
  byte bVar1;
  zb_buf_t *in_r0;
  u8 *pBuf;
  zb_buf_t *p;
  u8 *puVar2;
  u8 *puVar3;
  u8 *out;
  int iVar4;
  u8 *m2;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  u8 *puVar9;
  undefined local_50[12];
  undefined4 uStack_44;
  uint uStack_40;
  zdo_callback p_Stack_3c;
  u8 local_38;
  undefined auStack_34[8];
  uint local_2c;
  undefined uStack_28;

  puVar9 = *(u8 **)(in_r0->buf + 0xc);
  uStack_28 = 0;
  puVar3 = puVar9 + 1;
  bVar1 = puVar9[1];
  uVar5 = (uint)bVar1;
  local_2c = (uint)bVar1;
  iVar4 = (int)(char)bVar1;
  if (10 < iVar4)
    goto LAB_00024cc6;
  local_50._0_4_ = (u8 *)0x0;
  local_50._4_4_ = (zb_buf_t *)0x0;
  local_50._8_4_ = 0;
  uStack_44 = 0;
  uStack_40 = 0;
  p_Stack_3c = ll_reset;
  local_38 = '\0';
  pBuf = ev_buf_allocate((u16)((uint)(iVar4 << 0x13) >> 0x10));
  if (pBuf == (u8 *)0x0)
    goto LAB_00024ca8;
  memcpy(pBuf, puVar9 + 2, iVar4 << 3);
  p = (zb_buf_t *)c1();
  if (p == (zb_buf_t *)0x0)
  {
    ev_buf_free(pBuf);
    zb_buf_free(in_r0);
    return 0xfffffffe;
  }
  puVar2 = (u8 *)tl_bufInitalloc(p, 'K');
  *puVar2 = *puVar9;
  puVar2[1] = '\0';
  local_50._0_4_ = puVar2;
  if (0 < iVar4)
  {
    out = puVar2 + 3;
    uVar8 = 0;
    uVar7 = 0;
    m2 = pBuf;
    do
    {
      iVar4 = tl_zbNeighborTabSearchForChildEndDev();
      while (iVar4 != 0)
      {
        tl_zbExtAddrByIdx(*(u16 *)(iVar4 + 0x16), (addrExt_t)CONCAT44(out, puVar9));
        iVar4 = memcmp(auStack_34, m2, 8);
        if (iVar4 == 0)
        {
          uVar8 = uVar8 + 1 & 0xff;
          if (uVar7 < 9)
          {
            uVar7 = uVar7 + 1 & 0xff;
            memcpy(out, auStack_34, 8);
            out = out + 8;
          }
          if (uVar7 < uVar8)
          {
            *puVar3 = (u8)(uVar8 - uVar7);
            memcpy(puVar9 + (uVar8 - uVar7) * 8 + 2, auStack_34, 8);
          }
          break;
        }
        iVar4 = tl_zbNeighborTabSearchForChildEndDev();
      }
      uVar6 = uVar5 - 1;
      uVar5 = uVar6 & 0xff;
      if ((int)(uVar6 * 0x1000000) < 1)
        goto LAB_00024c50;
      m2 = m2 + 8;
    } while (true);
  }
  puVar2[2] = '\0';
  ev_buf_free(pBuf);
  goto LAB_00024cbe;
LAB_00024c50:
  puVar2[2] = (u8)uVar7;
  ev_buf_free(pBuf);
  if (uVar7 != 0)
  {
    p_Stack_3c = ll_reset;
    uStack_40 = (uint)CONCAT12((u8)uVar7 * '\b' + '\x03', 0x801f);
    local_50._8_4_ = local_50._8_4_ & 0xffff0000 | (uint) * (ushort *)(in_r0->buf + 0x14);
    local_50._4_4_ = p;
    zdo_send_req((zdo_zdp_req_t *)local_50);
    zb_buf_free(local_50._4_4_);
    if (uVar7 < uVar8)
    {
      return 0;
    }
  LAB_00024ca8:
    zb_buf_free(in_r0);
    return 0xfffffffe;
  }
LAB_00024cbe:
  zb_buf_free(in_r0);
  in_r0 = p;
LAB_00024cc6:
  zb_buf_free(in_r0);
  return 0xfffffffe;
}

undefined4 zdp_data_send(u32 *param_1, byte param_2, zdo_zdp_req_t *param_3)

{
  u8 uVar1;
  u8 uVar2;
  byte bVar3;
  u8 *pBuf;
  undefined4 uVar4;
  u8 *out;

  pBuf = ev_buf_allocate((ushort)param_2);
  uVar1 = zdp_txSeqNo;
  uVar4 = 0x8a;
  if (pBuf != (u8 *)0x0)
  {
    uVar2 = zdp_txSeqNo + '\x01';
    param_3->zdpSeqNum = zdp_txSeqNo;
    zdp_txSeqNo = uVar2;
    *(char *)&param_3->zdu = (char)pBuf;
    *(char *)((int)&param_3->zdu + 1) = (char)((uint)pBuf >> 8);
    *(char *)((int)&param_3->zdu + 2) = (char)((uint)pBuf >> 0x10);
    *(char *)((int)&param_3->zdu + 3) = (char)((uint)pBuf >> 0x18);
    param_3->zduLen = param_2;
    *pBuf = uVar1;
    if (param_3->cluster_id == 6)
    {
      memcpy(pBuf + 1, param_1, 4);
      pBuf[5] = *(u8 *)(param_1 + 1);
      out = pBuf + 6;
      memcpy(out, (void *)((int)param_1 + 6), (uint) * (byte *)(param_1 + 1) << 1);
      bVar3 = *(byte *)(param_1 + 1);
      out[(uint)bVar3 * 2] = *(u8 *)((int)param_1 + 5);
      memcpy(out + (uint)bVar3 * 2 + 1,
             (void *)((uint) * (byte *)(param_1 + 1) * 2 + (int)(void *)((int)param_1 + 6)),
             (uint) * (byte *)((int)param_1 + 5) << 1);
    }
    else if (param_3->cluster_id == 0x38)
    {
      memcpy(pBuf + 1, param_1, 5);
      bVar3 = *(byte *)(param_1 + 1);
      if (bVar3 < 6)
      {
        pBuf[6] = *(u8 *)((int)param_1 + 5);
      }
      else if (bVar3 == 0xff)
      {
        g_zbInfo.nwkNib.updateId = g_zbInfo.nwkNib.updateId + '\x01';
        pBuf[6] = g_zbInfo.nwkNib.updateId;
        pBuf[7] = *(u8 *)((int)param_1 + 6);
        pBuf[8] = *(u8 *)((int)param_1 + 7);
      }
      else if (bVar3 == 0xfe)
      {
        bVar3 = zdo_channel_page2num(*param_1);
        g_zbInfo.nwkNib.updateId = g_zbInfo.nwkNib.updateId + '\x01';
        pBuf[6] = g_zbInfo.nwkNib.updateId;
        ev_timer_taskPost(zdo_change_channel_cb, (void *)(uint)bVar3, 0x1cc);
      }
    }
    else
    {
      memcpy(pBuf + 1, param_1, param_2 - 1);
    }
    zdo_send_req(param_3);
    ev_buf_free(pBuf);
    uVar4 = 0;
  }
  return uVar4;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

zb_buf_t *zdo_devAnnce(void)

{
  u8 uVar1;
  byte bVar2;
  undefined4 in_r0;
  u8 *puVar3;
  void *in_r1;
  u8 in_r2;
  undefined local_38[10];
  undefined2 uStack_2e;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  zdo_callback p_Stack_24;
  u8 local_20;

  local_38._4_4_ = (zb_buf_t *)c1();
  if (local_38._4_4_ != (zb_buf_t *)0x0)
  {
    local_38._0_4_ = (u8 *)0x0;
    stack0xffffffd0 = 0;
    uStack_2c = 0;
    p_Stack_24 = ll_reset;
    local_20 = '\0';
    uStack_28 = 0xc0000;
    puVar3 = (u8 *)tl_bufInitalloc(local_38._4_4_, '\f');
    local_20 = zdp_txSeqNo;
    uVar1 = zdp_txSeqNo + '\x01';
    *puVar3 = zdp_txSeqNo;
    zdp_txSeqNo = uVar1;
    puVar3[1] = (u8)in_r0;
    puVar3[2] = (u8)((uint)in_r0 >> 8);
    local_38._0_4_ = puVar3;
    memcpy(puVar3 + 3, in_r1, 8);
    puVar3[0xb] = in_r2;
    p_Stack_24 = ll_reset;
    uStack_28 = CONCAT22(uStack_28._2_2_, 0x13);
    uStack_28 = uStack_28 & 0xffffff;
    stack0xffffffd0 = CONCAT22(uStack_2e, 0xfffc);
    zdo_send_req((zdo_zdp_req_t *)local_38);
    bVar2 = zb_buf_free(local_38._4_4_);
    local_38._4_4_ = (zb_buf_t *)(uint)bVar2;
  }
  return local_38._4_4_;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_device_announce_send(void)

{
  af_nodeMacCapabilityGet();
  zdo_devAnnce();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_apsParentAnnceTimerStart(void)

{
  char cVar1;
  u32 uVar2;

  uVar2 = drv_u32Rand();
  cVar1 = FUN_00001628(uVar2 & 0xff, 10);
  aps_ib.aps_parent_announce_timer = cVar1 + '\n';
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_parent_announce_send(void)

{
  byte bVar1;
  zb_buf_t *p;
  u8 *puVar2;
  u8 uVar3;
  uint uVar4;
  uint uVar5;
  u8 *puVar6;

  uVar5 = (uint)remainChildListNum_8696;
  if (uVar5 == 0)
  {
    bVar1 = tl_zbNeighborTableChildEDNumGet();
    uVar5 = (uint)bVar1;
  }
  if (uVar5 < 10)
  {
    remainChildListNum_8696 = '\0';
    if (uVar5 == 0)
    {
      remainChildListNum_8696 = 0;
      return;
    }
  }
  else
  {
    remainChildListNum_8696 = (char)uVar5 + -10;
    uVar5 = 10;
  }
  p = (zb_buf_t *)c1();
  if (p != (zb_buf_t *)0x0)
  {
    puVar2 = (u8 *)tl_bufInitalloc(p, (u8)(uVar5 * 0x8000000 + 0x2000000 >> 0x18));
    uVar3 = zdp_txSeqNo + '\x01';
    *puVar2 = zdp_txSeqNo;
    zdp_txSeqNo = uVar3;
    puVar2[1] = (u8)uVar5;
    uVar4 = 0;
    puVar6 = puVar2;
    do
    {
      uVar3 = (u8)uVar4;
      ent_8695 = tl_zbNeighborTabSearchForChildEndDev();
      if (ent_8695 == 0)
      {
        remainChildListNum_8696 = '\0';
        break;
      }
      tl_zbExtAddrByIdx(*(u16 *)(ent_8695 + 0x16), (addrExt_t)CONCAT44(p, puVar6));
      uVar4 = uVar4 + 1 & 0xff;
      uVar3 = (u8)uVar4;
    } while (uVar4 < uVar5);
    puVar2[1] = uVar3;
    zdo_send_req((zdo_zdp_req_t *)&stack0xffffffc4);
    zb_buf_free(p);
    if (remainChildListNum_8696 != '\0')
    {
      zdo_apsParentAnnceTimerStart();
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void apsParentAnncePeriodic(void)

{
  if ((aps_ib.aps_parent_announce_timer != '\0') &&
      (aps_ib.aps_parent_announce_timer = aps_ib.aps_parent_announce_timer + 0xff,
       aps_ib.aps_parent_announce_timer == '\0'))
  {
    zdo_parent_announce_send();
  }
  return;
}

void zdo_deviceAnnounceIndicate(void *buf)

{
  bool bVar1;
  u16 uVar2;
  int iVar3;
  tl_zb_normal_neighbor_entry_t *entry;
  undefined in_stack_ffffffcc;
  undefined in_stack_ffffffcd;
  undefined2 in_stack_ffffffce;
  undefined4 in_stack_ffffffd0;
  u16 local_28;
  u16 auStack_26[7];

  memcpy(&local_28, (void *)(*(int *)((int)buf + 0xc) + 1), 0xb);
  bVar1 = tl_zbNwkAddrConflictDetect(buf, local_28,
                                     (addrExt_t)
                                         CONCAT44(in_stack_ffffffd0,
                                                  CONCAT22(in_stack_ffffffce,
                                                           CONCAT11(in_stack_ffffffcd, in_stack_ffffffcc))));
  if (bVar1 != true)
  {
    if ((g_gpDeviceAnnounceCheckCb == ll_reset) || (iVar3 = zdo_dAI_sub(), iVar3 == 0))
    {
      entry = nwk_neTblGetByExtAddr((addrExt_t)
                                        CONCAT44(in_stack_ffffffd0,
                                                 CONCAT22(in_stack_ffffffce,
                                                          CONCAT11(in_stack_ffffffcd, in_stack_ffffffcc))));
      if (((entry != (tl_zb_normal_neighbor_entry_t *)0x0) && ((entry->field_0x1e & 0xe) == 4)) &&
          (*(u16 *)((int)buf + 0x1c) != local_28))
      {
        in_stack_ffffffce = 0;
        in_stack_ffffffd0 = 0;
        uVar2 = tl_zbshortAddrByIdx(entry->addrmapIdx);
        in_stack_ffffffcc = (undefined)uVar2;
        in_stack_ffffffcd = (undefined)(uVar2 >> 8);
        tl_zbExtAddrByIdx(entry->addrmapIdx,
                          (addrExt_t)CONCAT44(in_stack_ffffffd0, CONCAT22(in_stack_ffffffce, uVar2)));
        nwk_nodeAddrInfoDelete();
        tl_zbNeighborTableDelete(entry);
      }
      tl_zbNwkAddrMapAdd(local_28, (addrExt_t)CONCAT44(in_stack_ffffffd0, CONCAT22(in_stack_ffffffce, CONCAT11(in_stack_ffffffcd, in_stack_ffffffcc))),
                         auStack_26);
      nwkRoutingTabEntryDstDel();
      nwkRouteRecTabEntryDstDel();
      if ((int)((uint)g_zbInfo.nwkNib._45_1_ << 0x1b) < 0)
      {
        tl_zbTaskPost(zdo_manyToOneRouteDisc, buf);
      }
      else
      {
        zb_buf_free((zb_buf_t *)buf);
      }
      if ((zdoAppIndCbLst != 0) && (*(int *)(zdoAppIndCbLst + 8) != 0))
      {
        zdo_dAI_sub();
      }
    }
    else
    {
      zb_buf_free((zb_buf_t *)buf);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_dAI_sub(void)

{
  void *arg;
  u32 uVar1;
  code *in_r3;

  arg = (void *)(*in_r3)();
  uVar1 = drv_u32Rand();
  ev_timer_taskPost(zdo_parentAnnounceIndicateDelay, arg, (uVar1 & 0x1f) * 0x32 + 1000);
  return;
}

void zdo_parentAnnounceIndicate(void *buf)

{
  u32 uVar1;

  uVar1 = drv_u32Rand();
  ev_timer_taskPost(zdo_parentAnnounceIndicateDelay, buf, (uVar1 & 0x1f) * 0x32 + 1000);
  return;
}

void zdo_remoteAddrNotify(void *buf)

{
  int iVar1;
  undefined in_stack_ffffffd0;
  char cVar2;
  undefined6 in_stack_ffffffd2;
  u16 auStack_26[8];
  undefined2 local_16;

  iVar1 = *(int *)((int)buf + 0xc);
  cVar2 = *(char *)(iVar1 + 1);
  if (cVar2 == '\0')
  {
    memcpy(&stack0xffffffd2, (void *)(iVar1 + 2), 8);
    memcpy(auStack_26, (void *)(iVar1 + 10), 2);
    local_16 = 0;
    tl_zbNwkAddrMapAdd(auStack_26[0],
                       (addrExt_t)CONCAT62(in_stack_ffffffd2, CONCAT11(cVar2, in_stack_ffffffd0)),
                       (u16 *)&stack0xffffffd2);
  }
  return;
}

void zdo_parentAnnounceNotify(void *buf)

{
  byte bVar1;
  u16 uVar2;
  tl_zb_normal_neighbor_entry_t *entry;
  byte bVar3;
  undefined in_stack_ffffffd0;
  undefined in_stack_ffffffd1;
  undefined6 in_stack_ffffffd2;

  bVar1 = *(byte *)(*(int *)((int)buf + 0xc) + 2);
  if ((*(char *)(*(int *)((int)buf + 0xc) + 1) == '\0') && (bVar1 != 0))
  {
    bVar3 = 0;
    do
    {
      entry = nwk_neTblGetByExtAddr((addrExt_t)
                                        CONCAT62(in_stack_ffffffd2, CONCAT11(in_stack_ffffffd1, in_stack_ffffffd0)));
      if (entry != (tl_zb_normal_neighbor_entry_t *)0x0)
      {
        uVar2 = tl_zbshortAddrByIdx(entry->addrmapIdx);
        in_stack_ffffffd0 = (undefined)uVar2;
        in_stack_ffffffd1 = (undefined)(uVar2 >> 8);
        tl_zbExtAddrByIdx(entry->addrmapIdx, (addrExt_t)CONCAT62(in_stack_ffffffd2, uVar2));
        nwk_nodeAddrInfoDelete();
        tl_zbNeighborTableDelete(entry);
      }
      bVar3 = bVar3 + 1;
    } while (bVar3 < bVar1);
  }
  return;
}

void zdo_nwkAddrIndicate(void *buf)

{
  ev_timer_taskPost(zdo_nwkAddrReqDelayCb, buf, 200);
  return;
}

void zdo_ieeeAddrIndicate(void *buf)

{
  ev_timer_taskPost(zdo_ieeeAddrReqDelayCb, buf, 200);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_descriptorsIndicate(void *buf)

{
  byte ep;
  u8 *puVar1;
  char cVar2;
  device_type_t dVar3;
  u8 uVar4;
  u8 *puVar5;
  af_simple_descriptor_t *sd;
  u8 uVar6;
  short sVar7;
  uint uVar8;
  int iVar9;
  char cVar10;
  undefined local_40[12];
  undefined4 uStack_34;
  uint uStack_30;
  zdo_callback p_Stack_2c;
  u8 local_28;

  puVar1 = *(u8 **)((int)buf + 0xc);
  uVar4 = *puVar1;
  if ((*(ushort *)((int)buf + 2) & 0xfff8) == 0xfff8)
  {
    zb_buf_free((zb_buf_t *)buf);
    return;
  }
  uVar8 = (uint)puVar1[2] * 0x100 + (uint)puVar1[1];
  iVar9 = uVar8 * 0x10000;
  uVar8 = uVar8 & 0xffff;
  local_40._0_4_ = (u8 *)0x0;
  local_40._4_4_ = (zb_buf_t *)0x0;
  local_40._8_4_ = 0;
  uStack_34 = 0;
  uStack_30 = 0;
  p_Stack_2c = ll_reset;
  local_28 = '\0';
  puVar5 = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, '4');
  *puVar5 = uVar4;
  cVar2 = (char)puVar5;
  cVar10 = cVar2 + '\x01';
  local_40._0_4_ = puVar5;
  if (g_zbInfo.nwkNib.nwkAddr == uVar8)
  {
    sVar7 = *(short *)((int)buf + 8);
    uVar4 = (u8)g_zbInfo.nwkNib.nwkAddr;
    uVar6 = (u8)((uint)iVar9 >> 0x18);
    if (sVar7 == 2)
    {
      puVar5[1] = '\0';
      puVar5[2] = uVar4;
      puVar5[3] = uVar6;
      af_nodeDescriptorCopy((node_descriptor_t *)(puVar5 + 4));
      cVar10 = cVar2 + '\x11';
      sVar7 = *(short *)((int)buf + 8);
    }
    else if (sVar7 == 3)
    {
      puVar5[1] = '\0';
      puVar5[2] = uVar4;
      puVar5[3] = uVar6;
      af_powerDescriptorCopy((power_descriptor_t *)(puVar5 + 4));
      cVar10 = cVar2 + '\x06';
      sVar7 = *(short *)((int)buf + 8);
    }
    else if (sVar7 == 4)
    {
      ep = puVar1[3];
      uVar6 = (u8)(g_zbInfo.nwkNib.nwkAddr >> 8);
      if ((ep == 0) || ((ep != 0xf2 && (0xf0 < ep))))
      {
        puVar5[1] = 0x82;
        puVar5[2] = uVar4;
        puVar5[3] = uVar6;
        puVar5[4] = '\0';
      }
      else
      {
        sd = af_simpleDescGet(ep);
        if (sd != (af_simple_descriptor_t *)0x0)
        {
          puVar5[1] = '\0';
          puVar5[2] = uVar4;
          puVar5[3] = uVar6;
          uVar4 = af_simpleDescriptorCopy(puVar5 + 5, sd);
          cVar10 = (char)(puVar5 + 5) + uVar4;
          puVar5[4] = uVar4;
          sVar7 = *(short *)((int)buf + 8);
          goto LAB_00025306;
        }
        puVar5[1] = 0x83;
        puVar5[2] = uVar4;
        puVar5[3] = uVar6;
        puVar5[4] = '\0';
      }
      cVar10 = cVar2 + '\x05';
      sVar7 = *(short *)((int)buf + 8);
    }
  }
  else
  {
    dVar3 = af_nodeDevTypeGet();
    if (dVar3 == DEVICE_TYPE_END_DEVICE)
    {
      puVar5[1] = 0x80;
    }
    else
    {
      puVar5[1] = 0x81;
    }
    puVar5[2] = (u8)((uint)iVar9 >> 0x10);
    puVar5[3] = (u8)(uVar8 >> 8);
    cVar10 = cVar2 + '\x04';
    sVar7 = *(short *)((int)buf + 8);
    if (sVar7 == 4)
    {
      puVar5[4] = '\0';
      cVar10 = cVar2 + '\x05';
      sVar7 = *(short *)((int)buf + 8);
    }
  }
LAB_00025306:
  p_Stack_2c = ll_reset;
  uStack_30 = (uint)(uint3)(CONCAT12(cVar10 - (char)local_40._0_4_, sVar7) | 0x8000);
  local_40._8_4_ = local_40._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)buf + 0x14);
  local_40._4_4_ = (zb_buf_t *)buf;
  zdo_send_req((zdo_zdp_req_t *)local_40);
  zb_buf_free(local_40._4_4_);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_activeEpIndicate(void *buf)

{
  u16 uVar1;
  u8 uVar2;
  device_type_t dVar3;
  u8 *puVar4;
  af_endpoint_descriptor_t *paVar5;
  u8 uVar6;
  uint uVar7;
  int iVar8;
  u8 *puVar9;
  undefined local_3c[12];
  undefined4 uStack_30;
  uint uStack_2c;
  zdo_callback p_Stack_28;
  u8 local_24;

  puVar4 = *(u8 **)((int)buf + 0xc);
  uVar6 = *puVar4;
  if ((*(ushort *)((int)buf + 2) & 0xfff8) == 0xfff8)
  {
    zb_buf_free((zb_buf_t *)buf);
  }
  else
  {
    uVar7 = (uint)puVar4[2] * 0x100 + (uint)puVar4[1];
    iVar8 = uVar7 * 0x10000;
    local_3c._0_4_ = (u8 *)0x0;
    local_3c._4_4_ = (zb_buf_t *)0x0;
    local_3c._8_4_ = 0;
    uStack_30 = 0;
    uStack_2c = 0;
    p_Stack_28 = ll_reset;
    local_24 = '\0';
    uVar2 = af_availableEpNumGet();
    puVar4 = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, uVar2 + '\x05');
    *puVar4 = uVar6;
    uVar1 = g_zbInfo.macPib.shortAddress;
    uVar6 = (u8)((uint)iVar8 >> 0x18);
    local_3c._0_4_ = puVar4;
    if ((uint)g_zbInfo.macPib.shortAddress == (uVar7 & 0xffff))
    {
      puVar4[1] = '\0';
      puVar4[2] = (u8)uVar1;
      puVar4[3] = uVar6;
      puVar4[4] = uVar2;
      puVar9 = puVar4 + 5;
      paVar5 = af_epDescriptorGet();
      if (uVar2 != '\0')
      {
        puVar4 = puVar9;
        do
        {
          *puVar4 = paVar5->ep;
          puVar4 = puVar4 + 1;
          paVar5 = paVar5 + 1;
        } while (puVar4 != puVar4 + (byte)(uVar2 - 2) + 6);
        puVar9 = puVar9 + (byte)(uVar2 - 2) + 1;
      }
    }
    else
    {
      dVar3 = af_nodeDevTypeGet();
      uVar2 = 0x80;
      if (dVar3 != DEVICE_TYPE_END_DEVICE)
      {
        uVar2 = 0x81;
      }
      puVar4[1] = uVar2;
      puVar4[2] = (u8)((uint)iVar8 >> 0x10);
      puVar4[3] = uVar6;
      puVar4[4] = '\0';
      puVar9 = puVar4 + 5;
    }
    p_Stack_28 = ll_reset;
    uStack_2c = (uint)CONCAT12((char)puVar9 - (char)local_3c._0_4_, 0x8005);
    local_3c._8_4_ = local_3c._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)buf + 0x14);
    local_3c._4_4_ = (zb_buf_t *)buf;
    zdo_send_req((zdo_zdp_req_t *)local_3c);
    zb_buf_free(local_3c._4_4_);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_matchDescriptorIndicate(void *buf)

{
  undefined *puVar1;
  af_simple_descriptor_t *paVar2;
  device_type_t dVar3;
  byte bVar4;
  byte *pbVar5;
  af_endpoint_descriptor_t *paVar6;
  u16 *puVar7;
  int iVar8;
  int iVar9;
  byte *pbVar10;
  u8 *puVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  u8 uVar16;
  u16 uVar17;
  uint uVar18;
  ushort uVar19;
  byte bVar20;
  byte bVar21;
  uint local_a8;
  undefined4 *puStack_98;
  int iStack_84;
  u16 uStack_76;
  undefined4 uStack_74;
  undefined4 uStack_70;
  undefined4 uStack_6c;
  undefined4 uStack_68;
  undefined4 uStack_64;
  undefined4 uStack_60;
  undefined4 uStack_5c;
  undefined4 uStack_58;
  undefined2 local_54;
  undefined auStack_50[12];
  undefined4 uStack_44;
  uint local_40;
  zdo_callback p_Stack_3c;
  u8 local_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined local_28;

  puVar1 = *(undefined **)((int)buf + 0xc);
  uStack_34._0_1_ = *puVar1;
  uStack_70 = 0;
  uStack_6c = 0;
  uStack_68 = 0;
  uStack_64 = 0;
  uStack_60 = 0;
  uStack_5c = 0;
  uStack_58 = 0;
  local_54 = 0;
  // WARNING: Load size is inaccurate
  iStack_84 = 0;
  if (*buf == '\x02')
  {
    uVar14 = *(ushort *)((int)buf + 2) & 0xfff8;
    uVar15 = uVar14 - 0xfff8;
    iStack_84 = ~uVar15 + uVar15 + (uint)(0xfff7 < uVar14);
  }
  uVar19 = (ushort)(byte)puVar1[2] * 0x100 + (ushort)(byte)puVar1[1];
  uVar17 = (ushort)(byte)puVar1[4] * 0x100 + (ushort)(byte)puVar1[3];
  bVar4 = puVar1[5];
  uVar14 = (uint)bVar4;
  uStack_74 = (uint)bVar4;
  uStack_76 = uVar17;
  if (0x10 < uVar14)
    goto LAB_00025708;
  pbVar10 = puVar1 + 6;
  if (uVar14 != 0)
  {
    uVar15 = 0;
    pbVar5 = pbVar10;
    do
    {
      (&uStack_76)[uVar15 + 2] = (ushort)pbVar5[1] * 0x100 + (ushort)*pbVar5;
      pbVar5 = pbVar5 + 2;
      uVar15 = uVar15 + 1;
    } while ((uVar15 & 0xff) < uVar14);
    pbVar10 = pbVar10 + ((uVar14 - 1) * 0x1000000 >> 0x17) + 2;
  }
  bVar20 = *pbVar10;
  uStack_74 = (uint)CONCAT11(bVar20, bVar4);
  uVar15 = uVar14 + bVar20;
  if (0x10 < uVar15)
    goto LAB_00025708;
  if ((uVar14 < uVar15) && (uVar14 < 0x10))
  {
    pbVar10 = pbVar10 + 1;
    uVar12 = uVar14;
    do
    {
      (&uStack_76)[uVar12 + 2] = (ushort)pbVar10[1] * 0x100 + (ushort)*pbVar10;
      pbVar10 = pbVar10 + 2;
      uVar12 = uVar12 + 1 & 0xff;
      if (uVar15 <= uVar12)
        break;
    } while (uVar12 < 0x10);
  }
  auStack_50._0_4_ = (u8 *)0x0;
  auStack_50._4_4_ = (zb_buf_t *)0x0;
  uStack_44 = 0;
  local_40 = 0;
  p_Stack_3c = ll_reset;
  local_38 = '\0';
  auStack_50._8_4_ = (uint) * (ushort *)((int)buf + 0x14);
  uStack_34 = 0;
  uStack_30 = 0;
  uStack_2c = 0;
  local_28 = 0;
  if ((g_zbInfo.macPib.shortAddress != uVar19) && ((uVar19 & 0xfff8) != 0xfff8))
  {
    dVar3 = af_nodeDevTypeGet();
    if (dVar3 == DEVICE_TYPE_END_DEVICE)
    {
      uVar16 = '\x05';
    }
    else
    {
      uVar16 = '\x05';
    }
    goto LAB_000256c0;
  }
  if ((uVar14 != 0) || (local_a8 = 0, bVar20 != 0))
  {
    bVar4 = af_availableEpNumGet();
    paVar6 = af_epDescriptorGet();
    if (bVar4 != 0)
    {
      uVar12 = uStack_74 & 0xff;
      uVar15 = uStack_74 >> 8 & 0xff;
      local_a8 = uStack_30 & 0xff;
      bVar20 = 0;
      uVar14 = 0;
    LAB_00025788:
      paVar2 = paVar6->correspond_simple_desc;
      if ((paVar2->app_profile_id == uVar17) || (uVar17 == 0xffff))
      {
        if (uVar12 != 0)
        {
          puVar7 = paVar2->app_in_cluster_lst;
          if (paVar2->app_in_cluster_count != 0)
          {
            bVar21 = 0;
            do
            {
              uVar18 = (uint) * (byte *)((int)puVar7 + 1) * 0x100 + (uint) * (byte *)puVar7 & 0xffff;
              puVar7 = puVar7 + 1;
              if (uVar18 == uStack_74 >> 0x10)
                goto LAB_0002589c;
              uVar13 = 0;
              iVar9 = 0;
              while (uVar13 = uVar13 + 1 & 0xff, uVar13 < uVar12)
              {
                iVar8 = iVar9 + 3;
                iVar9 = iVar9 + 1;
                if ((&uStack_76)[iVar8] == uVar18)
                  goto LAB_0002589c;
              }
              bVar21 = bVar21 + 1;
            } while (bVar21 < paVar2->app_in_cluster_count);
          }
        }
        if (uVar15 != 0)
        {
          puVar7 = paVar2->app_out_cluster_lst;
          if (paVar2->app_out_cluster_count != 0)
          {
            bVar21 = 0;
            do
            {
              uVar17 = (ushort) * (byte *)((int)puVar7 + 1) * 0x100 + (ushort) * (byte *)puVar7;
              puVar7 = puVar7 + 1;
              if (uVar17 == (&uStack_76)[uVar12 + 2])
                goto LAB_0002589c;
              uVar13 = 0;
              uVar18 = uVar12;
              while (true)
              {
                uVar13 = uVar13 + 1 & 0xff;
                if (uVar15 <= uVar13)
                  break;
                iVar9 = uVar18 + 3;
                uVar18 = uVar18 + 1;
                if (uVar17 == (&uStack_76)[iVar9])
                  goto LAB_0002589c;
              }
              bVar21 = bVar21 + 1;
            } while (bVar21 < paVar2->app_out_cluster_count);
          }
        }
      }
      goto LAB_0002576c;
    }
    local_a8 = 0;
  }
LAB_0002590e:
  if (iStack_84 != 0)
  {
  LAB_00025708:
    zb_buf_free((zb_buf_t *)buf);
    return;
  }
LAB_0002591a:
  uVar16 = (char)local_a8 + '\x05';
LAB_000256c0:
  puStack_98 = &uStack_34;
  // WARNING: Ignoring partial resolution of indirect
  local_40._0_3_ = CONCAT12(uVar16, (u16)local_40);
  local_40 = local_40 & 0xff000000 | (uint)(uint3)local_40;
  auStack_50._0_4_ = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, uVar16);
  memcpy(auStack_50._0_4_, puStack_98, local_40 >> 0x10 & 0xff);
  local_40._0_3_ = (uint3)local_40 & 0xff0000 | 0x8006;
  p_Stack_3c = ll_reset;
  local_40 = (uint)(uint3)local_40;
  auStack_50._4_4_ = (zb_buf_t *)buf;
  zdo_send_req((zdo_zdp_req_t *)auStack_50);
  zb_buf_free(auStack_50._4_4_);
  return;
LAB_0002589c:
  if (7 < uVar14)
  {
    // WARNING: Ignoring partial resolution of indirect
    uStack_30._0_1_ = (undefined)local_a8;
    local_a8 = uVar14;
    goto LAB_0002591a;
  }
  if (uVar14 == 0)
  {
    uVar16 = paVar2->endpoint;
  }
  else
  {
    uVar16 = paVar2->endpoint;
    puVar11 = (u8 *)((int)&uStack_30 + 1);
    uVar18 = 0;
    do
    {
      if (*puVar11 == uVar16)
        break;
      uVar18 = uVar18 + 1 & 0xff;
      puVar11 = puVar11 + 1;
    } while (uVar18 < uVar14);
    if (uVar18 != uVar14)
      goto LAB_0002576c;
  }
  *(u8 *)((int)&uStack_30 + uVar14 + 1) = uVar16;
  local_a8 = uVar14 + 1 & 0xff;
LAB_0002576c:
  bVar20 = bVar20 + 1;
  paVar6 = paVar6 + 1;
  uVar14 = local_a8;
  uVar17 = uStack_76;
  if (bVar4 <= bVar20)
    goto LAB_0002593e;
  goto LAB_00025788;
LAB_0002593e:
  // WARNING: Ignoring partial resolution of indirect
  uStack_30._0_1_ = (undefined)local_a8;
  if (local_a8 == 0)
    goto LAB_0002590e;
  goto LAB_0002591a;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_SysServerDiscoveryIndiate(void *buf)

{
  u8 uVar1;
  byte bVar2;
  byte bVar3;
  u8 *puVar4;
  undefined local_44[12];
  undefined4 uStack_38;
  uint uStack_34;
  zdo_callback p_Stack_30;
  u8 local_2c;
  node_descriptor_t nStack_28;

  puVar4 = *(u8 **)((int)buf + 0xc);
  uVar1 = *puVar4;
  bVar2 = puVar4[2];
  bVar3 = puVar4[1];
  af_nodeDescriptorCopy(&nStack_28);
  nStack_28.server_mask = (ushort)bVar2 * 0x100 + (ushort)bVar3 & nStack_28.server_mask;
  if (nStack_28.server_mask == 0)
  {
    zb_buf_free((zb_buf_t *)buf);
  }
  else
  {
    local_44._0_4_ = (u8 *)0x0;
    local_44._4_4_ = (zb_buf_t *)0x0;
    local_44._8_4_ = 0;
    uStack_38 = 0;
    p_Stack_30 = ll_reset;
    local_2c = '\0';
    uStack_34 = 0x40000;
    local_44._0_4_ = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, '\x04');
    *local_44._0_4_ = uVar1;
    local_44._0_4_[1] = '\0';
    local_44._0_4_[2] = (u8)nStack_28.server_mask;
    local_44._0_4_[3] = (u8)(nStack_28.server_mask >> 8);
    p_Stack_30 = ll_reset;
    uStack_34 = (uint)((uint3)uStack_34 & 0xff0000 | 0x8015);
    local_44._8_4_ = local_44._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)buf + 0x14);
    local_44._4_4_ = (zb_buf_t *)buf;
    zdo_send_req((zdo_zdp_req_t *)local_44);
    zb_buf_free(local_44._4_4_);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 zdo_bind_unbind_req(void)

{
  byte bVar1;
  u8 uVar2;
  u8 uVar3;
  void *in_r0;
  zb_buf_t *p;
  u8 *puVar4;
  zdo_zdp_req_t *in_r1;
  byte in_r2;
  uint length;
  undefined4 uVar5;

  p = (zb_buf_t *)c1();
  uVar5 = 0x8a;
  if (p != (zb_buf_t *)0x0)
  {
    *(char *)&in_r1->buff_addr = (char)p;
    *(char *)((int)&in_r1->buff_addr + 1) = (char)((uint)p >> 8);
    *(char *)((int)&in_r1->buff_addr + 2) = (char)((uint)p >> 0x10);
    *(char *)((int)&in_r1->buff_addr + 3) = (char)((uint)p >> 0x18);
    puVar4 = (u8 *)tl_bufInitalloc(p, '\x15');
    *(char *)&in_r1->zdu = (char)puVar4;
    *(char *)((int)&in_r1->zdu + 1) = (char)((uint)puVar4 >> 8);
    *(char *)((int)&in_r1->zdu + 2) = (char)((uint)puVar4 >> 0x10);
    *(char *)((int)&in_r1->zdu + 3) = (char)((uint)puVar4 >> 0x18);
    uVar2 = zdp_txSeqNo;
    uVar3 = zdp_txSeqNo + '\x01';
    in_r1->zdpSeqNum = zdp_txSeqNo;
    zdp_txSeqNo = uVar3;
    *puVar4 = uVar2;
    if (*(char *)((int)in_r0 + 0xb) == '\x03')
    {
      in_r1->zduLen = '\x15';
      length = 0x15;
    }
    else
    {
      in_r1->zduLen = '\x0e';
      length = 0xe;
    }
    memcpy(puVar4 + 1, in_r0, length);
    bVar1 = in_r1->zduLen;
    in_r1->zduLen = bVar1 + 1;
    *(byte *)&in_r1->cluster_id = in_r2 + ~in_r2 + (0xfffffffe < bVar1) + '!';
    *(undefined *)((int)&in_r1->cluster_id + 1) = 0;
    zdo_send_req(in_r1);
    zb_buf_free((zb_buf_t *)in_r1->buff_addr);
    uVar5 = 0;
  }
  return uVar5;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_bind_toggle_action(void)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uStack_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  byte local_18;

  uStack_2c = 0;
  uStack_28 = 0;
  uStack_20 = 0;
  uStack_1c = 0;
  local_18 = 0;
  uVar2 = 0;
  uVar3 = 0;
  if (ed_binding_ctx[7] == '\0')
  {
    uStack_24 = (uint)ed_binding_ctx[14];
    tl_zbExtAddrByShortAddr(ed_binding_ctx._12_2_, (addrExt_t)0x0, (u16 *)&uStack_2c);
    tl_zbExtAddrByShortAddr(ed_binding_ctx._4_2_, (addrExt_t)CONCAT44(uVar3, uVar2), (u16 *)&uStack_20);
    local_18 = ed_binding_ctx[6];
  }
  else
  {
    uStack_24 = (uint)ed_binding_ctx[6];
    tl_zbExtAddrByShortAddr(ed_binding_ctx._4_2_, (addrExt_t)0x0, (u16 *)&uStack_2c);
    tl_zbExtAddrByShortAddr(ed_binding_ctx._12_2_, (addrExt_t)CONCAT44(uVar3, uVar2), (u16 *)&uStack_20);
    local_18 = ed_binding_ctx[14];
  }
  uStack_24._0_3_ =
      CONCAT12((char)((ushort)ed_binding_ctx._16_2_ >> 8),
               CONCAT11((char)ed_binding_ctx._16_2_, (undefined)uStack_24));
  uStack_24 = (uint3)uStack_24 | 0x3000000;
  iVar1 = zdo_bind_unbind_req();
  if (iVar1 == 0x8a)
  {
    tl_zbTaskPost(zdo_bind_toggle_action, (void *)0x0);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps
// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_bind_unbind_after_toggle_clone_0(void)

{
  int in_r0;
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uStack_34;
  undefined4 uStack_30;
  uint uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  undefined local_20;

  if ((in_r0 != 0) || (ed_binding_ctx[48] != 1))
  {
    uStack_34 = 0;
    uStack_30 = 0;
    uStack_28 = 0;
    uStack_24 = 0;
    local_20 = 0;
    uVar1 = 0;
    uVar2 = 0;
    if (ed_binding_ctx[48] != 0)
    {
      if (ed_binding_ctx[7] < ed_binding_ctx[48])
      {
        uStack_2c = ed_binding_ctx._12_4_ >> 0x10 & 0xff;
        tl_zbExtAddrByShortAddr(ed_binding_ctx._12_2_, (addrExt_t)0x0, (u16 *)&uStack_34);
        tl_zbExtAddrByShortAddr(ed_binding_ctx._4_2_, (addrExt_t)CONCAT44(uVar2, uVar1), (u16 *)&uStack_28);
        local_20 = ed_binding_ctx[6];
      }
      else
      {
        uStack_2c = ed_binding_ctx._4_4_ >> 0x10 & 0xff;
        tl_zbExtAddrByShortAddr(ed_binding_ctx._4_2_, (addrExt_t)0x0, (u16 *)&uStack_34);
        tl_zbExtAddrByShortAddr(ed_binding_ctx._12_2_, (addrExt_t)CONCAT44(uVar2, uVar1), (u16 *)&uStack_28);
        local_20 = ed_binding_ctx[14];
      }
      ed_binding_ctx._48_2_ =
          ed_binding_ctx._48_2_ & 0xff00 | (ushort)(byte)(ed_binding_ctx[48] - 1);
      uStack_2c = CONCAT13(3, CONCAT12((char)((ushort) * (undefined2 *)(ed_binding_ctx +
                                                                        ((byte)(ed_binding_ctx[48] - 1) + 8) * 2) >>
                                              8),
                                       CONCAT11((char)*(undefined2 *)(ed_binding_ctx +
                                                                      ((byte)(ed_binding_ctx[48] - 1) + 8) *
                                                                          2),
                                                (undefined)uStack_2c)));
      zdo_bind_unbind_req();
      return;
    }
  }
  ed_binding_ctx._48_2_ = 0;
  ed_binding_ctx._44_4_ = 0;
  ed_binding_ctx._40_4_ = 0;
  ed_binding_ctx._36_4_ = 0;
  ed_binding_ctx._32_4_ = 0;
  ed_binding_ctx._28_4_ = 0;
  ed_binding_ctx._24_4_ = 0;
  ed_binding_ctx._20_4_ = 0;
  ed_binding_ctx._16_4_ = 0;
  ed_binding_ctx._12_4_ = 0;
  ed_binding_ctx._8_4_ = 0;
  ed_binding_ctx._4_4_ = 0;
  ed_binding_ctx._0_4_ = 0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_bind_toggle_cb(void)

{
  zdo_bind_unbind_after_toggle_clone_0();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_end_device_unbind_cb(void)

{
  zdo_bind_unbind_after_toggle_clone_0();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void zdo_end_device_bind_cb(void)

{
  zdo_bind_unbind_after_toggle_clone_0();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

byte zdo_apsmeBindUnBind(void)

{
  u8 ep;
  char in_r0;
  byte bVar1;
  int iVar2;
  void *in_r1;
  byte bVar3;
  char cVar4;

  iVar2 = memcmp(in_r1, g_zbInfo.macPib.extAddress, 8);
  if (iVar2 != 0)
  {
    return 0x84;
  }
  ep = *(u8 *)((int)in_r1 + 8);
  bVar1 = *(byte *)((int)in_r1 + 0xb);
  if (bVar1 == 1)
  {
    bVar3 = 0x82;
    if (0xfd < (byte)(ep - 1))
      goto LAB_00025cee;
  }
  else
  {
    if ((((0xfd < (byte)(ep - 1)) || (*(char *)((int)in_r1 + 0x14) == '\0')) || (bVar1 == 2)) ||
        (bVar1 == 0))
    {
      bVar3 = 0x82;
      goto LAB_00025cee;
    }
    bVar3 = 0x82;
    if (3 < bVar1)
      goto LAB_00025cee;
  }
  cVar4 = '\0';
  bVar1 = af_clusterMatchedLocal((ushort) * (byte *)((int)in_r1 + 9) + (ushort) * (byte *)((int)in_r1 + 10) * 0x100,
                                 ep);
  bVar3 = ~(bVar1 + ~bVar1 + cVar4) & 0x88;
LAB_00025cee:
  if (in_r0 == '\0')
  {
    if (((bVar3 == 0) && (iVar2 = aps_me_unbind_req(), iVar2 != 0)) && (bVar3 = 0x84, iVar2 == 0xa4))
    {
      bVar3 = 0x88;
    }
  }
  else if (bVar3 == 0)
  {
    iVar2 = aps_me_bind_req();
    if ((iVar2 != 0) && (bVar3 = 0x84, iVar2 == 0xae))
    {
      bVar3 = 0x8c;
    }
  }
  else
  {
    bVar3 = 0x82;
  }
  return bVar3;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_bindOrUnbindIndicate(void *buf)

{
  u8 uVar1;
  u8 uVar2;
  undefined local_48[12];
  undefined4 uStack_3c;
  uint uStack_38;
  zdo_callback p_Stack_34;
  u8 local_30;
  undefined auStack_2c[28];

  uVar1 = **(u8 **)((int)buf + 0xc);
  memcpy(auStack_2c, *(u8 **)((int)buf + 0xc) + 1, *(ushort *)((int)buf + 10) - 1);
  local_48._0_4_ = (u8 *)0x0;
  local_48._4_4_ = (zb_buf_t *)0x0;
  local_48._8_4_ = 0;
  uStack_3c = 0;
  uStack_38 = 0;
  p_Stack_34 = ll_reset;
  local_30 = '\0';
  if (*(short *)((int)buf + 8) == 0x21)
  {
    uStack_38 = 0x8021;
  }
  else if (*(short *)((int)buf + 8) == 0x22)
  {
    uStack_38 = 0x8022;
  }
  uVar2 = zdo_apsmeBindUnBind();
  uStack_38._0_3_ = CONCAT12(2, (u16)uStack_38);
  uStack_38 = uStack_38 & 0xff000000 | (uint)(uint3)uStack_38;
  local_48._0_4_ = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, '\x02');
  *local_48._0_4_ = uVar1;
  local_48._0_4_[1] = uVar2;
  p_Stack_34 = ll_reset;
  uStack_38 = uStack_38 & 0xffffff;
  local_48._8_4_ = local_48._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)buf + 0x14);
  local_48._4_4_ = (zb_buf_t *)buf;
  zdo_send_req((zdo_zdp_req_t *)local_48);
  zb_buf_free(local_48._4_4_);
  return;
}

void zdo_endDeviceBindIndicate(void *buf)

{
  undefined uVar1;
  undefined uVar2;
  int iVar3;
  int iVar4;

  iVar3 = *(int *)((int)buf + 0xc);
  if ((byte)(*(char *)(iVar3 + 9) - 1U) < 0xfe)
  {
    if (ed_binding_ctx._0_4_ == (void *)0x0)
    {
      if (zdo_bind_timer_event != (ev_timer_event_t *)0x0)
      {
        ev_timer_taskCancel(&zdo_bind_timer_event);
      }
      zdo_bind_timer_event = ev_timer_taskPost(zdo_end_device_bind_timeout_cb, buf, 20000);
      ed_binding_ctx._0_4_ = buf;
      return;
    }
    if (zdo_bind_timer_event != (ev_timer_event_t *)0x0)
    {
      ev_timer_taskCancel(&zdo_bind_timer_event);
    }
    iVar4 = (int)ed_binding_ctx._0_4_;
    uVar1 = *(undefined *)(iVar3 + 0xb);
    uVar2 = *(undefined *)(*(int *)((int)ed_binding_ctx._0_4_ + 0xc) + 0xb);
    if (*(short *)(*(int *)((int)ed_binding_ctx._0_4_ + 0xc) + 0xc) == *(short *)(iVar3 + 0xc))
    {
      ed_binding_ctx._48_2_ = ed_binding_ctx._48_2_ & 0xff00;
      zdo_cluster_list_match_process_clone_1();
      ed_binding_ctx._4_4_ = ed_binding_ctx._4_4_ & 0xffffff | (uint)ed_binding_ctx[48] << 0x18;
      zdo_cluster_list_match_process_clone_1();
      ed_binding_ctx._12_4_ =
          ed_binding_ctx._12_4_ & 0xffffff |
          (uint)(byte)(ed_binding_ctx[48] - ed_binding_ctx[7]) << 0x18;
      if (ed_binding_ctx[48] != '\0')
      {
        ed_binding_ctx._4_3_ = CONCAT12(uVar2, *(undefined2 *)(iVar4 + 0x14));
        ed_binding_ctx._4_4_ = ed_binding_ctx._4_4_ & 0xff000000 | (uint)ed_binding_ctx._4_3_;
        ed_binding_ctx._12_4_ =
            CONCAT13(ed_binding_ctx[48] - ed_binding_ctx[7],
                     CONCAT12(uVar1, *(undefined2 *)((int)buf + 0x14)));
        tl_zbTaskPost(zdo_bind_toggle_action, (void *)0x0);
        zdo_end_device_bind_resp_send();
        zdo_end_device_bind_resp_send();
        return;
      }
    }
  }
  zdo_end_device_bind_resp_send();
  zdo_end_device_bind_resp_send();
  ed_binding_ctx._48_2_ = 0;
  ed_binding_ctx._44_4_ = 0;
  ed_binding_ctx._40_4_ = 0;
  ed_binding_ctx._36_4_ = 0;
  ed_binding_ctx._32_4_ = 0;
  ed_binding_ctx._28_4_ = 0;
  ed_binding_ctx._24_4_ = 0;
  ed_binding_ctx._20_4_ = 0;
  ed_binding_ctx._16_4_ = 0;
  ed_binding_ctx._12_4_ = 0;
  ed_binding_ctx._8_4_ = 0;
  ed_binding_ctx._4_4_ = 0;
  ed_binding_ctx._0_4_ = (void *)0x0;
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_mgmtPermitJoinIndicate(void *buf)

{
  u8 uVar1;
  zb_buf_t *p;
  undefined local_38[12];
  undefined4 uStack_2c;
  uint uStack_28;
  zdo_callback p_Stack_24;
  u8 local_20;
  u8 local_1c[4];

  uVar1 = **(u8 **)((int)buf + 0xc);
  local_1c[0] = (*(u8 **)((int)buf + 0xc))[1];
  if ((*(ushort *)((int)buf + 2) & 0xfff8) != 0xfff8)
  {
    local_38._0_4_ = (u8 *)0x0;
    local_38._4_4_ = (zb_buf_t *)0x0;
    local_38._8_4_ = 0;
    uStack_2c = 0;
    p_Stack_24 = ll_reset;
    local_20 = '\0';
    uStack_28 = 0x20000;
    p = (zb_buf_t *)c1();
    if (p == (zb_buf_t *)0x0)
    {
      zb_buf_free((zb_buf_t *)buf);
      return;
    }
    local_38._4_4_ = p;
    local_38._0_4_ = (u8 *)tl_bufInitalloc(p, '\x02');
    *local_38._0_4_ = uVar1;
    local_38._0_4_[1] = '\0';
    uStack_28 = (uint)((uint3)uStack_28 & 0xff0000 | 0x8036);
    local_38._8_4_ = local_38._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)buf + 0x14);
    zdo_send_req((zdo_zdp_req_t *)local_38);
    zb_buf_free(local_38._4_4_);
  }
  *(u8 *)buf = local_1c[0];
  tl_zbPrimitivePost('\x03', 'w', buf);
  if ((zdoAppIndCbLst != 0) && (*(int *)(zdoAppIndCbLst + 0x18) != 0))
  {
    zdo_nwkUpdateNotifyRespSend(local_1c);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_nwkUpdateNotifyRespSend(void *buf)

{
  undefined4 uVar1;
  zb_buf_t *p;
  u8 *puVar2;
  code *in_r3;
  uint uVar3;
  u8 local_114[3];
  byte bStack_111;
  u8 auStack_10c[216];
  undefined auStack_34[12];
  undefined4 uStack_28;
  uint uStack_24;
  zdo_callback p_Stack_20;
  u8 local_1c;

  p = (zb_buf_t *)(*in_r3)();
  memcpy(local_114, p, 0xe0);
  auStack_34._0_4_ = (u8 *)0x0;
  auStack_34._4_4_ = (zb_buf_t *)0x0;
  auStack_34._8_4_ = 0;
  uStack_28 = 0;
  uStack_24 = 0;
  p_Stack_20 = ll_reset;
  local_1c = '\0';
  auStack_34._0_4_ = (u8 *)tl_bufInitalloc(p, bStack_111 + 0xb);
  *auStack_34._0_4_ = zdo_nur[8];
  auStack_34._0_4_[1] = local_114[0];
  uVar1 = zdo_nur._0_4_;
  auStack_34._0_4_[2] = (u8)zdo_nur._0_4_;
  auStack_34._0_4_[3] = (u8)((uint)uVar1 >> 8);
  auStack_34._0_4_[4] = (u8)((uint)uVar1 >> 0x10);
  auStack_34._0_4_[5] = (u8)((uint)uVar1 >> 0x18);
  auStack_34._0_4_[6] = (u8)g_zbInfo.nwkNib.txTotal;
  auStack_34._0_4_[7] = g_zbInfo.nwkNib.txTotal._1_1_;
  auStack_34._0_4_[8] = (u8)g_zbInfo.nwkNib.txFail;
  auStack_34._0_4_[9] = g_zbInfo.nwkNib.txFail._1_1_;
  auStack_34._0_4_[10] = bStack_111;
  puVar2 = auStack_34._0_4_ + 0xb;
  uVar3 = 0;
  do
  {
    *puVar2 = auStack_10c[uVar3];
    puVar2 = puVar2 + 1;
    uVar3 = uVar3 + 1 & 0xff;
  } while (uVar3 <= bStack_111);
  uStack_24 = (uint)CONCAT12((char)puVar2 - (char)auStack_34._0_4_, 0x8038);
  auStack_34._8_4_ = auStack_34._8_4_ & 0xffff0000 | (uint)zdo_nur._6_2_;
  auStack_34._4_4_ = p;
  zdo_send_req((zdo_zdp_req_t *)auStack_34);
  zb_buf_free(auStack_34._4_4_);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_mgmNwkUpdateIndicate(void *buf)

{
  u8 uVar1;
  byte bVar2;
  u8 *puVar3;
  u32 chp;
  short sVar4;
  byte bVar5;
  u8 uVar6;
  int iVar7;
  undefined local_34[12];
  undefined4 uStack_28;
  undefined4 uStack_24;
  zdo_callback p_Stack_20;
  u8 local_1c;
  void *arg;

  puVar3 = *(u8 **)((int)buf + 0xc);
  uVar1 = *puVar3;
  chp = *(u32 *)(puVar3 + 1);
  bVar5 = puVar3[5];
  bVar2 = puVar3[6];
  sVar4 = *(short *)(puVar3 + 7);
  if (bVar5 == 0xfe)
  {
    bVar5 = zdo_channel_page2num(chp);
    arg = (void *)(uint)bVar5;
    uVar6 = zdo_af_get_accept_nwk_update_channel();
    if (((uVar6 != '\0') && (uVar6 = zdo_af_get_accept_nwk_update_channel(), uVar6 != 0xff)) &&
        (bVar5 = zdo_af_get_accept_nwk_update_channel(), (void *)(uint)bVar5 != arg))
      goto LAB_00026212;
    uVar6 = 0x80;
    if ((int)arg - 0xbU < 0x10)
    {
      g_zbInfo.nwkNib.updateId = bVar2;
      ev_timer_taskPost(zdo_change_channel_cb, arg, 0x2e);
      zb_buf_free((zb_buf_t *)buf);
      return;
    }
  }
  else
  {
    if (bVar5 == 0xff)
    {
      aps_ib.aps_channel_mask._0_1_ = (undefined)chp;
      aps_ib.aps_channel_mask._1_1_ = (undefined)(chp >> 8);
      aps_ib.aps_channel_mask._2_1_ = (undefined)(chp >> 0x10);
      aps_ib.aps_channel_mask._3_1_ = (undefined)(chp >> 0x18);
      iVar7 = memcmp(ss_ib.trust_center_address, &g_invalid_addr, 8);
      if ((iVar7 == 0) || (sVar4 == 0))
      {
        g_zbInfo.nwkNib.managerAddr._0_1_ = (undefined)sVar4;
        g_zbInfo.nwkNib.managerAddr._1_1_ = (undefined)((ushort)sVar4 >> 8);
      }
      goto LAB_00026212;
    }
    uVar6 = 0x80;
    if ((bVar5 < 6) && (bVar2 < 6))
    {
      zdo_nur._6_2_ = *(undefined2 *)((int)buf + 0x14);
      zdo_nur._0_4_ = chp;
      zdo_nur[4] = bVar5;
      zdo_nur[5] = bVar2;
      zdo_nur[8] = uVar1;
      iVar7 = (*(code *)&zdo_nlmeEdScanReq)(chp, bVar5, bVar2);
      uVar6 = 0x84;
      if (iVar7 == 0)
      {
        zdo_mgmt_nwk_flag = zdo_mgmt_nwk_flag | 1;
        goto LAB_00026212;
      }
    }
  }
  if ((*(ushort *)((int)buf + 2) & 0xfff8) != 0xfff8)
  {
    local_34._0_4_ = (u8 *)0x0;
    local_34._4_4_ = (u8 *)0x0;
    local_34._8_4_ = 0;
    uStack_28 = 0;
    p_Stack_20 = ll_reset;
    local_1c = '\0';
    uStack_24 = 0x20000;
    local_34._0_4_ = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, '\x02');
    *local_34._0_4_ = uVar1;
    local_34._0_4_[1] = uVar6;
    local_34._8_4_ = local_34._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)buf + 0x14);
    uStack_24 = CONCAT22((ushort)((uint)uStack_24 >> 0x10) & 0xff, 0x8038);
    local_34._4_4_ = (u8 *)buf;
    zdo_send_req((zdo_zdp_req_t *)local_34);
  }
LAB_00026212:
  zb_buf_free((zb_buf_t *)buf);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_mgmtBindIndicate(void *buf)

{
  u8 uVar1;
  byte bVar2;
  uint uVar3;
  u8 *puVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  u8 *out;
  uint uVar8;
  uint local_44;
  undefined auStack_40[12];
  undefined4 uStack_34;
  uint uStack_30;
  zdo_callback p_Stack_2c;
  u8 local_28;

  uVar1 = **(u8 **)((int)buf + 0xc);
  bVar2 = (*(u8 **)((int)buf + 0xc))[1];
  uVar5 = (uint)bVar2;
  if ((*(ushort *)((int)buf + 2) & 0xfff8) != 0xfff8)
  {
    auStack_40._0_4_ = (u8 *)0x0;
    auStack_40._4_4_ = (zb_buf_t *)0x0;
    auStack_40._8_4_ = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    p_Stack_2c = ll_reset;
    local_28 = '\0';
    uVar3 = aps_bindingTblEntryNum();
    puVar4 = (u8 *)aps_bindingTblEntryGet();
    local_44 = 0;
    if (uVar5 < uVar3)
    {
      local_44 = 2;
      if ((int)(uVar3 - uVar5) < 2)
      {
        local_44 = uVar3 - uVar5 & 0xff;
      }
    }
    auStack_40._0_4_ = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, '/');
    *auStack_40._0_4_ = uVar1;
    auStack_40._0_4_[1] = '\0';
    auStack_40._0_4_[2] = (u8)uVar3;
    auStack_40._0_4_[3] = bVar2;
    auStack_40._0_4_[4] = (u8)local_44;
    out = auStack_40._0_4_ + 5;
    if (APS_BINDING_TABLE_SIZE != '\0')
    {
      iVar7 = 0;
      uVar8 = 0;
      uVar3 = 0;
      do
      {
        uVar6 = uVar3;
        if ((puVar4[0xd] != '\0') && (uVar6 = uVar3 + 1 & 0xff, uVar5 <= uVar3))
        {
          memcpy(out, g_zbInfo.macPib.extAddress, 8);
          out[8] = puVar4[2];
          out[9] = *puVar4;
          out[10] = puVar4[1];
          out[0xb] = puVar4[3];
          if (puVar4[3] == '\x03')
          {
            memcpy(out + 0xc, puVar4 + 4, 8);
            out[0x14] = puVar4[0xc];
            out = out + 0x15;
          }
          else
          {
            out[0xc] = puVar4[4];
            out[0xd] = puVar4[5];
            out = out + 0xe;
          }
          uVar8 = uVar8 + 1 & 0xff;
          if (local_44 <= uVar8)
            break;
        }
        iVar7 = iVar7 + 1;
        if ((int)(uint)APS_BINDING_TABLE_SIZE <= iVar7)
          break;
        puVar4 = puVar4 + 0xe;
        uVar3 = uVar6;
      } while (true);
    }
    uStack_30 = (uint)CONCAT12((char)out - (char)auStack_40._0_4_, 0x8033);
    auStack_40._8_4_ = auStack_40._8_4_ & 0xffff0000 | (uint) * (ushort *)((int)buf + 0x14);
    auStack_40._4_4_ = (zb_buf_t *)buf;
    zdo_send_req((zdo_zdp_req_t *)auStack_40);
    buf = auStack_40._4_4_;
  }
  zb_buf_free((zb_buf_t *)buf);
  return;
}

// WARNING: Could not reconcile some variable overlaps

void zdo_mgmtLqiIndictate(void *buf)

{
  u8 uVar1;
  byte bVar2;
  u16 uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  u8 *puStack_64;
  uint uStack_60;
  undefined auStack_58[12];
  undefined4 uStack_4c;
  undefined4 uStack_48;
  zdo_callback p_Stack_44;
  u8 local_40;
  undefined4 uStack_3c;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined4 uStack_30;
  undefined4 uStack_2c;
  undefined2 local_28;
  uint extraout_r0;

  uVar1 = **(u8 **)((int)buf + 0xc);
  uVar5 = (uint)(*(u8 **)((int)buf + 0xc))[1];
  if ((*(ushort *)((int)buf + 2) & 0xfff8) != 0xfff8)
  {
    auStack_58._0_4_ = (u8 *)0x0;
    auStack_58._4_4_ = (zb_buf_t *)0x0;
    auStack_58._8_4_ = 0;
    uStack_4c = 0;
    uStack_48 = 0;
    p_Stack_44 = ll_reset;
    local_40 = '\0';
    uStack_3c = 0;
    uStack_38 = 0;
    uStack_34 = 0;
    uStack_30 = 0;
    uStack_2c = 0;
    local_28 = 0;
    puStack_64 = (u8 *)tl_bufInitalloc((zb_buf_t *)buf, '1');
    *puStack_64 = uVar1;
    puStack_64[1] = '\0';
    auStack_58._0_4_ = puStack_64;
    bVar2 = tl_zbNeighborTableNumGet();
    extraout_r0 = (uint)bVar2;
    puStack_64[2] = bVar2;
    puStack_64[3] = (u8)uVar5;
    if ((extraout_r0 < uVar5) || (extraout_r0 == 0))
    {
      puStack_64[4] = '\0';
      puStack_64 = puStack_64 + 5;
      memcpy(&uStack_3c, g_zbInfo.nwkNib.extPANId, 8);
    }
    else
    {
      uVar4 = extraout_r0 - uVar5;
      if (2 < (int)uVar4)
      {
        uVar4 = 2;
      }
      puStack_64[4] = (u8)uVar4;
      puStack_64 = puStack_64 + 5;
      memcpy(&uStack_3c, g_zbInfo.nwkNib.extPANId, 8);
      if (((uVar4 & 0xff) != 0) && (TL_ZB_NEIGHBOR_TABLE_SIZE != '\0'))
      {
        uStack_60 = 0;
        uVar7 = 0;
        uVar6 = 0;
        do
        {
          if ((char)g_zb_neighborTbl.neighborTbl[uVar6].field_0x1e < '\0')
          {
            if (uVar5 <= uVar7)
            {
              uVar3 = g_zb_neighborTbl.neighborTbl[uVar6].addrmapIdx;
              tl_zbExtAddrByIdx(uVar3, (addrExt_t)CONCAT44(buf, uVar5));
              uVar3 = tl_zbshortAddrByIdx(uVar3);
              uStack_2c = CONCAT13(2, CONCAT12((byte)(((byte)g_zb_neighborTbl.neighborTbl[uVar6].field_0x1e & 1) << 2) |
                                                   (byte)g_zb_neighborTbl.neighborTbl[uVar6].field_0x1e >> 1 & 3 |
                                                   (byte)(((byte)g_zb_neighborTbl.neighborTbl[uVar6].field_0x1e >> 4 & 7) << 4),
                                               uVar3));
              local_28 = CONCAT11(g_zb_neighborTbl.neighborTbl[uVar6].lqi,
                                  g_zb_neighborTbl.neighborTbl[uVar6].depth);
              memcpy(puStack_64, &uStack_3c, 0x16);
              puStack_64 = puStack_64 + 0x16;
              uStack_60 = uStack_60 + 1 & 0xff;
              if ((uVar4 & 0xff) <= uStack_60)
                break;
            }
            uVar7 = uVar7 + 1 & 0xff;
          }
          uVar6 = uVar6 + 1 & 0xff;
        } while (uVar6 < TL_ZB_NEIGHBOR_TABLE_SIZE);
      }
    }
    uStack_48 = CONCAT22((ushort)(byte)((char)puStack_64 - (char)auStack_58._0_4_), 0x8031);
    auStack_58._8_4_ = auStack_58._8_4_ & 0xffff0000 | (uint) * (ushort *)((u8 *)buf + 0x14);
    auStack_58._4_4_ = (zb_buf_t *)buf;
    zdo_send_req((zdo_zdp_req_t *)auStack_58);
    buf = auStack_58._4_4_;
  }
  zb_buf_free((zb_buf_t *)buf);
  return;
}

void zdo_mgmtLeaveIndicate(void *buf)

{
  undefined uVar1;
  ushort uVar2;
  bool bVar3;
  int iVar4;
  undefined *puVar5;
  void *out;
  tl_zb_normal_neighbor_entry_t *ptVar6;
  char cVar7;
  u8 *in_stack_ffffffb8;
  u8 *in_stack_ffffffbc;
  undefined auStack_2c[8];
  byte bStack_24;

  uVar1 = **(undefined **)((int)buf + 0xc);
  memcpy(auStack_2c, *(undefined **)((int)buf + 0xc) + 1, 9);
  uVar2 = *(ushort *)((int)buf + 2);
  iVar4 = memcmp(auStack_2c, &g_zero_addr, 8);
  cVar7 = -0x7c;
  if ((iVar4 != 0) && (iVar4 = memcmp(auStack_2c, g_zbInfo.macPib.extAddress, 8), iVar4 != 0))
  {
    ptVar6 = nwk_neTblGetByExtAddr((addrExt_t)CONCAT44(in_stack_ffffffbc, in_stack_ffffffb8));
    cVar7 = -0x38;
    if (ptVar6 != (tl_zb_normal_neighbor_entry_t *)0x0)
    {
      cVar7 = -0x38;
    }
  }
  bVar3 = zdo_af_get_mgmtLeave_use_aps_sec();
  if ((bVar3 != false) && (-1 < (int)((uint) * (byte *)((int)buf + 0x1f) << 0x1f)))
  {
    cVar7 = -0x73;
  }
  if ((uVar2 & 0xfff8) == 0xfff8)
  {
    zb_buf_free((zb_buf_t *)buf);
  }
  else
  {
    puVar5 = (undefined *)tl_bufInitalloc((zb_buf_t *)buf, '\x02');
    *puVar5 = uVar1;
    puVar5[1] = cVar7;
    zdo_send_req((zdo_zdp_req_t *)&stack0xffffffb8);
    zb_buf_free((zb_buf_t *)buf);
  }
  if ((cVar7 == '\0') && (out = (void *)c1(), out != (void *)0x0))
  {
    memcpy(out, auStack_2c, 8);
    *(byte *)((int)out + 8) = (byte)(((uint)bStack_24 << 0x19) >> 0x1f);
    *(byte *)((int)out + 9) = bStack_24 >> 7;
    ev_timer_taskPost(zdoMgmtLeaveCmdProcessCb, out, 100);
  }
  return;
}

// WARNING: Could not reconcile some variable overlaps

u8 af_dataSend(u8 srcEp, epInfo_t *pDstEpInfo, u16 clusterId, u16 cmdPldLen, u8 *cmdPld, u8 *apsCnt)

{
  u8 uVar1;
  u8 uVar2;
  aps_tx_options aVar3;
  uint uVar4;
  uint uStack_24;
  undefined4 uStack_20;
  uint uStack_1c;
  ushort local_18;
  undefined local_16;

  uStack_24 = 0;
  uStack_20 = 0;
  uStack_1c = 0;
  local_18 = 0;
  local_16 = 0;
  uVar2 = pDstEpInfo->dstAddrMode;
  if ((byte)(uVar2 - 2) < 2)
  {
    uStack_1c = (uint)pDstEpInfo->dstEp;
    if (uVar2 != '\x02')
    {
      memcpy(&uStack_24, pDstEpInfo, 8);
      aVar3 = pDstEpInfo->txOptions;
      goto LAB_000267e8;
    }
  }
  else if (uVar2 != '\x01')
  {
    aVar3 = pDstEpInfo->txOptions;
    if ((int)((uint)aVar3 << 0x1c) < 0)
    {
      return '\x01';
    }
    goto LAB_000267e8;
  }
  uStack_24 = (uint)(pDstEpInfo->dstAddr).shortAddr;
  aVar3 = pDstEpInfo->txOptions;
LAB_000267e8:
  uStack_1c = CONCAT22(pDstEpInfo->aliasSrcAddr, CONCAT11(pDstEpInfo->useAlias, (undefined)uStack_1c));
  local_18 = local_18 & 0xff00 | (ushort)pDstEpInfo->aliasSeqNum;
  uVar1 = aps_get_counter_value();
  *apsCnt = uVar1;
  uVar4 = (uint)aVar3;
  if ((int)(uVar4 << 0x1c) < 0)
  {
    if (aps_ib.aps_fragment_payload_size == 0)
    {
      return '\x01';
    }
    if (uVar2 == '\x01')
    {
      return '\x01';
    }
    if ((uVar2 == '\x02') && ((uStack_24 & 0xfff8) == 0xfff8))
    {
      return '\x01';
    }
    if (aps_ib.aps_fragment_payload_size < cmdPldLen)
    {
      uVar4 = uVar4 | 4;
    }
    else
    {
      uVar4 = uVar4 & 0xfffffff7;
    }
    if ((int)(uVar4 << 0x1c) < 0)
    {
      uVar2 = apsDataFragmentRequest();
      return uVar2;
    }
  }
  uVar2 = apsDataRequest();
  return uVar2;
}

void af_dataCnfHandler(void *arg)

{
  byte bVar1;
  af_endpoint_descriptor_t *paVar2;
  af_endpoint_descriptor_t *paVar3;
  byte bVar4;

  paVar2 = af_zdoSimpleDescriptorGet();
  paVar3 = af_epDescriptorGet();
  bVar1 = af_availableEpNumGet();
  if ((paVar2->cb_cnf == ll_reset) || (*(char *)((int)arg + 10) != '\0'))
  {
    if (bVar1 != 0)
    {
      bVar4 = 0;
      do
      {
        if ((paVar3->cb_cnf != ll_reset) && (paVar3->ep == *(u8 *)((int)arg + 10)))
          goto LAB_00026910;
        bVar4 = bVar4 + 1;
        paVar3 = paVar3 + 1;
      } while (bVar4 < bVar1);
    }
  }
  else
  {
  LAB_00026910:
    af_aps_data_entry(arg);
  }
  ev_buf_free((u8 *)arg);
  return;
}

void af_aps_data_entry(void *arg)

{
  ushort uVar1;
  byte bVar2;
  byte bVar3;
  u8 uVar4;
  zb_buf_t *buf;
  af_endpoint_descriptor_t *paVar5;
  u8 *pBuf;
  u8 *out;
  u16 uVar6;
  code *in_r3;
  uint uVar7;
  byte bVar8;

  buf = (zb_buf_t *)(*in_r3)();
  if (buf->buf[1] == '\0')
  {
    if (*(short *)(buf->buf + 6) == 0)
    {
      af_zdoSimpleDescriptorGet();
      af_aps_data_fragment_entry(buf);
      return;
    }
  }
  else
  {
    paVar5 = af_epDescriptorGet();
    bVar3 = af_availableEpNumGet();
    if (bVar3 != 0)
    {
      uVar7 = (uint)buf->buf[10] * 0x1000000 + 0x25000000;
      bVar2 = (byte)(uVar7 >> 0x18);
      pBuf = ev_buf_allocate((ushort)bVar2);
      if (pBuf != (u8 *)0x0)
      {
        memcpy(pBuf, buf, 0x23);
        uVar1 = *(ushort *)(buf->buf + 10);
        pBuf[0x23] = (u8)uVar1;
        pBuf[0x24] = (u8)((uint)uVar1 >> 8);
        memcpy(pBuf + 0x25, *(void **)(buf->buf + 0xc), (uint)uVar1);
        bVar8 = 0;
        do
        {
          uVar4 = buf->buf[1];
          if (paVar5->ep == uVar4)
          {
            uVar4 = af_profileIdMatched(*(u16 *)(buf->buf + 6), paVar5->correspond_simple_desc);
            if ((uVar4 != '\0') || (*(short *)(buf->buf + 6) == -0x3fa2))
            {
              if (paVar5->cb_rx != ll_reset)
              {
                uVar6 = *(u16 *)(buf->buf + 6);
                if (uVar6 == 0xffff)
                {
                  uVar6 = paVar5->correspond_simple_desc->app_profile_id;
                }
                pBuf[6] = (u8)uVar6;
                pBuf[7] = (u8)(uVar6 >> 8);
                af_aps_data_fragment_entry(pBuf);
                goto LAB_0002693a;
              }
              break;
            }
            uVar4 = buf->buf[1];
          }
          if ((uVar4 == 0xff) &&
              (((uVar4 = af_profileIdMatched(*(u16 *)(buf->buf + 6), paVar5->correspond_simple_desc),
                 uVar4 != '\0' || (*(short *)(buf->buf + 6) == -0x3fa2)) &&
                (paVar5->cb_rx != ll_reset))))
          {
            uVar6 = *(u16 *)(buf->buf + 6);
            if (uVar6 == 0xffff)
            {
              uVar6 = paVar5->correspond_simple_desc->app_profile_id;
            }
            pBuf[6] = (u8)uVar6;
            pBuf[7] = (u8)(uVar6 >> 8);
            pBuf[1] = paVar5->ep;
            out = ev_buf_allocate((ushort)bVar2);
            if (out == (u8 *)0x0)
              break;
            memcpy(out, pBuf, uVar7 >> 0x18);
            af_aps_data_fragment_entry(out);
          }
          bVar8 = bVar8 + 1;
          paVar5 = paVar5 + 1;
        } while (bVar8 < bVar3);
        ev_buf_free(pBuf);
      }
    }
  }
LAB_0002693a:
  zb_buf_free(buf);
  return;
}

void af_aps_data_fragment_entry(void *arg)

{
  byte bVar1;
  u8 uVar2;
  u8 *pBuf;
  af_endpoint_descriptor_t *paVar3;
  u16 uVar4;
  code *in_r3;
  byte bVar5;

  pBuf = (u8 *)(*in_r3)();
  paVar3 = af_epDescriptorGet();
  bVar1 = af_availableEpNumGet();
  if (bVar1 != 0)
  {
    bVar5 = 0;
    do
    {
      if (((pBuf[1] == paVar3->ep) &&
           (uVar2 = af_clsuterIdMatched(*(u16 *)(pBuf + 8), paVar3->correspond_simple_desc),
            uVar2 != '\0')) &&
          ((uVar2 = af_profileIdMatched(*(u16 *)(pBuf + 6), paVar3->correspond_simple_desc),
            uVar2 != '\0' || (*(short *)(pBuf + 6) == -0x3fa2))))
      {
        if (paVar3->cb_rx != ll_reset)
        {
          uVar4 = *(u16 *)(pBuf + 6);
          if (uVar4 == 0xffff)
          {
            uVar4 = paVar3->correspond_simple_desc->app_profile_id;
          }
          pBuf[6] = (u8)uVar4;
          pBuf[7] = (u8)(uVar4 >> 8);
          _cgp_mcpsDataIndFilter();
          return;
        }
        break;
      }
      bVar5 = bVar5 + 1;
      paVar3 = paVar3 + 1;
    } while (bVar5 < bVar1);
  }
  ev_buf_free(pBuf);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

byte _cgp_mcpsDataIndFilter(void)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  byte bVar4;
  code *in_r3;

  pbVar3 = (byte *)(*in_r3)();
  bVar1 = *pbVar3;
  bVar4 = 1;
  if (((((bVar1 & 0x3c) == 0xc) && ((bVar1 & 3) < 2)) && (bVar4 = 0, (bVar1 & 0x80) != 0)) &&
      (bVar4 = 1, (bVar1 & 3) != 1))
  {
    bVar2 = pbVar3[1];
    if ((((bVar1 & 0x40) == 0) || ((bVar2 & 0x40) == 0)) &&
        ((bVar4 = bVar2 >> 7, (bVar2 & 7) != 2 && (bVar4 = 1, (bVar2 & 7) == 0))))
    {
      bVar4 = bVar2 >> 7;
    }
  }
  return bVar4;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

byte cgp_mcpsDataIndFilter(void)

{
  byte bVar1;
  byte bVar2;
  byte *in_r0;
  byte bVar3;

  bVar1 = *in_r0;
  bVar3 = 1;
  if (((((bVar1 & 0x3c) == 0xc) && ((bVar1 & 3) < 2)) && (bVar3 = 0, (bVar1 & 0x80) != 0)) &&
      (bVar3 = 1, (bVar1 & 3) != 1))
  {
    bVar2 = in_r0[1];
    if ((((bVar1 & 0x40) == 0) || ((bVar2 & 0x40) == 0)) &&
        ((bVar3 = bVar2 >> 7, (bVar2 & 7) != 2 && (bVar3 = 1, (bVar2 & 7) == 0))))
    {
      bVar3 = bVar2 >> 7;
    }
  }
  return bVar3;
}

void cGp_mcpsDataInd(void *arg)

{
  undefined uVar1;
  undefined uVar2;
  undefined uVar3;
  undefined uVar4;
  undefined uVar5;
  undefined uVar6;
  undefined4 uVar7;
  ushort uVar8;
  ushort uVar9;
  int iVar10;
  undefined local_60;
  undefined local_5c;
  undefined auStack_50[20];
  undefined auStack_3c[10];
  undefined auStack_32[14];

  uVar1 = *(undefined *)((int)arg + 0xc2);
  memcpy(auStack_50, arg, 0x2c);
  uVar7 = *(undefined4 *)((int)arg + 4);
  uVar8 = *(ushort *)((int)arg + 0x10);
  uVar9 = *(ushort *)((int)arg + 0x12);
  uVar5 = *(undefined *)((int)arg + 0x1c);
  uVar6 = *(undefined *)((int)arg + 0x1d);
  uVar2 = *(undefined *)((int)arg + 0x26);
  uVar3 = *(undefined *)((int)arg + 0x27);
  uVar4 = *(undefined *)((int)arg + 0x28);
  iVar10 = cgp_mcpsDataIndFilter();
  if (iVar10 == 0)
  {
    *(undefined *)((int)arg + 0x1b) = uVar3;
    *(undefined *)((int)arg + 0x1a) = uVar1;
    *(undefined *)((int)arg + 0x1c) = uVar4;
    *(undefined *)((int)arg + 0x18) = uVar5;
    local_60 = (undefined)uVar8;
    *(undefined *)((int)arg + 4) = local_60;
    *(char *)((int)arg + 5) = (char)((uint)uVar8 >> 8);
    memcpy((void *)((int)arg + 8), auStack_3c, 8);
    *(undefined *)((int)arg + 0x19) = uVar2;
    local_5c = (undefined)uVar9;
    *(undefined *)((int)arg + 6) = local_5c;
    *(char *)((int)arg + 7) = (char)((uint)uVar9 >> 8);
    memcpy((void *)((int)arg + 0x10), auStack_32, 8);
    *(undefined *)((int)arg + 0x1d) = uVar6;
    *(char *)arg = (char)uVar7;
    *(char *)((int)arg + 1) = (char)((uint)uVar7 >> 8);
    *(char *)((int)arg + 2) = (char)((uint)uVar7 >> 0x10);
    *(char *)((int)arg + 3) = (char)((uint)uVar7 >> 0x18);
    tl_zbTaskPost(dGp_dataInd, arg);
  }
  else
  {
    zb_buf_free((zb_buf_t *)arg);
  }
  return;
}

void cGp_dataCnf(void *arg)

{
  cGpDataCnfHandler(arg);
  return;
}

s32 cGp_dataReq(void *arg)

{
  undefined uVar1;
  undefined uVar2;
  undefined uVar3;
  undefined uVar4;
  undefined4 uVar5;
  ushort uVar6;
  undefined auStack_44[16];
  undefined auStack_34[12];
  byte bStack_28;

  memcpy(auStack_44, arg, 0x1d);
  // WARNING: Load size is inaccurate
  uVar5 = *arg;
  uVar6 = *(ushort *)((int)arg + 6);
  uVar1 = *(undefined *)((int)arg + 0x18);
  uVar2 = *(undefined *)((int)arg + 0x19);
  uVar3 = *(undefined *)((int)arg + 0x1a);
  uVar4 = *(undefined *)((int)arg + 0x1b);
  memset(arg, 0, 0x26);
  *(undefined *)((int)arg + 8) = uVar1;
  *(undefined *)((int)arg + 0x13) = uVar2;
  memcpy((void *)((int)arg + 0xb), auStack_34, 8);
  *(char *)((int)arg + 9) = (char)uVar6;
  *(char *)((int)arg + 10) = (char)((uint)uVar6 >> 8);
  *(undefined *)((int)arg + 0x19) = uVar4;
  *(char *)((int)arg + 0x15) = (char)uVar5;
  *(char *)((int)arg + 0x16) = (char)((uint)uVar5 >> 8);
  *(char *)((int)arg + 0x17) = (char)((uint)uVar5 >> 0x10);
  *(char *)((int)arg + 0x18) = (char)((uint)uVar5 >> 0x18);
  *(undefined *)((int)arg + 0x14) = uVar3;
  if ((int)((uint)bStack_28 << 0x1e) < 0)
  {
    *(byte *)((int)arg + 0x1a) = *(byte *)((int)arg + 0x1a) | 1;
  }
  if ((int)((uint)bStack_28 << 0x1f) < 0)
  {
    *(byte *)((int)arg + 0x1a) = *(byte *)((int)arg + 0x1a) | 8;
  }
  tl_zbMacMcpsDataRequestProc(arg);
  return -2;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpSecReqSend(void)

{
  u8 uVar1;
  u8 uVar2;
  u8 uVar3;
  u8 uVar4;
  undefined4 uVar5;
  zb_buf_t *in_r0;
  int iVar6;
  undefined auStack_38[20];

  if ((gpStubCb == 0) || (*(int *)(gpStubCb + 8) == 0))
  {
    zb_buf_free(in_r0);
  }
  else
  {
    memcpy(auStack_38, in_r0, 0x11);
    uVar5 = *(undefined4 *)(in_r0->buf + 8);
    uVar1 = in_r0->buf[0xc];
    uVar2 = in_r0->buf[0xd];
    uVar3 = in_r0->buf[0xe];
    uVar4 = in_r0->buf[0x10];
    iVar6 = gpDataIndDuplicateFind();
    if (iVar6 == 0)
    {
      _gpTxQueueListClear();
    }
    else
    {
      memset(in_r0, 0, 0x22);
      in_r0->buf[0xe] = uVar1;
      in_r0->buf[0xd] = uVar4;
      in_r0->buf[0xf] = uVar2;
      memcpy(in_r0, auStack_38, 8);
      in_r0->buf[0x20] = uVar3;
      in_r0->buf[8] = (u8)uVar5;
      in_r0->buf[9] = (u8)((uint)uVar5 >> 8);
      in_r0->buf[10] = (u8)((uint)uVar5 >> 0x10);
      in_r0->buf[0xb] = (u8)((uint)uVar5 >> 0x18);
      in_r0->buf[0xc] = '\0';
      tl_zbTaskPost(gpSecRsp, in_r0);
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void _gpTxQueueListClear(void)

{
  zb_buf_t **ppzVar1;
  code *in_r3;

  ppzVar1 = (zb_buf_t **)(*in_r3)();
  if (*ppzVar1 != (zb_buf_t *)0x0)
  {
    zb_buf_free(*ppzVar1);
  }
  *(undefined *)ppzVar1 = 0;
  *(undefined *)((int)ppzVar1 + 1) = 0;
  *(undefined *)((int)ppzVar1 + 2) = 0;
  *(undefined *)((int)ppzVar1 + 3) = 0;
  *(undefined *)(ppzVar1 + 1) = 0;
  *(undefined *)((int)ppzVar1 + 5) = 0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpTxQueueListClear(void)

{
  zb_buf_t **in_r0;

  if (*in_r0 != (zb_buf_t *)0x0)
  {
    zb_buf_free(*in_r0);
  }
  *(undefined *)in_r0 = 0;
  *(undefined *)((int)in_r0 + 1) = 0;
  *(undefined *)((int)in_r0 + 2) = 0;
  *(undefined *)((int)in_r0 + 3) = 0;
  *(undefined *)(in_r0 + 1) = 0;
  *(undefined *)((int)in_r0 + 5) = 0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpTxQueueListReplace(void)

{
  zb_buf_t **in_r0;
  int in_r1;

  if (*(char *)((int)in_r0 + 5) != '\0')
  {
    if (*in_r0 != (zb_buf_t *)0x0)
    {
      zb_buf_free(*in_r0);
    }
    *(char *)in_r0 = (char)in_r1;
    *(char *)((int)in_r0 + 1) = (char)((uint)in_r1 >> 8);
    *(char *)((int)in_r0 + 2) = (char)((uint)in_r1 >> 0x10);
    *(char *)((int)in_r0 + 3) = (char)((uint)in_r1 >> 0x18);
    *(undefined *)(in_r0 + 1) = *(undefined *)(in_r1 + 0x16);
  }
  return;
}

void gpTxQueueMaintenceClear(void)

{
  if ((((gpTxQueue._5_1_ != '\0') && ((int)gpTxQueue != 0)) &&
       (*(char *)((int)gpTxQueue + 0x12) == '\0')) &&
      (*(int *)((int)gpTxQueue + 8) == 0))
  {
    gpTxQueueListClear();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpTxQueueInit(void)

{
  gpTxQueueListClear();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpTxQueueFree(void)

{
  gpTxQueueInit();
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpDataIndSecReqEntryClear(void)

{
  zb_buf_t **in_r0;

  if (*in_r0 != (zb_buf_t *)0x0)
  {
    zb_buf_free(*in_r0);
  }
  memset(in_r0, 0, 0x13);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpDataIndSend(void)

{
  u8 uVar1;
  u8 uVar2;
  int in_r0;

  if ((gpStubCb == 0) || (*(int *)(gpStubCb + 4) == 0))
  {
    gpDataIndSecReqEntryClear();
  }
  else
  {
    *(undefined *)(in_r0 + 0x10) = g_gpBaseCtx._5_1_;
    uVar1 = g_gpBaseCtx._4_1_;
    if (((int)g_gpBaseCtx == 0) || (uVar2 = rf_getChannel(), uVar1 == uVar2))
    {
      _gpDataIndSecReqEntryAdd();
    }
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *_gpDataIndSecReqEntryAdd(void)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  code *in_r3;
  uint uVar4;
  uint uVar5;

  iVar3 = (*in_r3)();
  uVar4 = 0;
  do
  {
    uVar5 = uVar4 & 0xff;
    if (-1 < (int)((uint)(byte)g_gpDataIndSecReqTab[uVar4 * 0x13 + 0x12] << 0x19))
    {
      iVar1 = uVar5 * 0x13;
      g_gpDataIndSecReqTab[iVar1 + 0x12] = g_gpDataIndSecReqTab[iVar1 + 0x12] | 0x40;
      g_gpDataIndSecReqTab[iVar1] = (char)iVar3;
      g_gpDataIndSecReqTab[iVar1 + 1] = (char)((uint)iVar3 >> 8);
      g_gpDataIndSecReqTab[iVar1 + 2] = (char)((uint)iVar3 >> 0x10);
      g_gpDataIndSecReqTab[iVar1 + 3] = (char)((uint)iVar3 >> 0x18);
      g_gpDataIndSecReqTab[iVar1 + 0x12] =
          g_gpDataIndSecReqTab[iVar1 + 0x12] & 0xf8 | *(byte *)(iVar3 + 0x21) & 7;
      if ((g_gpDataIndSecReqTab[iVar1 + 0x12] & 7) == 0)
      {
        uVar2 = *(undefined4 *)(iVar3 + 4);
        g_gpDataIndSecReqTab[iVar1 + 8] = (char)uVar2;
        g_gpDataIndSecReqTab[iVar1 + 9] = (char)((uint)uVar2 >> 8);
        g_gpDataIndSecReqTab[iVar1 + 10] = (char)((uint)uVar2 >> 0x10);
        g_gpDataIndSecReqTab[iVar1 + 0xb] = (char)((uint)uVar2 >> 0x18);
      }
      else
      {
        memcpy(g_gpDataIndSecReqTab + iVar1 + 8, (void *)(iVar3 + 0x10), 8);
      }
      iVar3 = uVar5 * 0x13;
      g_gpDataIndSecReqTab[iVar3 + 4] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 5] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 6] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 7] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 0x10] = 0xfe;
      dGpStubHandle = dGpStubHandle + 1;
      if (0xbd < dGpStubHandle)
      {
        dGpStubHandle = 0x70;
      }
      g_gpDataIndSecReqTab[uVar5 * 0x13 + 0x11] = dGpStubHandle;
      return g_gpDataIndSecReqTab + iVar1;
    }
    uVar4 = uVar4 + 1;
  } while (uVar4 != 4);
  return (undefined1 *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined1 *gpDataIndSecReqEntryAdd(void)

{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  int in_r0;
  uint uVar4;
  uint uVar5;

  uVar4 = 0;
  do
  {
    uVar5 = uVar4 & 0xff;
    if (-1 < (int)((uint)(byte)g_gpDataIndSecReqTab[uVar4 * 0x13 + 0x12] << 0x19))
    {
      iVar1 = uVar5 * 0x13;
      g_gpDataIndSecReqTab[iVar1 + 0x12] = g_gpDataIndSecReqTab[iVar1 + 0x12] | 0x40;
      g_gpDataIndSecReqTab[iVar1] = (char)in_r0;
      g_gpDataIndSecReqTab[iVar1 + 1] = (char)((uint)in_r0 >> 8);
      g_gpDataIndSecReqTab[iVar1 + 2] = (char)((uint)in_r0 >> 0x10);
      g_gpDataIndSecReqTab[iVar1 + 3] = (char)((uint)in_r0 >> 0x18);
      g_gpDataIndSecReqTab[iVar1 + 0x12] =
          g_gpDataIndSecReqTab[iVar1 + 0x12] & 0xf8 | *(byte *)(in_r0 + 0x21) & 7;
      if ((g_gpDataIndSecReqTab[iVar1 + 0x12] & 7) == 0)
      {
        uVar2 = *(undefined4 *)(in_r0 + 4);
        g_gpDataIndSecReqTab[iVar1 + 8] = (char)uVar2;
        g_gpDataIndSecReqTab[iVar1 + 9] = (char)((uint)uVar2 >> 8);
        g_gpDataIndSecReqTab[iVar1 + 10] = (char)((uint)uVar2 >> 0x10);
        g_gpDataIndSecReqTab[iVar1 + 0xb] = (char)((uint)uVar2 >> 0x18);
      }
      else
      {
        memcpy(g_gpDataIndSecReqTab + iVar1 + 8, (void *)(in_r0 + 0x10), 8);
      }
      iVar3 = uVar5 * 0x13;
      g_gpDataIndSecReqTab[iVar3 + 4] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 5] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 6] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 7] = 0xfe;
      g_gpDataIndSecReqTab[iVar3 + 0x10] = 0xfe;
      dGpStubHandle = dGpStubHandle + 1;
      if (0xbd < dGpStubHandle)
      {
        dGpStubHandle = 0x70;
      }
      g_gpDataIndSecReqTab[uVar5 * 0x13 + 0x11] = dGpStubHandle;
      return g_gpDataIndSecReqTab + iVar1;
    }
    uVar4 = uVar4 + 1;
  } while (uVar4 != 4);
  return (undefined1 *)0x0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpDataIndSecReqTabInit(void)

{
  int iVar1;

  iVar1 = 0;
  do
  {
    gpDataIndSecReqEntryClear();
    iVar1 = iVar1 + 1;
  } while (iVar1 != 4);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpStubCbInit(void)

{
  undefined4 in_r0;

  gpTxQueueInit();
  gpDataIndSecReqTabInit();
  gpStubCb = in_r0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

byte gpNwkHdrFrameCtrlBuild(void)

{
  byte in_r0;
  uint in_r1;
  byte in_r2;
  uint in_r3;
  char in_stack_00000000;
  uint in_stack_00000004;
  uint in_stack_00000008;
  byte *in_stack_0000000c;
  byte local_28;

  local_28 = (byte)((in_r1 & 1) << 6) | in_r0 & 3 | 0xc;
  if (in_stack_0000000c != (byte *)0x0)
  {
    local_28 = 0x7f;
    *in_stack_0000000c = *in_stack_0000000c & 0xf8 | in_r2 & 7;
    *in_stack_0000000c = *in_stack_0000000c & 0xe7 | (byte)((in_r3 & 3) << 3);
    *in_stack_0000000c = *in_stack_0000000c & 0xdf | ('\x01' - (in_stack_00000000 == '\0')) * ' ';
    *in_stack_0000000c = *in_stack_0000000c & 0xbf | (byte)((in_stack_00000004 & 1) << 6);
    *in_stack_0000000c = *in_stack_0000000c & 0x7f | (byte)((in_stack_00000008 & 0xff) << 7);
  }
  return local_28;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint gpNwkHdrParse(void)

{
  byte bVar1;
  void *in_r0;
  undefined *in_r1;
  undefined *in;
  byte bVar2;

  *(undefined *)((int)in_r0 + 8) = *in_r1;
  in = in_r1 + 1;
  bVar1 = *(byte *)((int)in_r0 + 8);
  bVar2 = 0;
  if ((bVar1 & 0x80) != 0)
  {
    *(undefined *)((int)in_r0 + 9) = in_r1[1];
    bVar2 = *(byte *)((int)in_r0 + 9);
    if (((bVar2 & 7) != 2) && ((bVar2 & 7) != 0))
    {
      return 0;
    }
    if ((bVar2 & 0x80) != 0)
    {
      return 0;
    }
    in = in_r1 + 2;
    bVar2 = bVar2 & 7;
  }
  if (((bVar1 & 3 | bVar2) == 0) || (((bVar1 & 0x83) == 0x81 && (bVar2 == 0))))
  {
    memcpy(in_r0, in, 4);
    in = in + 4;
    bVar1 = *(byte *)((int)in_r0 + 8);
  }
  if (bVar2 == 2)
  {
    *(undefined *)((int)in_r0 + 10) = *in;
    in = in + 1;
  }
  if (((bVar1 & 0x80) != 0) && (1 < ((uint) * (byte *)((int)in_r0 + 9) << 0x1b) >> 0x1e))
  {
    memcpy((void *)((int)in_r0 + 4), in, 4);
    in = in + 4;
  }
  return (int)in - (int)in_r1 & 0xff;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

u8 dGpStubHandleGet(void)

{
  dGpStubHandle = dGpStubHandle + 1;
  if (0xbd < dGpStubHandle)
  {
    dGpStubHandle = 0x70;
  }
  return dGpStubHandle;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gp_gpdfCreat(void)

{
  int *in_r0;
  byte *pbVar1;
  byte in_r1;
  byte *pbVar2;
  byte in_r2;
  undefined4 in_r3;
  uint uVar3;
  uint uVar4;
  undefined4 in_stack_00000000;
  byte *in_stack_00000004;

  uVar3 = (uint)(byte)(*in_stack_00000004 + 2);
  *in_stack_00000004 = *in_stack_00000004 + 2;
  if ((in_r1 & 0x80) != 0)
  {
    uVar4 = uVar3 + 1;
    uVar3 = uVar4 & 0xff;
    *in_stack_00000004 = (byte)(uVar4 * 0x1000000 >> 0x18);
    if ((in_r2 & 0x18) == 0x18)
    {
      uVar4 = uVar3 + 8;
      uVar3 = uVar4 & 0xff;
      *in_stack_00000004 = (byte)(uVar4 * 0x1000000 >> 0x18);
    }
    else if ((in_r2 & 0x18) == 0x10)
    {
      uVar4 = uVar3 + 8;
      uVar3 = uVar4 & 0xff;
      *in_stack_00000004 = (byte)(uVar4 * 0x1000000 >> 0x18);
    }
  }
  if ((in_r1 & 3) == 0)
  {
    if (*(char *)((int)in_r0 + 0x12) == '\x02')
    {
      uVar4 = uVar3 + 1;
      uVar3 = uVar4 & 0xff;
      *in_stack_00000004 = (byte)(uVar4 * 0x1000000 >> 0x18);
    }
    else
    {
      uVar4 = uVar3 + 4;
      uVar3 = uVar4 & 0xff;
      *in_stack_00000004 = (byte)(uVar4 * 0x1000000 >> 0x18);
    }
  }
  pbVar1 = (byte *)(*in_r0 - uVar3);
  *in_stack_00000004 = (char)uVar3 + *(char *)((int)in_r0 + 0x15);
  *pbVar1 = in_r1;
  pbVar2 = pbVar1 + 1;
  if ((in_r1 & 0x80) != 0)
  {
    pbVar1[1] = in_r2;
    pbVar2 = pbVar1 + 2;
  }
  if ((in_r1 & 3) == 0)
  {
    if (*(char *)((int)in_r0 + 0x12) == '\x02')
    {
      *pbVar2 = *(byte *)((int)in_r0 + 0x13);
      pbVar2 = pbVar2 + 1;
    }
    else
    {
      *pbVar2 = *(byte *)(in_r0 + 2);
      pbVar2[1] = *(byte *)((int)in_r0 + 9);
      pbVar2[2] = *(byte *)((int)in_r0 + 10);
      pbVar2[3] = *(byte *)((int)in_r0 + 0xb);
      pbVar2 = pbVar2 + 4;
    }
  }
  if (((in_r1 & 0x80) != 0) && (((in_r2 & 0x18) == 0x18 || ((in_r2 & 0x18) == 0x10))))
  {
    *pbVar2 = (byte)in_r3;
    pbVar2[1] = (byte)((uint)in_r3 >> 8);
    pbVar2[2] = (byte)((uint)in_r3 >> 0x10);
    pbVar2[3] = (byte)((uint)in_r3 >> 0x18);
    pbVar2 = pbVar2 + 4;
  }
  *pbVar2 = *(byte *)(in_r0 + 5);
  pbVar2 = pbVar2 + 1;
  if (*(byte *)((int)in_r0 + 0x15) != 0)
  {
    pbVar2 = pbVar2 + *(byte *)((int)in_r0 + 0x15);
  }
  if (((in_r1 & 0x80) != 0) && (((in_r2 & 0x18) == 0x18 || ((in_r2 & 0x18) == 0x10))))
  {
    *pbVar2 = (byte)in_stack_00000000;
    pbVar2[1] = (byte)((uint)in_stack_00000000 >> 8);
    pbVar2[2] = (byte)((uint)in_stack_00000000 >> 0x10);
    pbVar2[3] = (byte)((uint)in_stack_00000000 >> 0x18);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gp_gpdfGenerate(void)

{
  undefined uVar1;
  byte bVar2;
  void *pvVar3;
  undefined *arg;
  u16 uVar4;
  void **in_r0;
  undefined4 uVar5;
  char in_r1;
  undefined4 uStack_38;
  undefined4 uStack_34;
  undefined uStack_2d;
  byte local_2c;
  undefined local_28;

  uStack_38 = 0;
  uStack_34 = 0;
  local_28 = 0;
  local_2c = 0;
  pvVar3 = *in_r0;
  memcpy(&uStack_38, (void *)((int)pvVar3 + 8), 8);
  uVar1 = *(undefined *)((int)pvVar3 + 0x16);
  bVar2 = *(byte *)((int)pvVar3 + 0x10);
  if (in_r1 == '\x01')
  {
    FUN_00027628();
    return;
  }
  local_28 = gpNwkHdrFrameCtrlBuild();
  uStack_2d = 0;
  uVar5 = gp_gpdfCreat();
  arg = (undefined *)*in_r0;
  *arg = (char)uVar5;
  arg[1] = (char)((uint)uVar5 >> 8);
  arg[2] = (char)((uint)uVar5 >> 0x10);
  arg[3] = (char)((uint)uVar5 >> 0x18);
  arg[0x1a] = uStack_2d;
  uVar4 = g_zbInfo.nwkNib.panId;
  arg[4] = (char)g_zbInfo.nwkNib.panId;
  arg[5] = (char)(uVar4 >> 8);
  arg[6] = 0xfe;
  arg[7] = 0xfe;
  arg[0x18] = 0;
  if ((local_2c & 7) == 0)
  {
    arg[0x19] = 2;
    arg[0x10] = 0xfe;
    arg[0x11] = 0xfe;
  }
  else if ((local_2c & 7) == 2)
  {
    arg[0x19] = 3;
    memcpy(arg + 0x10, &uStack_38, 8);
  }
  arg[0x1b] = uVar1;
  arg[0x1c] = arg[0x1c] & 0xfe | (byte)(((uint)bVar2 << 0x1e) >> 0x1f);
  arg[0x1c] = arg[0x1c] & 0xfd | (byte)((((uint)bVar2 << 0x1d) >> 0x1f) << 1);
  *(undefined *)((int)*in_r0 + 0xc1) = uVar1;
  ev_timer_taskPost(cGp_dataReq, arg, 0x14);
  return;
}

void FUN_00027540(void)

{
  undefined *arg;
  u16 uVar1;
  undefined4 uVar2;
  void **unaff_r5;
  undefined *unaff_r6;
  byte *unaff_r8;
  void *unaff_r9;
  undefined unaff_fp;
  undefined4 param_5;
  byte param_9;
  int param_10;

  *unaff_r6 = 0;
  param_5 = 0;
  uVar2 = gp_gpdfCreat();
  arg = (undefined *)*unaff_r5;
  *arg = (char)uVar2;
  arg[1] = (char)((uint)uVar2 >> 8);
  arg[2] = (char)((uint)uVar2 >> 0x10);
  arg[3] = (char)((uint)uVar2 >> 0x18);
  arg[0x1a] = *unaff_r6;
  uVar1 = g_zbInfo.nwkNib.panId;
  arg[4] = (char)g_zbInfo.nwkNib.panId;
  arg[5] = (char)(uVar1 >> 8);
  arg[6] = 0xfe;
  arg[7] = 0xfe;
  arg[0x18] = 0;
  if ((*unaff_r8 & 7) == 0)
  {
    arg[0x19] = 2;
    arg[0x10] = 0xfe;
    arg[0x11] = 0xfe;
  }
  else if ((*unaff_r8 & 7) == 2)
  {
    arg[0x19] = 3;
    memcpy(arg + 0x10, unaff_r9, 8);
  }
  arg[0x1b] = unaff_fp;
  arg[0x1c] = arg[0x1c] & 0xfe | param_9;
  arg[0x1c] = arg[0x1c] & 0xfd | (byte)(param_10 << 1);
  *(undefined *)((int)*unaff_r5 + 0xc1) = unaff_fp;
  ev_timer_taskPost(cGp_dataReq, arg, 0x14);
  return;
}

void FUN_00027628(void)

{
  undefined *arg;
  u16 uVar1;
  undefined uVar2;
  undefined4 uVar3;
  void **unaff_r5;
  byte *unaff_r8;
  void *unaff_r9;
  undefined *unaff_sl;
  undefined unaff_fp;
  byte in_stack_00000010;
  int in_stack_00000014;
  undefined uStack00000023;

  uVar2 = gpNwkHdrFrameCtrlBuild();
  *unaff_sl = uVar2;
  uStack00000023 = 0;
  uVar3 = gp_gpdfCreat();
  arg = (undefined *)*unaff_r5;
  *arg = (char)uVar3;
  arg[1] = (char)((uint)uVar3 >> 8);
  arg[2] = (char)((uint)uVar3 >> 0x10);
  arg[3] = (char)((uint)uVar3 >> 0x18);
  arg[0x1a] = uStack00000023;
  uVar1 = g_zbInfo.nwkNib.panId;
  arg[4] = (char)g_zbInfo.nwkNib.panId;
  arg[5] = (char)(uVar1 >> 8);
  arg[6] = 0xfe;
  arg[7] = 0xfe;
  arg[0x18] = 0;
  if ((*unaff_r8 & 7) == 0)
  {
    arg[0x19] = 2;
    arg[0x10] = 0xfe;
    arg[0x11] = 0xfe;
  }
  else if ((*unaff_r8 & 7) == 2)
  {
    arg[0x19] = 3;
    memcpy(arg + 0x10, unaff_r9, 8);
  }
  arg[0x1b] = unaff_fp;
  arg[0x1c] = arg[0x1c] & 0xfe | in_stack_00000010;
  arg[0x1c] = arg[0x1c] & 0xfd | (byte)(in_stack_00000014 << 1);
  *(undefined *)((int)*unaff_r5 + 0xc1) = unaff_fp;
  ev_timer_taskPost(cGp_dataReq, arg, 0x14);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gp_gpdfTransSchedule(void)

{
  int iVar1;
  int iVar2;
  char in_r1;
  uint n;
  char in_stack_00000000;
  undefined local_20[8];

  iVar1 = (int)gpTxQueue;
  n = 4;
  if (in_r1 != '\0')
  {
    if (in_r1 != '\x02')
    {
      return;
    }
    n = 8;
  }
  if ((((gpTxQueue._5_1_ != '\0') && (*(char *)((int)gpTxQueue + 0x12) == in_r1)) &&
       (iVar2 = memcmp((void *)((int)gpTxQueue + 8), local_20, n), iVar2 == 0)) &&
      (((in_r1 != '\x02' || (in_stack_00000000 == -1)) ||
        (*(char *)(iVar1 + 0x13) == in_stack_00000000))))
  {
    *(byte *)(iVar1 + 0x10) = *(byte *)(iVar1 + 0x10) & 0xfd;
    *(byte *)(iVar1 + 0x10) = *(byte *)(iVar1 + 0x10) & 0xfb;
    gp_gpdfGenerate();
    gpTxQueue._0_4_ = 0;
    gpTxQueue._4_1_ = 0;
    gpTxQueue._5_1_ = '\0';
  }
  return;
}

void FUN_00027678(void)

{
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpSecRsp(void)

{
  u8 uVar1;
  byte bVar2;
  byte **ppbVar3;
  u8 uVar4;
  zb_buf_t *in_r0;
  u8 *puVar5;
  undefined1 *arg;
  uint uVar6;
  uint uVar7;
  byte *pbStack_2c;
  undefined4 uStack_28;

  puVar5 = g_gpDataIndSecReqTab + 0x11;
  uVar6 = 0;
  while ((uVar7 = uVar6 & 0xff,
          -1 < (int)((uint)(byte)g_gpDataIndSecReqTab[uVar6 * 0x13 + 0x12] << 0x19) ||
              (*puVar5 != in_r0->buf[0xd])))
  {
    uVar6 = uVar6 + 1;
    puVar5 = puVar5 + 0x13;
    if (uVar6 == 4)
    {
      zb_buf_free(in_r0);
      return;
    }
  }
  arg = g_gpDataIndSecReqTab + uVar7 * 0x13;
  ppbVar3 = *(byte ***)(g_gpDataIndSecReqTab + uVar7 * 0x13);
  *(u8 *)((int)ppbVar3 + 0x23) = in_r0->buf[0x21];
  pbStack_2c = (byte *)0x0;
  uStack_28 = 0;
  uVar4 = *(u8 *)((int)ppbVar3 + 0x21);
  if (uVar4 == '\0')
  {
    pbStack_2c = ppbVar3[1];
    uVar1 = in_r0->buf[0xc];
  }
  else
  {
    if (uVar4 == '\x02')
    {
      memcpy(&pbStack_2c, ppbVar3 + 4, 8);
    }
    uVar1 = in_r0->buf[0xc];
  }
  if (uVar1 == '\x01')
  {
    uVar4 = gpCcmStar(uVar4, (gpdId_t)(ulonglong)CONCAT14(*(undefined *)(ppbVar3 + 9), ((uint)(byte)g_gpDataIndSecReqTab[uVar7 * 0x13 + 0x12] << 0x1a) >> 0x1e), (u8)pbStack_2c, (u8)uStack_28,
                      (byte)(((uint)(byte)g_gpDataIndSecReqTab[uVar7 * 0x13 + 0x12] << 0x1c) >> 0x1f), (u32)ppbVar3[2], *(u8 *)((int)ppbVar3 + 0x26), *ppbVar3,
                      *(bool *)((int)ppbVar3 + 0x1a), *(bool *)((int)ppbVar3 + 0x1b), (u32)ppbVar3[3],
                      in_r0->buf + 0x10);
    if (uVar4 == '\0')
    {
      bVar2 = **ppbVar3;
      *(byte *)((int)ppbVar3 + 0x25) = bVar2;
      if ((bVar2 & 0xf0) == 0xf0)
        goto LAB_0002777e;
      if (*(char *)((int)ppbVar3 + 0x22) == '\0')
      {
        *(undefined *)(ppbVar3 + 7) = 1;
      }
      else
      {
        *(undefined *)(ppbVar3 + 7) = 0;
      }
      tl_zbTaskPost(gpDataIndSend, arg);
    }
    else
    {
      *(undefined *)(ppbVar3 + 7) = 3;
      tl_zbTaskPost(gpDataIndSend, arg);
    }
  }
  else
  {
    if (uVar1 == '\0')
    {
    LAB_0002777e:
      zb_buf_free(in_r0);
      gpDataIndSecReqEntryClear();
      return;
    }
    if (uVar1 == '\x02')
    {
      *(undefined *)(ppbVar3 + 7) = 4;
      tl_zbTaskPost(gpDataIndSend, arg);
    }
    else if (uVar1 == '\x03')
    {
      uVar4 = gpCcmStar(uVar4, (gpdId_t)(ulonglong)CONCAT14(*(undefined *)(ppbVar3 + 9), ((uint)(byte)g_gpDataIndSecReqTab[uVar7 * 0x13 + 0x12] << 0x1a) >> 0x1e), (u8)pbStack_2c, (u8)uStack_28,
                        (byte)(((uint)(byte)g_gpDataIndSecReqTab[uVar7 * 0x13 + 0x12] << 0x1c) >>
                               0x1f),
                        (u32)ppbVar3[2], *(u8 *)((int)ppbVar3 + 0x26), *ppbVar3,
                        *(bool *)((int)ppbVar3 + 0x1a), *(bool *)((int)ppbVar3 + 0x1b),
                        (u32)ppbVar3[3], in_r0->buf + 0x10);
      if (uVar4 == '\0')
      {
        bVar2 = **ppbVar3;
        *(byte *)((int)ppbVar3 + 0x25) = bVar2;
        if ((bVar2 & 0xf0) == 0xf0)
          goto LAB_0002777e;
        gpDataIndSecReqEntryClear();
      }
      else
      {
        *(undefined *)(ppbVar3 + 7) = 3;
        tl_zbTaskPost(gpDataIndSend, arg);
      }
    }
  }
  zb_buf_free(in_r0);
  if (*(int *)(g_gpDataIndSecReqTab + uVar7 * 0x13) == 0)
  {
    return;
  }
  if (*(char *)((int)ppbVar3 + 0x1b) != '\0')
  {
    gp_gpdfTransSchedule();
    return;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpDataFrameProcess(void)

{
  u8 uVar1;
  u8 uVar2;
  u8 uVar3;
  ushort uVar4;
  undefined4 uVar5;
  zb_buf_t *in_r0;
  undefined *dest;
  int iVar6;
  undefined4 *in_r1;
  uint uVar7;
  u8 in_r2;
  uint uVar8;
  byte bVar9;
  u8 *in_r3;
  uint uVar10;
  u8 in_stack_00000000;
  undefined4 in_stack_00000004;
  u8 local_54;
  undefined auStack_44[8];
  undefined auStack_3c[24];

  memcpy(auStack_44, in_r0, 0x1e);
  uVar4 = *(ushort *)(in_r0->buf + 4);
  uVar1 = in_r0->buf[0x18];
  uVar2 = in_r0->buf[0x1a];
  uVar3 = in_r0->buf[0x1b];
  bVar9 = in_r0->buf[0x1c];
  uVar7 = (uint)bVar9;
  memset(in_r0, 0, 0x28);
  in_r0->buf[0x1c] = '\x01';
  in_r0->buf[0x1d] = uVar2;
  in_r0->buf[0x1e] = uVar3;
  in_r0->buf[0x1f] = bVar9;
  in_r0->buf[0x20] = uVar1;
  local_54 = (u8)uVar4;
  in_r0->buf[0x18] = local_54;
  in_r0->buf[0x19] = (u8)((uint)uVar4 >> 8);
  memcpy(in_r0->buf + 0x10, auStack_3c, 8);
  in_r0->buf[0x21] = in_r2;
  uVar8 = 0;
  if ((*(byte *)(in_r1 + 2) & 0x80) != 0)
  {
    uVar8 = ((uint) * (byte *)((int)in_r1 + 9) << 0x1b) >> 0x1e;
  }
  in_r0->buf[0x22] = (u8)uVar8;
  in_r0->buf[0x23] = '\0';
  in_r0->buf[0x1a] = (byte)(((uint) * (byte *)(in_r1 + 2) << 0x19) >> 0x1f);
  bVar9 = 0;
  if ((*(byte *)(in_r1 + 2) & 0x80) != 0)
  {
    bVar9 = (byte)(((uint) * (byte *)((int)in_r1 + 9) << 0x19) >> 0x1f);
  }
  in_r0->buf[0x1b] = bVar9;
  uVar5 = *in_r1;
  in_r0->buf[4] = (u8)uVar5;
  in_r0->buf[5] = (u8)((uint)uVar5 >> 8);
  in_r0->buf[6] = (u8)((uint)uVar5 >> 0x10);
  in_r0->buf[7] = (u8)((uint)uVar5 >> 0x18);
  in_r0->buf[0x24] = *(u8 *)((int)in_r1 + 10);
  uVar10 = uVar7;
  if (uVar8 != 0)
  {
    uVar10 = in_r1[1];
  }
  in_r0->buf[8] = (u8)uVar10;
  in_r0->buf[9] = (u8)(uVar10 >> 8);
  in_r0->buf[10] = (u8)(uVar10 >> 0x10);
  in_r0->buf[0xb] = (u8)(uVar10 >> 0x18);
  in_r0->buf[0x25] = *in_r3;
  in_r0->buf[0] = (u8)in_r3;
  in_r0->buf[1] = (u8)((uint)in_r3 >> 8);
  in_r0->buf[2] = (u8)((uint)in_r3 >> 0x10);
  in_r0->buf[3] = (u8)((uint)in_r3 >> 0x18);
  in_r0->buf[0x26] = in_stack_00000000;
  in_r0->buf[0xc] = (u8)in_stack_00000004;
  in_r0->buf[0xd] = (u8)((uint)in_stack_00000004 >> 8);
  in_r0->buf[0xe] = (u8)((uint)in_stack_00000004 >> 0x10);
  in_r0->buf[0xf] = (u8)((uint)in_stack_00000004 >> 0x18);
  in_r0->buf[0x27] = (byte)(((uint) * (byte *)(in_r1 + 2) << 0x1e) >> 0x1e);
  dest = (undefined *)c1();
  if (dest == (undefined *)0x0)
  {
    zb_buf_free(in_r0);
    FUN_00027bde();
    return;
  }
  iVar6 = gpDataIndSecReqEntryAdd();
  if (iVar6 == 0)
  {
    FUN_00027c10();
    return;
  }
  uVar8 = 0;
  if ((*(byte *)(in_r1 + 2) & 0x80) != 0)
  {
    uVar8 = ((uint) * (byte *)((int)in_r1 + 9) << 0x1a) >> 0x1f;
  }
  *(byte *)(iVar6 + 0x12) = *(byte *)(iVar6 + 0x12) & 0xf7 | (byte)(uVar8 << 3);
  uVar8 = 0;
  if ((*(byte *)(in_r1 + 2) & 0x80) != 0)
  {
    uVar8 = ((uint) * (byte *)((int)in_r1 + 9) << 0x1b) >> 0x1e;
  }
  *(byte *)(iVar6 + 0x12) = *(byte *)(iVar6 + 0x12) & 0xcf | (byte)(uVar8 << 4);
  if ((*(byte *)(iVar6 + 0x12) & 0x30) != 0)
  {
    uVar7 = in_r1[1];
  }
  *(char *)(iVar6 + 4) = (char)uVar7;
  *(char *)(iVar6 + 5) = (char)(uVar7 >> 8);
  *(char *)(iVar6 + 6) = (char)(uVar7 >> 0x10);
  *(char *)(iVar6 + 7) = (char)(uVar7 >> 0x18);
  memset(dest, 0, 0x11);
  dest[0xc] = in_r2;
  if (in_r2 == '\0')
  {
    uVar5 = *in_r1;
    *dest = (char)uVar5;
    dest[1] = (char)((uint)uVar5 >> 8);
    dest[2] = (char)((uint)uVar5 >> 0x10);
    dest[3] = (char)((uint)uVar5 >> 0x18);
  }
  else if (in_r2 == '\x02')
  {
    memcpy(dest, auStack_3c, 8);
    dest[0xd] = in_r0->buf[0x24];
  }
  dest[0xe] = (byte)(((uint) * (byte *)(iVar6 + 0x12) << 0x1a) >> 0x1e);
  dest[0xf] = (byte)(((uint) * (byte *)(iVar6 + 0x12) << 0x1c) >> 0x1f);
  uVar5 = *(undefined4 *)(iVar6 + 4);
  dest[8] = (char)uVar5;
  dest[9] = (char)((uint)uVar5 >> 8);
  dest[10] = (char)((uint)uVar5 >> 0x10);
  dest[0xb] = (char)((uint)uVar5 >> 0x18);
  dest[0x10] = *(undefined *)(iVar6 + 0x11);
  tl_zbTaskPost(gpSecReqSend, dest);
  return;
}

void FUN_00027bde(void)

{
  return;
}

void FUN_00027c10(void)

{
  zb_buf_t *unaff_r4;
  zb_buf_t *unaff_r7;

  zb_buf_free(unaff_r7);
  zb_buf_free(unaff_r4);
  FUN_00027bde();
  return;
}

// WARNING: Removing unreachable block (RAM,0x00027c9c)
// WARNING: Removing unreachable block (RAM,0x00027c8e)
// WARNING: Removing unreachable block (RAM,0x00027dca)
// WARNING: Removing unreachable block (RAM,0x00027d2c)
// WARNING: Removing unreachable block (RAM,0x00027dbc)
// WARNING: Removing unreachable block (RAM,0x00027ca2)
// WARNING: Removing unreachable block (RAM,0x00027cba)
// WARNING: Removing unreachable block (RAM,0x00027cc4)
// WARNING: Removing unreachable block (RAM,0x00027cfc)
// WARNING: Removing unreachable block (RAM,0x00027d06)
// WARNING: Removing unreachable block (RAM,0x00027d0e)
// WARNING: Removing unreachable block (RAM,0x00027d8c)
// WARNING: Removing unreachable block (RAM,0x00027d96)
// WARNING: Removing unreachable block (RAM,0x00027d9a)
// WARNING: Removing unreachable block (RAM,0x00027d9e)

void dGp_dataInd(void *arg)

{
  uint uVar1;

  uVar1 = gpNwkHdrParse();
  if ((uVar1 == 0) || (*(byte *)((int)arg + 0x1d) <= uVar1))
  {
    zb_buf_free((zb_buf_t *)arg);
  }
  else
  {
    gpDataFrameProcess();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpDataCnfDeliver(void)

{
  char *in_r0;

  if ((gpStubCb != (int *)0x0) && (*gpStubCb != 0))
  {
    if ((*in_r0 == '\x05') && (in_r0[1] == -0x42))
    {
      gpTransmitChannelTimeoutStop();
    }
    _gpTxQueueCheck();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void _gpTxQueueCheck(void)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  zb_buf_t *pzVar4;
  zb_buf_t *buf;
  int iVar5;
  uint n;
  code *in_r3;
  uint uVar6;

  buf = (zb_buf_t *)(*in_r3)();
  pzVar4 = (zb_buf_t *)gpTxQueue;
  uVar6 = (uint)buf->buf[0x12];
  n = 4;
  if (uVar6 != 0)
  {
    n = ((uVar6 - 2) + ~(uVar6 - 2) + (uint)(1 < uVar6)) * 8;
  }
  if (gpTxQueue._5_1_ == '\0')
  {
    bVar1 = false;
    bVar3 = false;
  }
  else
  {
    if ((((zb_buf_t *)gpTxQueue)->buf[0x12] == uVar6) &&
        (iVar5 = memcmp(((zb_buf_t *)gpTxQueue)->buf + 8, buf->buf + 8, n), iVar5 == 0))
    {
      if (buf->buf[0x11] == '\0')
      {
        if (((uVar6 != 2) || (-1 < (int)((uint)buf->buf[0x10] << 0x1a))) ||
            (buf->buf[0x13] == pzVar4->buf[0x13]))
        {
          zb_buf_free(buf);
          gpTxQueueListClear();
          gpDataCnfDeliver();
          goto LAB_00027f3a;
        }
      }
      else
      {
        bVar1 = true;
        if (((uVar6 == 0) || (bVar1 = false, -1 < (int)((uint)buf->buf[0x10] << 0x1a))) ||
            (buf->buf[0x13] == pzVar4->buf[0x13]))
        {
          gpTxQueueListReplace();
          gpDataCnfDeliver();
          if (!bVar1)
          {
            bVar1 = true;
            bVar3 = true;
            goto LAB_00027e64;
          }
        LAB_00027f3a:
          bVar1 = true;
          bVar3 = true;
          bVar2 = true;
          goto LAB_00027e66;
        }
      }
    }
    bVar1 = false;
    bVar3 = true;
  }
LAB_00027e64:
  bVar2 = false;
LAB_00027e66:
  if ((!bVar1) && (!bVar2))
  {
    if (bVar3)
    {
      zb_buf_free(buf);
    }
    else if (buf->buf[0x11] == '\0')
    {
      zb_buf_free(buf);
    }
    else if (gpTxQueue._5_1_ == '\0')
    {
      gpTxQueue._5_1_ = '\x01';
      gpTxQueue._0_4_ = buf;
      gpTxQueue._4_1_ = buf->buf[0x16];
    }
    gpDataCnfDeliver();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpTxQueueCheck(void)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  zb_buf_t *pzVar4;
  zb_buf_t *in_r0;
  int iVar5;
  uint n;
  uint uVar6;

  pzVar4 = (zb_buf_t *)gpTxQueue;
  uVar6 = (uint)in_r0->buf[0x12];
  n = 4;
  if (uVar6 != 0)
  {
    n = ((uVar6 - 2) + ~(uVar6 - 2) + (uint)(1 < uVar6)) * 8;
  }
  if (gpTxQueue._5_1_ == '\0')
  {
    bVar1 = false;
    bVar3 = false;
  }
  else
  {
    if ((((zb_buf_t *)gpTxQueue)->buf[0x12] == uVar6) &&
        (iVar5 = memcmp(((zb_buf_t *)gpTxQueue)->buf + 8, in_r0->buf + 8, n), iVar5 == 0))
    {
      if (in_r0->buf[0x11] == '\0')
      {
        if (((uVar6 != 2) || (-1 < (int)((uint)in_r0->buf[0x10] << 0x1a))) ||
            (in_r0->buf[0x13] == pzVar4->buf[0x13]))
        {
          zb_buf_free(in_r0);
          gpTxQueueListClear();
          gpDataCnfDeliver();
          goto LAB_00027f3a;
        }
      }
      else
      {
        bVar1 = true;
        if (((uVar6 == 0) || (bVar1 = false, -1 < (int)((uint)in_r0->buf[0x10] << 0x1a))) ||
            (in_r0->buf[0x13] == pzVar4->buf[0x13]))
        {
          gpTxQueueListReplace();
          gpDataCnfDeliver();
          if (!bVar1)
          {
            bVar1 = true;
            bVar3 = true;
            goto LAB_00027e64;
          }
        LAB_00027f3a:
          bVar1 = true;
          bVar3 = true;
          bVar2 = true;
          goto LAB_00027e66;
        }
      }
    }
    bVar1 = false;
    bVar3 = true;
  }
LAB_00027e64:
  bVar2 = false;
LAB_00027e66:
  if ((!bVar1) && (!bVar2))
  {
    if (bVar3)
    {
      zb_buf_free(in_r0);
    }
    else if (in_r0->buf[0x11] == '\0')
    {
      zb_buf_free(in_r0);
    }
    else if (gpTxQueue._5_1_ == '\0')
    {
      gpTxQueue._5_1_ = '\x01';
      gpTxQueue._0_4_ = in_r0;
      gpTxQueue._4_1_ = in_r0->buf[0x16];
    }
    gpDataCnfDeliver();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpDataReq(void)

{
  zb_buf_t *in_r0;

  if ((int)((uint)in_r0->buf[0x10] << 0x1f) < 0)
  {
    if (in_r0->buf[0x12] == '\0')
    {
      in_r0->buf[0x10] = in_r0->buf[0x10] & 0xdf;
    }
    else if (in_r0->buf[0x12] != '\x02')
      goto LAB_00027f8a;
    in_r0->buf[4] = 0xfe;
    in_r0->buf[5] = 0xfe;
    in_r0->buf[6] = 0xfe;
    in_r0->buf[7] = '\0';
    gpTxQueueCheck();
  }
  else
  {
  LAB_00027f8a:
    zb_buf_free(in_r0);
  }
  return;
}

void cGpDataCnfHandler(void *arg)

{
  gpDataCnfDeliver();
  zb_buf_free((zb_buf_t *)arg);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 gpTransmitChannelTimeoutCb(void)

{
  u8 uVar1;
  u8 uVar2;

  uVar1 = g_gpBaseCtx._4_1_;
  uVar2 = rf_getChannel();
  if (uVar1 != uVar2)
  {
    tl_zbMacChannelSet(g_gpBaseCtx._4_1_);
  }
  gpTxQueueMaintenceClear();
  g_gpBaseCtx._0_4_ = 0;
  return 0xfffffffe;
}

void gpTransmitChannelTimeoutStop(void)

{
  u8 uVar1;
  u8 uVar2;

  uVar1 = g_gpBaseCtx._4_1_;
  uVar2 = rf_getChannel();
  if (uVar1 != uVar2)
  {
    tl_zbMacChannelSet(g_gpBaseCtx._4_1_);
  }
  if ((int)g_gpBaseCtx != 0)
  {
    ev_timer_taskCancel((ev_timer_event_t **)&g_gpBaseCtx);
  }
  return;
}

void gpSwitchToTransmitChannel(u8 operationChannel, u8 tempMasterTxChannel)

{
  byte bVar1;

  if ((uint)g_gpBaseCtx._4_1_ != operationChannel + 0xb)
  {
    g_gpBaseCtx._4_1_ = (byte)(operationChannel + 0xb);
  }
  bVar1 = rf_getChannel();
  if (tempMasterTxChannel + 0xb != (uint)bVar1)
  {
    tl_zbMacChannelSet((u8)(tempMasterTxChannel + 0xb));
  }
  if ((ev_timer_event_t *)g_gpBaseCtx != (ev_timer_event_t *)0x0)
  {
    ev_timer_taskCancel((ev_timer_event_t **)&g_gpBaseCtx);
  }
  g_gpBaseCtx._0_4_ = ev_timer_taskPost(gpTransmitChannelTimeoutCb, (void *)0x0, (u32)&DAT_00001388);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

uint gpAliasSrcAddrDerived(void)

{
  char in_r0;
  uint uVar1;
  uint in_r1;
  uint uVar2;
  uint uVar3;

  if (in_r0 == '\0')
  {
    uVar1 = in_r1 & 0xffff;
    uVar2 = in_r1 >> 0x10;
  }
  else
  {
    if (in_r0 != '\x02')
    {
      return 7;
    }
    uVar1 = (in_r1 >> 8 & 0xff) * 0x100 + (in_r1 & 0xff) & 0xffff;
    uVar2 = (in_r1 >> 0x18) * 0x100 + (in_r1 >> 0x10 & 0xff) & 0xffff;
  }
  uVar3 = uVar1;
  if ((0xfff5 < (uVar1 - 1 & 0xffff)) && (uVar3 = uVar2 ^ uVar1, 0xfff5 < (uVar3 - 1 & 0xffff)))
  {
    if (uVar1 == 0)
    {
      uVar3 = 7;
    }
    else
    {
      uVar3 = uVar1 - 8 & 0xffff;
    }
  }
  return uVar3;
}

u8 gppTunnelingDelayGet(bool rxAfterTx, u8 lqi, bool firstToForward, bool noRoute)

{
  u8 uVar1;
  char cVar2;

  uVar1 = '\x05';
  if (rxAfterTx)
  {
    uVar1 = ' ';
  }
  cVar2 = '`';
  if (lqi != '\0')
  {
    cVar2 = ' ';
  }
  if (noRoute)
  {
    uVar1 = uVar1 + 'd';
  }
  else if (!firstToForward)
  {
    uVar1 = cVar2 + uVar1;
  }
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpTranimitGPDF(void)

{
  u8 uVar1;
  void **in_r0;
  zb_buf_t *p;
  void *out;

  p = (zb_buf_t *)c1();
  if (p != (zb_buf_t *)0x0)
  {
    if (*(char *)(in_r0 + 5) == -0xd)
    {
      *(undefined *)((int)in_r0 + 0x16) = 0xbe;
    }
    else
    {
      uVar1 = dGpStubHandleGet();
      *(u8 *)((int)in_r0 + 0x16) = uVar1;
    }
    memcpy(p, in_r0, 0x17);
    p->buf[0] = '\0';
    p->buf[1] = '\0';
    p->buf[2] = '\0';
    p->buf[3] = '\0';
    if (p->buf[0x15] != '\0')
    {
      out = tl_bufInitalloc(p, p->buf[0x15]);
      p->buf[0] = (u8)out;
      p->buf[1] = (u8)((uint)out >> 8);
      p->buf[2] = (u8)((uint)out >> 0x10);
      p->buf[3] = (u8)((uint)out >> 0x18);
      memcpy(out, *in_r0, (uint)p->buf[0x15]);
    }
    tl_zbTaskPost(gpDataReq, p);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void gpDataIndDuplicatePeriodic(void)

{
  char cVar1;
  int iVar2;
  char *pcVar3;

  pcVar3 = g_gpDataIndSecReqTab + 0x10;
  iVar2 = 0;
  do
  {
    if ((g_gpDataIndSecReqTab[iVar2 * 0x13 + 0x12] & 0x40) != 0)
    {
      cVar1 = *pcVar3;
      if (cVar1 != -1)
      {
        if (cVar1 == '\0')
        {
          gpDataIndSecReqEntryClear();
        }
        else
        {
          *pcVar3 = cVar1 + -1;
        }
      }
    }
    iVar2 = iVar2 + 1;
    pcVar3 = pcVar3 + 0x13;
  } while (iVar2 != 4);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 gpDataIndDuplicateFind(void)

{
  int iVar1;
  byte in_r0;
  int iVar2;
  int in_r3;
  int iVar3;
  char *pcVar4;
  char in_stack_00000000;
  undefined auStack_2c[8];

  pcVar4 = g_gpDataIndSecReqTab + 0x11;
  iVar3 = 0;
  while (true)
  {
    iVar1 = iVar3 * 0x13;
    if (((((g_gpDataIndSecReqTab[iVar1 + 0x12] & 0x40) != 0) &&
          ((g_gpDataIndSecReqTab[iVar1 + 0x12] & 7) == in_r0)) &&
         (iVar2 = memcmp(auStack_2c, g_gpDataIndSecReqTab + iVar1 + 8, 8), iVar2 == 0)) &&
        ((*(int *)(g_gpDataIndSecReqTab + iVar1 + 4) == in_r3 && (*pcVar4 != in_stack_00000000))))
      break;
    iVar3 = iVar3 + 1;
    pcVar4 = pcVar4 + 0x13;
    if (iVar3 == 4)
    {
      return 0;
    }
  }
  return 1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

bool gpSecKeyTypeMappingChk(void)

{
  byte in_r0;
  char in_r1;
  bool bVar1;

  if ((in_r1 != '\x01') || (bVar1 = true, 3 < in_r0))
  {
    if ((in_r1 == '\0') && ((in_r0 == 7 || (in_r0 == 4))))
    {
      bVar1 = true;
    }
    else
    {
      bVar1 = (byte)(in_r0 - 5) < 2;
    }
  }
  return bVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined gpKeyRecovery(void)

{
  char in_r0;
  int iVar1;
  char in_r1;
  void *in_r2;
  undefined in_r3;
  uint uVar2;
  char *in_stack_00000000;
  void *in_stack_00000004;

  if (in_r0 != '\0')
  {
    if ((in_r1 != '\x04') && (in_r1 != '\a'))
    {
      return 0;
    }
    iVar1 = memcmp(in_r2, g_null_securityKey, 0x10);
    if (iVar1 == 0)
    {
      return 0;
    }
    memcpy(in_stack_00000004, in_r2, 0x10);
    *in_stack_00000000 = in_r1;
    return in_r3;
  }
  if (in_r1 == '\x01')
  {
    iVar1 = memcmp(in_r2, g_null_securityKey, 0x10);
    if (iVar1 == 0)
    {
      if (zclGpAttr_gpSharedSecKeyType == '\x01')
      {
        memcpy(in_stack_00000004, zclGpAttr_gpSharedSecKey, 0x10);
      }
      else
      {
        uVar2 = ((uint)ss_ib._62_1_ << 0x1a) >> 0x1e;
        iVar1 = memcmp(ss_ib.nwkSecurMaterialSet + uVar2, g_null_securityKey, 0x10);
        if (iVar1 == 0)
        {
          return 0;
        }
        memcpy(in_stack_00000004, ss_ib.nwkSecurMaterialSet + uVar2, 0x10);
      }
    }
    else
    {
      memcpy(in_stack_00000004, in_r2, 0x10);
    }
    *in_stack_00000000 = '\x01';
    return in_r3;
  }
  if (in_r1 != '\x02')
  {
    if (in_r1 != '\x03')
    {
      return 0;
    }
    iVar1 = memcmp(in_r2, g_null_securityKey, 0x10);
    if (iVar1 == 0)
    {
      if (zclGpAttr_gpSharedSecKeyType != '\x03')
      {
        return 0;
      }
      memcpy(in_stack_00000004, zclGpAttr_gpSharedSecKey, 0x10);
    }
    else
    {
      memcpy(in_stack_00000004, in_r2, 0x10);
    }
    *in_stack_00000000 = '\x03';
    return in_r3;
  }
  iVar1 = memcmp(in_r2, g_null_securityKey, 0x10);
  if (iVar1 == 0)
  {
    if (zclGpAttr_gpSharedSecKeyType != '\x02')
    {
      return 0;
    }
    memcpy(in_stack_00000004, zclGpAttr_gpSharedSecKey, 0x10);
  }
  else
  {
    memcpy(in_stack_00000004, in_r2, 0x10);
  }
  *in_stack_00000000 = '\x02';
  return in_r3;
}

void gpDevAnnceAliasSend(u16 aliasNwkAddr)

{
  undefined auStack_14[12];

  memcpy(auStack_14, &g_invalid_addr, 8);
  zdo_devAnnce();
  return;
}

u8 gpCcmStar(u8 appId, gpdId_t gpdId, u8 gpdfSecKey, u8 gpdfSecLevel, u8 endpoint, u32 secFrameCounter,
             u8 gpdAsduLen, u8 *gpdAsdu, bool autoComm, bool rxAfterTx, u32 mic, u8 *pKey)

{
  ushort size;
  uint length;
  u8 uVar1;
  u8 *aStr;
  u8 *puVar2;
  int iVar3;
  u8 aStrLen;
  u8 uStack_58;
  uint uStack_54;
  uint local_44;
  uint uStack_40;
  u32 uStack_3c;
  undefined uStack_38;
  uint local_34;
  uint uStack_30;
  u8 local_2c;
  u8 local_28;

  local_34 = (uint)gpdfSecLevel;
  uStack_30 = (uint)gpdfSecKey;
  iVar3 = (int)((ulonglong)gpdId & 0xff000000ff);
  length = (uint)gpdAsduLen;
  uVar1 = '\0';
  if (((ulonglong)gpdId & 0xff) != 0)
  {
    uStack_38 = 5;
    if (appId == '\0')
    {
      uStack_40 = (uint)gpdfSecKey;
      uStack_54 = 10;
      local_28 = appId;
    }
    else
    {
      if (appId != '\x02')
      {
        return '\x01';
      }
      local_28 = '\0';
      uStack_54 = 7;
      uStack_40 = local_34;
    }
    local_44 = (uint)gpdfSecKey;
    uStack_3c = secFrameCounter;
    local_2c = local_28;
    local_28 = gpNwkHdrFrameCtrlBuild();
    if (iVar3 == 3)
    {
      aStr = ev_buf_allocate((u16)uStack_54);
    }
    else
    {
      if (iVar3 != 2)
      {
        return '\x01';
      }
      uStack_54 = uStack_54 + length & 0xff;
      aStr = ev_buf_allocate((u16)uStack_54);
    }
    uVar1 = '\x01';
    if (aStr != (u8 *)0x0)
    {
      *aStr = local_28;
      aStr[1] = local_2c;
      puVar2 = aStr + 2;
      if (appId == '\0')
      {
        aStr[2] = gpdfSecKey;
        aStr[3] = '\0';
        aStr[4] = '\0';
        aStr[5] = '\0';
        puVar2 = aStr + 6;
      }
      else if (appId == '\x02')
      {
        uStack_58 = (u8)(((ulonglong)gpdId & 0xff000000ff) >> 0x20);
        aStr[2] = uStack_58;
        puVar2 = aStr + 3;
      }
      *puVar2 = (u8)secFrameCounter;
      puVar2[1] = (u8)(secFrameCounter >> 8);
      puVar2[2] = (u8)(secFrameCounter >> 0x10);
      puVar2[3] = (u8)(secFrameCounter >> 0x18);
      aStrLen = (u8)uStack_54;
      if (iVar3 == 2)
      {
        memcpy(puVar2 + 4, gpdAsdu, length);
        aes_ccmDecTran('\x04', pKey, (u8 *)&local_44, (u8 *)0x0, 0, aStr, aStrLen, (u8 *)&mic);
        uVar1 = aes_ccmDecAuthTran('\x04', pKey, (u8 *)&local_44, (u8 *)0x0, 0, aStr, aStrLen, (u8 *)&mic);
        uVar1 = '\x01' - (uVar1 == '\0');
      }
      else
      {
        uVar1 = '\x01';
        if (iVar3 == 3)
        {
          size = (ushort)gpdAsduLen;
          puVar2 = ev_buf_allocate(size);
          if ((puVar2 == (u8 *)0x0) && (gpdAsduLen != '\0'))
          {
            ev_buf_free(aStr);
            return '\x01';
          }
          memcpy(puVar2, gpdAsdu, length);
          aes_ccmDecTran('\x04', pKey, (u8 *)&local_44, gpdAsdu, size, aStr, aStrLen, (u8 *)&mic);
          uVar1 = aes_ccmDecAuthTran('\x04', pKey, (u8 *)&local_44, gpdAsdu, size, aStr, aStrLen,
                                     (u8 *)&mic);
          uVar1 = uVar1 != '\0';
          if ((bool)uVar1)
          {
            memcpy(gpdAsdu, puVar2, length);
          }
          if (puVar2 != (u8 *)0x0)
          {
            ev_buf_free(puVar2);
          }
        }
      }
      ev_buf_free(aStr);
    }
  }
  return uVar1;
}

void bdb_linkKeyCfg(bdb_commissionSetting_t *setting, u8 isFactoryNew)

{
  u8 *puVar1;

  if (isFactoryNew == '\0')
  {
    if (-1 < (int)((uint)ss_ib.preConfiguredKeyType << 0x1e))
    {
      ss_ib.tcLinkKeyType = '\x01';
      puVar1 = tcLinkKeyCentralDefault;
      goto LAB_00028660;
    }
  }
  else
  {
    isFactoryNew = (setting->linkKey).tcLinkKey.keyType;
  }
  puVar1 = (setting->linkKey).tcLinkKey.key;
  ss_ib.tcLinkKeyType = isFactoryNew;
LAB_00028660:
  ss_ib.tcLinkKey._0_1_ = (char)puVar1;
  ss_ib.tcLinkKey._1_1_ = (char)((uint)puVar1 >> 8);
  ss_ib.tcLinkKey._2_1_ = (char)((uint)puVar1 >> 0x10);
  ss_ib.tcLinkKey._3_1_ = (char)((uint)puVar1 >> 0x18);
  puVar1 = (setting->linkKey).distributeLinkKey.key;
  ss_ib.distibuteLinkKey._0_1_ = (char)puVar1;
  ss_ib.distibuteLinkKey._1_1_ = (char)((uint)puVar1 >> 8);
  ss_ib.distibuteLinkKey._2_1_ = (char)((uint)puVar1 >> 0x10);
  ss_ib.distibuteLinkKey._3_1_ = (char)((uint)puVar1 >> 0x18);
  return;
}

void bdb_coordinatorStart(void)

{
  aps_ib.aps_designated_coordinator = '\x01';
  ss_ib.tcPolicy.allowTCLKrequest = '\x01';
  zb_routerStart();
  return;
}

void bdb_outgoingFrameCountUpdate(u8 repower)

{
  if (repower == '\0')
  {
    ss_ib.outgoingFrameCounter = drv_pm_deepSleep_frameCnt_get();
  }
  else
  {
    ss_ib.outgoingFrameCounter = ss_ib.outgoingFrameCounter + 0x400;
    nv_nwkFrameCountSaveToFlash(ss_ib.outgoingFrameCounter);
  }
  return;
}

void bdb_scanCfg(u32 chanMask, u8 duration)

{
  aps_ib.aps_channel_mask._0_1_ = (char)chanMask;
  aps_ib.aps_channel_mask._1_1_ = (char)(chanMask >> 8);
  aps_ib.aps_channel_mask._2_1_ = (char)(chanMask >> 0x10);
  aps_ib.aps_channel_mask._3_1_ = (char)(chanMask >> 0x18);
  zdo_cfg_attributes.config_nwk_scan_duration = duration;
  return;
}

void bdb_factoryNewDevCfg(u8 touchLinkEn, u8 chan)

{
  aps_ib.aps_use_ext_panid[0] = '\0';
  aps_ib.aps_use_ext_panid[1] = '\0';
  aps_ib.aps_use_ext_panid[2] = '\0';
  aps_ib.aps_use_ext_panid[3] = '\0';
  aps_ib.aps_use_ext_panid[4] = '\0';
  aps_ib.aps_use_ext_panid[5] = '\0';
  aps_ib.aps_use_ext_panid[6] = '\0';
  aps_ib.aps_use_ext_panid[7] = '\0';
  aps_ib.aps_designated_coordinator = '\x01';
  ss_ib.tcPolicy.allowTCLKrequest = '\x01';
  g_zbInfo.nwkNib.panId = g_zbInfo.macPib.panId;
  if (touchLinkEn != '\0')
  {
    tl_zbMacChannelSet(chan);
    rf_setTrxState('\x01');
  }
  g_zbInfo.nwkNib.panId._1_1_ = (undefined)(g_zbInfo.nwkNib.panId >> 8);
  return;
}

bool zb_isDeviceFactoryNew(void)

{
  return (bool)(g_zbNwkCtx._45_1_ & 1);
}

bool zb_isDeviceJoinedNwk(void)

{
  return SUB41(((uint)g_zbNwkCtx._45_1_ << 0x1d) >> 0x1f, 0);
}

bool zb_getMacAssocPermit(void)

{
  return (bool)g_zbInfo.macPib.associationPermit;
}

u8 zb_nwkFormation(u32 scanChannels, u8 scanDuration)

{
  zdo_status_t zVar1;

  zVar1 = zdo_nwkFormationStart(scanChannels, scanDuration);
  return zVar1;
}

u8 zb_routerStart(void)

{
  zdo_status_t zVar1;

  zVar1 = zdo_nwkRouterStart();
  return zVar1;
}

u8 zb_nwkDiscovery(u32 scanChannels, u8 scanDuration, nwkDiscoveryUserCb_t cb)

{
  return '2';
}

u8 zb_assocJoinReq(void)

{
  return '2';
}

u8 zb_nlmePermitJoiningRequest(u8 permitDuration)

{
  u8 uVar1;

  uVar1 = zdo_nlmePermitJoinReq(permitDuration);
  return uVar1;
}

u8 zb_nlmeLeaveReq(nlme_leave_req_t *pLeaveReq)

{
  u8 uVar1;

  uVar1 = (*(code *)&zdo_nlmeLeaveReq)();
  return uVar1;
}

zdo_status_t zb_zdoNwkAddrReq(u16 dstNwkAddr, zdo_nwk_addr_req_t *pReq, u8 *seqNo, zdo_callback indCb)

{
  zdo_status_t zVar1;
  undefined4 local_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  zdo_callback p_Stack_18;
  u8 local_14;

  local_2c = 0;
  uStack_28 = 0;
  uStack_20 = 0;
  uStack_1c = 0;
  local_14 = '\0';
  uStack_24 = (uint)dstNwkAddr;
  p_Stack_18 = indCb;
  zVar1 = zdp_data_send(pReq, 0xb, &local_2c);
  *seqNo = local_14;
  return zVar1;
}

zdo_status_t
zb_zdoIeeeAddrReq(u16 dstNwkAddr, zdo_ieee_addr_req_t *pReq, u8 *seqNo, zdo_callback indCb)

{
  zdo_status_t zVar1;
  undefined4 local_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  zdo_callback p_Stack_18;
  u8 local_14;

  local_2c = 0;
  uStack_28 = 0;
  uStack_20 = 0;
  local_14 = '\0';
  uStack_24 = (uint)dstNwkAddr;
  uStack_1c = 1;
  p_Stack_18 = indCb;
  zVar1 = zdp_data_send(pReq, 5, &local_2c);
  *seqNo = local_14;
  return zVar1;
}

zdo_status_t
zb_zdoSimpleDescReq(u16 dstNwkAddr, zdo_simple_descriptor_req_t *pReq, u8 *seqNo, zdo_callback indCb)

{
  zdo_status_t zVar1;
  undefined4 local_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  zdo_callback p_Stack_18;
  u8 local_14;

  local_2c = 0;
  uStack_28 = 0;
  uStack_20 = 0;
  local_14 = '\0';
  uStack_24 = (uint)dstNwkAddr;
  uStack_1c = 4;
  p_Stack_18 = indCb;
  zVar1 = zdp_data_send(pReq, 4, &local_2c);
  *seqNo = local_14;
  return zVar1;
}

zdo_status_t
zb_zdoNodeDescReq(u16 dstNwkAddr, zdo_node_descriptor_req_t *pReq, u8 *seqNo, zdo_callback indCb)

{
  zdo_status_t zVar1;
  undefined4 local_2c;
  undefined4 uStack_28;
  uint uStack_24;
  undefined4 uStack_20;
  undefined4 uStack_1c;
  zdo_callback p_Stack_18;
  u8 local_14;

  local_2c = 0;
  uStack_28 = 0;
  uStack_20 = 0;
  local_14 = '\0';
  uStack_24 = (uint)dstNwkAddr;
  uStack_1c = 2;
  p_Stack_18 = indCb;
  zVar1 = zdp_data_send(pReq, 3, &local_2c);
  *seqNo = local_14;
  return zVar1;
}

zdo_status_t zb_zdoBindUnbindReq(bool isBinding, zdo_bind_req_t *pReq, u8 *seqNo, zdo_callback indCb)

{
  u8 uVar1;
  zdo_status_t zVar2;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  u16 local_22;

  uVar4 = 0;
  uVar5 = 0;
  iVar3 = memcmp(pReq, g_zbInfo.macPib.extAddress, 8);
  if (iVar3 == 0)
  {
    zVar2 = zdo_apsmeBindUnBind();
  }
  else
  {
    uVar1 = tl_zbShortAddrByExtAddr(&local_22, (addrExt_t)CONCAT44(uVar5, uVar4), (u16 *)pReq);
    zVar2 = ZDO_DEVICE_NOT_FOUND;
    if (uVar1 != 0xff)
    {
      uVar4 = 0xf;
      if (pReq->dst_addr_mode == LONG_EXADDR_DSTENDPOINT)
      {
        uVar4 = 0x16;
      }
      zVar2 = zdp_data_send(pReq, uVar4, &stack0xffffffc0);
      *seqNo = '\0';
    }
  }
  return zVar2;
}

zdo_status_t
zb_mgmtPermitJoinReq(u16 dstNwkAddr, u8 permitJoinDuration, u8 tcSignificance, u8 *seqNo, zdo_callback indCb)

{
  zdo_status_t zVar1;
  undefined4 local_34;
  undefined4 uStack_30;
  uint uStack_2c;
  undefined4 uStack_28;
  undefined4 uStack_24;
  zdo_callback p_Stack_20;
  u8 local_1c;
  u8 local_18;
  u8 uStack_17;

  if (g_zbInfo.nwkNib.nwkAddr == dstNwkAddr)
  {
    zVar1 = zdo_nlmePermitJoinReq(permitJoinDuration);
  }
  else
  {
    if ((dstNwkAddr & 0xfff8) == 0xfff8)
    {
      zdo_nlmePermitJoinReq(permitJoinDuration);
      p_Stack_20 = ll_reset;
    }
    else
    {
      p_Stack_20 = indCb;
    }
    uStack_24 = 0x36;
    uStack_2c = (uint)dstNwkAddr;
    local_1c = '\0';
    uStack_28 = 0;
    uStack_30 = 0;
    local_34 = 0;
    local_18 = permitJoinDuration;
    uStack_17 = tcSignificance;
    zVar1 = zdp_data_send(&local_18, 3, &local_34);
    *seqNo = local_1c;
  }
  return zVar1;
}

u8 zb_apsmeRequestKeyReq(ss_apsmeRequestKeyReq_t *pRequestKeyReq)

{
  u8 uVar1;
  void *out;

  out = (void *)c1();
  uVar1 = '\n';
  if (out != (void *)0x0)
  {
    memcpy(out, pRequestKeyReq, 0x12);
    tl_zbTaskPost(ss_apsmeRequestKeyReq, out);
    uVar1 = '\0';
  }
  return uVar1;
}

u8 zb_apsmeSwitchKeyReq(ss_apsmeSwitchKeyReq_t *pSwitchKeyReq)

{
  u8 uVar1;
  void *out;

  out = (void *)c1();
  uVar1 = '\n';
  if (out != (void *)0x0)
  {
    memcpy(out, pSwitchKeyReq, 9);
    tl_zbTaskPost(ss_apsmeSwitchKeyReq, out);
    uVar1 = '\0';
  }
  return uVar1;
}

u8 zb_tcUpdateNwkKey(ss_tcUpdateNwkKey_t *pTcUpdateNwkKey)

{
  u8 uVar1;
  void *dest;

  dest = (void *)c1();
  uVar1 = '\n';
  if (dest != (void *)0x0)
  {
    memset(dest, 0, 0x25);
    memcpy(dest, pTcUpdateNwkKey, 8);
    memcpy((void *)((int)dest + 9), pTcUpdateNwkKey->key, 0x10);
    *(undefined *)((int)dest + 8) = 1;
    *(u8 *)((int)dest + 0x1a) = ss_ib.activeKeySeqNum + '\x01';
    *(undefined *)((int)dest + 0x19) = 0;
    *(undefined *)((int)dest + 0x24) = 1;
    *(undefined *)((int)dest + 0x23) = 0;
    ss_tcTransportKeyTimerStart();
    uVar1 = '\0';
  }
  return uVar1;
}

u8 zb_zdoSendDevAnnance(void)

{
  zdo_device_announce_send();
  return '\0';
}

void zb_zdoSendParentAnnce(void)

{
  zdo_apsParentAnnceTimerStart();
  return;
}

void zb_zdoCbRegister(zdo_appIndCb_t *cb)

{
  zdo_zdpCbTblRegister(cb);
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int aes_encrypt(uchar *Key, uchar *Data, uchar *Result)

{
  int iVar1;
  uchar *puVar2;

  DAT_00800540 = DAT_00800540 & 0xfe;
  puVar2 = &DAT_00800550;
  do
  {
    *puVar2 = *Key;
    Key = Key + 1;
    puVar2 = puVar2 + 1;
  } while (puVar2 != (uchar *)0x800560);
  if ((int)((uint)DAT_00800540 << 0x1e) < 0)
  {
    do
    {
      _DAT_00800548 =
          (uint)Data[1] * 0x100 + (uint)Data[2] * 0x10000 + (uint)*Data + (uint)Data[3] * 0x1000000;
      Data = Data + 4;
    } while ((DAT_00800540 & 2) != 0);
  }
  do
  {
  } while ((DAT_00800540 & 4) == 0);
  puVar2 = Result + 0x10;
  do
  {
    iVar1 = _DAT_00800548;
    *Result = (uchar)_DAT_00800548;
    Result[1] = (uchar)((uint)iVar1 >> 8);
    Result[2] = (uchar)((uint)iVar1 >> 0x10);
    Result[3] = (uchar)((uint)iVar1 >> 0x18);
    Result = Result + 4;
  } while (puVar2 != Result);
  return 0;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int aes_decrypt(uchar *Key, uchar *Data, uchar *Result)

{
  int iVar1;
  uchar *puVar2;

  DAT_00800540 = DAT_00800540 | 1;
  puVar2 = &DAT_00800550;
  do
  {
    *puVar2 = *Key;
    Key = Key + 1;
    puVar2 = puVar2 + 1;
  } while (puVar2 != (uchar *)0x800560);
  if ((int)((uint)DAT_00800540 << 0x1e) < 0)
  {
    do
    {
      _DAT_00800548 =
          (uint)Data[1] * 0x100 + (uint)Data[2] * 0x10000 + (uint)*Data + (uint)Data[3] * 0x1000000;
      Data = Data + 4;
    } while ((DAT_00800540 & 2) != 0);
  }
  do
  {
  } while ((DAT_00800540 & 4) == 0);
  puVar2 = Result + 0x10;
  do
  {
    iVar1 = _DAT_00800548;
    *Result = (uchar)_DAT_00800548;
    Result[1] = (uchar)((uint)iVar1 >> 8);
    Result[2] = (uchar)((uint)iVar1 >> 0x10);
    Result[3] = (uchar)((uint)iVar1 >> 0x18);
    Result = Result + 4;
  } while (puVar2 != Result);
  return 0;
}

int LoadTblCmdSet(TBLCMDSET *pt, int size)

{
  byte v;
  uint uVar1;
  byte bVar2;
  int iVar3;

  if (0 < size)
  {
    iVar3 = 0;
    do
    {
      while (true)
      {
        uVar1 = (uint) * (byte *)((int)&pt->adr + 1) * 0x100 | (uint) * (byte *)&pt->adr;
        v = *(byte *)&pt->dat;
        bVar2 = *(byte *)((int)&pt->dat + 1);
        if ((bVar2 & 0x40) == 0)
          break;
        bVar2 = bVar2 & 0x3f;
        if (bVar2 != 3)
        {
          if (bVar2 == 8)
          {
            analog_write(*(byte *)&pt->adr, v);
          }
          else if (bVar2 == 7)
          {
            sleep_us(uVar1 * 0x100 + (uint)v);
          }
          break;
        }
        *(byte *)((uVar1 | 0x800000) + 0x800000) = v;
        iVar3 = iVar3 + 1;
        pt = (TBLCMDSET *)&pt->cmd;
        if (size <= iVar3)
        {
          return size;
        }
      }
      iVar3 = iVar3 + 1;
      pt = (TBLCMDSET *)&pt->cmd;
    } while (iVar3 < size);
  }
  return size;
}

void clock_init(SYS_CLK_TypeDef SYS_CLK)

{
  if (SYS_CLK == 0x20)
  {
  LAB_00028cb4:
    system_clk_mHz = 0x30;
    goto joined_r0x00028ca6;
  }
  if (SYS_CLK < 0x21)
  {
    if (SYS_CLK != 1)
    {
      if (SYS_CLK != 0)
      {
        if (SYS_CLK != 2)
        {
          DAT_00800066 = SYS_CLK;
          system_clk_type = SYS_CLK;
          return;
        }
        goto LAB_00028cb4;
      }
    LAB_00028c9e:
      system_clk_mHz = 0x18;
      goto joined_r0x00028ca6;
    }
  }
  else
  {
    if (SYS_CLK == 0x43)
    {
      DAT_00800066 = SYS_CLK;
      system_clk_mHz = 0x10;
      system_clk_type = SYS_CLK;
      return;
    }
    if (SYS_CLK < SYS_CLK_12M_Crystal)
    {
      if (SYS_CLK != 0x42)
      {
        DAT_00800066 = SYS_CLK;
        system_clk_type = SYS_CLK;
        return;
      }
      goto LAB_00028c9e;
    }
    if (SYS_CLK == SYS_CLK_12M_Crystal)
    {
      DAT_00800066 = SYS_CLK;
      system_clk_mHz = 0xc;
      system_clk_type = SYS_CLK;
      return;
    }
    if (SYS_CLK != 0x60)
    {
      DAT_00800066 = SYS_CLK;
      system_clk_type = SYS_CLK;
      return;
    }
  }
  system_clk_mHz = 0x20;
joined_r0x00028ca6:
  DAT_00800066 = SYS_CLK;
  system_clk_type = SYS_CLK;
  if (SYS_CLK == 0x20)
  {
    analog_write('\f', 0xc6);
  }
  return;
}

void rc_24m_cal(void)

{
  byte bVar1;
  uchar v;

  analog_write(200, 0x80);
  bVar1 = analog_read('0');
  analog_write('0', bVar1 | 0x7f);
  analog_write(199, '\x0e');
  analog_write(199, '\x0f');
  do
  {
    bVar1 = analog_read(0xcf);
  } while (-1 < (int)((uint)bVar1 << 0x18));
  v = analog_read(0xcb);
  analog_write('3', v);
  bVar1 = analog_read('0');
  analog_write('0', bVar1 & 0x7f);
  analog_write(199, '\x0e');
  tl_24mrc_cal = analog_read('3');
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void doubler_calibration(void)

{
  byte bVar1;
  byte bVar2;

  analog_write(0x86, 0xbb);
  bVar1 = analog_read(0x82);
  analog_write(0x82, bVar1 & 0x7f);
  bVar1 = analog_read(0x87);
  analog_write(0x87, bVar1 & 0xfc | 2);
  bVar1 = analog_read(0x87);
  analog_write(0x87, bVar1 | 4);
  bVar1 = analog_read(0x88);
  bVar2 = analog_read(0x87);
  analog_write(0x87, (byte)((bVar1 & 0x1f) << 3) | bVar2 & 7);
  bVar1 = analog_read(0x82);
  analog_write(0x82, bVar1 | 0x7f);
  bVar1 = analog_read(0x87);
  analog_write(0x87, bVar1 & 0xfd);
  analog_write(0x86, 0xfb);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 get_sp_normal(void)

{
  undefined4 in_r0;
  undefined local_8[8];

  pm_curr_stack = local_8;
  return in_r0;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void efuse_sys_check(void)

{
  uint in_r0;
  undefined1 *puVar1;
  uint uVar2;
  uint uVar3;

  pm_bit_info_1 = (byte)((in_r0 << 6) >> 0x1e);
  uVar2 = in_r0 >> 0x1d;
  pm_bit_info_0 = (byte)(in_r0 >> 0x1d);
  uVar3 = 0;
  if (((in_r0 & 0xc0) == 0xc0) && (uVar3 = 1, (in_r0 << 6) >> 0x1e < 2))
  {
    uVar3 = (in_r0 << 0x17) >> 0x1f;
  }
  if ((uVar3 | uVar2) == 0)
  {
    return;
  }
  get_sp_normal();
  if (uVar3 == 0)
  {
    if (uVar2 == 2)
    {
      if (pm_curr_stack < g_ssTcKeyPair + 1)
      {
        return;
      }
    }
    else
    {
      if (uVar2 != 4)
      {
        return;
      }
      if (pm_curr_stack < (undefined1 *)0x84c001)
      {
        return;
      }
    }
  }
  puVar1 = pm_curr_stack + 100;
  for (uVar2 = (uint)(pm_curr_stack + -100) & 0xffffff00; uVar2 < ((uint)puVar1 & 0xffffff00);
       uVar2 = uVar2 + 0x10)
  {
    *(undefined4 *)(uVar2 + 0x800000) = 0;
  }
  return;
}

void gpio_set_input_en(GPIO_PinTypeDef pin, uint value)

{
  byte bVar1;
  byte bVar2;
  byte *pbVar3;
  ushort uVar4;

  bVar1 = (byte)pin;
  uVar4 = pin & 0xf00;
  if (((uVar4 == 0x300) || ((pin & 0xf00) == 0)) || (uVar4 == 0x400))
  {
    if (value == 0)
    {
      pbVar3 = (byte *)((uint)(pin >> 8) * 8 + 0x800581);
      *pbVar3 = *pbVar3 & ~bVar1;
    }
    else
    {
      pbVar3 = (byte *)((uint)(pin >> 8) * 8 + 0x800581);
      *pbVar3 = bVar1 | *pbVar3;
    }
  }
  else if (uVar4 == 0x100)
  {
    if (value == 0)
    {
      bVar2 = analog_read(0xbd);
      analog_write(0xbd, bVar2 & ~bVar1);
    }
    else
    {
      bVar2 = analog_read(0xbd);
      analog_write(0xbd, bVar1 | bVar2);
    }
  }
  else if (uVar4 == 0x200)
  {
    if (value == 0)
    {
      bVar2 = analog_read(0xc0);
      analog_write(0xc0, bVar2 & ~bVar1);
    }
    else
    {
      bVar2 = analog_read(0xc0);
      analog_write(0xc0, bVar1 | bVar2);
    }
  }
  return;
}

void gpio_set_func(GPIO_PinTypeDef pin, GPIO_FuncTypeDef func)

{
  uint uVar1;
  byte *pbVar2;
  byte bVar3;
  byte bVar4;

  uVar1 = (uint)pin;
  if (func == AS_GPIO)
  {
    pbVar2 = (byte *)(((uVar1 << 0x10) >> 0x18) * 8 + 0x800586);
    *pbVar2 = (byte)pin | *pbVar2;
    return;
  }
  if (uVar1 == 0x180)
  {
    if (func == 9)
    {
      bVar3 = 0x3f;
      bVar4 = 0;
    }
    else if (func == 5)
    {
      bVar3 = 0x3f;
      bVar4 = 0x40;
    }
    else if (func == 3)
    {
      bVar3 = 0x3f;
      bVar4 = 0x80;
    }
    else
    {
      bVar3 = 0x3f;
      bVar4 = 0;
    }
    goto LAB_00029044;
  }
  if (uVar1 < 0x181)
  {
    if (uVar1 == 0x80)
    {
      if (func == 2)
      {
        bVar3 = 0x3f;
        bVar4 = 0;
      }
      else if (func == 3)
      {
        bVar3 = 0x3f;
        bVar4 = 0x40;
      }
      else
      {
        bVar3 = 0x3f;
        bVar4 = 0;
      }
      goto LAB_00029044;
    }
    if (uVar1 < 0x81)
    {
      if (uVar1 == 8)
      {
        if ((byte)(func + 0xfc) < 2)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else if (func == 0x15)
        {
          bVar3 = 0x3f;
          bVar4 = 0x80;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 9)
      {
        if (uVar1 == 2)
        {
          if (func == 8)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 6)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 4)
        {
          if (func == 5)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 0x14)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 1)
        {
          if (func == 8)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 0x1a)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if ((uVar1 == 0x20) || (uVar1 == 0x40))
        {
          gpio_set_input_en(pin, 1);
          bVar3 = 0xff;
          bVar4 = 0;
          goto LAB_00029044;
        }
        if (uVar1 == 0x10)
        {
          if ((byte)(func + 0xfc) < 2)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0x16)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
    }
    else
    {
      if (uVar1 == 0x108)
      {
        if (func == 0x1a)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 0x109)
      {
        if (uVar1 == 0x102)
        {
          if (func == 0x18)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0xd)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x104)
        {
          if (func == 0x19)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x101)
        {
          if (func == 0x17)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0xd)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if (uVar1 == 0x120)
        {
          if (func == 9)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 0x19)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0xc)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x140)
        {
          if (func == 9)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if ((byte)(func + 0xfc) < 2)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x110)
        {
          if (func == 9)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 0x18)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0xc)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
    }
  }
  else
  {
    if (uVar1 == 0x280)
    {
      if (func == 0xd)
      {
        bVar3 = 0x3f;
        bVar4 = 0x40;
      }
      else if (func == 0x1f)
      {
        bVar3 = 0x3f;
        bVar4 = 0x80;
      }
      else
      {
        bVar3 = 0x3f;
        bVar4 = 0;
      }
      goto LAB_00029044;
    }
    if (uVar1 < 0x281)
    {
      if (uVar1 == 0x208)
      {
        if (func == 0x15)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else if (func == 4)
        {
          bVar3 = 0x3f;
          bVar4 = 0x80;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 0x209)
      {
        if (uVar1 == 0x202)
        {
          if (func == 4)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 0x1b)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0x14)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x204)
        {
          if (func == 0x14)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 4)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x201)
        {
          if (func == 4)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 0x1e)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if (uVar1 == 0x220)
        {
          if (func == 0x1d)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0xd)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x240)
        {
          if (func == 0xd)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 0x1e)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x210)
        {
          if (func == 0x16)
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 0x1a)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
    }
    else
    {
      if (uVar1 == 0x308)
      {
        if (func == 0x1b)
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        else if (func == 6)
        {
          bVar3 = 0x3f;
          bVar4 = 0x40;
        }
        else if (func == 3)
        {
          bVar3 = 0x3f;
          bVar4 = 0x80;
        }
        else
        {
          bVar3 = 0x3f;
          bVar4 = 0;
        }
        goto LAB_00029044;
      }
      if (uVar1 < 0x309)
      {
        if (uVar1 == 0x302)
        {
          if (func == 0xc)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 3)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x304)
        {
          if (func == 5)
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          else if (func == 6)
          {
            bVar3 = 0xcf;
            bVar4 = 0x10;
          }
          else if (func == 0x17)
          {
            bVar3 = 0xcf;
            bVar4 = 0x20;
          }
          else
          {
            bVar3 = 0xcf;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 == 0x301)
        {
          if (func == 0xc)
          {
            bVar3 = 0xfc;
            bVar4 = 1;
          }
          else if (func == 3)
          {
            bVar3 = 0xfc;
            bVar4 = 2;
          }
          else
          {
            bVar3 = 0xfc;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
      }
      else
      {
        if (uVar1 == 800)
        {
          if (func == 0x14)
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          else if (func == 0xc)
          {
            bVar3 = 0xf3;
            bVar4 = 4;
          }
          else if (func == 0x1a)
          {
            bVar3 = 0xf3;
            bVar4 = 8;
          }
          else
          {
            bVar3 = 0xf3;
            bVar4 = 0;
          }
          goto LAB_00029044;
        }
        if (uVar1 < 0x321)
        {
          if (uVar1 == 0x310)
          {
            if (func == 2)
            {
              bVar3 = 0xfc;
              bVar4 = 0;
            }
            else if (func == 6)
            {
              bVar3 = 0xfc;
              bVar4 = 1;
            }
            else if (func == 0x1c)
            {
              bVar3 = 0xfc;
              bVar4 = 2;
            }
            else
            {
              bVar3 = 0xfc;
              bVar4 = 0;
            }
            goto LAB_00029044;
          }
        }
        else
        {
          if (uVar1 == 0x340)
          {
            if (func == 5)
            {
              bVar3 = 0xcf;
              bVar4 = 0;
            }
            else if (func == 3)
            {
              bVar3 = 0xcf;
              bVar4 = 0x10;
            }
            else if (func == 0xd)
            {
              bVar3 = 0xcf;
              bVar4 = 0x20;
            }
            else
            {
              bVar3 = 0xcf;
              bVar4 = 0;
            }
            goto LAB_00029044;
          }
          if (uVar1 == 0x380)
          {
            if ((byte)(func + 0xfc) < 2)
            {
              bVar3 = 0x3f;
              bVar4 = 0;
            }
            else if (func == 6)
            {
              bVar3 = 0x3f;
              bVar4 = 0x40;
            }
            else if (func == 3)
            {
              bVar3 = 0x3f;
              bVar4 = 0x80;
            }
            else
            {
              bVar3 = 0x3f;
              bVar4 = 0;
            }
            goto LAB_00029044;
          }
        }
      }
    }
  }
  bVar3 = 0xff;
  bVar4 = 0;
LAB_00029044:
  pbVar2 = (byte *)((uint)(pin >> 8) * 2 + (uint)((pin & 0xf0) != 0) + 0x8005a8);
  *pbVar2 = bVar3 & *pbVar2 | bVar4;
  pbVar2 = (byte *)((uint)(pin >> 8) * 8 + 0x800586);
  *pbVar2 = *pbVar2 & ~(byte)pin;
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined4 pm_get_info1(void)

{
  DAT_00800074 = 0;
  return _DAT_0080004c;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void cpu_wakeup_no_deepretn_back_init(void)

{
  ushort uVar1;

  rc_24m_cal();
  doubler_calibration();
  uVar1 = pm_get_info1();
  if ((uVar1 & 0xc0) == 0xc0)
  {
    adc_set_gpio_calib_vref((uVar1 & 0x3f) * 5 + 0x3f7);
  }
  efuse_sys_check();
  flash_vdd_f_calib();
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void cpu_wakeup_init(void)

{
  byte bVar1;

  DAT_00800060 = 0;
  DAT_00800061 = 0;
  DAT_00800062 = 0;
  DAT_00800063 = 0xff;
  DAT_00800064 = 0xff;
  DAT_00800065 = 0xff;
  analog_write(0x82, 'd');
  analog_write('4', 0x80);
  analog_write('\v', '8');
  analog_write(0x8c, '\x02');
  analog_write('\x02', 0xa2);
  analog_write('\'', '\0');
  analog_write('(', '\0');
  analog_write(')', '\0');
  analog_write('*', '\0');
  _DAT_00800c40 = 0x4040404;
  _DAT_00800c44 = 0x4040404;
  DAT_00800c48 = 4;
  _DAT_00800750 = 8000;
  if (DAT_0080007d == '\x01')
  {
    analog_write('\x01', '<');
  }
  else
  {
    analog_write('\x01', 'L');
  }
  bVar1 = analog_read('\x7f');
  if ((bVar1 & 1) == 0)
  {
    pmParam._2_1_ = 1;
  LAB_00029686:
    pmParam._1_1_ = analog_read('D');
    pmParam._0_1_ = (pmParam._1_1_ & 10) == 8;
    if (pmParam._2_1_ == 1)
    {
      cpu_get_32k_tick();
      _DAT_00800740 = _adc_rng_result();
      DAT_0080074c = 0x90;
      DAT_0080074f = 1;
      goto LAB_000296da;
    }
  }
  else
  {
    bVar1 = analog_read('<');
    pmParam._2_1_ = bVar1 & 2;
    if ((bVar1 & 2) != 0)
    {
      pmParam._2_1_ = 2;
      bVar1 = analog_read('<');
      analog_write('<', bVar1 & 0xfd);
      if ((byte)(pmParam._2_1_ - 1) < 2)
        goto LAB_00029686;
    }
  }
  DAT_0080074f = 1;
  cpu_wakeup_no_deepretn_back_init();
LAB_000296da:
  DAT_00800c20 = 0;
  DAT_00800c21 = 0;
  DAT_008005b5 = DAT_008005b5 | 0xc;
  return;
}

// WARNING: Removing unreachable block (RAM,0x0002979e)
// WARNING: Removing unreachable block (RAM,0x000297bc)
// WARNING: Removing unreachable block (RAM,0x000297be)
// WARNING: Removing unreachable block (RAM,0x000297cc)
// WARNING: Removing unreachable block (RAM,0x000297de)
// WARNING: Removing unreachable block (RAM,0x000297e6)
// WARNING: Removing unreachable block (RAM,0x00029862)
// WARNING: Removing unreachable block (RAM,0x0002982e)
// WARNING: Removing unreachable block (RAM,0x00029836)
// WARNING: Removing unreachable block (RAM,0x00029846)
// WARNING: Removing unreachable block (RAM,0x000297c4)
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

void _adc_rng_result(void)

{
  code *in_r3;

  (*in_r3)();
  do
  {
  } while (true);
}

// WARNING: Removing unreachable block (RAM,0x0002979e)
// WARNING: Removing unreachable block (RAM,0x000297bc)
// WARNING: Removing unreachable block (RAM,0x000297be)
// WARNING: Removing unreachable block (RAM,0x000297cc)
// WARNING: Removing unreachable block (RAM,0x000297de)
// WARNING: Removing unreachable block (RAM,0x000297e6)
// WARNING: Removing unreachable block (RAM,0x00029862)
// WARNING: Removing unreachable block (RAM,0x0002982e)
// WARNING: Removing unreachable block (RAM,0x00029836)
// WARNING: Removing unreachable block (RAM,0x00029846)
// WARNING: Removing unreachable block (RAM,0x000297c4)
// WARNING: Unknown calling convention -- yet parameter storage is locked

void adc_rng_result(void)

{
  // WARNING: Do nothing block with infinite loop
  do
  {
  } while (true);
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void trng_init(void)

{
  byte bVar1;

  analog_write(0xef, 0xf0);
  bVar1 = analog_read(0xf1);
  analog_write(0xf1, bVar1 & 0x3f);
  bVar1 = analog_read(0xf1);
  analog_write(0xf1, bVar1 & 0xf0 | 10);
  bVar1 = analog_read(0xf2);
  analog_write(0xf2, bVar1 & 0xf0 | 4);
  bVar1 = analog_read(0xf2);
  analog_write(0xf2, bVar1 & 0x8f | 0x20);
  adc_set_ref_voltage(ADC_MISC_CHN, ADC_VREF_1P2V);
  bVar1 = analog_read(0xf9);
  analog_write(0xf9, bVar1 & 0xf3);
  adc_set_ain_channel_differential_mode(ADC_MISC_CHN, VBAT, GND);
  adc_set_resolution(ADC_MISC_CHN, RES14);
  adc_set_tsample_cycle(ADC_MISC_CHN, SAMPLING_CYCLES_6);
  adc_set_ain_pre_scaler(ADC_PRESCALER_1F8);
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xef);
  return;
}

void random_generator_init(void)

{
  byte bVar1;
  int iVar2;
  uint uVar3;

  rng = 0xffff;
  adc_init();
  trng_init();
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xdf);
  iVar2 = adc_rng_result();
  uVar3 = adc_rng_result();
  rnd_m_w = iVar2 << 0x10 | uVar3;
  iVar2 = adc_rng_result();
  uVar3 = adc_rng_result();
  rnd_m_z = iVar2 << 0x10 | uVar3;
  bVar1 = analog_read(0xfc);
  analog_write(0xfc, bVar1 & 0xdf | 0x20);
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// WARNING: Unknown calling convention -- yet parameter storage is locked

uint rand(void)

{
  rnd_m_w = (rnd_m_w & 0xffff) * 18000 + (rnd_m_w >> 0x10);
  rnd_m_z = (rnd_m_z & 0xffff) * 0x9069 + (rnd_m_z >> 0x10);
  return rnd_m_z * 0x10000 + rnd_m_w ^ _DAT_00800740;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_drv_init(void)

{
  undefined2 in_r0;

  LoadTblCmdSet((TBLCMDSET *)tbl_rf_init, 5);
  LoadTblCmdSet((TBLCMDSET *)tbl_rf_zigbee_250k, 0x1c);
  DAT_00800c20 = DAT_00800c20 | 0xc;
  g_RFMode = in_r0;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_set_channel(void)

{
  char in_r0;
  int iVar1;
  uint uVar2;
  int in_r1;
  byte bVar3;

  iVar1 = (int)in_r0;
  if (in_r1 << 0x10 < 0)
  {
    iVar1 = (int)(char)rf_chn_table[iVar1];
  }
  uVar2 = iVar1 + 0x960U & 0xffff;
  bVar3 = 0;
  if ((((uVar2 < 0x9f6) && (bVar3 = 4, uVar2 < 0x9d8)) && (bVar3 = 8, uVar2 < 0x9bf)) &&
      (bVar3 = 0xc, uVar2 < 0x9a1))
  {
    bVar3 = 0x10;
    if (((uVar2 < 0x983) && (bVar3 = 0x14, uVar2 < 0x965)) && (bVar3 = 0x1c, 0x94b < uVar2))
    {
      bVar3 = 0x18;
    }
  }
  DAT_00801244 = (byte)((uVar2 << 0x11) >> 0xf) | 1;
  DAT_00801245 = (byte)((uVar2 << 0x11) >> 0x17) & 0x3f | DAT_00801245 & 0xc0;
  DAT_00801229 = bVar3 | DAT_00801229 & 0xc3;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_set_power_level(void)

{
  uint in_r0;

  if ((int)(in_r0 * 0x1000000) < 0)
  {
    DAT_00801225 = DAT_00801225 | 0x40;
  }
  else
  {
    DAT_00801225 = DAT_00801225 & 0xbf;
  }
  DAT_00801226 = DAT_00801226 & 0x7f | (byte)(((in_r0 & 0x3f) << 0x18) >> 0x11);
  DAT_00801227 = DAT_00801227 & 0xe0 | (byte)(in_r0 & 0x3f) >> 1;
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_set_power_level_index(void)

{
  byte in_r0;

  if (in_r0 < 0x3c)
  {
    rf_set_power_level();
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

undefined rf_trx_state_get(void)

{
  return RF_TRxState;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void rf_rx_cf(void)

{
  int in_r0;
  char in_r1;

  DAT_00800c0b = 1;
  if (in_r1 != '\0')
  {
    DAT_00800c0b = 3;
  }
  DAT_00800c0a = (char)((uint)(in_r0 << 0x14) >> 0x18);
  g_RFRxPingpongEn = in_r1;
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void timer_start(TIMER_TypeDef type)

{
  if (type == TIMER1)
  {
    _DAT_00800620 = _DAT_00800620 | 8;
  }
  else if (type == TIMER0)
  {
    _DAT_00800620 = _DAT_00800620 | 1;
  }
  else if (type == TIMER2)
  {
    _DAT_00800620 = _DAT_00800620 | 0x40;
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void timer_stop(TIMER_TypeDef type)

{
  if (type == TIMER1)
  {
    _DAT_00800620 = _DAT_00800620 & 0xfffffff7;
  }
  else if (type == TIMER0)
  {
    _DAT_00800620 = _DAT_00800620 & 0xfffffffe;
  }
  else if (type == TIMER2)
  {
    _DAT_00800620 = _DAT_00800620 & 0xffffffbf;
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void timer_set_mode(TIMER_TypeDef type, TIMER_ModeTypeDef mode)

{
  uint uVar1;

  uVar1 = (uint)mode;
  if (type == TIMER1)
  {
    _DAT_00800620 = CONCAT13(2, _DAT_00800620);
    _DAT_00800620 = uVar1 << 4 | _DAT_00800620 & 0xffffffcf;
  }
  else if (type == TIMER0)
  {
    _DAT_00800620 = CONCAT13(1, _DAT_00800620);
    _DAT_00800620 = uVar1 << 1 | _DAT_00800620 & 0xfffffff9;
  }
  else if (type == TIMER2)
  {
    _DAT_00800620 = CONCAT13(4, _DAT_00800620);
    _DAT_00800620 = uVar1 << 7 | _DAT_00800620 & 0xfffffe7f;
  }
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

u8 uart_dma_send(u8 *pBuf)

{
  bool bVar1;

  bVar1 = (int)((uint)DAT_0080009e << 0x1f) < 0;
  if (bVar1)
  {
    _DAT_00800c04 = SUB42(pBuf, 0);
    DAT_00800c06 = 0xff;
    DAT_00800c24 = DAT_00800c24 | 2;
  }
  return bVar1;
}
